#include "command_factory.h"
#include "command_result_factory.h"
#include "parse_json.hpp"

///
/// Definition of SuccessResult
///
#include "gen/SuccessResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SuccessResult::CmdName = "SuccessResult";
    const char* const SuccessResult::Documentation = "When command succeed.";

    REGISTER_COMMAND_RESULT_FACTORY(SuccessResult);


    SuccessResult::SuccessResult()
      : CommandResult(CmdName)
    {}

    SuccessResult::SuccessResult(CommandBasePtr relatedCommand)
      : CommandResult(CmdName, relatedCommand)
    {

    }


    SuccessResultPtr SuccessResult::create(CommandBasePtr relatedCommand)
    {
      return std::make_shared<SuccessResult>(relatedCommand);
    }

    SuccessResultPtr SuccessResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SuccessResult>(ptr);
    }

    bool SuccessResult::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string SuccessResult::documentation() const { return Documentation; }

  }
}


///
/// Definition of FailureResult
///
#include "gen/FailureResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const FailureResult::CmdName = "FailureResult";
    const char* const FailureResult::Documentation = "When command failed";

    REGISTER_COMMAND_RESULT_FACTORY(FailureResult);


    FailureResult::FailureResult()
      : CommandResult(CmdName)
    {}

    FailureResult::FailureResult(CommandBasePtr relatedCommand, const std::string& errorMsg)
      : CommandResult(CmdName, relatedCommand)
    {

      setErrorMsg(errorMsg);
    }


    FailureResultPtr FailureResult::create(CommandBasePtr relatedCommand, const std::string& errorMsg)
    {
      return std::make_shared<FailureResult>(relatedCommand, errorMsg);
    }

    FailureResultPtr FailureResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<FailureResult>(ptr);
    }

    bool FailureResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ErrorMsg"])
        ;

    }

    std::string FailureResult::documentation() const { return Documentation; }


    std::string FailureResult::errorMsg() const
    {
      return parse_json<std::string>::parse(m_values["ErrorMsg"]);
    }

    void FailureResult::setErrorMsg(const std::string& errorMsg)
    {
      m_values.AddMember("ErrorMsg", parse_json<std::string>::format(errorMsg, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of UndoCmd
///
#include "gen/UndoCmd.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const UndoCmd::CmdName = "UndoCmd";
    const char* const UndoCmd::Documentation = "Undo the last command like Ctrl+Z in the UI";

    REGISTER_COMMAND_FACTORY(UndoCmd);


    UndoCmd::UndoCmd()
      : CommandBase(CmdName)
    {

    }


    UndoCmdPtr UndoCmd::create()
    {
      return std::make_shared<UndoCmd>();
    }

    UndoCmdPtr UndoCmd::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<UndoCmd>(ptr);
    }

    bool UndoCmd::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string UndoCmd::documentation() const { return Documentation; }


    int UndoCmd::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of RedoCmd
///
#include "gen/RedoCmd.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RedoCmd::CmdName = "RedoCmd";
    const char* const RedoCmd::Documentation = "Redo the last undone command like Ctrl+Shift+Z in the UI";

    REGISTER_COMMAND_FACTORY(RedoCmd);


    RedoCmd::RedoCmd()
      : CommandBase(CmdName)
    {

    }


    RedoCmdPtr RedoCmd::create()
    {
      return std::make_shared<RedoCmd>();
    }

    RedoCmdPtr RedoCmd::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RedoCmd>(ptr);
    }

    bool RedoCmd::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RedoCmd::documentation() const { return Documentation; }


    int RedoCmd::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetDataFolder
///
#include "gen/GetDataFolder.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDataFolder::CmdName = "GetDataFolder";
    const char* const GetDataFolder::Documentation = "Get Skydel's Data Folder. The user can changed it in the GUI's Preferences.";

    REGISTER_COMMAND_FACTORY(GetDataFolder);


    GetDataFolder::GetDataFolder()
      : CommandBase(CmdName)
    {

    }


    GetDataFolderPtr GetDataFolder::create()
    {
      return std::make_shared<GetDataFolder>();
    }

    GetDataFolderPtr GetDataFolder::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDataFolder>(ptr);
    }

    bool GetDataFolder::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetDataFolder::documentation() const { return Documentation; }


    int GetDataFolder::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of DataFolderResult
///
#include "gen/DataFolderResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const DataFolderResult::CmdName = "DataFolderResult";
    const char* const DataFolderResult::Documentation = "Result of GetDataFolder.";

    REGISTER_COMMAND_RESULT_FACTORY(DataFolderResult);


    DataFolderResult::DataFolderResult()
      : CommandResult(CmdName)
    {}

    DataFolderResult::DataFolderResult(CommandBasePtr relatedCommand, const std::string& folder)
      : CommandResult(CmdName, relatedCommand)
    {

      setFolder(folder);
    }


    DataFolderResultPtr DataFolderResult::create(CommandBasePtr relatedCommand, const std::string& folder)
    {
      return std::make_shared<DataFolderResult>(relatedCommand, folder);
    }

    DataFolderResultPtr DataFolderResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<DataFolderResult>(ptr);
    }

    bool DataFolderResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Folder"])
        ;

    }

    std::string DataFolderResult::documentation() const { return Documentation; }


    std::string DataFolderResult::folder() const
    {
      return parse_json<std::string>::parse(m_values["Folder"]);
    }

    void DataFolderResult::setFolder(const std::string& folder)
    {
      m_values.AddMember("Folder", parse_json<std::string>::format(folder, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVersion
///
#include "gen/GetVersion.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVersion::CmdName = "GetVersion";
    const char* const GetVersion::Documentation = "Get Skydel version.";

    REGISTER_COMMAND_FACTORY(GetVersion);


    GetVersion::GetVersion()
      : CommandBase(CmdName)
    {

    }


    GetVersionPtr GetVersion::create()
    {
      return std::make_shared<GetVersion>();
    }

    GetVersionPtr GetVersion::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVersion>(ptr);
    }

    bool GetVersion::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVersion::documentation() const { return Documentation; }


    int GetVersion::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of VersionResult
///
#include "gen/VersionResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const VersionResult::CmdName = "VersionResult";
    const char* const VersionResult::Documentation = "Result of GetVersion.";

    REGISTER_COMMAND_RESULT_FACTORY(VersionResult);


    VersionResult::VersionResult()
      : CommandResult(CmdName)
    {}

    VersionResult::VersionResult(CommandBasePtr relatedCommand, const std::string& version)
      : CommandResult(CmdName, relatedCommand)
    {

      setVersion(version);
    }


    VersionResultPtr VersionResult::create(CommandBasePtr relatedCommand, const std::string& version)
    {
      return std::make_shared<VersionResult>(relatedCommand, version);
    }

    VersionResultPtr VersionResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<VersionResult>(ptr);
    }

    bool VersionResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Version"])
        ;

    }

    std::string VersionResult::documentation() const { return Documentation; }


    std::string VersionResult::version() const
    {
      return parse_json<std::string>::parse(m_values["Version"]);
    }

    void VersionResult::setVersion(const std::string& version)
    {
      m_values.AddMember("Version", parse_json<std::string>::format(version, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSimulationElapsedTime
///
#include "gen/GetSimulationElapsedTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSimulationElapsedTime::CmdName = "GetSimulationElapsedTime";
    const char* const GetSimulationElapsedTime::Documentation = "Get simulation elapsed time in milliseconds.";

    REGISTER_COMMAND_FACTORY(GetSimulationElapsedTime);


    GetSimulationElapsedTime::GetSimulationElapsedTime()
      : CommandBase(CmdName)
    {

    }


    GetSimulationElapsedTimePtr GetSimulationElapsedTime::create()
    {
      return std::make_shared<GetSimulationElapsedTime>();
    }

    GetSimulationElapsedTimePtr GetSimulationElapsedTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSimulationElapsedTime>(ptr);
    }

    bool GetSimulationElapsedTime::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSimulationElapsedTime::documentation() const { return Documentation; }


    int GetSimulationElapsedTime::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of SimulationElapsedTimeResult
///
#include "gen/SimulationElapsedTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SimulationElapsedTimeResult::CmdName = "SimulationElapsedTimeResult";
    const char* const SimulationElapsedTimeResult::Documentation = "Result of GetSimulationElapsedTime.";

    REGISTER_COMMAND_RESULT_FACTORY(SimulationElapsedTimeResult);


    SimulationElapsedTimeResult::SimulationElapsedTimeResult()
      : CommandResult(CmdName)
    {}

    SimulationElapsedTimeResult::SimulationElapsedTimeResult(CommandBasePtr relatedCommand, int milliseconds)
      : CommandResult(CmdName, relatedCommand)
    {

      setMilliseconds(milliseconds);
    }


    SimulationElapsedTimeResultPtr SimulationElapsedTimeResult::create(CommandBasePtr relatedCommand, int milliseconds)
    {
      return std::make_shared<SimulationElapsedTimeResult>(relatedCommand, milliseconds);
    }

    SimulationElapsedTimeResultPtr SimulationElapsedTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SimulationElapsedTimeResult>(ptr);
    }

    bool SimulationElapsedTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Milliseconds"])
        ;

    }

    std::string SimulationElapsedTimeResult::documentation() const { return Documentation; }


    int SimulationElapsedTimeResult::milliseconds() const
    {
      return parse_json<int>::parse(m_values["Milliseconds"]);
    }

    void SimulationElapsedTimeResult::setMilliseconds(int milliseconds)
    {
      m_values.AddMember("Milliseconds", parse_json<int>::format(milliseconds, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of New
///
#include "gen/New.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const New::CmdName = "New";
    const char* const New::Documentation = "Create a new configuration.";

    REGISTER_COMMAND_FACTORY(New);


    New::New()
      : CommandBase(CmdName)
    {}

    New::New(bool discardCurrentConfig, const Sdx::optional<bool>& loadDefaultConfig)
      : CommandBase(CmdName)
    {

      setDiscardCurrentConfig(discardCurrentConfig);
      setLoadDefaultConfig(loadDefaultConfig);
    }


    NewPtr New::create(bool discardCurrentConfig, const Sdx::optional<bool>& loadDefaultConfig)
    {
      return std::make_shared<New>(discardCurrentConfig, loadDefaultConfig);
    }

    NewPtr New::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<New>(ptr);
    }

    bool New::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["DiscardCurrentConfig"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["LoadDefaultConfig"])
        ;

    }

    std::string New::documentation() const { return Documentation; }


    int New::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    bool New::discardCurrentConfig() const
    {
      return parse_json<bool>::parse(m_values["DiscardCurrentConfig"]);
    }

    void New::setDiscardCurrentConfig(bool discardCurrentConfig)
    {
      m_values.AddMember("DiscardCurrentConfig", parse_json<bool>::format(discardCurrentConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> New::loadDefaultConfig() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["LoadDefaultConfig"]);
    }

    void New::setLoadDefaultConfig(const Sdx::optional<bool>& loadDefaultConfig)
    {
      m_values.AddMember("LoadDefaultConfig", parse_json<Sdx::optional<bool>>::format(loadDefaultConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SaveAs
///
#include "gen/SaveAs.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SaveAs::CmdName = "SaveAs";
    const char* const SaveAs::Documentation = "Save configuration with new name.";

    REGISTER_COMMAND_FACTORY(SaveAs);


    SaveAs::SaveAs()
      : CommandBase(CmdName)
    {}

    SaveAs::SaveAs(const std::string& path, bool overwrite)
      : CommandBase(CmdName)
    {

      setPath(path);
      setOverwrite(overwrite);
    }


    SaveAsPtr SaveAs::create(const std::string& path, bool overwrite)
    {
      return std::make_shared<SaveAs>(path, overwrite);
    }

    SaveAsPtr SaveAs::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SaveAs>(ptr);
    }

    bool SaveAs::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<bool>::is_valid(m_values["Overwrite"])
        ;

    }

    std::string SaveAs::documentation() const { return Documentation; }


    int SaveAs::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SaveAs::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void SaveAs::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SaveAs::overwrite() const
    {
      return parse_json<bool>::parse(m_values["Overwrite"]);
    }

    void SaveAs::setOverwrite(bool overwrite)
    {
      m_values.AddMember("Overwrite", parse_json<bool>::format(overwrite, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of Save
///
#include "gen/Save.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Save::CmdName = "Save";
    const char* const Save::Documentation = "Save configuration.";

    REGISTER_COMMAND_FACTORY(Save);


    Save::Save()
      : CommandBase(CmdName)
    {

    }


    SavePtr Save::create()
    {
      return std::make_shared<Save>();
    }

    SavePtr Save::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Save>(ptr);
    }

    bool Save::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Save::documentation() const { return Documentation; }


    int Save::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Open
///
#include "gen/Open.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Open::CmdName = "Open";
    const char* const Open::Documentation = "Open configuration.";

    REGISTER_COMMAND_FACTORY(Open);


    Open::Open()
      : CommandBase(CmdName)
    {}

    Open::Open(const std::string& path, bool discardCurrentConfig)
      : CommandBase(CmdName)
    {

      setPath(path);
      setDiscardCurrentConfig(discardCurrentConfig);
    }


    OpenPtr Open::create(const std::string& path, bool discardCurrentConfig)
    {
      return std::make_shared<Open>(path, discardCurrentConfig);
    }

    OpenPtr Open::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Open>(ptr);
    }

    bool Open::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<bool>::is_valid(m_values["DiscardCurrentConfig"])
        ;

    }

    std::string Open::documentation() const { return Documentation; }


    int Open::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    std::string Open::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void Open::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool Open::discardCurrentConfig() const
    {
      return parse_json<bool>::parse(m_values["DiscardCurrentConfig"]);
    }

    void Open::setDiscardCurrentConfig(bool discardCurrentConfig)
    {
      m_values.AddMember("DiscardCurrentConfig", parse_json<bool>::format(discardCurrentConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetDefaultConfiguration
///
#include "gen/SetDefaultConfiguration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetDefaultConfiguration::CmdName = "SetDefaultConfiguration";
    const char* const SetDefaultConfiguration::Documentation = "Set current configuration as default configuration.";

    REGISTER_COMMAND_FACTORY(SetDefaultConfiguration);


    SetDefaultConfiguration::SetDefaultConfiguration()
      : CommandBase(CmdName)
    {

    }


    SetDefaultConfigurationPtr SetDefaultConfiguration::create()
    {
      return std::make_shared<SetDefaultConfiguration>();
    }

    SetDefaultConfigurationPtr SetDefaultConfiguration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetDefaultConfiguration>(ptr);
    }

    bool SetDefaultConfiguration::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string SetDefaultConfiguration::documentation() const { return Documentation; }


    int SetDefaultConfiguration::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of ResetDefaultConfiguration
///
#include "gen/ResetDefaultConfiguration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetDefaultConfiguration::CmdName = "ResetDefaultConfiguration";
    const char* const ResetDefaultConfiguration::Documentation = "Reset the default configuration.";

    REGISTER_COMMAND_FACTORY(ResetDefaultConfiguration);


    ResetDefaultConfiguration::ResetDefaultConfiguration()
      : CommandBase(CmdName)
    {

    }


    ResetDefaultConfigurationPtr ResetDefaultConfiguration::create()
    {
      return std::make_shared<ResetDefaultConfiguration>();
    }

    ResetDefaultConfigurationPtr ResetDefaultConfiguration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetDefaultConfiguration>(ptr);
    }

    bool ResetDefaultConfiguration::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ResetDefaultConfiguration::documentation() const { return Documentation; }


    int ResetDefaultConfiguration::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of ClearAutomatePage
///
#include "gen/ClearAutomatePage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAutomatePage::CmdName = "ClearAutomatePage";
    const char* const ClearAutomatePage::Documentation = "Clear automate page.";

    REGISTER_COMMAND_FACTORY(ClearAutomatePage);


    ClearAutomatePage::ClearAutomatePage()
      : CommandBase(CmdName)
    {

    }


    ClearAutomatePagePtr ClearAutomatePage::create()
    {
      return std::make_shared<ClearAutomatePage>();
    }

    ClearAutomatePagePtr ClearAutomatePage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAutomatePage>(ptr);
    }

    bool ClearAutomatePage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAutomatePage::documentation() const { return Documentation; }


    int ClearAutomatePage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Start
///
#include "gen/Start.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Start::CmdName = "Start";
    const char* const Start::Documentation = "Start the simulation. Simulation may or may not start depending on the current state of the simulator.";

    REGISTER_COMMAND_FACTORY(Start);


    Start::Start()
      : CommandBase(CmdName)
    {

    }


    StartPtr Start::create()
    {
      return std::make_shared<Start>();
    }

    StartPtr Start::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Start>(ptr);
    }

    bool Start::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Start::documentation() const { return Documentation; }


    int Start::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Arm
///
#include "gen/Arm.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Arm::CmdName = "Arm";
    const char* const Arm::Documentation = "Arm the simulation. Simulation may or may not arm depending on the current state of the simulator.";

    REGISTER_COMMAND_FACTORY(Arm);


    Arm::Arm()
      : CommandBase(CmdName)
    {

    }


    ArmPtr Arm::create()
    {
      return std::make_shared<Arm>();
    }

    ArmPtr Arm::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Arm>(ptr);
    }

    bool Arm::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Arm::documentation() const { return Documentation; }


    int Arm::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Pause
///
#include "gen/Pause.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Pause::CmdName = "Pause";
    const char* const Pause::Documentation = "Pause vehicle motion during simulation.";

    REGISTER_COMMAND_FACTORY(Pause);


    Pause::Pause()
      : CommandBase(CmdName)
    {

    }


    PausePtr Pause::create()
    {
      return std::make_shared<Pause>();
    }

    PausePtr Pause::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Pause>(ptr);
    }

    bool Pause::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Pause::documentation() const { return Documentation; }


    int Pause::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of Resume
///
#include "gen/Resume.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Resume::CmdName = "Resume";
    const char* const Resume::Documentation = "Resume vehicle motion during simulation.";

    REGISTER_COMMAND_FACTORY(Resume);


    Resume::Resume()
      : CommandBase(CmdName)
    {

    }


    ResumePtr Resume::create()
    {
      return std::make_shared<Resume>();
    }

    ResumePtr Resume::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Resume>(ptr);
    }

    bool Resume::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Resume::documentation() const { return Documentation; }


    int Resume::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of Stop
///
#include "gen/Stop.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Stop::CmdName = "Stop";
    const char* const Stop::Documentation = "Stop the simulation.";

    REGISTER_COMMAND_FACTORY(Stop);


    Stop::Stop()
      : CommandBase(CmdName)
    {

    }


    StopPtr Stop::create()
    {
      return std::make_shared<Stop>();
    }

    StopPtr Stop::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Stop>(ptr);
    }

    bool Stop::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Stop::documentation() const { return Documentation; }


    int Stop::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Quit
///
#include "gen/Quit.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Quit::CmdName = "Quit";
    const char* const Quit::Documentation = "Quit/Exit Skydel. Simulation must be stopped to be able to quit Skydel";

    REGISTER_COMMAND_FACTORY(Quit);


    Quit::Quit()
      : CommandBase(CmdName)
    {}

    Quit::Quit(bool forceQuit)
      : CommandBase(CmdName)
    {

      setForceQuit(forceQuit);
    }


    QuitPtr Quit::create(bool forceQuit)
    {
      return std::make_shared<Quit>(forceQuit);
    }

    QuitPtr Quit::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Quit>(ptr);
    }

    bool Quit::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["ForceQuit"])
        ;

    }

    std::string Quit::documentation() const { return Documentation; }


    int Quit::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    bool Quit::forceQuit() const
    {
      return parse_json<bool>::parse(m_values["ForceQuit"]);
    }

    void Quit::setForceQuit(bool forceQuit)
    {
      m_values.AddMember("ForceQuit", parse_json<bool>::format(forceQuit, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of LockGUI
///
#include "gen/LockGUI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const LockGUI::CmdName = "LockGUI";
    const char* const LockGUI::Documentation = "Prevent GUI updates while modify the configuration. Use UnlockGUI when done with\nconfiguration modifications.";

    REGISTER_COMMAND_FACTORY(LockGUI);


    LockGUI::LockGUI()
      : CommandBase(CmdName)
    {

    }


    LockGUIPtr LockGUI::create()
    {
      return std::make_shared<LockGUI>();
    }

    LockGUIPtr LockGUI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<LockGUI>(ptr);
    }

    bool LockGUI::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string LockGUI::documentation() const { return Documentation; }


    int LockGUI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of UnlockGUI
///
#include "gen/UnlockGUI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const UnlockGUI::CmdName = "UnlockGUI";
    const char* const UnlockGUI::Documentation = "Resume GUI updates and force one update immediately.";

    REGISTER_COMMAND_FACTORY(UnlockGUI);


    UnlockGUI::UnlockGUI()
      : CommandBase(CmdName)
    {

    }


    UnlockGUIPtr UnlockGUI::create()
    {
      return std::make_shared<UnlockGUI>();
    }

    UnlockGUIPtr UnlockGUI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<UnlockGUI>(ptr);
    }

    bool UnlockGUI::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string UnlockGUI::documentation() const { return Documentation; }


    int UnlockGUI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of EnableRFOutputForSV
///
#include "gen/EnableRFOutputForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableRFOutputForSV::CmdName = "EnableRFOutputForSV";
    const char* const EnableRFOutputForSV::Documentation = "Enable (or disable) RF output for specified satellite. Use SV ID 0 to enabled/disable all satellites.";

    REGISTER_COMMAND_FACTORY(EnableRFOutputForSV);


    EnableRFOutputForSV::EnableRFOutputForSV()
      : CommandBase(CmdName)
    {}

    EnableRFOutputForSV::EnableRFOutputForSV(const std::string& system, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnableRFOutputForSVPtr EnableRFOutputForSV::create(const std::string& system, int svId, bool enabled)
    {
      return std::make_shared<EnableRFOutputForSV>(system, svId, enabled);
    }

    EnableRFOutputForSVPtr EnableRFOutputForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableRFOutputForSV>(ptr);
    }

    bool EnableRFOutputForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableRFOutputForSV::documentation() const { return Documentation; }


    int EnableRFOutputForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableRFOutputForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableRFOutputForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnableRFOutputForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnableRFOutputForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableRFOutputForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableRFOutputForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFOutputEnabled
///
#include "gen/IsRFOutputEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFOutputEnabled::CmdName = "IsRFOutputEnabled";
    const char* const IsRFOutputEnabled::Documentation = "Tells if the RF output is enabled or disabled for the specified satellite.";

    REGISTER_COMMAND_FACTORY(IsRFOutputEnabled);


    IsRFOutputEnabled::IsRFOutputEnabled()
      : CommandBase(CmdName)
    {}

    IsRFOutputEnabled::IsRFOutputEnabled(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    IsRFOutputEnabledPtr IsRFOutputEnabled::create(const std::string& system, int svId)
    {
      return std::make_shared<IsRFOutputEnabled>(system, svId);
    }

    IsRFOutputEnabledPtr IsRFOutputEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFOutputEnabled>(ptr);
    }

    bool IsRFOutputEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsRFOutputEnabled::documentation() const { return Documentation; }


    int IsRFOutputEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsRFOutputEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFOutputEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsRFOutputEnabled::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsRFOutputEnabled::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFOutputEnabledResult
///
#include "gen/IsRFOutputEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFOutputEnabledResult::CmdName = "IsRFOutputEnabledResult";
    const char* const IsRFOutputEnabledResult::Documentation = "Result of IsRFOutputEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsRFOutputEnabledResult);


    IsRFOutputEnabledResult::IsRFOutputEnabledResult()
      : CommandResult(CmdName)
    {}

    IsRFOutputEnabledResult::IsRFOutputEnabledResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsRFOutputEnabledResultPtr IsRFOutputEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
    {
      return std::make_shared<IsRFOutputEnabledResult>(relatedCommand, system, svId, enabled);
    }

    IsRFOutputEnabledResultPtr IsRFOutputEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFOutputEnabledResult>(ptr);
    }

    bool IsRFOutputEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsRFOutputEnabledResult::documentation() const { return Documentation; }


    std::string IsRFOutputEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFOutputEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsRFOutputEnabledResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsRFOutputEnabledResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsRFOutputEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsRFOutputEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableRFOutputForEachSV
///
#include "gen/EnableRFOutputForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableRFOutputForEachSV::CmdName = "EnableRFOutputForEachSV";
    const char* const EnableRFOutputForEachSV::Documentation = "Enable (or disable) RF output for each satellite individually.";

    REGISTER_COMMAND_FACTORY(EnableRFOutputForEachSV);


    EnableRFOutputForEachSV::EnableRFOutputForEachSV()
      : CommandBase(CmdName)
    {}

    EnableRFOutputForEachSV::EnableRFOutputForEachSV(const std::string& system, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    EnableRFOutputForEachSVPtr EnableRFOutputForEachSV::create(const std::string& system, const std::vector<bool>& enabled)
    {
      return std::make_shared<EnableRFOutputForEachSV>(system, enabled);
    }

    EnableRFOutputForEachSVPtr EnableRFOutputForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableRFOutputForEachSV>(ptr);
    }

    bool EnableRFOutputForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableRFOutputForEachSV::documentation() const { return Documentation; }


    int EnableRFOutputForEachSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableRFOutputForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableRFOutputForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableRFOutputForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableRFOutputForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFOutputEnabledForEachSV
///
#include "gen/IsRFOutputEnabledForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFOutputEnabledForEachSV::CmdName = "IsRFOutputEnabledForEachSV";
    const char* const IsRFOutputEnabledForEachSV::Documentation = "Tells if the RF output is enabled or disabled for each satellite.";

    REGISTER_COMMAND_FACTORY(IsRFOutputEnabledForEachSV);


    IsRFOutputEnabledForEachSV::IsRFOutputEnabledForEachSV()
      : CommandBase(CmdName)
    {}

    IsRFOutputEnabledForEachSV::IsRFOutputEnabledForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsRFOutputEnabledForEachSVPtr IsRFOutputEnabledForEachSV::create(const std::string& system)
    {
      return std::make_shared<IsRFOutputEnabledForEachSV>(system);
    }

    IsRFOutputEnabledForEachSVPtr IsRFOutputEnabledForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFOutputEnabledForEachSV>(ptr);
    }

    bool IsRFOutputEnabledForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsRFOutputEnabledForEachSV::documentation() const { return Documentation; }


    int IsRFOutputEnabledForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsRFOutputEnabledForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFOutputEnabledForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFOutputEnabledForEachSVResult
///
#include "gen/IsRFOutputEnabledForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFOutputEnabledForEachSVResult::CmdName = "IsRFOutputEnabledForEachSVResult";
    const char* const IsRFOutputEnabledForEachSVResult::Documentation = "Result of IsRFOutputEnabledForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(IsRFOutputEnabledForEachSVResult);


    IsRFOutputEnabledForEachSVResult::IsRFOutputEnabledForEachSVResult()
      : CommandResult(CmdName)
    {}

    IsRFOutputEnabledForEachSVResult::IsRFOutputEnabledForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    IsRFOutputEnabledForEachSVResultPtr IsRFOutputEnabledForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
    {
      return std::make_shared<IsRFOutputEnabledForEachSVResult>(relatedCommand, system, enabled);
    }

    IsRFOutputEnabledForEachSVResultPtr IsRFOutputEnabledForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFOutputEnabledForEachSVResult>(ptr);
    }

    bool IsRFOutputEnabledForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsRFOutputEnabledForEachSVResult::documentation() const { return Documentation; }


    std::string IsRFOutputEnabledForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFOutputEnabledForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsRFOutputEnabledForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsRFOutputEnabledForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSignalForSV
///
#include "gen/EnableSignalForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSignalForSV::CmdName = "EnableSignalForSV";
    const char* const EnableSignalForSV::Documentation = "Enable (or disable) signal for specified satellite.";

    REGISTER_COMMAND_FACTORY(EnableSignalForSV);


    EnableSignalForSV::EnableSignalForSV()
      : CommandBase(CmdName)
    {}

    EnableSignalForSV::EnableSignalForSV(const std::string& signal, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnableSignalForSVPtr EnableSignalForSV::create(const std::string& signal, int svId, bool enabled)
    {
      return std::make_shared<EnableSignalForSV>(signal, svId, enabled);
    }

    EnableSignalForSVPtr EnableSignalForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSignalForSV>(ptr);
    }

    bool EnableSignalForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSignalForSV::documentation() const { return Documentation; }


    int EnableSignalForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableSignalForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnableSignalForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnableSignalForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnableSignalForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableSignalForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSignalForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabledForSV
///
#include "gen/IsSignalEnabledForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabledForSV::CmdName = "IsSignalEnabledForSV";
    const char* const IsSignalEnabledForSV::Documentation = "Tells if the signal is enabled or disabled.";

    REGISTER_COMMAND_FACTORY(IsSignalEnabledForSV);


    IsSignalEnabledForSV::IsSignalEnabledForSV()
      : CommandBase(CmdName)
    {}

    IsSignalEnabledForSV::IsSignalEnabledForSV(const std::string& signal, int svId)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
    }


    IsSignalEnabledForSVPtr IsSignalEnabledForSV::create(const std::string& signal, int svId)
    {
      return std::make_shared<IsSignalEnabledForSV>(signal, svId);
    }

    IsSignalEnabledForSVPtr IsSignalEnabledForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabledForSV>(ptr);
    }

    bool IsSignalEnabledForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsSignalEnabledForSV::documentation() const { return Documentation; }


    int IsSignalEnabledForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSignalEnabledForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabledForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSignalEnabledForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSignalEnabledForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabledForSVResult
///
#include "gen/IsSignalEnabledForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabledForSVResult::CmdName = "IsSignalEnabledForSVResult";
    const char* const IsSignalEnabledForSVResult::Documentation = "Result of IsSignalEnabledForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSignalEnabledForSVResult);


    IsSignalEnabledForSVResult::IsSignalEnabledForSVResult()
      : CommandResult(CmdName)
    {}

    IsSignalEnabledForSVResult::IsSignalEnabledForSVResult(CommandBasePtr relatedCommand, const std::string& signal, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsSignalEnabledForSVResultPtr IsSignalEnabledForSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, int svId, bool enabled)
    {
      return std::make_shared<IsSignalEnabledForSVResult>(relatedCommand, signal, svId, enabled);
    }

    IsSignalEnabledForSVResultPtr IsSignalEnabledForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabledForSVResult>(ptr);
    }

    bool IsSignalEnabledForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSignalEnabledForSVResult::documentation() const { return Documentation; }


    std::string IsSignalEnabledForSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabledForSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSignalEnabledForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSignalEnabledForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSignalEnabledForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSignalEnabledForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEnabledSignalsForSV
///
#include "gen/GetEnabledSignalsForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEnabledSignalsForSV::CmdName = "GetEnabledSignalsForSV";
    const char* const GetEnabledSignalsForSV::Documentation = "Get the list of enabled signals for a specified SV ID.";

    REGISTER_COMMAND_FACTORY(GetEnabledSignalsForSV);


    GetEnabledSignalsForSV::GetEnabledSignalsForSV()
      : CommandBase(CmdName)
    {}

    GetEnabledSignalsForSV::GetEnabledSignalsForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetEnabledSignalsForSVPtr GetEnabledSignalsForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<GetEnabledSignalsForSV>(system, svId);
    }

    GetEnabledSignalsForSVPtr GetEnabledSignalsForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEnabledSignalsForSV>(ptr);
    }

    bool GetEnabledSignalsForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetEnabledSignalsForSV::documentation() const { return Documentation; }


    int GetEnabledSignalsForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string GetEnabledSignalsForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEnabledSignalsForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEnabledSignalsForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEnabledSignalsForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEnabledSignalsForSVResult
///
#include "gen/GetEnabledSignalsForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEnabledSignalsForSVResult::CmdName = "GetEnabledSignalsForSVResult";
    const char* const GetEnabledSignalsForSVResult::Documentation = "Result of GetEnabledSignalsForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetEnabledSignalsForSVResult);


    GetEnabledSignalsForSVResult::GetEnabledSignalsForSVResult()
      : CommandResult(CmdName)
    {}

    GetEnabledSignalsForSVResult::GetEnabledSignalsForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::vector<std::string>& signalArray)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setSignalArray(signalArray);
    }


    GetEnabledSignalsForSVResultPtr GetEnabledSignalsForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::vector<std::string>& signalArray)
    {
      return std::make_shared<GetEnabledSignalsForSVResult>(relatedCommand, system, svId, signalArray);
    }

    GetEnabledSignalsForSVResultPtr GetEnabledSignalsForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEnabledSignalsForSVResult>(ptr);
    }

    bool GetEnabledSignalsForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
        ;

    }

    std::string GetEnabledSignalsForSVResult::documentation() const { return Documentation; }


    std::string GetEnabledSignalsForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEnabledSignalsForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEnabledSignalsForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEnabledSignalsForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetEnabledSignalsForSVResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetEnabledSignalsForSVResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSignalForEachSV
///
#include "gen/EnableSignalForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSignalForEachSV::CmdName = "EnableSignalForEachSV";
    const char* const EnableSignalForEachSV::Documentation = "Enable (or disable) signal for each satellite individually.";

    REGISTER_COMMAND_FACTORY(EnableSignalForEachSV);


    EnableSignalForEachSV::EnableSignalForEachSV()
      : CommandBase(CmdName)
    {}

    EnableSignalForEachSV::EnableSignalForEachSV(const std::string& signal, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    EnableSignalForEachSVPtr EnableSignalForEachSV::create(const std::string& signal, const std::vector<bool>& enabled)
    {
      return std::make_shared<EnableSignalForEachSV>(signal, enabled);
    }

    EnableSignalForEachSVPtr EnableSignalForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSignalForEachSV>(ptr);
    }

    bool EnableSignalForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSignalForEachSV::documentation() const { return Documentation; }


    int EnableSignalForEachSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableSignalForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnableSignalForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableSignalForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableSignalForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabledForEachSV
///
#include "gen/IsSignalEnabledForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabledForEachSV::CmdName = "IsSignalEnabledForEachSV";
    const char* const IsSignalEnabledForEachSV::Documentation = "Tells if the signal is enabled or disabled for each satellite.";

    REGISTER_COMMAND_FACTORY(IsSignalEnabledForEachSV);


    IsSignalEnabledForEachSV::IsSignalEnabledForEachSV()
      : CommandBase(CmdName)
    {}

    IsSignalEnabledForEachSV::IsSignalEnabledForEachSV(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    IsSignalEnabledForEachSVPtr IsSignalEnabledForEachSV::create(const std::string& signal)
    {
      return std::make_shared<IsSignalEnabledForEachSV>(signal);
    }

    IsSignalEnabledForEachSVPtr IsSignalEnabledForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabledForEachSV>(ptr);
    }

    bool IsSignalEnabledForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string IsSignalEnabledForEachSV::documentation() const { return Documentation; }


    int IsSignalEnabledForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSignalEnabledForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabledForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabledForEachSVResult
///
#include "gen/IsSignalEnabledForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabledForEachSVResult::CmdName = "IsSignalEnabledForEachSVResult";
    const char* const IsSignalEnabledForEachSVResult::Documentation = "Result of IsSignalEnabledForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSignalEnabledForEachSVResult);


    IsSignalEnabledForEachSVResult::IsSignalEnabledForEachSVResult()
      : CommandResult(CmdName)
    {}

    IsSignalEnabledForEachSVResult::IsSignalEnabledForEachSVResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    IsSignalEnabledForEachSVResultPtr IsSignalEnabledForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
    {
      return std::make_shared<IsSignalEnabledForEachSVResult>(relatedCommand, signal, enabled);
    }

    IsSignalEnabledForEachSVResultPtr IsSignalEnabledForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabledForEachSVResult>(ptr);
    }

    bool IsSignalEnabledForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSignalEnabledForEachSVResult::documentation() const { return Documentation; }


    std::string IsSignalEnabledForEachSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabledForEachSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsSignalEnabledForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsSignalEnabledForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnablePYCodeForSV
///
#include "gen/EnablePYCodeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnablePYCodeForSV::CmdName = "EnablePYCodeForSV";
    const char* const EnablePYCodeForSV::Documentation = "Enable (or disable) P(Y)-Code for specified satellite.";

    REGISTER_COMMAND_FACTORY(EnablePYCodeForSV);


    EnablePYCodeForSV::EnablePYCodeForSV()
      : CommandBase(CmdName)
    {}

    EnablePYCodeForSV::EnablePYCodeForSV(const std::string& signal, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnablePYCodeForSVPtr EnablePYCodeForSV::create(const std::string& signal, int svId, bool enabled)
    {
      return std::make_shared<EnablePYCodeForSV>(signal, svId, enabled);
    }

    EnablePYCodeForSVPtr EnablePYCodeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnablePYCodeForSV>(ptr);
    }

    bool EnablePYCodeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnablePYCodeForSV::documentation() const { return Documentation; }


    int EnablePYCodeForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnablePYCodeForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnablePYCodeForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnablePYCodeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnablePYCodeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnablePYCodeForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnablePYCodeForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYCodeEnabledForSV
///
#include "gen/IsPYCodeEnabledForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYCodeEnabledForSV::CmdName = "IsPYCodeEnabledForSV";
    const char* const IsPYCodeEnabledForSV::Documentation = "Tells if P(Y)-Code is enabled for the specified satellite.";

    REGISTER_COMMAND_FACTORY(IsPYCodeEnabledForSV);


    IsPYCodeEnabledForSV::IsPYCodeEnabledForSV()
      : CommandBase(CmdName)
    {}

    IsPYCodeEnabledForSV::IsPYCodeEnabledForSV(const std::string& signal, int svId)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
    }


    IsPYCodeEnabledForSVPtr IsPYCodeEnabledForSV::create(const std::string& signal, int svId)
    {
      return std::make_shared<IsPYCodeEnabledForSV>(signal, svId);
    }

    IsPYCodeEnabledForSVPtr IsPYCodeEnabledForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYCodeEnabledForSV>(ptr);
    }

    bool IsPYCodeEnabledForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsPYCodeEnabledForSV::documentation() const { return Documentation; }


    int IsPYCodeEnabledForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsPYCodeEnabledForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYCodeEnabledForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsPYCodeEnabledForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsPYCodeEnabledForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYCodeEnabledForSVResult
///
#include "gen/IsPYCodeEnabledForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYCodeEnabledForSVResult::CmdName = "IsPYCodeEnabledForSVResult";
    const char* const IsPYCodeEnabledForSVResult::Documentation = "Result of IsPYCodeEnabledForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(IsPYCodeEnabledForSVResult);


    IsPYCodeEnabledForSVResult::IsPYCodeEnabledForSVResult()
      : CommandResult(CmdName)
    {}

    IsPYCodeEnabledForSVResult::IsPYCodeEnabledForSVResult(CommandBasePtr relatedCommand, const std::string& signal, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsPYCodeEnabledForSVResultPtr IsPYCodeEnabledForSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, int svId, bool enabled)
    {
      return std::make_shared<IsPYCodeEnabledForSVResult>(relatedCommand, signal, svId, enabled);
    }

    IsPYCodeEnabledForSVResultPtr IsPYCodeEnabledForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYCodeEnabledForSVResult>(ptr);
    }

    bool IsPYCodeEnabledForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsPYCodeEnabledForSVResult::documentation() const { return Documentation; }


    std::string IsPYCodeEnabledForSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYCodeEnabledForSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsPYCodeEnabledForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsPYCodeEnabledForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsPYCodeEnabledForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsPYCodeEnabledForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnablePYCodeForEachSV
///
#include "gen/EnablePYCodeForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnablePYCodeForEachSV::CmdName = "EnablePYCodeForEachSV";
    const char* const EnablePYCodeForEachSV::Documentation = "Enable (or disable) P(Y)-Code for each satellite individually.";

    REGISTER_COMMAND_FACTORY(EnablePYCodeForEachSV);


    EnablePYCodeForEachSV::EnablePYCodeForEachSV()
      : CommandBase(CmdName)
    {}

    EnablePYCodeForEachSV::EnablePYCodeForEachSV(const std::string& signal, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    EnablePYCodeForEachSVPtr EnablePYCodeForEachSV::create(const std::string& signal, const std::vector<bool>& enabled)
    {
      return std::make_shared<EnablePYCodeForEachSV>(signal, enabled);
    }

    EnablePYCodeForEachSVPtr EnablePYCodeForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnablePYCodeForEachSV>(ptr);
    }

    bool EnablePYCodeForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnablePYCodeForEachSV::documentation() const { return Documentation; }


    int EnablePYCodeForEachSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnablePYCodeForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnablePYCodeForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnablePYCodeForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnablePYCodeForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYCodeEnabledForEachSV
///
#include "gen/IsPYCodeEnabledForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYCodeEnabledForEachSV::CmdName = "IsPYCodeEnabledForEachSV";
    const char* const IsPYCodeEnabledForEachSV::Documentation = "Tells if the P(Y)-Code is enabled or disabled for each satellite.";

    REGISTER_COMMAND_FACTORY(IsPYCodeEnabledForEachSV);


    IsPYCodeEnabledForEachSV::IsPYCodeEnabledForEachSV()
      : CommandBase(CmdName)
    {}

    IsPYCodeEnabledForEachSV::IsPYCodeEnabledForEachSV(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    IsPYCodeEnabledForEachSVPtr IsPYCodeEnabledForEachSV::create(const std::string& signal)
    {
      return std::make_shared<IsPYCodeEnabledForEachSV>(signal);
    }

    IsPYCodeEnabledForEachSVPtr IsPYCodeEnabledForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYCodeEnabledForEachSV>(ptr);
    }

    bool IsPYCodeEnabledForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string IsPYCodeEnabledForEachSV::documentation() const { return Documentation; }


    int IsPYCodeEnabledForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsPYCodeEnabledForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYCodeEnabledForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYCodeEnabledForEachSVResult
///
#include "gen/IsPYCodeEnabledForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYCodeEnabledForEachSVResult::CmdName = "IsPYCodeEnabledForEachSVResult";
    const char* const IsPYCodeEnabledForEachSVResult::Documentation = "Result of IsPYCodeEnabledForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(IsPYCodeEnabledForEachSVResult);


    IsPYCodeEnabledForEachSVResult::IsPYCodeEnabledForEachSVResult()
      : CommandResult(CmdName)
    {}

    IsPYCodeEnabledForEachSVResult::IsPYCodeEnabledForEachSVResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    IsPYCodeEnabledForEachSVResultPtr IsPYCodeEnabledForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
    {
      return std::make_shared<IsPYCodeEnabledForEachSVResult>(relatedCommand, signal, enabled);
    }

    IsPYCodeEnabledForEachSVResultPtr IsPYCodeEnabledForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYCodeEnabledForEachSVResult>(ptr);
    }

    bool IsPYCodeEnabledForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsPYCodeEnabledForEachSVResult::documentation() const { return Documentation; }


    std::string IsPYCodeEnabledForEachSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYCodeEnabledForEachSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsPYCodeEnabledForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsPYCodeEnabledForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetManualPowerOffsetForSV
///
#include "gen/SetManualPowerOffsetForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetManualPowerOffsetForSV::CmdName = "SetManualPowerOffsetForSV";
    const char* const SetManualPowerOffsetForSV::Documentation = "Set the power offsets applied to the signals of a satellite. Use SV ID 0 to set the power offset of all the satellites. Use key \"All\" to set the power offset to all signals.";

    REGISTER_COMMAND_FACTORY(SetManualPowerOffsetForSV);


    SetManualPowerOffsetForSV::SetManualPowerOffsetForSV()
      : CommandBase(CmdName)
    {}

    SetManualPowerOffsetForSV::SetManualPowerOffsetForSV(const std::string& system, int svId, const std::map<std::string, double>& signalPowerOffsetDict, bool isRelativePowerOffset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setSignalPowerOffsetDict(signalPowerOffsetDict);
      setIsRelativePowerOffset(isRelativePowerOffset);
    }


    SetManualPowerOffsetForSVPtr SetManualPowerOffsetForSV::create(const std::string& system, int svId, const std::map<std::string, double>& signalPowerOffsetDict, bool isRelativePowerOffset)
    {
      return std::make_shared<SetManualPowerOffsetForSV>(system, svId, signalPowerOffsetDict, isRelativePowerOffset);
    }

    SetManualPowerOffsetForSVPtr SetManualPowerOffsetForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetManualPowerOffsetForSV>(ptr);
    }

    bool SetManualPowerOffsetForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, double>>::is_valid(m_values["SignalPowerOffsetDict"])
          && parse_json<bool>::is_valid(m_values["IsRelativePowerOffset"])
        ;

    }

    std::string SetManualPowerOffsetForSV::documentation() const { return Documentation; }


    int SetManualPowerOffsetForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string SetManualPowerOffsetForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetManualPowerOffsetForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetManualPowerOffsetForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetManualPowerOffsetForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, double> SetManualPowerOffsetForSV::signalPowerOffsetDict() const
    {
      return parse_json<std::map<std::string, double>>::parse(m_values["SignalPowerOffsetDict"]);
    }

    void SetManualPowerOffsetForSV::setSignalPowerOffsetDict(const std::map<std::string, double>& signalPowerOffsetDict)
    {
      m_values.AddMember("SignalPowerOffsetDict", parse_json<std::map<std::string, double>>::format(signalPowerOffsetDict, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetManualPowerOffsetForSV::isRelativePowerOffset() const
    {
      return parse_json<bool>::parse(m_values["IsRelativePowerOffset"]);
    }

    void SetManualPowerOffsetForSV::setIsRelativePowerOffset(bool isRelativePowerOffset)
    {
      m_values.AddMember("IsRelativePowerOffset", parse_json<bool>::format(isRelativePowerOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetManualPowerOffsetForSV
///
#include "gen/GetManualPowerOffsetForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetManualPowerOffsetForSV::CmdName = "GetManualPowerOffsetForSV";
    const char* const GetManualPowerOffsetForSV::Documentation = "Get the power offsets for specific signals of a satellite.";

    REGISTER_COMMAND_FACTORY(GetManualPowerOffsetForSV);


    GetManualPowerOffsetForSV::GetManualPowerOffsetForSV()
      : CommandBase(CmdName)
    {}

    GetManualPowerOffsetForSV::GetManualPowerOffsetForSV(const std::string& system, int svId, const std::vector<std::string>& signalArray)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setSignalArray(signalArray);
    }


    GetManualPowerOffsetForSVPtr GetManualPowerOffsetForSV::create(const std::string& system, int svId, const std::vector<std::string>& signalArray)
    {
      return std::make_shared<GetManualPowerOffsetForSV>(system, svId, signalArray);
    }

    GetManualPowerOffsetForSVPtr GetManualPowerOffsetForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetManualPowerOffsetForSV>(ptr);
    }

    bool GetManualPowerOffsetForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
        ;

    }

    std::string GetManualPowerOffsetForSV::documentation() const { return Documentation; }


    int GetManualPowerOffsetForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string GetManualPowerOffsetForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetManualPowerOffsetForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetManualPowerOffsetForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetManualPowerOffsetForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetManualPowerOffsetForSV::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetManualPowerOffsetForSV::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetManualPowerOffsetForSVResult
///
#include "gen/GetManualPowerOffsetForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetManualPowerOffsetForSVResult::CmdName = "GetManualPowerOffsetForSVResult";
    const char* const GetManualPowerOffsetForSVResult::Documentation = "Result of GetManualPowerOffsetForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetManualPowerOffsetForSVResult);


    GetManualPowerOffsetForSVResult::GetManualPowerOffsetForSVResult()
      : CommandResult(CmdName)
    {}

    GetManualPowerOffsetForSVResult::GetManualPowerOffsetForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::map<std::string, double>& signalPowerOffsetDict)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setSignalPowerOffsetDict(signalPowerOffsetDict);
    }


    GetManualPowerOffsetForSVResultPtr GetManualPowerOffsetForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::map<std::string, double>& signalPowerOffsetDict)
    {
      return std::make_shared<GetManualPowerOffsetForSVResult>(relatedCommand, system, svId, signalPowerOffsetDict);
    }

    GetManualPowerOffsetForSVResultPtr GetManualPowerOffsetForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetManualPowerOffsetForSVResult>(ptr);
    }

    bool GetManualPowerOffsetForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, double>>::is_valid(m_values["SignalPowerOffsetDict"])
        ;

    }

    std::string GetManualPowerOffsetForSVResult::documentation() const { return Documentation; }


    std::string GetManualPowerOffsetForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetManualPowerOffsetForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetManualPowerOffsetForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetManualPowerOffsetForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, double> GetManualPowerOffsetForSVResult::signalPowerOffsetDict() const
    {
      return parse_json<std::map<std::string, double>>::parse(m_values["SignalPowerOffsetDict"]);
    }

    void GetManualPowerOffsetForSVResult::setSignalPowerOffsetDict(const std::map<std::string, double>& signalPowerOffsetDict)
    {
      m_values.AddMember("SignalPowerOffsetDict", parse_json<std::map<std::string, double>>::format(signalPowerOffsetDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetManualPowerOffsets
///
#include "gen/ResetManualPowerOffsets.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetManualPowerOffsets::CmdName = "ResetManualPowerOffsets";
    const char* const ResetManualPowerOffsets::Documentation = "Reset power offset for all satellites is specified system to default value";

    REGISTER_COMMAND_FACTORY(ResetManualPowerOffsets);


    ResetManualPowerOffsets::ResetManualPowerOffsets()
      : CommandBase(CmdName)
    {}

    ResetManualPowerOffsets::ResetManualPowerOffsets(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    ResetManualPowerOffsetsPtr ResetManualPowerOffsets::create(const std::string& system)
    {
      return std::make_shared<ResetManualPowerOffsets>(system);
    }

    ResetManualPowerOffsetsPtr ResetManualPowerOffsets::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetManualPowerOffsets>(ptr);
    }

    bool ResetManualPowerOffsets::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string ResetManualPowerOffsets::documentation() const { return Documentation; }


    int ResetManualPowerOffsets::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string ResetManualPowerOffsets::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ResetManualPowerOffsets::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetAllSatPower
///
#include "gen/ResetAllSatPower.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetAllSatPower::CmdName = "ResetAllSatPower";
    const char* const ResetAllSatPower::Documentation = "Please note the command ResetAllSatPower is deprecated since 21.7. You may use ResetManualPowerOffsets.\n\nReset power offset for all satellites is specified system to default value";

    REGISTER_COMMAND_FACTORY(ResetAllSatPower);


    ResetAllSatPower::ResetAllSatPower()
      : CommandBase(CmdName)
    {}

    ResetAllSatPower::ResetAllSatPower(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    ResetAllSatPowerPtr ResetAllSatPower::create(const std::string& system)
    {
      return std::make_shared<ResetAllSatPower>(system);
    }

    ResetAllSatPowerPtr ResetAllSatPower::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetAllSatPower>(ptr);
    }

    bool ResetAllSatPower::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string ResetAllSatPower::documentation() const { return Documentation; }


    int ResetAllSatPower::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string ResetAllSatPower::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ResetAllSatPower::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllPowerForSV
///
#include "gen/GetAllPowerForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllPowerForSV::CmdName = "GetAllPowerForSV";
    const char* const GetAllPowerForSV::Documentation = "Get the power information for the specified satellite.";

    REGISTER_COMMAND_FACTORY(GetAllPowerForSV);


    GetAllPowerForSV::GetAllPowerForSV()
      : CommandBase(CmdName)
    {}

    GetAllPowerForSV::GetAllPowerForSV(const std::string& system, int svId, const std::vector<std::string>& signalArray)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setSignalArray(signalArray);
    }


    GetAllPowerForSVPtr GetAllPowerForSV::create(const std::string& system, int svId, const std::vector<std::string>& signalArray)
    {
      return std::make_shared<GetAllPowerForSV>(system, svId, signalArray);
    }

    GetAllPowerForSVPtr GetAllPowerForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllPowerForSV>(ptr);
    }

    bool GetAllPowerForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
        ;

    }

    std::string GetAllPowerForSV::documentation() const { return Documentation; }


    int GetAllPowerForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string GetAllPowerForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllPowerForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllPowerForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllPowerForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetAllPowerForSV::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetAllPowerForSV::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllPowerForSVResult
///
#include "gen/GetAllPowerForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllPowerForSVResult::CmdName = "GetAllPowerForSVResult";
    const char* const GetAllPowerForSVResult::Documentation = "Result of GetAllPowerForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllPowerForSVResult);


    GetAllPowerForSVResult::GetAllPowerForSVResult()
      : CommandResult(CmdName)
    {}

    GetAllPowerForSVResult::GetAllPowerForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, double nominalPower, double globalOffset, const std::map<std::string, Sdx::SignalPower>& signalPowerDict)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setNominalPower(nominalPower);
      setGlobalOffset(globalOffset);
      setSignalPowerDict(signalPowerDict);
    }


    GetAllPowerForSVResultPtr GetAllPowerForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, double nominalPower, double globalOffset, const std::map<std::string, Sdx::SignalPower>& signalPowerDict)
    {
      return std::make_shared<GetAllPowerForSVResult>(relatedCommand, system, svId, nominalPower, globalOffset, signalPowerDict);
    }

    GetAllPowerForSVResultPtr GetAllPowerForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllPowerForSVResult>(ptr);
    }

    bool GetAllPowerForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["NominalPower"])
          && parse_json<double>::is_valid(m_values["GlobalOffset"])
          && parse_json<std::map<std::string, Sdx::SignalPower>>::is_valid(m_values["SignalPowerDict"])
        ;

    }

    std::string GetAllPowerForSVResult::documentation() const { return Documentation; }


    std::string GetAllPowerForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllPowerForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllPowerForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllPowerForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetAllPowerForSVResult::nominalPower() const
    {
      return parse_json<double>::parse(m_values["NominalPower"]);
    }

    void GetAllPowerForSVResult::setNominalPower(double nominalPower)
    {
      m_values.AddMember("NominalPower", parse_json<double>::format(nominalPower, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetAllPowerForSVResult::globalOffset() const
    {
      return parse_json<double>::parse(m_values["GlobalOffset"]);
    }

    void GetAllPowerForSVResult::setGlobalOffset(double globalOffset)
    {
      m_values.AddMember("GlobalOffset", parse_json<double>::format(globalOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, Sdx::SignalPower> GetAllPowerForSVResult::signalPowerDict() const
    {
      return parse_json<std::map<std::string, Sdx::SignalPower>>::parse(m_values["SignalPowerDict"]);
    }

    void GetAllPowerForSVResult::setSignalPowerDict(const std::map<std::string, Sdx::SignalPower>& signalPowerDict)
    {
      m_values.AddMember("SignalPowerDict", parse_json<std::map<std::string, Sdx::SignalPower>>::format(signalPowerDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportPerformanceDataToCSV
///
#include "gen/ExportPerformanceDataToCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportPerformanceDataToCSV::CmdName = "ExportPerformanceDataToCSV";
    const char* const ExportPerformanceDataToCSV::Documentation = "Export the performance graph data into a csv file.";

    REGISTER_COMMAND_FACTORY(ExportPerformanceDataToCSV);


    ExportPerformanceDataToCSV::ExportPerformanceDataToCSV()
      : CommandBase(CmdName)
    {}

    ExportPerformanceDataToCSV::ExportPerformanceDataToCSV(const std::string& path, bool overwriting)
      : CommandBase(CmdName)
    {

      setPath(path);
      setOverwriting(overwriting);
    }


    ExportPerformanceDataToCSVPtr ExportPerformanceDataToCSV::create(const std::string& path, bool overwriting)
    {
      return std::make_shared<ExportPerformanceDataToCSV>(path, overwriting);
    }

    ExportPerformanceDataToCSVPtr ExportPerformanceDataToCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportPerformanceDataToCSV>(ptr);
    }

    bool ExportPerformanceDataToCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
        ;

    }

    std::string ExportPerformanceDataToCSV::documentation() const { return Documentation; }


    int ExportPerformanceDataToCSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string ExportPerformanceDataToCSV::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ExportPerformanceDataToCSV::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ExportPerformanceDataToCSV::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportPerformanceDataToCSV::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportHilGraphDataToCSV
///
#include "gen/ExportHilGraphDataToCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportHilGraphDataToCSV::CmdName = "ExportHilGraphDataToCSV";
    const char* const ExportHilGraphDataToCSV::Documentation = "Export the hil graph data into a csv file.";

    REGISTER_COMMAND_FACTORY(ExportHilGraphDataToCSV);


    ExportHilGraphDataToCSV::ExportHilGraphDataToCSV()
      : CommandBase(CmdName)
    {}

    ExportHilGraphDataToCSV::ExportHilGraphDataToCSV(const std::string& path, bool overwriting)
      : CommandBase(CmdName)
    {

      setPath(path);
      setOverwriting(overwriting);
    }


    ExportHilGraphDataToCSVPtr ExportHilGraphDataToCSV::create(const std::string& path, bool overwriting)
    {
      return std::make_shared<ExportHilGraphDataToCSV>(path, overwriting);
    }

    ExportHilGraphDataToCSVPtr ExportHilGraphDataToCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportHilGraphDataToCSV>(ptr);
    }

    bool ExportHilGraphDataToCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
        ;

    }

    std::string ExportHilGraphDataToCSV::documentation() const { return Documentation; }


    int ExportHilGraphDataToCSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string ExportHilGraphDataToCSV::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ExportHilGraphDataToCSV::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ExportHilGraphDataToCSV::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportHilGraphDataToCSV::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPropagationDelay
///
#include "gen/SetPropagationDelay.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPropagationDelay::CmdName = "SetPropagationDelay";
    const char* const SetPropagationDelay::Documentation = "Enable (or disable) the satellite signal propagation delay. If disabled, the signal is immediately received\nby the receiver. The delay should always be enabled, unless your are doing a PPS calibration for the simulator.";

    REGISTER_COMMAND_FACTORY(SetPropagationDelay);


    SetPropagationDelay::SetPropagationDelay()
      : CommandBase(CmdName)
    {}

    SetPropagationDelay::SetPropagationDelay(const std::string& system, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    SetPropagationDelayPtr SetPropagationDelay::create(const std::string& system, bool enabled)
    {
      return std::make_shared<SetPropagationDelay>(system, enabled);
    }

    SetPropagationDelayPtr SetPropagationDelay::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPropagationDelay>(ptr);
    }

    bool SetPropagationDelay::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string SetPropagationDelay::documentation() const { return Documentation; }


    int SetPropagationDelay::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPropagationDelay::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPropagationDelay::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPropagationDelay::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPropagationDelay::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPropagationDelayEnabled
///
#include "gen/IsPropagationDelayEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPropagationDelayEnabled::CmdName = "IsPropagationDelayEnabled";
    const char* const IsPropagationDelayEnabled::Documentation = "Tells if the propagation delay is enabled.";

    REGISTER_COMMAND_FACTORY(IsPropagationDelayEnabled);


    IsPropagationDelayEnabled::IsPropagationDelayEnabled()
      : CommandBase(CmdName)
    {}

    IsPropagationDelayEnabled::IsPropagationDelayEnabled(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsPropagationDelayEnabledPtr IsPropagationDelayEnabled::create(const std::string& system)
    {
      return std::make_shared<IsPropagationDelayEnabled>(system);
    }

    IsPropagationDelayEnabledPtr IsPropagationDelayEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPropagationDelayEnabled>(ptr);
    }

    bool IsPropagationDelayEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsPropagationDelayEnabled::documentation() const { return Documentation; }


    int IsPropagationDelayEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsPropagationDelayEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsPropagationDelayEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPropagationDelayEnabledResult
///
#include "gen/IsPropagationDelayEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPropagationDelayEnabledResult::CmdName = "IsPropagationDelayEnabledResult";
    const char* const IsPropagationDelayEnabledResult::Documentation = "Result of IsPropagationDelayEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsPropagationDelayEnabledResult);


    IsPropagationDelayEnabledResult::IsPropagationDelayEnabledResult()
      : CommandResult(CmdName)
    {}

    IsPropagationDelayEnabledResult::IsPropagationDelayEnabledResult(CommandBasePtr relatedCommand, const std::string& system, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    IsPropagationDelayEnabledResultPtr IsPropagationDelayEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, bool enabled)
    {
      return std::make_shared<IsPropagationDelayEnabledResult>(relatedCommand, system, enabled);
    }

    IsPropagationDelayEnabledResultPtr IsPropagationDelayEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPropagationDelayEnabledResult>(ptr);
    }

    bool IsPropagationDelayEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsPropagationDelayEnabledResult::documentation() const { return Documentation; }


    std::string IsPropagationDelayEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsPropagationDelayEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsPropagationDelayEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsPropagationDelayEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSatMotionFixed
///
#include "gen/SetSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSatMotionFixed::CmdName = "SetSatMotionFixed";
    const char* const SetSatMotionFixed::Documentation = "If IsFixed is set to true, the satellite will not move during the simulation and keep its initial position calculated at the beginning of the simulation.";

    REGISTER_COMMAND_FACTORY(SetSatMotionFixed);


    SetSatMotionFixed::SetSatMotionFixed()
      : CommandBase(CmdName)
    {}

    SetSatMotionFixed::SetSatMotionFixed(const std::string& system, int svId, bool isFixed)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setIsFixed(isFixed);
    }


    SetSatMotionFixedPtr SetSatMotionFixed::create(const std::string& system, int svId, bool isFixed)
    {
      return std::make_shared<SetSatMotionFixed>(system, svId, isFixed);
    }

    SetSatMotionFixedPtr SetSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSatMotionFixed>(ptr);
    }

    bool SetSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string SetSatMotionFixed::documentation() const { return Documentation; }


    int SetSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSatMotionFixed::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSatMotionFixed::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatMotionFixed::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSatMotionFixed::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSatMotionFixed::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void SetSatMotionFixed::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSatMotionFixed
///
#include "gen/IsSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSatMotionFixed::CmdName = "IsSatMotionFixed";
    const char* const IsSatMotionFixed::Documentation = "Tells if the satellite is fixed (True) or not fixed (false).";

    REGISTER_COMMAND_FACTORY(IsSatMotionFixed);


    IsSatMotionFixed::IsSatMotionFixed()
      : CommandBase(CmdName)
    {}

    IsSatMotionFixed::IsSatMotionFixed(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    IsSatMotionFixedPtr IsSatMotionFixed::create(const std::string& system, int svId)
    {
      return std::make_shared<IsSatMotionFixed>(system, svId);
    }

    IsSatMotionFixedPtr IsSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSatMotionFixed>(ptr);
    }

    bool IsSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsSatMotionFixed::documentation() const { return Documentation; }


    int IsSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSatMotionFixed::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSatMotionFixed::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSatMotionFixed::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSatMotionFixed::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSatMotionFixedResult
///
#include "gen/IsSatMotionFixedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSatMotionFixedResult::CmdName = "IsSatMotionFixedResult";
    const char* const IsSatMotionFixedResult::Documentation = "Result of IsSatMotionFixed.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSatMotionFixedResult);


    IsSatMotionFixedResult::IsSatMotionFixedResult()
      : CommandResult(CmdName)
    {}

    IsSatMotionFixedResult::IsSatMotionFixedResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool isFixed)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setIsFixed(isFixed);
    }


    IsSatMotionFixedResultPtr IsSatMotionFixedResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool isFixed)
    {
      return std::make_shared<IsSatMotionFixedResult>(relatedCommand, system, svId, isFixed);
    }

    IsSatMotionFixedResultPtr IsSatMotionFixedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSatMotionFixedResult>(ptr);
    }

    bool IsSatMotionFixedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string IsSatMotionFixedResult::documentation() const { return Documentation; }


    std::string IsSatMotionFixedResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSatMotionFixedResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSatMotionFixedResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSatMotionFixedResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSatMotionFixedResult::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void IsSatMotionFixedResult::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoAlpha
///
#include "gen/SetIonoAlpha.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoAlpha::CmdName = "SetIonoAlpha";
    const char* const SetIonoAlpha::Documentation = "Set the GPS ionospheric Alpha coefficient\nAlpha 0 is in seconds\nAlpha 1 is in seconds/semicircle\nAlpha 2 is in seconds/semicircle^2\nAlpha 3 is in seconds/semicircle^3";

    REGISTER_COMMAND_FACTORY(SetIonoAlpha);


    SetIonoAlpha::SetIonoAlpha()
      : CommandBase(CmdName)
    {}

    SetIonoAlpha::SetIonoAlpha(int index, double val)
      : CommandBase(CmdName)
    {

      setIndex(index);
      setVal(val);
    }


    SetIonoAlphaPtr SetIonoAlpha::create(int index, double val)
    {
      return std::make_shared<SetIonoAlpha>(index, val);
    }

    SetIonoAlphaPtr SetIonoAlpha::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoAlpha>(ptr);
    }

    bool SetIonoAlpha::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetIonoAlpha::documentation() const { return Documentation; }


    int SetIonoAlpha::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoAlpha::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void SetIonoAlpha::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIonoAlpha::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetIonoAlpha::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoAlpha
///
#include "gen/GetIonoAlpha.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoAlpha::CmdName = "GetIonoAlpha";
    const char* const GetIonoAlpha::Documentation = "Get the GPS ionospheric Alpha coefficient\nAlpha 0 is in seconds\nAlpha 1 is in seconds/semicircle\nAlpha 2 is in seconds/semicircle^2\nAlpha 3 is in seconds/semicircle^3";

    REGISTER_COMMAND_FACTORY(GetIonoAlpha);


    GetIonoAlpha::GetIonoAlpha()
      : CommandBase(CmdName)
    {}

    GetIonoAlpha::GetIonoAlpha(int index)
      : CommandBase(CmdName)
    {

      setIndex(index);
    }


    GetIonoAlphaPtr GetIonoAlpha::create(int index)
    {
      return std::make_shared<GetIonoAlpha>(index);
    }

    GetIonoAlphaPtr GetIonoAlpha::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoAlpha>(ptr);
    }

    bool GetIonoAlpha::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
        ;

    }

    std::string GetIonoAlpha::documentation() const { return Documentation; }


    int GetIonoAlpha::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoAlpha::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoAlpha::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoAlphaResult
///
#include "gen/GetIonoAlphaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoAlphaResult::CmdName = "GetIonoAlphaResult";
    const char* const GetIonoAlphaResult::Documentation = "Result of GetIonoAlpha.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoAlphaResult);


    GetIonoAlphaResult::GetIonoAlphaResult()
      : CommandResult(CmdName)
    {}

    GetIonoAlphaResult::GetIonoAlphaResult(CommandBasePtr relatedCommand, int index, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setIndex(index);
      setVal(val);
    }


    GetIonoAlphaResultPtr GetIonoAlphaResult::create(CommandBasePtr relatedCommand, int index, double val)
    {
      return std::make_shared<GetIonoAlphaResult>(relatedCommand, index, val);
    }

    GetIonoAlphaResultPtr GetIonoAlphaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoAlphaResult>(ptr);
    }

    bool GetIonoAlphaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetIonoAlphaResult::documentation() const { return Documentation; }


    int GetIonoAlphaResult::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoAlphaResult::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIonoAlphaResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetIonoAlphaResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoBeta
///
#include "gen/SetIonoBeta.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoBeta::CmdName = "SetIonoBeta";
    const char* const SetIonoBeta::Documentation = "Set the GPS ionospheric Beta coefficient\nBeta 0 is in seconds\nBeta 1 is in seconds/semicircle\nBeta 2 is in seconds/semicircle^2\nBeta 3 is in seconds/semicircle^3";

    REGISTER_COMMAND_FACTORY(SetIonoBeta);


    SetIonoBeta::SetIonoBeta()
      : CommandBase(CmdName)
    {}

    SetIonoBeta::SetIonoBeta(int index, double val)
      : CommandBase(CmdName)
    {

      setIndex(index);
      setVal(val);
    }


    SetIonoBetaPtr SetIonoBeta::create(int index, double val)
    {
      return std::make_shared<SetIonoBeta>(index, val);
    }

    SetIonoBetaPtr SetIonoBeta::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoBeta>(ptr);
    }

    bool SetIonoBeta::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetIonoBeta::documentation() const { return Documentation; }


    int SetIonoBeta::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoBeta::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void SetIonoBeta::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIonoBeta::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetIonoBeta::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoBeta
///
#include "gen/GetIonoBeta.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoBeta::CmdName = "GetIonoBeta";
    const char* const GetIonoBeta::Documentation = "Get the GPS ionospheric Beta coefficient\nBeta 0 is in seconds\nBeta 1 is in seconds/semicircle\nBeta 2 is in seconds/semicircle^2\nBeta 3 is in seconds/semicircle^3";

    REGISTER_COMMAND_FACTORY(GetIonoBeta);


    GetIonoBeta::GetIonoBeta()
      : CommandBase(CmdName)
    {}

    GetIonoBeta::GetIonoBeta(int index)
      : CommandBase(CmdName)
    {

      setIndex(index);
    }


    GetIonoBetaPtr GetIonoBeta::create(int index)
    {
      return std::make_shared<GetIonoBeta>(index);
    }

    GetIonoBetaPtr GetIonoBeta::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoBeta>(ptr);
    }

    bool GetIonoBeta::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
        ;

    }

    std::string GetIonoBeta::documentation() const { return Documentation; }


    int GetIonoBeta::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoBeta::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoBeta::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoBetaResult
///
#include "gen/GetIonoBetaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoBetaResult::CmdName = "GetIonoBetaResult";
    const char* const GetIonoBetaResult::Documentation = "Result of GetIonoBeta.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoBetaResult);


    GetIonoBetaResult::GetIonoBetaResult()
      : CommandResult(CmdName)
    {}

    GetIonoBetaResult::GetIonoBetaResult(CommandBasePtr relatedCommand, int index, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setIndex(index);
      setVal(val);
    }


    GetIonoBetaResultPtr GetIonoBetaResult::create(CommandBasePtr relatedCommand, int index, double val)
    {
      return std::make_shared<GetIonoBetaResult>(relatedCommand, index, val);
    }

    GetIonoBetaResultPtr GetIonoBetaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoBetaResult>(ptr);
    }

    bool GetIonoBetaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetIonoBetaResult::documentation() const { return Documentation; }


    int GetIonoBetaResult::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoBetaResult::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIonoBetaResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetIonoBetaResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoBdgimAlpha
///
#include "gen/SetIonoBdgimAlpha.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoBdgimAlpha::CmdName = "SetIonoBdgimAlpha";
    const char* const SetIonoBdgimAlpha::Documentation = "Set the BeiDou (BDGIM) ionospheric Alpha coefficient (in TECu)";

    REGISTER_COMMAND_FACTORY(SetIonoBdgimAlpha);


    SetIonoBdgimAlpha::SetIonoBdgimAlpha()
      : CommandBase(CmdName)
    {}

    SetIonoBdgimAlpha::SetIonoBdgimAlpha(int index, double val)
      : CommandBase(CmdName)
    {

      setIndex(index);
      setVal(val);
    }


    SetIonoBdgimAlphaPtr SetIonoBdgimAlpha::create(int index, double val)
    {
      return std::make_shared<SetIonoBdgimAlpha>(index, val);
    }

    SetIonoBdgimAlphaPtr SetIonoBdgimAlpha::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoBdgimAlpha>(ptr);
    }

    bool SetIonoBdgimAlpha::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetIonoBdgimAlpha::documentation() const { return Documentation; }


    int SetIonoBdgimAlpha::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoBdgimAlpha::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void SetIonoBdgimAlpha::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIonoBdgimAlpha::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetIonoBdgimAlpha::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoBdgimAlpha
///
#include "gen/GetIonoBdgimAlpha.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoBdgimAlpha::CmdName = "GetIonoBdgimAlpha";
    const char* const GetIonoBdgimAlpha::Documentation = "Get the BeiDou (BDGIM) ionospheric Alpha coefficient (in TECu)";

    REGISTER_COMMAND_FACTORY(GetIonoBdgimAlpha);


    GetIonoBdgimAlpha::GetIonoBdgimAlpha()
      : CommandBase(CmdName)
    {}

    GetIonoBdgimAlpha::GetIonoBdgimAlpha(int index)
      : CommandBase(CmdName)
    {

      setIndex(index);
    }


    GetIonoBdgimAlphaPtr GetIonoBdgimAlpha::create(int index)
    {
      return std::make_shared<GetIonoBdgimAlpha>(index);
    }

    GetIonoBdgimAlphaPtr GetIonoBdgimAlpha::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoBdgimAlpha>(ptr);
    }

    bool GetIonoBdgimAlpha::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
        ;

    }

    std::string GetIonoBdgimAlpha::documentation() const { return Documentation; }


    int GetIonoBdgimAlpha::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoBdgimAlpha::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoBdgimAlpha::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoBdgimAlphaResult
///
#include "gen/GetIonoBdgimAlphaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoBdgimAlphaResult::CmdName = "GetIonoBdgimAlphaResult";
    const char* const GetIonoBdgimAlphaResult::Documentation = "Result of GetIonoBdgimAlpha.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoBdgimAlphaResult);


    GetIonoBdgimAlphaResult::GetIonoBdgimAlphaResult()
      : CommandResult(CmdName)
    {}

    GetIonoBdgimAlphaResult::GetIonoBdgimAlphaResult(CommandBasePtr relatedCommand, int index, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setIndex(index);
      setVal(val);
    }


    GetIonoBdgimAlphaResultPtr GetIonoBdgimAlphaResult::create(CommandBasePtr relatedCommand, int index, double val)
    {
      return std::make_shared<GetIonoBdgimAlphaResult>(relatedCommand, index, val);
    }

    GetIonoBdgimAlphaResultPtr GetIonoBdgimAlphaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoBdgimAlphaResult>(ptr);
    }

    bool GetIonoBdgimAlphaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetIonoBdgimAlphaResult::documentation() const { return Documentation; }


    int GetIonoBdgimAlphaResult::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoBdgimAlphaResult::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIonoBdgimAlphaResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetIonoBdgimAlphaResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetEffectiveIonisationLevelCoefficient
///
#include "gen/SetEffectiveIonisationLevelCoefficient.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetEffectiveIonisationLevelCoefficient::CmdName = "SetEffectiveIonisationLevelCoefficient";
    const char* const SetEffectiveIonisationLevelCoefficient::Documentation = "Set the effective ionisation level coefficient for the 1st, 2nd or 3rd order, (ai0 , ai1 , ai2).";

    REGISTER_COMMAND_FACTORY(SetEffectiveIonisationLevelCoefficient);


    SetEffectiveIonisationLevelCoefficient::SetEffectiveIonisationLevelCoefficient()
      : CommandBase(CmdName)
    {}

    SetEffectiveIonisationLevelCoefficient::SetEffectiveIonisationLevelCoefficient(int index, double val)
      : CommandBase(CmdName)
    {

      setIndex(index);
      setVal(val);
    }


    SetEffectiveIonisationLevelCoefficientPtr SetEffectiveIonisationLevelCoefficient::create(int index, double val)
    {
      return std::make_shared<SetEffectiveIonisationLevelCoefficient>(index, val);
    }

    SetEffectiveIonisationLevelCoefficientPtr SetEffectiveIonisationLevelCoefficient::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetEffectiveIonisationLevelCoefficient>(ptr);
    }

    bool SetEffectiveIonisationLevelCoefficient::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetEffectiveIonisationLevelCoefficient::documentation() const { return Documentation; }


    int SetEffectiveIonisationLevelCoefficient::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetEffectiveIonisationLevelCoefficient::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void SetEffectiveIonisationLevelCoefficient::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetEffectiveIonisationLevelCoefficient::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetEffectiveIonisationLevelCoefficient::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEffectiveIonisationLevelCoefficient
///
#include "gen/GetEffectiveIonisationLevelCoefficient.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEffectiveIonisationLevelCoefficient::CmdName = "GetEffectiveIonisationLevelCoefficient";
    const char* const GetEffectiveIonisationLevelCoefficient::Documentation = "Get the effective ionisation level coefficient for the 1st, 2nd or 3rd order, (ai0 , ai1 , ai2).";

    REGISTER_COMMAND_FACTORY(GetEffectiveIonisationLevelCoefficient);


    GetEffectiveIonisationLevelCoefficient::GetEffectiveIonisationLevelCoefficient()
      : CommandBase(CmdName)
    {}

    GetEffectiveIonisationLevelCoefficient::GetEffectiveIonisationLevelCoefficient(int index)
      : CommandBase(CmdName)
    {

      setIndex(index);
    }


    GetEffectiveIonisationLevelCoefficientPtr GetEffectiveIonisationLevelCoefficient::create(int index)
    {
      return std::make_shared<GetEffectiveIonisationLevelCoefficient>(index);
    }

    GetEffectiveIonisationLevelCoefficientPtr GetEffectiveIonisationLevelCoefficient::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEffectiveIonisationLevelCoefficient>(ptr);
    }

    bool GetEffectiveIonisationLevelCoefficient::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
        ;

    }

    std::string GetEffectiveIonisationLevelCoefficient::documentation() const { return Documentation; }


    int GetEffectiveIonisationLevelCoefficient::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetEffectiveIonisationLevelCoefficient::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetEffectiveIonisationLevelCoefficient::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEffectiveIonisationLevelCoefficientResult
///
#include "gen/GetEffectiveIonisationLevelCoefficientResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEffectiveIonisationLevelCoefficientResult::CmdName = "GetEffectiveIonisationLevelCoefficientResult";
    const char* const GetEffectiveIonisationLevelCoefficientResult::Documentation = "Result of GetEffectiveIonisationLevelCoefficient.";

    REGISTER_COMMAND_RESULT_FACTORY(GetEffectiveIonisationLevelCoefficientResult);


    GetEffectiveIonisationLevelCoefficientResult::GetEffectiveIonisationLevelCoefficientResult()
      : CommandResult(CmdName)
    {}

    GetEffectiveIonisationLevelCoefficientResult::GetEffectiveIonisationLevelCoefficientResult(CommandBasePtr relatedCommand, int index, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setIndex(index);
      setVal(val);
    }


    GetEffectiveIonisationLevelCoefficientResultPtr GetEffectiveIonisationLevelCoefficientResult::create(CommandBasePtr relatedCommand, int index, double val)
    {
      return std::make_shared<GetEffectiveIonisationLevelCoefficientResult>(relatedCommand, index, val);
    }

    GetEffectiveIonisationLevelCoefficientResultPtr GetEffectiveIonisationLevelCoefficientResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEffectiveIonisationLevelCoefficientResult>(ptr);
    }

    bool GetEffectiveIonisationLevelCoefficientResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetEffectiveIonisationLevelCoefficientResult::documentation() const { return Documentation; }


    int GetEffectiveIonisationLevelCoefficientResult::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetEffectiveIonisationLevelCoefficientResult::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetEffectiveIonisationLevelCoefficientResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetEffectiveIonisationLevelCoefficientResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoModel
///
#include "gen/SetIonoModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoModel::CmdName = "SetIonoModel";
    const char* const SetIonoModel::Documentation = "Set ionospheric model";

    REGISTER_COMMAND_FACTORY(SetIonoModel);


    SetIonoModel::SetIonoModel()
      : CommandBase(CmdName)
    {}

    SetIonoModel::SetIonoModel(const std::string& model)
      : CommandBase(CmdName)
    {

      setModel(model);
    }


    SetIonoModelPtr SetIonoModel::create(const std::string& model)
    {
      return std::make_shared<SetIonoModel>(model);
    }

    SetIonoModelPtr SetIonoModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoModel>(ptr);
    }

    bool SetIonoModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Model"])
        ;

    }

    std::string SetIonoModel::documentation() const { return Documentation; }


    int SetIonoModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetIonoModel::model() const
    {
      return parse_json<std::string>::parse(m_values["Model"]);
    }

    void SetIonoModel::setModel(const std::string& model)
    {
      m_values.AddMember("Model", parse_json<std::string>::format(model, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoModel
///
#include "gen/GetIonoModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoModel::CmdName = "GetIonoModel";
    const char* const GetIonoModel::Documentation = "Get ionospheric model";

    REGISTER_COMMAND_FACTORY(GetIonoModel);


    GetIonoModel::GetIonoModel()
      : CommandBase(CmdName)
    {

    }


    GetIonoModelPtr GetIonoModel::create()
    {
      return std::make_shared<GetIonoModel>();
    }

    GetIonoModelPtr GetIonoModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoModel>(ptr);
    }

    bool GetIonoModel::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIonoModel::documentation() const { return Documentation; }


    int GetIonoModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIonoModelResult
///
#include "gen/GetIonoModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoModelResult::CmdName = "GetIonoModelResult";
    const char* const GetIonoModelResult::Documentation = "Result of GetIonoModel.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoModelResult);


    GetIonoModelResult::GetIonoModelResult()
      : CommandResult(CmdName)
    {}

    GetIonoModelResult::GetIonoModelResult(CommandBasePtr relatedCommand, const std::string& model)
      : CommandResult(CmdName, relatedCommand)
    {

      setModel(model);
    }


    GetIonoModelResultPtr GetIonoModelResult::create(CommandBasePtr relatedCommand, const std::string& model)
    {
      return std::make_shared<GetIonoModelResult>(relatedCommand, model);
    }

    GetIonoModelResultPtr GetIonoModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoModelResult>(ptr);
    }

    bool GetIonoModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Model"])
        ;

    }

    std::string GetIonoModelResult::documentation() const { return Documentation; }


    std::string GetIonoModelResult::model() const
    {
      return parse_json<std::string>::parse(m_values["Model"]);
    }

    void GetIonoModelResult::setModel(const std::string& model)
    {
      m_values.AddMember("Model", parse_json<std::string>::format(model, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetTropoModel
///
#include "gen/SetTropoModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetTropoModel::CmdName = "SetTropoModel";
    const char* const SetTropoModel::Documentation = "Set tropospheric model";

    REGISTER_COMMAND_FACTORY(SetTropoModel);


    SetTropoModel::SetTropoModel()
      : CommandBase(CmdName)
    {}

    SetTropoModel::SetTropoModel(const std::string& model)
      : CommandBase(CmdName)
    {

      setModel(model);
    }


    SetTropoModelPtr SetTropoModel::create(const std::string& model)
    {
      return std::make_shared<SetTropoModel>(model);
    }

    SetTropoModelPtr SetTropoModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetTropoModel>(ptr);
    }

    bool SetTropoModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Model"])
        ;

    }

    std::string SetTropoModel::documentation() const { return Documentation; }


    int SetTropoModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetTropoModel::model() const
    {
      return parse_json<std::string>::parse(m_values["Model"]);
    }

    void SetTropoModel::setModel(const std::string& model)
    {
      m_values.AddMember("Model", parse_json<std::string>::format(model, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetTropoModel
///
#include "gen/GetTropoModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetTropoModel::CmdName = "GetTropoModel";
    const char* const GetTropoModel::Documentation = "Get tropospheric model";

    REGISTER_COMMAND_FACTORY(GetTropoModel);


    GetTropoModel::GetTropoModel()
      : CommandBase(CmdName)
    {

    }


    GetTropoModelPtr GetTropoModel::create()
    {
      return std::make_shared<GetTropoModel>();
    }

    GetTropoModelPtr GetTropoModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetTropoModel>(ptr);
    }

    bool GetTropoModel::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetTropoModel::documentation() const { return Documentation; }


    int GetTropoModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetTropoModelResult
///
#include "gen/GetTropoModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetTropoModelResult::CmdName = "GetTropoModelResult";
    const char* const GetTropoModelResult::Documentation = "Result of GetTropoModel.";

    REGISTER_COMMAND_RESULT_FACTORY(GetTropoModelResult);


    GetTropoModelResult::GetTropoModelResult()
      : CommandResult(CmdName)
    {}

    GetTropoModelResult::GetTropoModelResult(CommandBasePtr relatedCommand, const std::string& model)
      : CommandResult(CmdName, relatedCommand)
    {

      setModel(model);
    }


    GetTropoModelResultPtr GetTropoModelResult::create(CommandBasePtr relatedCommand, const std::string& model)
    {
      return std::make_shared<GetTropoModelResult>(relatedCommand, model);
    }

    GetTropoModelResultPtr GetTropoModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetTropoModelResult>(ptr);
    }

    bool GetTropoModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Model"])
        ;

    }

    std::string GetTropoModelResult::documentation() const { return Documentation; }


    std::string GetTropoModelResult::model() const
    {
      return parse_json<std::string>::parse(m_values["Model"]);
    }

    void GetTropoModelResult::setModel(const std::string& model)
    {
      m_values.AddMember("Model", parse_json<std::string>::format(model, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetStartTimeMode
///
#include "gen/SetStartTimeMode.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetStartTimeMode::CmdName = "SetStartTimeMode";
    const char* const SetStartTimeMode::Documentation = "Set the simulation start time mode.";

    REGISTER_COMMAND_FACTORY(SetStartTimeMode);


    SetStartTimeMode::SetStartTimeMode()
      : CommandBase(CmdName)
    {}

    SetStartTimeMode::SetStartTimeMode(const std::string& mode)
      : CommandBase(CmdName)
    {

      setMode(mode);
    }


    SetStartTimeModePtr SetStartTimeMode::create(const std::string& mode)
    {
      return std::make_shared<SetStartTimeMode>(mode);
    }

    SetStartTimeModePtr SetStartTimeMode::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetStartTimeMode>(ptr);
    }

    bool SetStartTimeMode::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Mode"])
        ;

    }

    std::string SetStartTimeMode::documentation() const { return Documentation; }


    int SetStartTimeMode::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetStartTimeMode::mode() const
    {
      return parse_json<std::string>::parse(m_values["Mode"]);
    }

    void SetStartTimeMode::setMode(const std::string& mode)
    {
      m_values.AddMember("Mode", parse_json<std::string>::format(mode, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetStartTimeMode
///
#include "gen/GetStartTimeMode.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStartTimeMode::CmdName = "GetStartTimeMode";
    const char* const GetStartTimeMode::Documentation = "Get the simulation start time mode.";

    REGISTER_COMMAND_FACTORY(GetStartTimeMode);


    GetStartTimeMode::GetStartTimeMode()
      : CommandBase(CmdName)
    {

    }


    GetStartTimeModePtr GetStartTimeMode::create()
    {
      return std::make_shared<GetStartTimeMode>();
    }

    GetStartTimeModePtr GetStartTimeMode::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStartTimeMode>(ptr);
    }

    bool GetStartTimeMode::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetStartTimeMode::documentation() const { return Documentation; }


    int GetStartTimeMode::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetStartTimeModeResult
///
#include "gen/GetStartTimeModeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStartTimeModeResult::CmdName = "GetStartTimeModeResult";
    const char* const GetStartTimeModeResult::Documentation = "Result of GetStartTimeMode.";

    REGISTER_COMMAND_RESULT_FACTORY(GetStartTimeModeResult);


    GetStartTimeModeResult::GetStartTimeModeResult()
      : CommandResult(CmdName)
    {}

    GetStartTimeModeResult::GetStartTimeModeResult(CommandBasePtr relatedCommand, const std::string& mode)
      : CommandResult(CmdName, relatedCommand)
    {

      setMode(mode);
    }


    GetStartTimeModeResultPtr GetStartTimeModeResult::create(CommandBasePtr relatedCommand, const std::string& mode)
    {
      return std::make_shared<GetStartTimeModeResult>(relatedCommand, mode);
    }

    GetStartTimeModeResultPtr GetStartTimeModeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStartTimeModeResult>(ptr);
    }

    bool GetStartTimeModeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Mode"])
        ;

    }

    std::string GetStartTimeModeResult::documentation() const { return Documentation; }


    std::string GetStartTimeModeResult::mode() const
    {
      return parse_json<std::string>::parse(m_values["Mode"]);
    }

    void GetStartTimeModeResult::setMode(const std::string& mode)
    {
      m_values.AddMember("Mode", parse_json<std::string>::format(mode, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ConnectSerialPortReceiver
///
#include "gen/ConnectSerialPortReceiver.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ConnectSerialPortReceiver::CmdName = "ConnectSerialPortReceiver";
    const char* const ConnectSerialPortReceiver::Documentation = "Connect a receiver.";

    REGISTER_COMMAND_FACTORY(ConnectSerialPortReceiver);


    ConnectSerialPortReceiver::ConnectSerialPortReceiver()
      : CommandBase(CmdName)
    {}

    ConnectSerialPortReceiver::ConnectSerialPortReceiver(const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
      : CommandBase(CmdName)
    {

      setPort(port);
      setBaudRate(baudRate);
      setDataBits(dataBits);
      setParity(parity);
      setStopBits(stopBits);
      setFlowControl(flowControl);
    }


    ConnectSerialPortReceiverPtr ConnectSerialPortReceiver::create(const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      return std::make_shared<ConnectSerialPortReceiver>(port, baudRate, dataBits, parity, stopBits, flowControl);
    }

    ConnectSerialPortReceiverPtr ConnectSerialPortReceiver::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ConnectSerialPortReceiver>(ptr);
    }

    bool ConnectSerialPortReceiver::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Port"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["BaudRate"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["DataBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortParity>>::is_valid(m_values["Parity"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["StopBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::is_valid(m_values["FlowControl"])
        ;

    }

    std::string ConnectSerialPortReceiver::documentation() const { return Documentation; }


    int ConnectSerialPortReceiver::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string ConnectSerialPortReceiver::port() const
    {
      return parse_json<std::string>::parse(m_values["Port"]);
    }

    void ConnectSerialPortReceiver::setPort(const std::string& port)
    {
      m_values.AddMember("Port", parse_json<std::string>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> ConnectSerialPortReceiver::baudRate() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["BaudRate"]);
    }

    void ConnectSerialPortReceiver::setBaudRate(const Sdx::optional<int>& baudRate)
    {
      m_values.AddMember("BaudRate", parse_json<Sdx::optional<int>>::format(baudRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> ConnectSerialPortReceiver::dataBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["DataBits"]);
    }

    void ConnectSerialPortReceiver::setDataBits(const Sdx::optional<int>& dataBits)
    {
      m_values.AddMember("DataBits", parse_json<Sdx::optional<int>>::format(dataBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortParity> ConnectSerialPortReceiver::parity() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortParity>>::parse(m_values["Parity"]);
    }

    void ConnectSerialPortReceiver::setParity(const Sdx::optional<Sdx::SerialPortParity>& parity)
    {
      m_values.AddMember("Parity", parse_json<Sdx::optional<Sdx::SerialPortParity>>::format(parity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> ConnectSerialPortReceiver::stopBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["StopBits"]);
    }

    void ConnectSerialPortReceiver::setStopBits(const Sdx::optional<int>& stopBits)
    {
      m_values.AddMember("StopBits", parse_json<Sdx::optional<int>>::format(stopBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortFlowControl> ConnectSerialPortReceiver::flowControl() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::parse(m_values["FlowControl"]);
    }

    void ConnectSerialPortReceiver::setFlowControl(const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      m_values.AddMember("FlowControl", parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::format(flowControl, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of DisconnectSerialPortReceiver
///
#include "gen/DisconnectSerialPortReceiver.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const DisconnectSerialPortReceiver::CmdName = "DisconnectSerialPortReceiver";
    const char* const DisconnectSerialPortReceiver::Documentation = "Disconnects the connected receiver. Does nothing if no receiver is connected.";

    REGISTER_COMMAND_FACTORY(DisconnectSerialPortReceiver);


    DisconnectSerialPortReceiver::DisconnectSerialPortReceiver()
      : CommandBase(CmdName)
    {

    }


    DisconnectSerialPortReceiverPtr DisconnectSerialPortReceiver::create()
    {
      return std::make_shared<DisconnectSerialPortReceiver>();
    }

    DisconnectSerialPortReceiverPtr DisconnectSerialPortReceiver::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<DisconnectSerialPortReceiver>(ptr);
    }

    bool DisconnectSerialPortReceiver::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string DisconnectSerialPortReceiver::documentation() const { return Documentation; }


    int DisconnectSerialPortReceiver::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of SetGpsTimingReceiver
///
#include "gen/SetGpsTimingReceiver.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsTimingReceiver::CmdName = "SetGpsTimingReceiver";
    const char* const SetGpsTimingReceiver::Documentation = "Set the connection parameters to the GPS Receiver from which the simulator will get the simulation start time.";

    REGISTER_COMMAND_FACTORY(SetGpsTimingReceiver);


    SetGpsTimingReceiver::SetGpsTimingReceiver()
      : CommandBase(CmdName)
    {}

    SetGpsTimingReceiver::SetGpsTimingReceiver(const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
      : CommandBase(CmdName)
    {

      setPort(port);
      setBaudRate(baudRate);
      setDataBits(dataBits);
      setParity(parity);
      setStopBits(stopBits);
      setFlowControl(flowControl);
    }


    SetGpsTimingReceiverPtr SetGpsTimingReceiver::create(const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      return std::make_shared<SetGpsTimingReceiver>(port, baudRate, dataBits, parity, stopBits, flowControl);
    }

    SetGpsTimingReceiverPtr SetGpsTimingReceiver::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsTimingReceiver>(ptr);
    }

    bool SetGpsTimingReceiver::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Port"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["BaudRate"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["DataBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortParity>>::is_valid(m_values["Parity"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["StopBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::is_valid(m_values["FlowControl"])
        ;

    }

    std::string SetGpsTimingReceiver::documentation() const { return Documentation; }


    int SetGpsTimingReceiver::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsTimingReceiver::port() const
    {
      return parse_json<std::string>::parse(m_values["Port"]);
    }

    void SetGpsTimingReceiver::setPort(const std::string& port)
    {
      m_values.AddMember("Port", parse_json<std::string>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetGpsTimingReceiver::baudRate() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["BaudRate"]);
    }

    void SetGpsTimingReceiver::setBaudRate(const Sdx::optional<int>& baudRate)
    {
      m_values.AddMember("BaudRate", parse_json<Sdx::optional<int>>::format(baudRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetGpsTimingReceiver::dataBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["DataBits"]);
    }

    void SetGpsTimingReceiver::setDataBits(const Sdx::optional<int>& dataBits)
    {
      m_values.AddMember("DataBits", parse_json<Sdx::optional<int>>::format(dataBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortParity> SetGpsTimingReceiver::parity() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortParity>>::parse(m_values["Parity"]);
    }

    void SetGpsTimingReceiver::setParity(const Sdx::optional<Sdx::SerialPortParity>& parity)
    {
      m_values.AddMember("Parity", parse_json<Sdx::optional<Sdx::SerialPortParity>>::format(parity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetGpsTimingReceiver::stopBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["StopBits"]);
    }

    void SetGpsTimingReceiver::setStopBits(const Sdx::optional<int>& stopBits)
    {
      m_values.AddMember("StopBits", parse_json<Sdx::optional<int>>::format(stopBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortFlowControl> SetGpsTimingReceiver::flowControl() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::parse(m_values["FlowControl"]);
    }

    void SetGpsTimingReceiver::setFlowControl(const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      m_values.AddMember("FlowControl", parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::format(flowControl, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsTimingReceiver
///
#include "gen/GetGpsTimingReceiver.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsTimingReceiver::CmdName = "GetGpsTimingReceiver";
    const char* const GetGpsTimingReceiver::Documentation = "Get the connection parameters to the GPS Receiver from which the simulator will get the simulation start time.";

    REGISTER_COMMAND_FACTORY(GetGpsTimingReceiver);


    GetGpsTimingReceiver::GetGpsTimingReceiver()
      : CommandBase(CmdName)
    {

    }


    GetGpsTimingReceiverPtr GetGpsTimingReceiver::create()
    {
      return std::make_shared<GetGpsTimingReceiver>();
    }

    GetGpsTimingReceiverPtr GetGpsTimingReceiver::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsTimingReceiver>(ptr);
    }

    bool GetGpsTimingReceiver::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGpsTimingReceiver::documentation() const { return Documentation; }


    int GetGpsTimingReceiver::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsTimingReceiverResult
///
#include "gen/GetGpsTimingReceiverResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsTimingReceiverResult::CmdName = "GetGpsTimingReceiverResult";
    const char* const GetGpsTimingReceiverResult::Documentation = "Result of GetGpsTimingReceiver.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsTimingReceiverResult);


    GetGpsTimingReceiverResult::GetGpsTimingReceiverResult()
      : CommandResult(CmdName)
    {}

    GetGpsTimingReceiverResult::GetGpsTimingReceiverResult(CommandBasePtr relatedCommand, const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
      : CommandResult(CmdName, relatedCommand)
    {

      setPort(port);
      setBaudRate(baudRate);
      setDataBits(dataBits);
      setParity(parity);
      setStopBits(stopBits);
      setFlowControl(flowControl);
    }


    GetGpsTimingReceiverResultPtr GetGpsTimingReceiverResult::create(CommandBasePtr relatedCommand, const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      return std::make_shared<GetGpsTimingReceiverResult>(relatedCommand, port, baudRate, dataBits, parity, stopBits, flowControl);
    }

    GetGpsTimingReceiverResultPtr GetGpsTimingReceiverResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsTimingReceiverResult>(ptr);
    }

    bool GetGpsTimingReceiverResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Port"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["BaudRate"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["DataBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortParity>>::is_valid(m_values["Parity"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["StopBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::is_valid(m_values["FlowControl"])
        ;

    }

    std::string GetGpsTimingReceiverResult::documentation() const { return Documentation; }


    std::string GetGpsTimingReceiverResult::port() const
    {
      return parse_json<std::string>::parse(m_values["Port"]);
    }

    void GetGpsTimingReceiverResult::setPort(const std::string& port)
    {
      m_values.AddMember("Port", parse_json<std::string>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetGpsTimingReceiverResult::baudRate() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["BaudRate"]);
    }

    void GetGpsTimingReceiverResult::setBaudRate(const Sdx::optional<int>& baudRate)
    {
      m_values.AddMember("BaudRate", parse_json<Sdx::optional<int>>::format(baudRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetGpsTimingReceiverResult::dataBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["DataBits"]);
    }

    void GetGpsTimingReceiverResult::setDataBits(const Sdx::optional<int>& dataBits)
    {
      m_values.AddMember("DataBits", parse_json<Sdx::optional<int>>::format(dataBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortParity> GetGpsTimingReceiverResult::parity() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortParity>>::parse(m_values["Parity"]);
    }

    void GetGpsTimingReceiverResult::setParity(const Sdx::optional<Sdx::SerialPortParity>& parity)
    {
      m_values.AddMember("Parity", parse_json<Sdx::optional<Sdx::SerialPortParity>>::format(parity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetGpsTimingReceiverResult::stopBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["StopBits"]);
    }

    void GetGpsTimingReceiverResult::setStopBits(const Sdx::optional<int>& stopBits)
    {
      m_values.AddMember("StopBits", parse_json<Sdx::optional<int>>::format(stopBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortFlowControl> GetGpsTimingReceiverResult::flowControl() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::parse(m_values["FlowControl"]);
    }

    void GetGpsTimingReceiverResult::setFlowControl(const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      m_values.AddMember("FlowControl", parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::format(flowControl, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetStartTimeOffset
///
#include "gen/SetStartTimeOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetStartTimeOffset::CmdName = "SetStartTimeOffset";
    const char* const SetStartTimeOffset::Documentation = "Set offset between the simulated GPS time and time given by GPS Timing receiver when using GPS Timing receiver to set the start time of the simulation.\nThis value has no effect when GPS start time is \"custom\" or \"computer\".";

    REGISTER_COMMAND_FACTORY(SetStartTimeOffset);


    SetStartTimeOffset::SetStartTimeOffset()
      : CommandBase(CmdName)
    {}

    SetStartTimeOffset::SetStartTimeOffset(int offset)
      : CommandBase(CmdName)
    {

      setOffset(offset);
    }


    SetStartTimeOffsetPtr SetStartTimeOffset::create(int offset)
    {
      return std::make_shared<SetStartTimeOffset>(offset);
    }

    SetStartTimeOffsetPtr SetStartTimeOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetStartTimeOffset>(ptr);
    }

    bool SetStartTimeOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetStartTimeOffset::documentation() const { return Documentation; }


    int SetStartTimeOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetStartTimeOffset::offset() const
    {
      return parse_json<int>::parse(m_values["Offset"]);
    }

    void SetStartTimeOffset::setOffset(int offset)
    {
      m_values.AddMember("Offset", parse_json<int>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetStartTimeOffset
///
#include "gen/GetStartTimeOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStartTimeOffset::CmdName = "GetStartTimeOffset";
    const char* const GetStartTimeOffset::Documentation = "Get offset between the simulated GPS time and time given by GPS Timing receiver when using GPS Timing receiver to set the start time of the simulation.\nThis value has no effect when GPS start time is \"custom\" or \"computer\".";

    REGISTER_COMMAND_FACTORY(GetStartTimeOffset);


    GetStartTimeOffset::GetStartTimeOffset()
      : CommandBase(CmdName)
    {

    }


    GetStartTimeOffsetPtr GetStartTimeOffset::create()
    {
      return std::make_shared<GetStartTimeOffset>();
    }

    GetStartTimeOffsetPtr GetStartTimeOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStartTimeOffset>(ptr);
    }

    bool GetStartTimeOffset::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetStartTimeOffset::documentation() const { return Documentation; }


    int GetStartTimeOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetStartTimeOffsetResult
///
#include "gen/GetStartTimeOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStartTimeOffsetResult::CmdName = "GetStartTimeOffsetResult";
    const char* const GetStartTimeOffsetResult::Documentation = "Result of GetStartTimeOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetStartTimeOffsetResult);


    GetStartTimeOffsetResult::GetStartTimeOffsetResult()
      : CommandResult(CmdName)
    {}

    GetStartTimeOffsetResult::GetStartTimeOffsetResult(CommandBasePtr relatedCommand, int offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setOffset(offset);
    }


    GetStartTimeOffsetResultPtr GetStartTimeOffsetResult::create(CommandBasePtr relatedCommand, int offset)
    {
      return std::make_shared<GetStartTimeOffsetResult>(relatedCommand, offset);
    }

    GetStartTimeOffsetResultPtr GetStartTimeOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStartTimeOffsetResult>(ptr);
    }

    bool GetStartTimeOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetStartTimeOffsetResult::documentation() const { return Documentation; }


    int GetStartTimeOffsetResult::offset() const
    {
      return parse_json<int>::parse(m_values["Offset"]);
    }

    void GetStartTimeOffsetResult::setOffset(int offset)
    {
      m_values.AddMember("Offset", parse_json<int>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetLeapSecond
///
#include "gen/SetLeapSecond.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetLeapSecond::CmdName = "SetLeapSecond";
    const char* const SetLeapSecond::Documentation = "Set the UTC leap seconds added since GPS epoch.";

    REGISTER_COMMAND_FACTORY(SetLeapSecond);


    SetLeapSecond::SetLeapSecond()
      : CommandBase(CmdName)
    {}

    SetLeapSecond::SetLeapSecond(int leapSecond)
      : CommandBase(CmdName)
    {

      setLeapSecond(leapSecond);
    }


    SetLeapSecondPtr SetLeapSecond::create(int leapSecond)
    {
      return std::make_shared<SetLeapSecond>(leapSecond);
    }

    SetLeapSecondPtr SetLeapSecond::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetLeapSecond>(ptr);
    }

    bool SetLeapSecond::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["LeapSecond"])
        ;

    }

    std::string SetLeapSecond::documentation() const { return Documentation; }


    int SetLeapSecond::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetLeapSecond::leapSecond() const
    {
      return parse_json<int>::parse(m_values["LeapSecond"]);
    }

    void SetLeapSecond::setLeapSecond(int leapSecond)
    {
      m_values.AddMember("LeapSecond", parse_json<int>::format(leapSecond, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsStartTime
///
#include "gen/SetGpsStartTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsStartTime::CmdName = "SetGpsStartTime";
    const char* const SetGpsStartTime::Documentation = "Set the simulation start date and time";

    REGISTER_COMMAND_FACTORY(SetGpsStartTime);


    SetGpsStartTime::SetGpsStartTime()
      : CommandBase(CmdName)
    {}

    SetGpsStartTime::SetGpsStartTime(const Sdx::DateTime& start)
      : CommandBase(CmdName)
    {

      setStart(start);
    }


    SetGpsStartTimePtr SetGpsStartTime::create(const Sdx::DateTime& start)
    {
      return std::make_shared<SetGpsStartTime>(start);
    }

    SetGpsStartTimePtr SetGpsStartTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsStartTime>(ptr);
    }

    bool SetGpsStartTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::DateTime>::is_valid(m_values["Start"])
        ;

    }

    std::string SetGpsStartTime::documentation() const { return Documentation; }


    int SetGpsStartTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::DateTime SetGpsStartTime::start() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Start"]);
    }

    void SetGpsStartTime::setStart(const Sdx::DateTime& start)
    {
      m_values.AddMember("Start", parse_json<Sdx::DateTime>::format(start, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsStartTime
///
#include "gen/GetGpsStartTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsStartTime::CmdName = "GetGpsStartTime";
    const char* const GetGpsStartTime::Documentation = "Get the simulation GPS start date and time and leap second to convert into UTC time";

    REGISTER_COMMAND_FACTORY(GetGpsStartTime);


    GetGpsStartTime::GetGpsStartTime()
      : CommandBase(CmdName)
    {

    }


    GetGpsStartTimePtr GetGpsStartTime::create()
    {
      return std::make_shared<GetGpsStartTime>();
    }

    GetGpsStartTimePtr GetGpsStartTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsStartTime>(ptr);
    }

    bool GetGpsStartTime::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGpsStartTime::documentation() const { return Documentation; }


    int GetGpsStartTime::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsStartTimeResult
///
#include "gen/GetGpsStartTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsStartTimeResult::CmdName = "GetGpsStartTimeResult";
    const char* const GetGpsStartTimeResult::Documentation = "Result of GetGpsStartTime.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsStartTimeResult);


    GetGpsStartTimeResult::GetGpsStartTimeResult()
      : CommandResult(CmdName)
    {}

    GetGpsStartTimeResult::GetGpsStartTimeResult(CommandBasePtr relatedCommand, const Sdx::DateTime& startTime, int leapSecond)
      : CommandResult(CmdName, relatedCommand)
    {

      setStartTime(startTime);
      setLeapSecond(leapSecond);
    }


    GetGpsStartTimeResultPtr GetGpsStartTimeResult::create(CommandBasePtr relatedCommand, const Sdx::DateTime& startTime, int leapSecond)
    {
      return std::make_shared<GetGpsStartTimeResult>(relatedCommand, startTime, leapSecond);
    }

    GetGpsStartTimeResultPtr GetGpsStartTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsStartTimeResult>(ptr);
    }

    bool GetGpsStartTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::DateTime>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["LeapSecond"])
        ;

    }

    std::string GetGpsStartTimeResult::documentation() const { return Documentation; }


    Sdx::DateTime GetGpsStartTimeResult::startTime() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["StartTime"]);
    }

    void GetGpsStartTimeResult::setStartTime(const Sdx::DateTime& startTime)
    {
      m_values.AddMember("StartTime", parse_json<Sdx::DateTime>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsStartTimeResult::leapSecond() const
    {
      return parse_json<int>::parse(m_values["LeapSecond"]);
    }

    void GetGpsStartTimeResult::setLeapSecond(int leapSecond)
    {
      m_values.AddMember("LeapSecond", parse_json<int>::format(leapSecond, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetDuration
///
#include "gen/SetDuration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetDuration::CmdName = "SetDuration";
    const char* const SetDuration::Documentation = "Set the simulation duration. The simulation will stop automatically when this duration is reached";

    REGISTER_COMMAND_FACTORY(SetDuration);


    SetDuration::SetDuration()
      : CommandBase(CmdName)
    {}

    SetDuration::SetDuration(int second)
      : CommandBase(CmdName)
    {

      setSecond(second);
    }


    SetDurationPtr SetDuration::create(int second)
    {
      return std::make_shared<SetDuration>(second);
    }

    SetDurationPtr SetDuration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetDuration>(ptr);
    }

    bool SetDuration::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Second"])
        ;

    }

    std::string SetDuration::documentation() const { return Documentation; }


    int SetDuration::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetDuration::second() const
    {
      return parse_json<int>::parse(m_values["Second"]);
    }

    void SetDuration::setSecond(int second)
    {
      m_values.AddMember("Second", parse_json<int>::format(second, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetDuration
///
#include "gen/GetDuration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDuration::CmdName = "GetDuration";
    const char* const GetDuration::Documentation = "Get the simulation duration.";

    REGISTER_COMMAND_FACTORY(GetDuration);


    GetDuration::GetDuration()
      : CommandBase(CmdName)
    {

    }


    GetDurationPtr GetDuration::create()
    {
      return std::make_shared<GetDuration>();
    }

    GetDurationPtr GetDuration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDuration>(ptr);
    }

    bool GetDuration::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetDuration::documentation() const { return Documentation; }


    int GetDuration::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetDurationResult
///
#include "gen/GetDurationResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDurationResult::CmdName = "GetDurationResult";
    const char* const GetDurationResult::Documentation = "Result of GetDuration.";

    REGISTER_COMMAND_RESULT_FACTORY(GetDurationResult);


    GetDurationResult::GetDurationResult()
      : CommandResult(CmdName)
    {}

    GetDurationResult::GetDurationResult(CommandBasePtr relatedCommand, int second)
      : CommandResult(CmdName, relatedCommand)
    {

      setSecond(second);
    }


    GetDurationResultPtr GetDurationResult::create(CommandBasePtr relatedCommand, int second)
    {
      return std::make_shared<GetDurationResult>(relatedCommand, second);
    }

    GetDurationResultPtr GetDurationResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDurationResult>(ptr);
    }

    bool GetDurationResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Second"])
        ;

    }

    std::string GetDurationResult::documentation() const { return Documentation; }


    int GetDurationResult::second() const
    {
      return parse_json<int>::parse(m_values["Second"]);
    }

    void GetDurationResult::setSecond(int second)
    {
      m_values.AddMember("Second", parse_json<int>::format(second, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogRaw
///
#include "gen/EnableLogRaw.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogRaw::CmdName = "EnableLogRaw";
    const char* const EnableLogRaw::Documentation = "Enable (or disable) raw data logging (pseudorange, antenna gain, receiver position, satellite position, etc.)";

    REGISTER_COMMAND_FACTORY(EnableLogRaw);


    EnableLogRaw::EnableLogRaw()
      : CommandBase(CmdName)
    {}

    EnableLogRaw::EnableLogRaw(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableLogRawPtr EnableLogRaw::create(bool enabled)
    {
      return std::make_shared<EnableLogRaw>(enabled);
    }

    EnableLogRawPtr EnableLogRaw::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogRaw>(ptr);
    }

    bool EnableLogRaw::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLogRaw::documentation() const { return Documentation; }


    int EnableLogRaw::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogRaw::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogRaw::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogRawEnabled
///
#include "gen/IsLogRawEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogRawEnabled::CmdName = "IsLogRawEnabled";
    const char* const IsLogRawEnabled::Documentation = "Tells if raw data logging is enabled.";

    REGISTER_COMMAND_FACTORY(IsLogRawEnabled);


    IsLogRawEnabled::IsLogRawEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogRawEnabledPtr IsLogRawEnabled::create()
    {
      return std::make_shared<IsLogRawEnabled>();
    }

    IsLogRawEnabledPtr IsLogRawEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogRawEnabled>(ptr);
    }

    bool IsLogRawEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogRawEnabled::documentation() const { return Documentation; }


    int IsLogRawEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogRawEnabledResult
///
#include "gen/IsLogRawEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogRawEnabledResult::CmdName = "IsLogRawEnabledResult";
    const char* const IsLogRawEnabledResult::Documentation = "Result of IsLogRawEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogRawEnabledResult);


    IsLogRawEnabledResult::IsLogRawEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogRawEnabledResult::IsLogRawEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsLogRawEnabledResultPtr IsLogRawEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsLogRawEnabledResult>(relatedCommand, enabled);
    }

    IsLogRawEnabledResultPtr IsLogRawEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogRawEnabledResult>(ptr);
    }

    bool IsLogRawEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLogRawEnabledResult::documentation() const { return Documentation; }


    bool IsLogRawEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogRawEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogDownlink
///
#include "gen/EnableLogDownlink.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogDownlink::CmdName = "EnableLogDownlink";
    const char* const EnableLogDownlink::Documentation = "Enable (or disable) downlink data logging in csv format";

    REGISTER_COMMAND_FACTORY(EnableLogDownlink);


    EnableLogDownlink::EnableLogDownlink()
      : CommandBase(CmdName)
    {}

    EnableLogDownlink::EnableLogDownlink(bool enabled, const Sdx::optional<bool>& beforeEncoding, const Sdx::optional<bool>& afterEncoding)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setBeforeEncoding(beforeEncoding);
      setAfterEncoding(afterEncoding);
    }


    EnableLogDownlinkPtr EnableLogDownlink::create(bool enabled, const Sdx::optional<bool>& beforeEncoding, const Sdx::optional<bool>& afterEncoding)
    {
      return std::make_shared<EnableLogDownlink>(enabled, beforeEncoding, afterEncoding);
    }

    EnableLogDownlinkPtr EnableLogDownlink::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogDownlink>(ptr);
    }

    bool EnableLogDownlink::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["BeforeEncoding"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["AfterEncoding"])
        ;

    }

    std::string EnableLogDownlink::documentation() const { return Documentation; }


    int EnableLogDownlink::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogDownlink::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogDownlink::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> EnableLogDownlink::beforeEncoding() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["BeforeEncoding"]);
    }

    void EnableLogDownlink::setBeforeEncoding(const Sdx::optional<bool>& beforeEncoding)
    {
      m_values.AddMember("BeforeEncoding", parse_json<Sdx::optional<bool>>::format(beforeEncoding, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> EnableLogDownlink::afterEncoding() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["AfterEncoding"]);
    }

    void EnableLogDownlink::setAfterEncoding(const Sdx::optional<bool>& afterEncoding)
    {
      m_values.AddMember("AfterEncoding", parse_json<Sdx::optional<bool>>::format(afterEncoding, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogDownlinkEnabled
///
#include "gen/IsLogDownlinkEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogDownlinkEnabled::CmdName = "IsLogDownlinkEnabled";
    const char* const IsLogDownlinkEnabled::Documentation = "Tells if downlink data Logging is enabled";

    REGISTER_COMMAND_FACTORY(IsLogDownlinkEnabled);


    IsLogDownlinkEnabled::IsLogDownlinkEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogDownlinkEnabledPtr IsLogDownlinkEnabled::create()
    {
      return std::make_shared<IsLogDownlinkEnabled>();
    }

    IsLogDownlinkEnabledPtr IsLogDownlinkEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogDownlinkEnabled>(ptr);
    }

    bool IsLogDownlinkEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogDownlinkEnabled::documentation() const { return Documentation; }


    int IsLogDownlinkEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogDownlinkEnabledResult
///
#include "gen/IsLogDownlinkEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogDownlinkEnabledResult::CmdName = "IsLogDownlinkEnabledResult";
    const char* const IsLogDownlinkEnabledResult::Documentation = "Result of IsLogDownlinkEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogDownlinkEnabledResult);


    IsLogDownlinkEnabledResult::IsLogDownlinkEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogDownlinkEnabledResult::IsLogDownlinkEnabledResult(CommandBasePtr relatedCommand, bool enabled, const Sdx::optional<bool>& beforeEncoding, const Sdx::optional<bool>& afterEncoding)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setBeforeEncoding(beforeEncoding);
      setAfterEncoding(afterEncoding);
    }


    IsLogDownlinkEnabledResultPtr IsLogDownlinkEnabledResult::create(CommandBasePtr relatedCommand, bool enabled, const Sdx::optional<bool>& beforeEncoding, const Sdx::optional<bool>& afterEncoding)
    {
      return std::make_shared<IsLogDownlinkEnabledResult>(relatedCommand, enabled, beforeEncoding, afterEncoding);
    }

    IsLogDownlinkEnabledResultPtr IsLogDownlinkEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogDownlinkEnabledResult>(ptr);
    }

    bool IsLogDownlinkEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["BeforeEncoding"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["AfterEncoding"])
        ;

    }

    std::string IsLogDownlinkEnabledResult::documentation() const { return Documentation; }


    bool IsLogDownlinkEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogDownlinkEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> IsLogDownlinkEnabledResult::beforeEncoding() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["BeforeEncoding"]);
    }

    void IsLogDownlinkEnabledResult::setBeforeEncoding(const Sdx::optional<bool>& beforeEncoding)
    {
      m_values.AddMember("BeforeEncoding", parse_json<Sdx::optional<bool>>::format(beforeEncoding, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> IsLogDownlinkEnabledResult::afterEncoding() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["AfterEncoding"]);
    }

    void IsLogDownlinkEnabledResult::setAfterEncoding(const Sdx::optional<bool>& afterEncoding)
    {
      m_values.AddMember("AfterEncoding", parse_json<Sdx::optional<bool>>::format(afterEncoding, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogRinex
///
#include "gen/EnableLogRinex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogRinex::CmdName = "EnableLogRinex";
    const char* const EnableLogRinex::Documentation = "Enable (or disable) ephemeris data logging in RINEX v3.03 format";

    REGISTER_COMMAND_FACTORY(EnableLogRinex);


    EnableLogRinex::EnableLogRinex()
      : CommandBase(CmdName)
    {}

    EnableLogRinex::EnableLogRinex(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableLogRinexPtr EnableLogRinex::create(bool enabled)
    {
      return std::make_shared<EnableLogRinex>(enabled);
    }

    EnableLogRinexPtr EnableLogRinex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogRinex>(ptr);
    }

    bool EnableLogRinex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLogRinex::documentation() const { return Documentation; }


    int EnableLogRinex::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogRinex::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogRinex::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogRinexEnabled
///
#include "gen/IsLogRinexEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogRinexEnabled::CmdName = "IsLogRinexEnabled";
    const char* const IsLogRinexEnabled::Documentation = "Tells if ephemeris data Logging is enabled";

    REGISTER_COMMAND_FACTORY(IsLogRinexEnabled);


    IsLogRinexEnabled::IsLogRinexEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogRinexEnabledPtr IsLogRinexEnabled::create()
    {
      return std::make_shared<IsLogRinexEnabled>();
    }

    IsLogRinexEnabledPtr IsLogRinexEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogRinexEnabled>(ptr);
    }

    bool IsLogRinexEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogRinexEnabled::documentation() const { return Documentation; }


    int IsLogRinexEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogRinexEnabledResult
///
#include "gen/IsLogRinexEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogRinexEnabledResult::CmdName = "IsLogRinexEnabledResult";
    const char* const IsLogRinexEnabledResult::Documentation = "Result of IsLogRinexEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogRinexEnabledResult);


    IsLogRinexEnabledResult::IsLogRinexEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogRinexEnabledResult::IsLogRinexEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsLogRinexEnabledResultPtr IsLogRinexEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsLogRinexEnabledResult>(relatedCommand, enabled);
    }

    IsLogRinexEnabledResultPtr IsLogRinexEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogRinexEnabledResult>(ptr);
    }

    bool IsLogRinexEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLogRinexEnabledResult::documentation() const { return Documentation; }


    bool IsLogRinexEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogRinexEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogHILInput
///
#include "gen/EnableLogHILInput.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogHILInput::CmdName = "EnableLogHILInput";
    const char* const EnableLogHILInput::Documentation = "Enable (or disable) log of all the data received on the HIL API in a CSV format";

    REGISTER_COMMAND_FACTORY(EnableLogHILInput);


    EnableLogHILInput::EnableLogHILInput()
      : CommandBase(CmdName)
    {}

    EnableLogHILInput::EnableLogHILInput(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableLogHILInputPtr EnableLogHILInput::create(bool enabled)
    {
      return std::make_shared<EnableLogHILInput>(enabled);
    }

    EnableLogHILInputPtr EnableLogHILInput::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogHILInput>(ptr);
    }

    bool EnableLogHILInput::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLogHILInput::documentation() const { return Documentation; }


    int EnableLogHILInput::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogHILInput::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogHILInput::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogHILInputEnabled
///
#include "gen/IsLogHILInputEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogHILInputEnabled::CmdName = "IsLogHILInputEnabled";
    const char* const IsLogHILInputEnabled::Documentation = "Tells if data received on the HIL API logging is enabled";

    REGISTER_COMMAND_FACTORY(IsLogHILInputEnabled);


    IsLogHILInputEnabled::IsLogHILInputEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogHILInputEnabledPtr IsLogHILInputEnabled::create()
    {
      return std::make_shared<IsLogHILInputEnabled>();
    }

    IsLogHILInputEnabledPtr IsLogHILInputEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogHILInputEnabled>(ptr);
    }

    bool IsLogHILInputEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogHILInputEnabled::documentation() const { return Documentation; }


    int IsLogHILInputEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogHILInputEnabledResult
///
#include "gen/IsLogHILInputEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogHILInputEnabledResult::CmdName = "IsLogHILInputEnabledResult";
    const char* const IsLogHILInputEnabledResult::Documentation = "Result of IsLogHILInputEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogHILInputEnabledResult);


    IsLogHILInputEnabledResult::IsLogHILInputEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogHILInputEnabledResult::IsLogHILInputEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsLogHILInputEnabledResultPtr IsLogHILInputEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsLogHILInputEnabledResult>(relatedCommand, enabled);
    }

    IsLogHILInputEnabledResultPtr IsLogHILInputEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogHILInputEnabledResult>(ptr);
    }

    bool IsLogHILInputEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLogHILInputEnabledResult::documentation() const { return Documentation; }


    bool IsLogHILInputEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogHILInputEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetLogRawRate
///
#include "gen/SetLogRawRate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetLogRawRate::CmdName = "SetLogRawRate";
    const char* const SetLogRawRate::Documentation = "Set Rate logging of raw data";

    REGISTER_COMMAND_FACTORY(SetLogRawRate);


    SetLogRawRate::SetLogRawRate()
      : CommandBase(CmdName)
    {}

    SetLogRawRate::SetLogRawRate(int rate)
      : CommandBase(CmdName)
    {

      setRate(rate);
    }


    SetLogRawRatePtr SetLogRawRate::create(int rate)
    {
      return std::make_shared<SetLogRawRate>(rate);
    }

    SetLogRawRatePtr SetLogRawRate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetLogRawRate>(ptr);
    }

    bool SetLogRawRate::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Rate"])
        ;

    }

    std::string SetLogRawRate::documentation() const { return Documentation; }


    int SetLogRawRate::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetLogRawRate::rate() const
    {
      return parse_json<int>::parse(m_values["Rate"]);
    }

    void SetLogRawRate::setRate(int rate)
    {
      m_values.AddMember("Rate", parse_json<int>::format(rate, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetLogRawRate
///
#include "gen/GetLogRawRate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLogRawRate::CmdName = "GetLogRawRate";
    const char* const GetLogRawRate::Documentation = "Get Rate logging of raw data";

    REGISTER_COMMAND_FACTORY(GetLogRawRate);


    GetLogRawRate::GetLogRawRate()
      : CommandBase(CmdName)
    {

    }


    GetLogRawRatePtr GetLogRawRate::create()
    {
      return std::make_shared<GetLogRawRate>();
    }

    GetLogRawRatePtr GetLogRawRate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLogRawRate>(ptr);
    }

    bool GetLogRawRate::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLogRawRate::documentation() const { return Documentation; }


    int GetLogRawRate::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of LogRawRateResult
///
#include "gen/LogRawRateResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const LogRawRateResult::CmdName = "LogRawRateResult";
    const char* const LogRawRateResult::Documentation = "Result of GetLogRawRate.";

    REGISTER_COMMAND_RESULT_FACTORY(LogRawRateResult);


    LogRawRateResult::LogRawRateResult()
      : CommandResult(CmdName)
    {}

    LogRawRateResult::LogRawRateResult(CommandBasePtr relatedCommand, int rate)
      : CommandResult(CmdName, relatedCommand)
    {

      setRate(rate);
    }


    LogRawRateResultPtr LogRawRateResult::create(CommandBasePtr relatedCommand, int rate)
    {
      return std::make_shared<LogRawRateResult>(relatedCommand, rate);
    }

    LogRawRateResultPtr LogRawRateResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<LogRawRateResult>(ptr);
    }

    bool LogRawRateResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Rate"])
        ;

    }

    std::string LogRawRateResult::documentation() const { return Documentation; }


    int LogRawRateResult::rate() const
    {
      return parse_json<int>::parse(m_values["Rate"]);
    }

    void LogRawRateResult::setRate(int rate)
    {
      m_values.AddMember("Rate", parse_json<int>::format(rate, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogNmea
///
#include "gen/EnableLogNmea.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogNmea::CmdName = "EnableLogNmea";
    const char* const EnableLogNmea::Documentation = "Set Logging of NMEA for the simulated position enable/disable.\nIf a receiver is connected, that NMEA is saved as well.";

    REGISTER_COMMAND_FACTORY(EnableLogNmea);


    EnableLogNmea::EnableLogNmea()
      : CommandBase(CmdName)
    {}

    EnableLogNmea::EnableLogNmea(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableLogNmeaPtr EnableLogNmea::create(bool enabled)
    {
      return std::make_shared<EnableLogNmea>(enabled);
    }

    EnableLogNmeaPtr EnableLogNmea::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogNmea>(ptr);
    }

    bool EnableLogNmea::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLogNmea::documentation() const { return Documentation; }


    int EnableLogNmea::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogNmea::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogNmea::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogNmeaEnabled
///
#include "gen/IsLogNmeaEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogNmeaEnabled::CmdName = "IsLogNmeaEnabled";
    const char* const IsLogNmeaEnabled::Documentation = "Get Logging of NMEA for the simulated position enable/disable.\nIf a receiver is connected, that NMEA is saved as well.";

    REGISTER_COMMAND_FACTORY(IsLogNmeaEnabled);


    IsLogNmeaEnabled::IsLogNmeaEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogNmeaEnabledPtr IsLogNmeaEnabled::create()
    {
      return std::make_shared<IsLogNmeaEnabled>();
    }

    IsLogNmeaEnabledPtr IsLogNmeaEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogNmeaEnabled>(ptr);
    }

    bool IsLogNmeaEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogNmeaEnabled::documentation() const { return Documentation; }


    int IsLogNmeaEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogNmeaEnabledResult
///
#include "gen/IsLogNmeaEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogNmeaEnabledResult::CmdName = "IsLogNmeaEnabledResult";
    const char* const IsLogNmeaEnabledResult::Documentation = "Result of IsLogNmeaEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogNmeaEnabledResult);


    IsLogNmeaEnabledResult::IsLogNmeaEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogNmeaEnabledResult::IsLogNmeaEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsLogNmeaEnabledResultPtr IsLogNmeaEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsLogNmeaEnabledResult>(relatedCommand, enabled);
    }

    IsLogNmeaEnabledResultPtr IsLogNmeaEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogNmeaEnabledResult>(ptr);
    }

    bool IsLogNmeaEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLogNmeaEnabledResult::documentation() const { return Documentation; }


    bool IsLogNmeaEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogNmeaEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetLogNmeaRate
///
#include "gen/SetLogNmeaRate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetLogNmeaRate::CmdName = "SetLogNmeaRate";
    const char* const SetLogNmeaRate::Documentation = "Set Rate logging of NMEA data";

    REGISTER_COMMAND_FACTORY(SetLogNmeaRate);


    SetLogNmeaRate::SetLogNmeaRate()
      : CommandBase(CmdName)
    {}

    SetLogNmeaRate::SetLogNmeaRate(int rate)
      : CommandBase(CmdName)
    {

      setRate(rate);
    }


    SetLogNmeaRatePtr SetLogNmeaRate::create(int rate)
    {
      return std::make_shared<SetLogNmeaRate>(rate);
    }

    SetLogNmeaRatePtr SetLogNmeaRate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetLogNmeaRate>(ptr);
    }

    bool SetLogNmeaRate::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Rate"])
        ;

    }

    std::string SetLogNmeaRate::documentation() const { return Documentation; }


    int SetLogNmeaRate::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetLogNmeaRate::rate() const
    {
      return parse_json<int>::parse(m_values["Rate"]);
    }

    void SetLogNmeaRate::setRate(int rate)
    {
      m_values.AddMember("Rate", parse_json<int>::format(rate, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetLogNmeaRate
///
#include "gen/GetLogNmeaRate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLogNmeaRate::CmdName = "GetLogNmeaRate";
    const char* const GetLogNmeaRate::Documentation = "Get Rate logging of NMEA data";

    REGISTER_COMMAND_FACTORY(GetLogNmeaRate);


    GetLogNmeaRate::GetLogNmeaRate()
      : CommandBase(CmdName)
    {

    }


    GetLogNmeaRatePtr GetLogNmeaRate::create()
    {
      return std::make_shared<GetLogNmeaRate>();
    }

    GetLogNmeaRatePtr GetLogNmeaRate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLogNmeaRate>(ptr);
    }

    bool GetLogNmeaRate::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLogNmeaRate::documentation() const { return Documentation; }


    int GetLogNmeaRate::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of LogNmeaRateResult
///
#include "gen/LogNmeaRateResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const LogNmeaRateResult::CmdName = "LogNmeaRateResult";
    const char* const LogNmeaRateResult::Documentation = "Result of GetLogNmeaRate.";

    REGISTER_COMMAND_RESULT_FACTORY(LogNmeaRateResult);


    LogNmeaRateResult::LogNmeaRateResult()
      : CommandResult(CmdName)
    {}

    LogNmeaRateResult::LogNmeaRateResult(CommandBasePtr relatedCommand, int rate)
      : CommandResult(CmdName, relatedCommand)
    {

      setRate(rate);
    }


    LogNmeaRateResultPtr LogNmeaRateResult::create(CommandBasePtr relatedCommand, int rate)
    {
      return std::make_shared<LogNmeaRateResult>(relatedCommand, rate);
    }

    LogNmeaRateResultPtr LogNmeaRateResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<LogNmeaRateResult>(ptr);
    }

    bool LogNmeaRateResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Rate"])
        ;

    }

    std::string LogNmeaRateResult::documentation() const { return Documentation; }


    int LogNmeaRateResult::rate() const
    {
      return parse_json<int>::parse(m_values["Rate"]);
    }

    void LogNmeaRateResult::setRate(int rate)
    {
      m_values.AddMember("Rate", parse_json<int>::format(rate, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableMasterPps
///
#include "gen/EnableMasterPps.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableMasterPps::CmdName = "EnableMasterPps";
    const char* const EnableMasterPps::Documentation = "Enable/Disable Time Synchronization Master.\nThe Master will control other Skydel simulators with Slave PPS Enabled.";

    REGISTER_COMMAND_FACTORY(EnableMasterPps);


    EnableMasterPps::EnableMasterPps()
      : CommandBase(CmdName)
    {}

    EnableMasterPps::EnableMasterPps(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableMasterPpsPtr EnableMasterPps::create(bool enabled)
    {
      return std::make_shared<EnableMasterPps>(enabled);
    }

    EnableMasterPpsPtr EnableMasterPps::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableMasterPps>(ptr);
    }

    bool EnableMasterPps::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableMasterPps::documentation() const { return Documentation; }


    int EnableMasterPps::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableMasterPps::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableMasterPps::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMasterStatus
///
#include "gen/GetMasterStatus.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMasterStatus::CmdName = "GetMasterStatus";
    const char* const GetMasterStatus::Documentation = "Request for the master status, returns a GetMasterStatusResult";

    REGISTER_COMMAND_FACTORY(GetMasterStatus);


    GetMasterStatus::GetMasterStatus()
      : CommandBase(CmdName)
    {

    }


    GetMasterStatusPtr GetMasterStatus::create()
    {
      return std::make_shared<GetMasterStatus>();
    }

    GetMasterStatusPtr GetMasterStatus::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMasterStatus>(ptr);
    }

    bool GetMasterStatus::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetMasterStatus::documentation() const { return Documentation; }


    int GetMasterStatus::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetMasterStatusResult
///
#include "gen/GetMasterStatusResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMasterStatusResult::CmdName = "GetMasterStatusResult";
    const char* const GetMasterStatusResult::Documentation = "Result of GetMasterStatus.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMasterStatusResult);


    GetMasterStatusResult::GetMasterStatusResult()
      : CommandResult(CmdName)
    {}

    GetMasterStatusResult::GetMasterStatusResult(CommandBasePtr relatedCommand, bool isMaster, int slaveConnected, int port)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsMaster(isMaster);
      setSlaveConnected(slaveConnected);
      setPort(port);
    }


    GetMasterStatusResultPtr GetMasterStatusResult::create(CommandBasePtr relatedCommand, bool isMaster, int slaveConnected, int port)
    {
      return std::make_shared<GetMasterStatusResult>(relatedCommand, isMaster, slaveConnected, port);
    }

    GetMasterStatusResultPtr GetMasterStatusResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMasterStatusResult>(ptr);
    }

    bool GetMasterStatusResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsMaster"])
          && parse_json<int>::is_valid(m_values["SlaveConnected"])
          && parse_json<int>::is_valid(m_values["Port"])
        ;

    }

    std::string GetMasterStatusResult::documentation() const { return Documentation; }


    bool GetMasterStatusResult::isMaster() const
    {
      return parse_json<bool>::parse(m_values["IsMaster"]);
    }

    void GetMasterStatusResult::setIsMaster(bool isMaster)
    {
      m_values.AddMember("IsMaster", parse_json<bool>::format(isMaster, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMasterStatusResult::slaveConnected() const
    {
      return parse_json<int>::parse(m_values["SlaveConnected"]);
    }

    void GetMasterStatusResult::setSlaveConnected(int slaveConnected)
    {
      m_values.AddMember("SlaveConnected", parse_json<int>::format(slaveConnected, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMasterStatusResult::port() const
    {
      return parse_json<int>::parse(m_values["Port"]);
    }

    void GetMasterStatusResult::setPort(int port)
    {
      m_values.AddMember("Port", parse_json<int>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSlavePps
///
#include "gen/EnableSlavePps.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSlavePps::CmdName = "EnableSlavePps";
    const char* const EnableSlavePps::Documentation = "Enable/Disable Time Synchronization Slave.\nThe Slave will wait for the Master to synchronize the simulators.";

    REGISTER_COMMAND_FACTORY(EnableSlavePps);


    EnableSlavePps::EnableSlavePps()
      : CommandBase(CmdName)
    {}

    EnableSlavePps::EnableSlavePps(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableSlavePpsPtr EnableSlavePps::create(bool enabled)
    {
      return std::make_shared<EnableSlavePps>(enabled);
    }

    EnableSlavePpsPtr EnableSlavePps::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSlavePps>(ptr);
    }

    bool EnableSlavePps::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSlavePps::documentation() const { return Documentation; }


    int EnableSlavePps::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableSlavePps::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSlavePps::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSlaveStatus
///
#include "gen/GetSlaveStatus.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSlaveStatus::CmdName = "GetSlaveStatus";
    const char* const GetSlaveStatus::Documentation = "Request for the slave status, returns a GetSlaveStatusResult";

    REGISTER_COMMAND_FACTORY(GetSlaveStatus);


    GetSlaveStatus::GetSlaveStatus()
      : CommandBase(CmdName)
    {

    }


    GetSlaveStatusPtr GetSlaveStatus::create()
    {
      return std::make_shared<GetSlaveStatus>();
    }

    GetSlaveStatusPtr GetSlaveStatus::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSlaveStatus>(ptr);
    }

    bool GetSlaveStatus::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSlaveStatus::documentation() const { return Documentation; }


    int GetSlaveStatus::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetSlaveStatusResult
///
#include "gen/GetSlaveStatusResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSlaveStatusResult::CmdName = "GetSlaveStatusResult";
    const char* const GetSlaveStatusResult::Documentation = "Result of GetSlaveStatus.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSlaveStatusResult);


    GetSlaveStatusResult::GetSlaveStatusResult()
      : CommandResult(CmdName)
    {}

    GetSlaveStatusResult::GetSlaveStatusResult(CommandBasePtr relatedCommand, bool isSlave, bool isConnected, const std::string& hostName, int hostPort)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsSlave(isSlave);
      setIsConnected(isConnected);
      setHostName(hostName);
      setHostPort(hostPort);
    }


    GetSlaveStatusResultPtr GetSlaveStatusResult::create(CommandBasePtr relatedCommand, bool isSlave, bool isConnected, const std::string& hostName, int hostPort)
    {
      return std::make_shared<GetSlaveStatusResult>(relatedCommand, isSlave, isConnected, hostName, hostPort);
    }

    GetSlaveStatusResultPtr GetSlaveStatusResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSlaveStatusResult>(ptr);
    }

    bool GetSlaveStatusResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsSlave"])
          && parse_json<bool>::is_valid(m_values["IsConnected"])
          && parse_json<std::string>::is_valid(m_values["HostName"])
          && parse_json<int>::is_valid(m_values["HostPort"])
        ;

    }

    std::string GetSlaveStatusResult::documentation() const { return Documentation; }


    bool GetSlaveStatusResult::isSlave() const
    {
      return parse_json<bool>::parse(m_values["IsSlave"]);
    }

    void GetSlaveStatusResult::setIsSlave(bool isSlave)
    {
      m_values.AddMember("IsSlave", parse_json<bool>::format(isSlave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetSlaveStatusResult::isConnected() const
    {
      return parse_json<bool>::parse(m_values["IsConnected"]);
    }

    void GetSlaveStatusResult::setIsConnected(bool isConnected)
    {
      m_values.AddMember("IsConnected", parse_json<bool>::format(isConnected, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSlaveStatusResult::hostName() const
    {
      return parse_json<std::string>::parse(m_values["HostName"]);
    }

    void GetSlaveStatusResult::setHostName(const std::string& hostName)
    {
      m_values.AddMember("HostName", parse_json<std::string>::format(hostName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSlaveStatusResult::hostPort() const
    {
      return parse_json<int>::parse(m_values["HostPort"]);
    }

    void GetSlaveStatusResult::setHostPort(int hostPort)
    {
      m_values.AddMember("HostPort", parse_json<int>::format(hostPort, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetLeapSecondFuture
///
#include "gen/SetLeapSecondFuture.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetLeapSecondFuture::CmdName = "SetLeapSecondFuture";
    const char* const SetLeapSecondFuture::Documentation = "Set the next leap second event";

    REGISTER_COMMAND_FACTORY(SetLeapSecondFuture);


    SetLeapSecondFuture::SetLeapSecondFuture()
      : CommandBase(CmdName)
    {}

    SetLeapSecondFuture::SetLeapSecondFuture(bool enabled, int seconds, const Sdx::Date& date)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setSeconds(seconds);
      setDate(date);
    }


    SetLeapSecondFuturePtr SetLeapSecondFuture::create(bool enabled, int seconds, const Sdx::Date& date)
    {
      return std::make_shared<SetLeapSecondFuture>(enabled, seconds, date);
    }

    SetLeapSecondFuturePtr SetLeapSecondFuture::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetLeapSecondFuture>(ptr);
    }

    bool SetLeapSecondFuture::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["Seconds"])
          && parse_json<Sdx::Date>::is_valid(m_values["Date"])
        ;

    }

    std::string SetLeapSecondFuture::documentation() const { return Documentation; }


    int SetLeapSecondFuture::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool SetLeapSecondFuture::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetLeapSecondFuture::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetLeapSecondFuture::seconds() const
    {
      return parse_json<int>::parse(m_values["Seconds"]);
    }

    void SetLeapSecondFuture::setSeconds(int seconds)
    {
      m_values.AddMember("Seconds", parse_json<int>::format(seconds, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::Date SetLeapSecondFuture::date() const
    {
      return parse_json<Sdx::Date>::parse(m_values["Date"]);
    }

    void SetLeapSecondFuture::setDate(const Sdx::Date& date)
    {
      m_values.AddMember("Date", parse_json<Sdx::Date>::format(date, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetLeapSecondFuture
///
#include "gen/GetLeapSecondFuture.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLeapSecondFuture::CmdName = "GetLeapSecondFuture";
    const char* const GetLeapSecondFuture::Documentation = "Get the next leap second event";

    REGISTER_COMMAND_FACTORY(GetLeapSecondFuture);


    GetLeapSecondFuture::GetLeapSecondFuture()
      : CommandBase(CmdName)
    {

    }


    GetLeapSecondFuturePtr GetLeapSecondFuture::create()
    {
      return std::make_shared<GetLeapSecondFuture>();
    }

    GetLeapSecondFuturePtr GetLeapSecondFuture::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLeapSecondFuture>(ptr);
    }

    bool GetLeapSecondFuture::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLeapSecondFuture::documentation() const { return Documentation; }


    int GetLeapSecondFuture::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetLeapSecondFutureResult
///
#include "gen/GetLeapSecondFutureResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLeapSecondFutureResult::CmdName = "GetLeapSecondFutureResult";
    const char* const GetLeapSecondFutureResult::Documentation = "Result of GetLeapSecondFuture.";

    REGISTER_COMMAND_RESULT_FACTORY(GetLeapSecondFutureResult);


    GetLeapSecondFutureResult::GetLeapSecondFutureResult()
      : CommandResult(CmdName)
    {}

    GetLeapSecondFutureResult::GetLeapSecondFutureResult(CommandBasePtr relatedCommand, bool enabled, int seconds, const Sdx::Date& date)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setSeconds(seconds);
      setDate(date);
    }


    GetLeapSecondFutureResultPtr GetLeapSecondFutureResult::create(CommandBasePtr relatedCommand, bool enabled, int seconds, const Sdx::Date& date)
    {
      return std::make_shared<GetLeapSecondFutureResult>(relatedCommand, enabled, seconds, date);
    }

    GetLeapSecondFutureResultPtr GetLeapSecondFutureResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLeapSecondFutureResult>(ptr);
    }

    bool GetLeapSecondFutureResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["Seconds"])
          && parse_json<Sdx::Date>::is_valid(m_values["Date"])
        ;

    }

    std::string GetLeapSecondFutureResult::documentation() const { return Documentation; }


    bool GetLeapSecondFutureResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetLeapSecondFutureResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetLeapSecondFutureResult::seconds() const
    {
      return parse_json<int>::parse(m_values["Seconds"]);
    }

    void GetLeapSecondFutureResult::setSeconds(int seconds)
    {
      m_values.AddMember("Seconds", parse_json<int>::format(seconds, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::Date GetLeapSecondFutureResult::date() const
    {
      return parse_json<Sdx::Date>::parse(m_values["Date"]);
    }

    void GetLeapSecondFutureResult::setDate(const Sdx::Date& date)
    {
      m_values.AddMember("Date", parse_json<Sdx::Date>::format(date, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSignalStrengthModel
///
#include "gen/EnableSignalStrengthModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSignalStrengthModel::CmdName = "EnableSignalStrengthModel";
    const char* const EnableSignalStrengthModel::Documentation = "Set signal strength model Enable/Disable which affect satellite transmission strength based on their elevation angle";

    REGISTER_COMMAND_FACTORY(EnableSignalStrengthModel);


    EnableSignalStrengthModel::EnableSignalStrengthModel()
      : CommandBase(CmdName)
    {}

    EnableSignalStrengthModel::EnableSignalStrengthModel(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableSignalStrengthModelPtr EnableSignalStrengthModel::create(bool enabled)
    {
      return std::make_shared<EnableSignalStrengthModel>(enabled);
    }

    EnableSignalStrengthModelPtr EnableSignalStrengthModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSignalStrengthModel>(ptr);
    }

    bool EnableSignalStrengthModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSignalStrengthModel::documentation() const { return Documentation; }


    int EnableSignalStrengthModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableSignalStrengthModel::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSignalStrengthModel::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalStrengthModelEnabled
///
#include "gen/IsSignalStrengthModelEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalStrengthModelEnabled::CmdName = "IsSignalStrengthModelEnabled";
    const char* const IsSignalStrengthModelEnabled::Documentation = "Get signal strength model Enable/Disable which affect satellite transmission strength based on their elevation angle";

    REGISTER_COMMAND_FACTORY(IsSignalStrengthModelEnabled);


    IsSignalStrengthModelEnabled::IsSignalStrengthModelEnabled()
      : CommandBase(CmdName)
    {

    }


    IsSignalStrengthModelEnabledPtr IsSignalStrengthModelEnabled::create()
    {
      return std::make_shared<IsSignalStrengthModelEnabled>();
    }

    IsSignalStrengthModelEnabledPtr IsSignalStrengthModelEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalStrengthModelEnabled>(ptr);
    }

    bool IsSignalStrengthModelEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsSignalStrengthModelEnabled::documentation() const { return Documentation; }


    int IsSignalStrengthModelEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsSignalStrengthModelEnabledResult
///
#include "gen/IsSignalStrengthModelEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalStrengthModelEnabledResult::CmdName = "IsSignalStrengthModelEnabledResult";
    const char* const IsSignalStrengthModelEnabledResult::Documentation = "Result of IsSignalStrengthModelEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSignalStrengthModelEnabledResult);


    IsSignalStrengthModelEnabledResult::IsSignalStrengthModelEnabledResult()
      : CommandResult(CmdName)
    {}

    IsSignalStrengthModelEnabledResult::IsSignalStrengthModelEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsSignalStrengthModelEnabledResultPtr IsSignalStrengthModelEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsSignalStrengthModelEnabledResult>(relatedCommand, enabled);
    }

    IsSignalStrengthModelEnabledResultPtr IsSignalStrengthModelEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalStrengthModelEnabledResult>(ptr);
    }

    bool IsSignalStrengthModelEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSignalStrengthModelEnabledResult::documentation() const { return Documentation; }


    bool IsSignalStrengthModelEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSignalStrengthModelEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableElevationMaskBelow
///
#include "gen/EnableElevationMaskBelow.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableElevationMaskBelow::CmdName = "EnableElevationMaskBelow";
    const char* const EnableElevationMaskBelow::Documentation = "Set GNSS satellite mask based on elevation enabled or disabled (See SetElevationMaskBelow).";

    REGISTER_COMMAND_FACTORY(EnableElevationMaskBelow);


    EnableElevationMaskBelow::EnableElevationMaskBelow()
      : CommandBase(CmdName)
    {}

    EnableElevationMaskBelow::EnableElevationMaskBelow(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableElevationMaskBelowPtr EnableElevationMaskBelow::create(bool enabled)
    {
      return std::make_shared<EnableElevationMaskBelow>(enabled);
    }

    EnableElevationMaskBelowPtr EnableElevationMaskBelow::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableElevationMaskBelow>(ptr);
    }

    bool EnableElevationMaskBelow::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableElevationMaskBelow::documentation() const { return Documentation; }


    int EnableElevationMaskBelow::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableElevationMaskBelow::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableElevationMaskBelow::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsElevationMaskBelowEnabled
///
#include "gen/IsElevationMaskBelowEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsElevationMaskBelowEnabled::CmdName = "IsElevationMaskBelowEnabled";
    const char* const IsElevationMaskBelowEnabled::Documentation = "Get GNSS satellite mask based on elevation enabled or disabled (See SetElevationMaskBelow).";

    REGISTER_COMMAND_FACTORY(IsElevationMaskBelowEnabled);


    IsElevationMaskBelowEnabled::IsElevationMaskBelowEnabled()
      : CommandBase(CmdName)
    {

    }


    IsElevationMaskBelowEnabledPtr IsElevationMaskBelowEnabled::create()
    {
      return std::make_shared<IsElevationMaskBelowEnabled>();
    }

    IsElevationMaskBelowEnabledPtr IsElevationMaskBelowEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsElevationMaskBelowEnabled>(ptr);
    }

    bool IsElevationMaskBelowEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsElevationMaskBelowEnabled::documentation() const { return Documentation; }


    int IsElevationMaskBelowEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsElevationMaskBelowEnabledResult
///
#include "gen/IsElevationMaskBelowEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsElevationMaskBelowEnabledResult::CmdName = "IsElevationMaskBelowEnabledResult";
    const char* const IsElevationMaskBelowEnabledResult::Documentation = "Result of IsElevationMaskBelowEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsElevationMaskBelowEnabledResult);


    IsElevationMaskBelowEnabledResult::IsElevationMaskBelowEnabledResult()
      : CommandResult(CmdName)
    {}

    IsElevationMaskBelowEnabledResult::IsElevationMaskBelowEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsElevationMaskBelowEnabledResultPtr IsElevationMaskBelowEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsElevationMaskBelowEnabledResult>(relatedCommand, enabled);
    }

    IsElevationMaskBelowEnabledResultPtr IsElevationMaskBelowEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsElevationMaskBelowEnabledResult>(ptr);
    }

    bool IsElevationMaskBelowEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsElevationMaskBelowEnabledResult::documentation() const { return Documentation; }


    bool IsElevationMaskBelowEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsElevationMaskBelowEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableElevationMaskAbove
///
#include "gen/EnableElevationMaskAbove.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableElevationMaskAbove::CmdName = "EnableElevationMaskAbove";
    const char* const EnableElevationMaskAbove::Documentation = "Set GNSS satellite mask based on elevation enabled or disabled (See SetElevationMaskAbove).";

    REGISTER_COMMAND_FACTORY(EnableElevationMaskAbove);


    EnableElevationMaskAbove::EnableElevationMaskAbove()
      : CommandBase(CmdName)
    {}

    EnableElevationMaskAbove::EnableElevationMaskAbove(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableElevationMaskAbovePtr EnableElevationMaskAbove::create(bool enabled)
    {
      return std::make_shared<EnableElevationMaskAbove>(enabled);
    }

    EnableElevationMaskAbovePtr EnableElevationMaskAbove::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableElevationMaskAbove>(ptr);
    }

    bool EnableElevationMaskAbove::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableElevationMaskAbove::documentation() const { return Documentation; }


    int EnableElevationMaskAbove::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableElevationMaskAbove::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableElevationMaskAbove::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsElevationMaskAboveEnabled
///
#include "gen/IsElevationMaskAboveEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsElevationMaskAboveEnabled::CmdName = "IsElevationMaskAboveEnabled";
    const char* const IsElevationMaskAboveEnabled::Documentation = "Get GNSS satellite mask based on elevation enabled or disabled (See SetElevationMaskAbove).";

    REGISTER_COMMAND_FACTORY(IsElevationMaskAboveEnabled);


    IsElevationMaskAboveEnabled::IsElevationMaskAboveEnabled()
      : CommandBase(CmdName)
    {

    }


    IsElevationMaskAboveEnabledPtr IsElevationMaskAboveEnabled::create()
    {
      return std::make_shared<IsElevationMaskAboveEnabled>();
    }

    IsElevationMaskAboveEnabledPtr IsElevationMaskAboveEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsElevationMaskAboveEnabled>(ptr);
    }

    bool IsElevationMaskAboveEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsElevationMaskAboveEnabled::documentation() const { return Documentation; }


    int IsElevationMaskAboveEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsElevationMaskAboveEnabledResult
///
#include "gen/IsElevationMaskAboveEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsElevationMaskAboveEnabledResult::CmdName = "IsElevationMaskAboveEnabledResult";
    const char* const IsElevationMaskAboveEnabledResult::Documentation = "Result of IsElevationMaskAboveEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsElevationMaskAboveEnabledResult);


    IsElevationMaskAboveEnabledResult::IsElevationMaskAboveEnabledResult()
      : CommandResult(CmdName)
    {}

    IsElevationMaskAboveEnabledResult::IsElevationMaskAboveEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsElevationMaskAboveEnabledResultPtr IsElevationMaskAboveEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsElevationMaskAboveEnabledResult>(relatedCommand, enabled);
    }

    IsElevationMaskAboveEnabledResultPtr IsElevationMaskAboveEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsElevationMaskAboveEnabledResult>(ptr);
    }

    bool IsElevationMaskAboveEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsElevationMaskAboveEnabledResult::documentation() const { return Documentation; }


    bool IsElevationMaskAboveEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsElevationMaskAboveEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetElevationMaskBelow
///
#include "gen/SetElevationMaskBelow.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetElevationMaskBelow::CmdName = "SetElevationMaskBelow";
    const char* const SetElevationMaskBelow::Documentation = "Set elevation mask angle. See command EnableElevationMaskBelow";

    REGISTER_COMMAND_FACTORY(SetElevationMaskBelow);


    SetElevationMaskBelow::SetElevationMaskBelow()
      : CommandBase(CmdName)
    {}

    SetElevationMaskBelow::SetElevationMaskBelow(double angle)
      : CommandBase(CmdName)
    {

      setAngle(angle);
    }


    SetElevationMaskBelowPtr SetElevationMaskBelow::create(double angle)
    {
      return std::make_shared<SetElevationMaskBelow>(angle);
    }

    SetElevationMaskBelowPtr SetElevationMaskBelow::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetElevationMaskBelow>(ptr);
    }

    bool SetElevationMaskBelow::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Angle"])
        ;

    }

    std::string SetElevationMaskBelow::documentation() const { return Documentation; }


    int SetElevationMaskBelow::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetElevationMaskBelow::angle() const
    {
      return parse_json<double>::parse(m_values["Angle"]);
    }

    void SetElevationMaskBelow::setAngle(double angle)
    {
      m_values.AddMember("Angle", parse_json<double>::format(angle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetElevationMaskBelow
///
#include "gen/GetElevationMaskBelow.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationMaskBelow::CmdName = "GetElevationMaskBelow";
    const char* const GetElevationMaskBelow::Documentation = "Get elevation mask angle. See command EnableElevationMaskBelow";

    REGISTER_COMMAND_FACTORY(GetElevationMaskBelow);


    GetElevationMaskBelow::GetElevationMaskBelow()
      : CommandBase(CmdName)
    {

    }


    GetElevationMaskBelowPtr GetElevationMaskBelow::create()
    {
      return std::make_shared<GetElevationMaskBelow>();
    }

    GetElevationMaskBelowPtr GetElevationMaskBelow::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationMaskBelow>(ptr);
    }

    bool GetElevationMaskBelow::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetElevationMaskBelow::documentation() const { return Documentation; }


    int GetElevationMaskBelow::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetElevationMaskBelowResult
///
#include "gen/GetElevationMaskBelowResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationMaskBelowResult::CmdName = "GetElevationMaskBelowResult";
    const char* const GetElevationMaskBelowResult::Documentation = "Result of GetElevationMaskBelow.";

    REGISTER_COMMAND_RESULT_FACTORY(GetElevationMaskBelowResult);


    GetElevationMaskBelowResult::GetElevationMaskBelowResult()
      : CommandResult(CmdName)
    {}

    GetElevationMaskBelowResult::GetElevationMaskBelowResult(CommandBasePtr relatedCommand, double angle)
      : CommandResult(CmdName, relatedCommand)
    {

      setAngle(angle);
    }


    GetElevationMaskBelowResultPtr GetElevationMaskBelowResult::create(CommandBasePtr relatedCommand, double angle)
    {
      return std::make_shared<GetElevationMaskBelowResult>(relatedCommand, angle);
    }

    GetElevationMaskBelowResultPtr GetElevationMaskBelowResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationMaskBelowResult>(ptr);
    }

    bool GetElevationMaskBelowResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Angle"])
        ;

    }

    std::string GetElevationMaskBelowResult::documentation() const { return Documentation; }


    double GetElevationMaskBelowResult::angle() const
    {
      return parse_json<double>::parse(m_values["Angle"]);
    }

    void GetElevationMaskBelowResult::setAngle(double angle)
    {
      m_values.AddMember("Angle", parse_json<double>::format(angle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetElevationMaskAbove
///
#include "gen/SetElevationMaskAbove.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetElevationMaskAbove::CmdName = "SetElevationMaskAbove";
    const char* const SetElevationMaskAbove::Documentation = "Set elevation mask angle. See command EnableElevationMaskAbove";

    REGISTER_COMMAND_FACTORY(SetElevationMaskAbove);


    SetElevationMaskAbove::SetElevationMaskAbove()
      : CommandBase(CmdName)
    {}

    SetElevationMaskAbove::SetElevationMaskAbove(double angle)
      : CommandBase(CmdName)
    {

      setAngle(angle);
    }


    SetElevationMaskAbovePtr SetElevationMaskAbove::create(double angle)
    {
      return std::make_shared<SetElevationMaskAbove>(angle);
    }

    SetElevationMaskAbovePtr SetElevationMaskAbove::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetElevationMaskAbove>(ptr);
    }

    bool SetElevationMaskAbove::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Angle"])
        ;

    }

    std::string SetElevationMaskAbove::documentation() const { return Documentation; }


    int SetElevationMaskAbove::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetElevationMaskAbove::angle() const
    {
      return parse_json<double>::parse(m_values["Angle"]);
    }

    void SetElevationMaskAbove::setAngle(double angle)
    {
      m_values.AddMember("Angle", parse_json<double>::format(angle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetElevationMaskAbove
///
#include "gen/GetElevationMaskAbove.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationMaskAbove::CmdName = "GetElevationMaskAbove";
    const char* const GetElevationMaskAbove::Documentation = "Get elevation mask angle. See command EnableElevationMaskAbove";

    REGISTER_COMMAND_FACTORY(GetElevationMaskAbove);


    GetElevationMaskAbove::GetElevationMaskAbove()
      : CommandBase(CmdName)
    {

    }


    GetElevationMaskAbovePtr GetElevationMaskAbove::create()
    {
      return std::make_shared<GetElevationMaskAbove>();
    }

    GetElevationMaskAbovePtr GetElevationMaskAbove::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationMaskAbove>(ptr);
    }

    bool GetElevationMaskAbove::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetElevationMaskAbove::documentation() const { return Documentation; }


    int GetElevationMaskAbove::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetElevationMaskAboveResult
///
#include "gen/GetElevationMaskAboveResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationMaskAboveResult::CmdName = "GetElevationMaskAboveResult";
    const char* const GetElevationMaskAboveResult::Documentation = "Result of GetElevationMaskAbove.";

    REGISTER_COMMAND_RESULT_FACTORY(GetElevationMaskAboveResult);


    GetElevationMaskAboveResult::GetElevationMaskAboveResult()
      : CommandResult(CmdName)
    {}

    GetElevationMaskAboveResult::GetElevationMaskAboveResult(CommandBasePtr relatedCommand, double angle)
      : CommandResult(CmdName, relatedCommand)
    {

      setAngle(angle);
    }


    GetElevationMaskAboveResultPtr GetElevationMaskAboveResult::create(CommandBasePtr relatedCommand, double angle)
    {
      return std::make_shared<GetElevationMaskAboveResult>(relatedCommand, angle);
    }

    GetElevationMaskAboveResultPtr GetElevationMaskAboveResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationMaskAboveResult>(ptr);
    }

    bool GetElevationMaskAboveResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Angle"])
        ;

    }

    std::string GetElevationMaskAboveResult::documentation() const { return Documentation; }


    double GetElevationMaskAboveResult::angle() const
    {
      return parse_json<double>::parse(m_values["Angle"]);
    }

    void GetElevationMaskAboveResult::setAngle(double angle)
    {
      m_values.AddMember("Angle", parse_json<double>::format(angle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfData
///
#include "gen/SetIssueOfData.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfData::CmdName = "SetIssueOfData";
    const char* const SetIssueOfData::Documentation = "Set GPS Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(SetIssueOfData);


    SetIssueOfData::SetIssueOfData()
      : CommandBase(CmdName)
    {}

    SetIssueOfData::SetIssueOfData(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    SetIssueOfDataPtr SetIssueOfData::create(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<SetIssueOfData>(clock, ephemeris, overrideRinex);
    }

    SetIssueOfDataPtr SetIssueOfData::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfData>(ptr);
    }

    bool SetIssueOfData::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetIssueOfData::documentation() const { return Documentation; }


    int SetIssueOfData::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfData::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void SetIssueOfData::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIssueOfData::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void SetIssueOfData::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetIssueOfData::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetIssueOfData::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfData
///
#include "gen/GetIssueOfData.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfData::CmdName = "GetIssueOfData";
    const char* const GetIssueOfData::Documentation = "Get GPS Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(GetIssueOfData);


    GetIssueOfData::GetIssueOfData()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataPtr GetIssueOfData::create()
    {
      return std::make_shared<GetIssueOfData>();
    }

    GetIssueOfDataPtr GetIssueOfData::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfData>(ptr);
    }

    bool GetIssueOfData::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfData::documentation() const { return Documentation; }


    int GetIssueOfData::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataResult
///
#include "gen/GetIssueOfDataResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataResult::CmdName = "GetIssueOfDataResult";
    const char* const GetIssueOfDataResult::Documentation = "Result of GetIssueOfData.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataResult);


    GetIssueOfDataResult::GetIssueOfDataResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataResult::GetIssueOfDataResult(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    GetIssueOfDataResultPtr GetIssueOfDataResult::create(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<GetIssueOfDataResult>(relatedCommand, clock, ephemeris, overrideRinex);
    }

    GetIssueOfDataResultPtr GetIssueOfDataResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataResult>(ptr);
    }

    bool GetIssueOfDataResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetIssueOfDataResult::documentation() const { return Documentation; }


    int GetIssueOfDataResult::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void GetIssueOfDataResult::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIssueOfDataResult::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void GetIssueOfDataResult::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetIssueOfDataResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetIssueOfDataResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfDataGalileo
///
#include "gen/SetIssueOfDataGalileo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfDataGalileo::CmdName = "SetIssueOfDataGalileo";
    const char* const SetIssueOfDataGalileo::Documentation = "Set Galileo Issue of data, Navigation (IODNAV) and Issue of data, Almanac (IODA)";

    REGISTER_COMMAND_FACTORY(SetIssueOfDataGalileo);


    SetIssueOfDataGalileo::SetIssueOfDataGalileo()
      : CommandBase(CmdName)
    {}

    SetIssueOfDataGalileo::SetIssueOfDataGalileo(int navigation, int almanac, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setNavigation(navigation);
      setAlmanac(almanac);
      setOverrideRinex(overrideRinex);
    }


    SetIssueOfDataGalileoPtr SetIssueOfDataGalileo::create(int navigation, int almanac, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<SetIssueOfDataGalileo>(navigation, almanac, overrideRinex);
    }

    SetIssueOfDataGalileoPtr SetIssueOfDataGalileo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfDataGalileo>(ptr);
    }

    bool SetIssueOfDataGalileo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Navigation"])
          && parse_json<int>::is_valid(m_values["Almanac"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetIssueOfDataGalileo::documentation() const { return Documentation; }


    int SetIssueOfDataGalileo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfDataGalileo::navigation() const
    {
      return parse_json<int>::parse(m_values["Navigation"]);
    }

    void SetIssueOfDataGalileo::setNavigation(int navigation)
    {
      m_values.AddMember("Navigation", parse_json<int>::format(navigation, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIssueOfDataGalileo::almanac() const
    {
      return parse_json<int>::parse(m_values["Almanac"]);
    }

    void SetIssueOfDataGalileo::setAlmanac(int almanac)
    {
      m_values.AddMember("Almanac", parse_json<int>::format(almanac, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetIssueOfDataGalileo::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetIssueOfDataGalileo::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfDataGalileo
///
#include "gen/GetIssueOfDataGalileo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataGalileo::CmdName = "GetIssueOfDataGalileo";
    const char* const GetIssueOfDataGalileo::Documentation = "Get Galileo Issue of data, Navigation (IODNAV) and Issue of data, Almanac (IODA)";

    REGISTER_COMMAND_FACTORY(GetIssueOfDataGalileo);


    GetIssueOfDataGalileo::GetIssueOfDataGalileo()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataGalileoPtr GetIssueOfDataGalileo::create()
    {
      return std::make_shared<GetIssueOfDataGalileo>();
    }

    GetIssueOfDataGalileoPtr GetIssueOfDataGalileo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataGalileo>(ptr);
    }

    bool GetIssueOfDataGalileo::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfDataGalileo::documentation() const { return Documentation; }


    int GetIssueOfDataGalileo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataGalileoResult
///
#include "gen/GetIssueOfDataGalileoResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataGalileoResult::CmdName = "GetIssueOfDataGalileoResult";
    const char* const GetIssueOfDataGalileoResult::Documentation = "Result of GetIssueOfDataGalileo.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataGalileoResult);


    GetIssueOfDataGalileoResult::GetIssueOfDataGalileoResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataGalileoResult::GetIssueOfDataGalileoResult(CommandBasePtr relatedCommand, int navigation, int almanac, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setNavigation(navigation);
      setAlmanac(almanac);
      setOverrideRinex(overrideRinex);
    }


    GetIssueOfDataGalileoResultPtr GetIssueOfDataGalileoResult::create(CommandBasePtr relatedCommand, int navigation, int almanac, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<GetIssueOfDataGalileoResult>(relatedCommand, navigation, almanac, overrideRinex);
    }

    GetIssueOfDataGalileoResultPtr GetIssueOfDataGalileoResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataGalileoResult>(ptr);
    }

    bool GetIssueOfDataGalileoResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Navigation"])
          && parse_json<int>::is_valid(m_values["Almanac"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetIssueOfDataGalileoResult::documentation() const { return Documentation; }


    int GetIssueOfDataGalileoResult::navigation() const
    {
      return parse_json<int>::parse(m_values["Navigation"]);
    }

    void GetIssueOfDataGalileoResult::setNavigation(int navigation)
    {
      m_values.AddMember("Navigation", parse_json<int>::format(navigation, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIssueOfDataGalileoResult::almanac() const
    {
      return parse_json<int>::parse(m_values["Almanac"]);
    }

    void GetIssueOfDataGalileoResult::setAlmanac(int almanac)
    {
      m_values.AddMember("Almanac", parse_json<int>::format(almanac, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetIssueOfDataGalileoResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetIssueOfDataGalileoResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAgeOfDataBeiDou
///
#include "gen/SetAgeOfDataBeiDou.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAgeOfDataBeiDou::CmdName = "SetAgeOfDataBeiDou";
    const char* const SetAgeOfDataBeiDou::Documentation = "Set BeiDou Age of data, Ephemeris (AODE) and Age of data, Clock (AODC)";

    REGISTER_COMMAND_FACTORY(SetAgeOfDataBeiDou);


    SetAgeOfDataBeiDou::SetAgeOfDataBeiDou()
      : CommandBase(CmdName)
    {}

    SetAgeOfDataBeiDou::SetAgeOfDataBeiDou(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    SetAgeOfDataBeiDouPtr SetAgeOfDataBeiDou::create(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<SetAgeOfDataBeiDou>(clock, ephemeris, overrideRinex);
    }

    SetAgeOfDataBeiDouPtr SetAgeOfDataBeiDou::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAgeOfDataBeiDou>(ptr);
    }

    bool SetAgeOfDataBeiDou::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetAgeOfDataBeiDou::documentation() const { return Documentation; }


    int SetAgeOfDataBeiDou::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetAgeOfDataBeiDou::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void SetAgeOfDataBeiDou::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAgeOfDataBeiDou::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void SetAgeOfDataBeiDou::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetAgeOfDataBeiDou::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetAgeOfDataBeiDou::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAgeOfDataBeiDou
///
#include "gen/GetAgeOfDataBeiDou.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAgeOfDataBeiDou::CmdName = "GetAgeOfDataBeiDou";
    const char* const GetAgeOfDataBeiDou::Documentation = "Get BeiDou Age of data, Ephemeris (AODE) and Age of data, Clock (AODC)";

    REGISTER_COMMAND_FACTORY(GetAgeOfDataBeiDou);


    GetAgeOfDataBeiDou::GetAgeOfDataBeiDou()
      : CommandBase(CmdName)
    {

    }


    GetAgeOfDataBeiDouPtr GetAgeOfDataBeiDou::create()
    {
      return std::make_shared<GetAgeOfDataBeiDou>();
    }

    GetAgeOfDataBeiDouPtr GetAgeOfDataBeiDou::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAgeOfDataBeiDou>(ptr);
    }

    bool GetAgeOfDataBeiDou::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAgeOfDataBeiDou::documentation() const { return Documentation; }


    int GetAgeOfDataBeiDou::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAgeOfDataBeiDouResult
///
#include "gen/GetAgeOfDataBeiDouResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAgeOfDataBeiDouResult::CmdName = "GetAgeOfDataBeiDouResult";
    const char* const GetAgeOfDataBeiDouResult::Documentation = "Result of GetAgeOfDataBeiDou.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAgeOfDataBeiDouResult);


    GetAgeOfDataBeiDouResult::GetAgeOfDataBeiDouResult()
      : CommandResult(CmdName)
    {}

    GetAgeOfDataBeiDouResult::GetAgeOfDataBeiDouResult(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    GetAgeOfDataBeiDouResultPtr GetAgeOfDataBeiDouResult::create(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<GetAgeOfDataBeiDouResult>(relatedCommand, clock, ephemeris, overrideRinex);
    }

    GetAgeOfDataBeiDouResultPtr GetAgeOfDataBeiDouResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAgeOfDataBeiDouResult>(ptr);
    }

    bool GetAgeOfDataBeiDouResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetAgeOfDataBeiDouResult::documentation() const { return Documentation; }


    int GetAgeOfDataBeiDouResult::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void GetAgeOfDataBeiDouResult::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAgeOfDataBeiDouResult::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void GetAgeOfDataBeiDouResult::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetAgeOfDataBeiDouResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetAgeOfDataBeiDouResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfDataBeiDou
///
#include "gen/SetIssueOfDataBeiDou.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfDataBeiDou::CmdName = "SetIssueOfDataBeiDou";
    const char* const SetIssueOfDataBeiDou::Documentation = "Set BeiDou Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(SetIssueOfDataBeiDou);


    SetIssueOfDataBeiDou::SetIssueOfDataBeiDou()
      : CommandBase(CmdName)
    {}

    SetIssueOfDataBeiDou::SetIssueOfDataBeiDou(int clock, int ephemeris)
      : CommandBase(CmdName)
    {

      setClock(clock);
      setEphemeris(ephemeris);
    }


    SetIssueOfDataBeiDouPtr SetIssueOfDataBeiDou::create(int clock, int ephemeris)
    {
      return std::make_shared<SetIssueOfDataBeiDou>(clock, ephemeris);
    }

    SetIssueOfDataBeiDouPtr SetIssueOfDataBeiDou::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfDataBeiDou>(ptr);
    }

    bool SetIssueOfDataBeiDou::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
        ;

    }

    std::string SetIssueOfDataBeiDou::documentation() const { return Documentation; }


    int SetIssueOfDataBeiDou::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfDataBeiDou::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void SetIssueOfDataBeiDou::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIssueOfDataBeiDou::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void SetIssueOfDataBeiDou::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfDataBeiDou
///
#include "gen/GetIssueOfDataBeiDou.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataBeiDou::CmdName = "GetIssueOfDataBeiDou";
    const char* const GetIssueOfDataBeiDou::Documentation = "Get BeiDou Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(GetIssueOfDataBeiDou);


    GetIssueOfDataBeiDou::GetIssueOfDataBeiDou()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataBeiDouPtr GetIssueOfDataBeiDou::create()
    {
      return std::make_shared<GetIssueOfDataBeiDou>();
    }

    GetIssueOfDataBeiDouPtr GetIssueOfDataBeiDou::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataBeiDou>(ptr);
    }

    bool GetIssueOfDataBeiDou::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfDataBeiDou::documentation() const { return Documentation; }


    int GetIssueOfDataBeiDou::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataBeiDouResult
///
#include "gen/GetIssueOfDataBeiDouResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataBeiDouResult::CmdName = "GetIssueOfDataBeiDouResult";
    const char* const GetIssueOfDataBeiDouResult::Documentation = "Result of GetIssueOfDataBeiDou.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataBeiDouResult);


    GetIssueOfDataBeiDouResult::GetIssueOfDataBeiDouResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataBeiDouResult::GetIssueOfDataBeiDouResult(CommandBasePtr relatedCommand, int clock, int ephemeris)
      : CommandResult(CmdName, relatedCommand)
    {

      setClock(clock);
      setEphemeris(ephemeris);
    }


    GetIssueOfDataBeiDouResultPtr GetIssueOfDataBeiDouResult::create(CommandBasePtr relatedCommand, int clock, int ephemeris)
    {
      return std::make_shared<GetIssueOfDataBeiDouResult>(relatedCommand, clock, ephemeris);
    }

    GetIssueOfDataBeiDouResultPtr GetIssueOfDataBeiDouResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataBeiDouResult>(ptr);
    }

    bool GetIssueOfDataBeiDouResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
        ;

    }

    std::string GetIssueOfDataBeiDouResult::documentation() const { return Documentation; }


    int GetIssueOfDataBeiDouResult::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void GetIssueOfDataBeiDouResult::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIssueOfDataBeiDouResult::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void GetIssueOfDataBeiDouResult::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfDataQzss
///
#include "gen/SetIssueOfDataQzss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfDataQzss::CmdName = "SetIssueOfDataQzss";
    const char* const SetIssueOfDataQzss::Documentation = "Set QZSS Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(SetIssueOfDataQzss);


    SetIssueOfDataQzss::SetIssueOfDataQzss()
      : CommandBase(CmdName)
    {}

    SetIssueOfDataQzss::SetIssueOfDataQzss(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    SetIssueOfDataQzssPtr SetIssueOfDataQzss::create(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<SetIssueOfDataQzss>(clock, ephemeris, overrideRinex);
    }

    SetIssueOfDataQzssPtr SetIssueOfDataQzss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfDataQzss>(ptr);
    }

    bool SetIssueOfDataQzss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetIssueOfDataQzss::documentation() const { return Documentation; }


    int SetIssueOfDataQzss::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfDataQzss::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void SetIssueOfDataQzss::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIssueOfDataQzss::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void SetIssueOfDataQzss::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetIssueOfDataQzss::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetIssueOfDataQzss::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfDataQzss
///
#include "gen/GetIssueOfDataQzss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataQzss::CmdName = "GetIssueOfDataQzss";
    const char* const GetIssueOfDataQzss::Documentation = "Get QZSS Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(GetIssueOfDataQzss);


    GetIssueOfDataQzss::GetIssueOfDataQzss()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataQzssPtr GetIssueOfDataQzss::create()
    {
      return std::make_shared<GetIssueOfDataQzss>();
    }

    GetIssueOfDataQzssPtr GetIssueOfDataQzss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataQzss>(ptr);
    }

    bool GetIssueOfDataQzss::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfDataQzss::documentation() const { return Documentation; }


    int GetIssueOfDataQzss::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataQzssResult
///
#include "gen/GetIssueOfDataQzssResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataQzssResult::CmdName = "GetIssueOfDataQzssResult";
    const char* const GetIssueOfDataQzssResult::Documentation = "Result of GetIssueOfDataQzss.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataQzssResult);


    GetIssueOfDataQzssResult::GetIssueOfDataQzssResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataQzssResult::GetIssueOfDataQzssResult(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    GetIssueOfDataQzssResultPtr GetIssueOfDataQzssResult::create(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<GetIssueOfDataQzssResult>(relatedCommand, clock, ephemeris, overrideRinex);
    }

    GetIssueOfDataQzssResultPtr GetIssueOfDataQzssResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataQzssResult>(ptr);
    }

    bool GetIssueOfDataQzssResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetIssueOfDataQzssResult::documentation() const { return Documentation; }


    int GetIssueOfDataQzssResult::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void GetIssueOfDataQzssResult::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIssueOfDataQzssResult::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void GetIssueOfDataQzssResult::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetIssueOfDataQzssResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetIssueOfDataQzssResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfDataNavIC
///
#include "gen/SetIssueOfDataNavIC.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfDataNavIC::CmdName = "SetIssueOfDataNavIC";
    const char* const SetIssueOfDataNavIC::Documentation = "Set NavIC Issue of data, Ephemeris and Clock (IODEC)";

    REGISTER_COMMAND_FACTORY(SetIssueOfDataNavIC);


    SetIssueOfDataNavIC::SetIssueOfDataNavIC()
      : CommandBase(CmdName)
    {}

    SetIssueOfDataNavIC::SetIssueOfDataNavIC(int ephemerisAndClock, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setEphemerisAndClock(ephemerisAndClock);
      setOverrideRinex(overrideRinex);
    }


    SetIssueOfDataNavICPtr SetIssueOfDataNavIC::create(int ephemerisAndClock, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<SetIssueOfDataNavIC>(ephemerisAndClock, overrideRinex);
    }

    SetIssueOfDataNavICPtr SetIssueOfDataNavIC::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfDataNavIC>(ptr);
    }

    bool SetIssueOfDataNavIC::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["EphemerisAndClock"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetIssueOfDataNavIC::documentation() const { return Documentation; }


    int SetIssueOfDataNavIC::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfDataNavIC::ephemerisAndClock() const
    {
      return parse_json<int>::parse(m_values["EphemerisAndClock"]);
    }

    void SetIssueOfDataNavIC::setEphemerisAndClock(int ephemerisAndClock)
    {
      m_values.AddMember("EphemerisAndClock", parse_json<int>::format(ephemerisAndClock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetIssueOfDataNavIC::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetIssueOfDataNavIC::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfDataNavIC
///
#include "gen/GetIssueOfDataNavIC.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataNavIC::CmdName = "GetIssueOfDataNavIC";
    const char* const GetIssueOfDataNavIC::Documentation = "Get NavIC Issue of data, Ephemeris and Clock (IODEC)";

    REGISTER_COMMAND_FACTORY(GetIssueOfDataNavIC);


    GetIssueOfDataNavIC::GetIssueOfDataNavIC()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataNavICPtr GetIssueOfDataNavIC::create()
    {
      return std::make_shared<GetIssueOfDataNavIC>();
    }

    GetIssueOfDataNavICPtr GetIssueOfDataNavIC::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataNavIC>(ptr);
    }

    bool GetIssueOfDataNavIC::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfDataNavIC::documentation() const { return Documentation; }


    int GetIssueOfDataNavIC::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataNavICResult
///
#include "gen/GetIssueOfDataNavICResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataNavICResult::CmdName = "GetIssueOfDataNavICResult";
    const char* const GetIssueOfDataNavICResult::Documentation = "Result of GetIssueOfDataNavIC.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataNavICResult);


    GetIssueOfDataNavICResult::GetIssueOfDataNavICResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataNavICResult::GetIssueOfDataNavICResult(CommandBasePtr relatedCommand, int ephemerisAndClock, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setEphemerisAndClock(ephemerisAndClock);
      setOverrideRinex(overrideRinex);
    }


    GetIssueOfDataNavICResultPtr GetIssueOfDataNavICResult::create(CommandBasePtr relatedCommand, int ephemerisAndClock, const Sdx::optional<bool>& overrideRinex)
    {
      return std::make_shared<GetIssueOfDataNavICResult>(relatedCommand, ephemerisAndClock, overrideRinex);
    }

    GetIssueOfDataNavICResultPtr GetIssueOfDataNavICResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataNavICResult>(ptr);
    }

    bool GetIssueOfDataNavICResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["EphemerisAndClock"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetIssueOfDataNavICResult::documentation() const { return Documentation; }


    int GetIssueOfDataNavICResult::ephemerisAndClock() const
    {
      return parse_json<int>::parse(m_values["EphemerisAndClock"]);
    }

    void GetIssueOfDataNavICResult::setEphemerisAndClock(int ephemerisAndClock)
    {
      m_values.AddMember("EphemerisAndClock", parse_json<int>::format(ephemerisAndClock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetIssueOfDataNavICResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetIssueOfDataNavICResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsConfigurationCodeForSV
///
#include "gen/SetGpsConfigurationCodeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsConfigurationCodeForSV::CmdName = "SetGpsConfigurationCodeForSV";
    const char* const SetGpsConfigurationCodeForSV::Documentation = "Set GPS SV configuration flag for one satellite";

    REGISTER_COMMAND_FACTORY(SetGpsConfigurationCodeForSV);


    SetGpsConfigurationCodeForSV::SetGpsConfigurationCodeForSV()
      : CommandBase(CmdName)
    {}

    SetGpsConfigurationCodeForSV::SetGpsConfigurationCodeForSV(int svId, int svConfig, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSvConfig(svConfig);
      setDataSetName(dataSetName);
    }


    SetGpsConfigurationCodeForSVPtr SetGpsConfigurationCodeForSV::create(int svId, int svConfig, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsConfigurationCodeForSV>(svId, svConfig, dataSetName);
    }

    SetGpsConfigurationCodeForSVPtr SetGpsConfigurationCodeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsConfigurationCodeForSV>(ptr);
    }

    bool SetGpsConfigurationCodeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SvConfig"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsConfigurationCodeForSV::documentation() const { return Documentation; }


    int SetGpsConfigurationCodeForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGpsConfigurationCodeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsConfigurationCodeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsConfigurationCodeForSV::svConfig() const
    {
      return parse_json<int>::parse(m_values["SvConfig"]);
    }

    void SetGpsConfigurationCodeForSV::setSvConfig(int svConfig)
    {
      m_values.AddMember("SvConfig", parse_json<int>::format(svConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsConfigurationCodeForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsConfigurationCodeForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsConfigurationCodeForSV
///
#include "gen/GetGpsConfigurationCodeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsConfigurationCodeForSV::CmdName = "GetGpsConfigurationCodeForSV";
    const char* const GetGpsConfigurationCodeForSV::Documentation = "Get GPS SV configuration flag for one satellite";

    REGISTER_COMMAND_FACTORY(GetGpsConfigurationCodeForSV);


    GetGpsConfigurationCodeForSV::GetGpsConfigurationCodeForSV()
      : CommandBase(CmdName)
    {}

    GetGpsConfigurationCodeForSV::GetGpsConfigurationCodeForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsConfigurationCodeForSVPtr GetGpsConfigurationCodeForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsConfigurationCodeForSV>(svId, dataSetName);
    }

    GetGpsConfigurationCodeForSVPtr GetGpsConfigurationCodeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsConfigurationCodeForSV>(ptr);
    }

    bool GetGpsConfigurationCodeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsConfigurationCodeForSV::documentation() const { return Documentation; }


    int GetGpsConfigurationCodeForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsConfigurationCodeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsConfigurationCodeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsConfigurationCodeForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsConfigurationCodeForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsConfigurationCodeForSVResult
///
#include "gen/GetGpsConfigurationCodeForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsConfigurationCodeForSVResult::CmdName = "GetGpsConfigurationCodeForSVResult";
    const char* const GetGpsConfigurationCodeForSVResult::Documentation = "Result of GetGpsConfigurationCodeForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsConfigurationCodeForSVResult);


    GetGpsConfigurationCodeForSVResult::GetGpsConfigurationCodeForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsConfigurationCodeForSVResult::GetGpsConfigurationCodeForSVResult(CommandBasePtr relatedCommand, int svId, int svConfig, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setSvConfig(svConfig);
      setDataSetName(dataSetName);
    }


    GetGpsConfigurationCodeForSVResultPtr GetGpsConfigurationCodeForSVResult::create(CommandBasePtr relatedCommand, int svId, int svConfig, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsConfigurationCodeForSVResult>(relatedCommand, svId, svConfig, dataSetName);
    }

    GetGpsConfigurationCodeForSVResultPtr GetGpsConfigurationCodeForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsConfigurationCodeForSVResult>(ptr);
    }

    bool GetGpsConfigurationCodeForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SvConfig"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsConfigurationCodeForSVResult::documentation() const { return Documentation; }


    int GetGpsConfigurationCodeForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsConfigurationCodeForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsConfigurationCodeForSVResult::svConfig() const
    {
      return parse_json<int>::parse(m_values["SvConfig"]);
    }

    void GetGpsConfigurationCodeForSVResult::setSvConfig(int svConfig)
    {
      m_values.AddMember("SvConfig", parse_json<int>::format(svConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsConfigurationCodeForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsConfigurationCodeForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsConfigurationForEachSV
///
#include "gen/SetGpsConfigurationForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsConfigurationForEachSV::CmdName = "SetGpsConfigurationForEachSV";
    const char* const SetGpsConfigurationForEachSV::Documentation = "Set GPS SV configuration flag for each SVs";

    REGISTER_COMMAND_FACTORY(SetGpsConfigurationForEachSV);


    SetGpsConfigurationForEachSV::SetGpsConfigurationForEachSV()
      : CommandBase(CmdName)
    {}

    SetGpsConfigurationForEachSV::SetGpsConfigurationForEachSV(const std::vector<int>& svConfigs, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvConfigs(svConfigs);
      setDataSetName(dataSetName);
    }


    SetGpsConfigurationForEachSVPtr SetGpsConfigurationForEachSV::create(const std::vector<int>& svConfigs, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsConfigurationForEachSV>(svConfigs, dataSetName);
    }

    SetGpsConfigurationForEachSVPtr SetGpsConfigurationForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsConfigurationForEachSV>(ptr);
    }

    bool SetGpsConfigurationForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["SvConfigs"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsConfigurationForEachSV::documentation() const { return Documentation; }


    int SetGpsConfigurationForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::vector<int> SetGpsConfigurationForEachSV::svConfigs() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvConfigs"]);
    }

    void SetGpsConfigurationForEachSV::setSvConfigs(const std::vector<int>& svConfigs)
    {
      m_values.AddMember("SvConfigs", parse_json<std::vector<int>>::format(svConfigs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsConfigurationForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsConfigurationForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSVConfigurationForAllSat
///
#include "gen/SetGpsSVConfigurationForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSVConfigurationForAllSat::CmdName = "SetGpsSVConfigurationForAllSat";
    const char* const SetGpsSVConfigurationForAllSat::Documentation = "Please note the command SetGpsSVConfigurationForAllSat is deprecated since 21.3. You may use SetGpsConfigurationForEachSV.\n\nSet GPS SV configuration flag for each SVs";

    REGISTER_COMMAND_FACTORY(SetGpsSVConfigurationForAllSat);


    SetGpsSVConfigurationForAllSat::SetGpsSVConfigurationForAllSat()
      : CommandBase(CmdName)
    {}

    SetGpsSVConfigurationForAllSat::SetGpsSVConfigurationForAllSat(const std::vector<int>& svConfigs, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvConfigs(svConfigs);
      setDataSetName(dataSetName);
    }


    SetGpsSVConfigurationForAllSatPtr SetGpsSVConfigurationForAllSat::create(const std::vector<int>& svConfigs, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsSVConfigurationForAllSat>(svConfigs, dataSetName);
    }

    SetGpsSVConfigurationForAllSatPtr SetGpsSVConfigurationForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSVConfigurationForAllSat>(ptr);
    }

    bool SetGpsSVConfigurationForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["SvConfigs"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsSVConfigurationForAllSat::documentation() const { return Documentation; }


    int SetGpsSVConfigurationForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::vector<int> SetGpsSVConfigurationForAllSat::svConfigs() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvConfigs"]);
    }

    void SetGpsSVConfigurationForAllSat::setSvConfigs(const std::vector<int>& svConfigs)
    {
      m_values.AddMember("SvConfigs", parse_json<std::vector<int>>::format(svConfigs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsSVConfigurationForAllSat::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsSVConfigurationForAllSat::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsConfigurationForEachSV
///
#include "gen/GetGpsConfigurationForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsConfigurationForEachSV::CmdName = "GetGpsConfigurationForEachSV";
    const char* const GetGpsConfigurationForEachSV::Documentation = "Get GPS SV configuration flag for each SVs";

    REGISTER_COMMAND_FACTORY(GetGpsConfigurationForEachSV);


    GetGpsConfigurationForEachSV::GetGpsConfigurationForEachSV(const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setDataSetName(dataSetName);
    }


    GetGpsConfigurationForEachSVPtr GetGpsConfigurationForEachSV::create(const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsConfigurationForEachSV>(dataSetName);
    }

    GetGpsConfigurationForEachSVPtr GetGpsConfigurationForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsConfigurationForEachSV>(ptr);
    }

    bool GetGpsConfigurationForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsConfigurationForEachSV::documentation() const { return Documentation; }


    int GetGpsConfigurationForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::optional<std::string> GetGpsConfigurationForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsConfigurationForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSVConfigurationForAllSat
///
#include "gen/GetGpsSVConfigurationForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSVConfigurationForAllSat::CmdName = "GetGpsSVConfigurationForAllSat";
    const char* const GetGpsSVConfigurationForAllSat::Documentation = "Please note the command GetGpsSVConfigurationForAllSat is deprecated since 21.3. You may use GetGpsConfigurationForEachSV.\n\nGet GPS SV configuration flag for each SVs";

    REGISTER_COMMAND_FACTORY(GetGpsSVConfigurationForAllSat);


    GetGpsSVConfigurationForAllSat::GetGpsSVConfigurationForAllSat(const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setDataSetName(dataSetName);
    }


    GetGpsSVConfigurationForAllSatPtr GetGpsSVConfigurationForAllSat::create(const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsSVConfigurationForAllSat>(dataSetName);
    }

    GetGpsSVConfigurationForAllSatPtr GetGpsSVConfigurationForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSVConfigurationForAllSat>(ptr);
    }

    bool GetGpsSVConfigurationForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsSVConfigurationForAllSat::documentation() const { return Documentation; }


    int GetGpsSVConfigurationForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::optional<std::string> GetGpsSVConfigurationForAllSat::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsSVConfigurationForAllSat::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsConfigurationForEachSVResult
///
#include "gen/GetGpsConfigurationForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsConfigurationForEachSVResult::CmdName = "GetGpsConfigurationForEachSVResult";
    const char* const GetGpsConfigurationForEachSVResult::Documentation = "Result of GetGpsConfigurationForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsConfigurationForEachSVResult);


    GetGpsConfigurationForEachSVResult::GetGpsConfigurationForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsConfigurationForEachSVResult::GetGpsConfigurationForEachSVResult(CommandBasePtr relatedCommand, const std::vector<int>& svConfigs, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvConfigs(svConfigs);
      setDataSetName(dataSetName);
    }


    GetGpsConfigurationForEachSVResultPtr GetGpsConfigurationForEachSVResult::create(CommandBasePtr relatedCommand, const std::vector<int>& svConfigs, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsConfigurationForEachSVResult>(relatedCommand, svConfigs, dataSetName);
    }

    GetGpsConfigurationForEachSVResultPtr GetGpsConfigurationForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsConfigurationForEachSVResult>(ptr);
    }

    bool GetGpsConfigurationForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["SvConfigs"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsConfigurationForEachSVResult::documentation() const { return Documentation; }


    std::vector<int> GetGpsConfigurationForEachSVResult::svConfigs() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvConfigs"]);
    }

    void GetGpsConfigurationForEachSVResult::setSvConfigs(const std::vector<int>& svConfigs)
    {
      m_values.AddMember("SvConfigs", parse_json<std::vector<int>>::format(svConfigs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsConfigurationForEachSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsConfigurationForEachSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsDataHealthForSV
///
#include "gen/SetGpsDataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsDataHealthForSV::CmdName = "SetGpsDataHealthForSV";
    const char* const SetGpsDataHealthForSV::Documentation = "Set GPS nav data health";

    REGISTER_COMMAND_FACTORY(SetGpsDataHealthForSV);


    SetGpsDataHealthForSV::SetGpsDataHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsDataHealthForSV::SetGpsDataHealthForSV(int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetGpsDataHealthForSVPtr SetGpsDataHealthForSV::create(int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsDataHealthForSV>(svId, health, dataSetName);
    }

    SetGpsDataHealthForSVPtr SetGpsDataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsDataHealthForSV>(ptr);
    }

    bool SetGpsDataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsDataHealthForSV::documentation() const { return Documentation; }


    int SetGpsDataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsDataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsDataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsDataHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetGpsDataHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsDataHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsDataHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsDataHealthForSV
///
#include "gen/GetGpsDataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsDataHealthForSV::CmdName = "GetGpsDataHealthForSV";
    const char* const GetGpsDataHealthForSV::Documentation = "Get GPS nav data health";

    REGISTER_COMMAND_FACTORY(GetGpsDataHealthForSV);


    GetGpsDataHealthForSV::GetGpsDataHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsDataHealthForSV::GetGpsDataHealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsDataHealthForSVPtr GetGpsDataHealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsDataHealthForSV>(svId, dataSetName);
    }

    GetGpsDataHealthForSVPtr GetGpsDataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsDataHealthForSV>(ptr);
    }

    bool GetGpsDataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsDataHealthForSV::documentation() const { return Documentation; }


    int GetGpsDataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsDataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsDataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsDataHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsDataHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsDataHealthForSVResult
///
#include "gen/GetGpsDataHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsDataHealthForSVResult::CmdName = "GetGpsDataHealthForSVResult";
    const char* const GetGpsDataHealthForSVResult::Documentation = "Result of GetGpsDataHealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsDataHealthForSVResult);


    GetGpsDataHealthForSVResult::GetGpsDataHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsDataHealthForSVResult::GetGpsDataHealthForSVResult(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetGpsDataHealthForSVResultPtr GetGpsDataHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsDataHealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetGpsDataHealthForSVResultPtr GetGpsDataHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsDataHealthForSVResult>(ptr);
    }

    bool GetGpsDataHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsDataHealthForSVResult::documentation() const { return Documentation; }


    int GetGpsDataHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsDataHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsDataHealthForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetGpsDataHealthForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsDataHealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsDataHealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSignalHealthForSV
///
#include "gen/SetGpsSignalHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSignalHealthForSV::CmdName = "SetGpsSignalHealthForSV";
    const char* const SetGpsSignalHealthForSV::Documentation = "Set GPS signal health";

    REGISTER_COMMAND_FACTORY(SetGpsSignalHealthForSV);


    SetGpsSignalHealthForSV::SetGpsSignalHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsSignalHealthForSV::SetGpsSignalHealthForSV(int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetGpsSignalHealthForSVPtr SetGpsSignalHealthForSV::create(int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsSignalHealthForSV>(svId, health, dataSetName);
    }

    SetGpsSignalHealthForSVPtr SetGpsSignalHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSignalHealthForSV>(ptr);
    }

    bool SetGpsSignalHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsSignalHealthForSV::documentation() const { return Documentation; }


    int SetGpsSignalHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSignalHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsSignalHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsSignalHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetGpsSignalHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsSignalHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsSignalHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSignalHealthForSV
///
#include "gen/GetGpsSignalHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSignalHealthForSV::CmdName = "GetGpsSignalHealthForSV";
    const char* const GetGpsSignalHealthForSV::Documentation = "Get GPS signal health";

    REGISTER_COMMAND_FACTORY(GetGpsSignalHealthForSV);


    GetGpsSignalHealthForSV::GetGpsSignalHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsSignalHealthForSV::GetGpsSignalHealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsSignalHealthForSVPtr GetGpsSignalHealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsSignalHealthForSV>(svId, dataSetName);
    }

    GetGpsSignalHealthForSVPtr GetGpsSignalHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSignalHealthForSV>(ptr);
    }

    bool GetGpsSignalHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsSignalHealthForSV::documentation() const { return Documentation; }


    int GetGpsSignalHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSignalHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsSignalHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsSignalHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsSignalHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSignalHealthForSVResult
///
#include "gen/GetGpsSignalHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSignalHealthForSVResult::CmdName = "GetGpsSignalHealthForSVResult";
    const char* const GetGpsSignalHealthForSVResult::Documentation = "Result of GetGpsSignalHealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSignalHealthForSVResult);


    GetGpsSignalHealthForSVResult::GetGpsSignalHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsSignalHealthForSVResult::GetGpsSignalHealthForSVResult(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetGpsSignalHealthForSVResultPtr GetGpsSignalHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsSignalHealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetGpsSignalHealthForSVResultPtr GetGpsSignalHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSignalHealthForSVResult>(ptr);
    }

    bool GetGpsSignalHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsSignalHealthForSVResult::documentation() const { return Documentation; }


    int GetGpsSignalHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsSignalHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsSignalHealthForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetGpsSignalHealthForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsSignalHealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsSignalHealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoDataHealthForSV
///
#include "gen/SetGalileoDataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoDataHealthForSV::CmdName = "SetGalileoDataHealthForSV";
    const char* const SetGalileoDataHealthForSV::Documentation = "Set Galileo data health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(SetGalileoDataHealthForSV);


    SetGalileoDataHealthForSV::SetGalileoDataHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoDataHealthForSV::SetGalileoDataHealthForSV(int svId, const std::string& component, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setComponent(component);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetGalileoDataHealthForSVPtr SetGalileoDataHealthForSV::create(int svId, const std::string& component, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGalileoDataHealthForSV>(svId, component, health, dataSetName);
    }

    SetGalileoDataHealthForSVPtr SetGalileoDataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoDataHealthForSV>(ptr);
    }

    bool SetGalileoDataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGalileoDataHealthForSV::documentation() const { return Documentation; }


    int SetGalileoDataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGalileoDataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoDataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGalileoDataHealthForSV::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void SetGalileoDataHealthForSV::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGalileoDataHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGalileoDataHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGalileoDataHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGalileoDataHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoDataHealthForSV
///
#include "gen/GetGalileoDataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoDataHealthForSV::CmdName = "GetGalileoDataHealthForSV";
    const char* const GetGalileoDataHealthForSV::Documentation = "Get Galileo data health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(GetGalileoDataHealthForSV);


    GetGalileoDataHealthForSV::GetGalileoDataHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGalileoDataHealthForSV::GetGalileoDataHealthForSV(int svId, const std::string& component, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setComponent(component);
      setDataSetName(dataSetName);
    }


    GetGalileoDataHealthForSVPtr GetGalileoDataHealthForSV::create(int svId, const std::string& component, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGalileoDataHealthForSV>(svId, component, dataSetName);
    }

    GetGalileoDataHealthForSVPtr GetGalileoDataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoDataHealthForSV>(ptr);
    }

    bool GetGalileoDataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGalileoDataHealthForSV::documentation() const { return Documentation; }


    int GetGalileoDataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoDataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoDataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoDataHealthForSV::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoDataHealthForSV::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGalileoDataHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGalileoDataHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoDataHealthForSVResult
///
#include "gen/GetGalileoDataHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoDataHealthForSVResult::CmdName = "GetGalileoDataHealthForSVResult";
    const char* const GetGalileoDataHealthForSVResult::Documentation = "Result of GetGalileoDataHealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoDataHealthForSVResult);


    GetGalileoDataHealthForSVResult::GetGalileoDataHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGalileoDataHealthForSVResult::GetGalileoDataHealthForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& component, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setComponent(component);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetGalileoDataHealthForSVResultPtr GetGalileoDataHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& component, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGalileoDataHealthForSVResult>(relatedCommand, svId, component, health, dataSetName);
    }

    GetGalileoDataHealthForSVResultPtr GetGalileoDataHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoDataHealthForSVResult>(ptr);
    }

    bool GetGalileoDataHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGalileoDataHealthForSVResult::documentation() const { return Documentation; }


    int GetGalileoDataHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoDataHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoDataHealthForSVResult::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoDataHealthForSVResult::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGalileoDataHealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGalileoDataHealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGalileoDataHealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGalileoDataHealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSignalHealthForSV
///
#include "gen/SetGalileoSignalHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSignalHealthForSV::CmdName = "SetGalileoSignalHealthForSV";
    const char* const SetGalileoSignalHealthForSV::Documentation = "Set Galileo signal health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(SetGalileoSignalHealthForSV);


    SetGalileoSignalHealthForSV::SetGalileoSignalHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoSignalHealthForSV::SetGalileoSignalHealthForSV(int svId, const std::string& component, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setComponent(component);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetGalileoSignalHealthForSVPtr SetGalileoSignalHealthForSV::create(int svId, const std::string& component, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGalileoSignalHealthForSV>(svId, component, health, dataSetName);
    }

    SetGalileoSignalHealthForSVPtr SetGalileoSignalHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSignalHealthForSV>(ptr);
    }

    bool SetGalileoSignalHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGalileoSignalHealthForSV::documentation() const { return Documentation; }


    int SetGalileoSignalHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGalileoSignalHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoSignalHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGalileoSignalHealthForSV::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void SetGalileoSignalHealthForSV::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoSignalHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetGalileoSignalHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGalileoSignalHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGalileoSignalHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoSignalHealthForSV
///
#include "gen/GetGalileoSignalHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoSignalHealthForSV::CmdName = "GetGalileoSignalHealthForSV";
    const char* const GetGalileoSignalHealthForSV::Documentation = "Get Galileo signal health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(GetGalileoSignalHealthForSV);


    GetGalileoSignalHealthForSV::GetGalileoSignalHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGalileoSignalHealthForSV::GetGalileoSignalHealthForSV(int svId, const std::string& component, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setComponent(component);
      setDataSetName(dataSetName);
    }


    GetGalileoSignalHealthForSVPtr GetGalileoSignalHealthForSV::create(int svId, const std::string& component, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGalileoSignalHealthForSV>(svId, component, dataSetName);
    }

    GetGalileoSignalHealthForSVPtr GetGalileoSignalHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoSignalHealthForSV>(ptr);
    }

    bool GetGalileoSignalHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGalileoSignalHealthForSV::documentation() const { return Documentation; }


    int GetGalileoSignalHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoSignalHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoSignalHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoSignalHealthForSV::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoSignalHealthForSV::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGalileoSignalHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGalileoSignalHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoSignalHealthForSVResult
///
#include "gen/GetGalileoSignalHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoSignalHealthForSVResult::CmdName = "GetGalileoSignalHealthForSVResult";
    const char* const GetGalileoSignalHealthForSVResult::Documentation = "Result of GetGalileoSignalHealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoSignalHealthForSVResult);


    GetGalileoSignalHealthForSVResult::GetGalileoSignalHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGalileoSignalHealthForSVResult::GetGalileoSignalHealthForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& component, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setComponent(component);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetGalileoSignalHealthForSVResultPtr GetGalileoSignalHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& component, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGalileoSignalHealthForSVResult>(relatedCommand, svId, component, health, dataSetName);
    }

    GetGalileoSignalHealthForSVResultPtr GetGalileoSignalHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoSignalHealthForSVResult>(ptr);
    }

    bool GetGalileoSignalHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGalileoSignalHealthForSVResult::documentation() const { return Documentation; }


    int GetGalileoSignalHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoSignalHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoSignalHealthForSVResult::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoSignalHealthForSVResult::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoSignalHealthForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetGalileoSignalHealthForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGalileoSignalHealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGalileoSignalHealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsL1HealthForSV
///
#include "gen/SetGpsL1HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsL1HealthForSV::CmdName = "SetGpsL1HealthForSV";
    const char* const SetGpsL1HealthForSV::Documentation = "Set GPS L1 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(SetGpsL1HealthForSV);


    SetGpsL1HealthForSV::SetGpsL1HealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsL1HealthForSV::SetGpsL1HealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetGpsL1HealthForSVPtr SetGpsL1HealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsL1HealthForSV>(svId, health, dataSetName);
    }

    SetGpsL1HealthForSVPtr SetGpsL1HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsL1HealthForSV>(ptr);
    }

    bool SetGpsL1HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsL1HealthForSV::documentation() const { return Documentation; }


    int SetGpsL1HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsL1HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsL1HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsL1HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsL1HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsL1HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsL1HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL1HealthForSV
///
#include "gen/GetGpsL1HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL1HealthForSV::CmdName = "GetGpsL1HealthForSV";
    const char* const GetGpsL1HealthForSV::Documentation = "Get GPS L1 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(GetGpsL1HealthForSV);


    GetGpsL1HealthForSV::GetGpsL1HealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsL1HealthForSV::GetGpsL1HealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsL1HealthForSVPtr GetGpsL1HealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsL1HealthForSV>(svId, dataSetName);
    }

    GetGpsL1HealthForSVPtr GetGpsL1HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL1HealthForSV>(ptr);
    }

    bool GetGpsL1HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsL1HealthForSV::documentation() const { return Documentation; }


    int GetGpsL1HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsL1HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL1HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsL1HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsL1HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL1HealthForSVResult
///
#include "gen/GetGpsL1HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL1HealthForSVResult::CmdName = "GetGpsL1HealthForSVResult";
    const char* const GetGpsL1HealthForSVResult::Documentation = "Result of GetGpsL1HealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsL1HealthForSVResult);


    GetGpsL1HealthForSVResult::GetGpsL1HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsL1HealthForSVResult::GetGpsL1HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetGpsL1HealthForSVResultPtr GetGpsL1HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsL1HealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetGpsL1HealthForSVResultPtr GetGpsL1HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL1HealthForSVResult>(ptr);
    }

    bool GetGpsL1HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsL1HealthForSVResult::documentation() const { return Documentation; }


    int GetGpsL1HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL1HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsL1HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsL1HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsL1HealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsL1HealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsL2HealthForSV
///
#include "gen/SetGpsL2HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsL2HealthForSV::CmdName = "SetGpsL2HealthForSV";
    const char* const SetGpsL2HealthForSV::Documentation = "Set GPS L2 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(SetGpsL2HealthForSV);


    SetGpsL2HealthForSV::SetGpsL2HealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsL2HealthForSV::SetGpsL2HealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetGpsL2HealthForSVPtr SetGpsL2HealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsL2HealthForSV>(svId, health, dataSetName);
    }

    SetGpsL2HealthForSVPtr SetGpsL2HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsL2HealthForSV>(ptr);
    }

    bool SetGpsL2HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsL2HealthForSV::documentation() const { return Documentation; }


    int SetGpsL2HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsL2HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsL2HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsL2HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsL2HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsL2HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsL2HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL2HealthForSV
///
#include "gen/GetGpsL2HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL2HealthForSV::CmdName = "GetGpsL2HealthForSV";
    const char* const GetGpsL2HealthForSV::Documentation = "Get GPS L2 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(GetGpsL2HealthForSV);


    GetGpsL2HealthForSV::GetGpsL2HealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsL2HealthForSV::GetGpsL2HealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsL2HealthForSVPtr GetGpsL2HealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsL2HealthForSV>(svId, dataSetName);
    }

    GetGpsL2HealthForSVPtr GetGpsL2HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL2HealthForSV>(ptr);
    }

    bool GetGpsL2HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsL2HealthForSV::documentation() const { return Documentation; }


    int GetGpsL2HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsL2HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL2HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsL2HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsL2HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL2HealthForSVResult
///
#include "gen/GetGpsL2HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL2HealthForSVResult::CmdName = "GetGpsL2HealthForSVResult";
    const char* const GetGpsL2HealthForSVResult::Documentation = "Result of GetGpsL2HealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsL2HealthForSVResult);


    GetGpsL2HealthForSVResult::GetGpsL2HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsL2HealthForSVResult::GetGpsL2HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetGpsL2HealthForSVResultPtr GetGpsL2HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsL2HealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetGpsL2HealthForSVResultPtr GetGpsL2HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL2HealthForSVResult>(ptr);
    }

    bool GetGpsL2HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsL2HealthForSVResult::documentation() const { return Documentation; }


    int GetGpsL2HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL2HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsL2HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsL2HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsL2HealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsL2HealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsL5HealthForSV
///
#include "gen/SetGpsL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsL5HealthForSV::CmdName = "SetGpsL5HealthForSV";
    const char* const SetGpsL5HealthForSV::Documentation = "Set GPS L5 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(SetGpsL5HealthForSV);


    SetGpsL5HealthForSV::SetGpsL5HealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsL5HealthForSV::SetGpsL5HealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetGpsL5HealthForSVPtr SetGpsL5HealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsL5HealthForSV>(svId, health, dataSetName);
    }

    SetGpsL5HealthForSVPtr SetGpsL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsL5HealthForSV>(ptr);
    }

    bool SetGpsL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsL5HealthForSV::documentation() const { return Documentation; }


    int SetGpsL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsL5HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsL5HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsL5HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsL5HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL5HealthForSV
///
#include "gen/GetGpsL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL5HealthForSV::CmdName = "GetGpsL5HealthForSV";
    const char* const GetGpsL5HealthForSV::Documentation = "Get GPS L5 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(GetGpsL5HealthForSV);


    GetGpsL5HealthForSV::GetGpsL5HealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsL5HealthForSV::GetGpsL5HealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsL5HealthForSVPtr GetGpsL5HealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsL5HealthForSV>(svId, dataSetName);
    }

    GetGpsL5HealthForSVPtr GetGpsL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL5HealthForSV>(ptr);
    }

    bool GetGpsL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsL5HealthForSV::documentation() const { return Documentation; }


    int GetGpsL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsL5HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsL5HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL5HealthForSVResult
///
#include "gen/GetGpsL5HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL5HealthForSVResult::CmdName = "GetGpsL5HealthForSVResult";
    const char* const GetGpsL5HealthForSVResult::Documentation = "Result of GetGpsL5HealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsL5HealthForSVResult);


    GetGpsL5HealthForSVResult::GetGpsL5HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsL5HealthForSVResult::GetGpsL5HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetGpsL5HealthForSVResultPtr GetGpsL5HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsL5HealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetGpsL5HealthForSVResultPtr GetGpsL5HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL5HealthForSVResult>(ptr);
    }

    bool GetGpsL5HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsL5HealthForSVResult::documentation() const { return Documentation; }


    int GetGpsL5HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL5HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsL5HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsL5HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsL5HealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsL5HealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsL1cHealthForSV
///
#include "gen/SetGpsL1cHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsL1cHealthForSV::CmdName = "SetGpsL1cHealthForSV";
    const char* const SetGpsL1cHealthForSV::Documentation = "Set GPS L1C health (used in CNAV2 only)";

    REGISTER_COMMAND_FACTORY(SetGpsL1cHealthForSV);


    SetGpsL1cHealthForSV::SetGpsL1cHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsL1cHealthForSV::SetGpsL1cHealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetGpsL1cHealthForSVPtr SetGpsL1cHealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsL1cHealthForSV>(svId, health, dataSetName);
    }

    SetGpsL1cHealthForSVPtr SetGpsL1cHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsL1cHealthForSV>(ptr);
    }

    bool SetGpsL1cHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsL1cHealthForSV::documentation() const { return Documentation; }


    int SetGpsL1cHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsL1cHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsL1cHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsL1cHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsL1cHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsL1cHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsL1cHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL1cHealthForSV
///
#include "gen/GetGpsL1cHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL1cHealthForSV::CmdName = "GetGpsL1cHealthForSV";
    const char* const GetGpsL1cHealthForSV::Documentation = "Get GPS L1C health (used in CNAV2 only)";

    REGISTER_COMMAND_FACTORY(GetGpsL1cHealthForSV);


    GetGpsL1cHealthForSV::GetGpsL1cHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsL1cHealthForSV::GetGpsL1cHealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsL1cHealthForSVPtr GetGpsL1cHealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsL1cHealthForSV>(svId, dataSetName);
    }

    GetGpsL1cHealthForSVPtr GetGpsL1cHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL1cHealthForSV>(ptr);
    }

    bool GetGpsL1cHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsL1cHealthForSV::documentation() const { return Documentation; }


    int GetGpsL1cHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsL1cHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL1cHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsL1cHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsL1cHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL1cHealthForSVResult
///
#include "gen/GetGpsL1cHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL1cHealthForSVResult::CmdName = "GetGpsL1cHealthForSVResult";
    const char* const GetGpsL1cHealthForSVResult::Documentation = "Result of GetGpsL1cHealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsL1cHealthForSVResult);


    GetGpsL1cHealthForSVResult::GetGpsL1cHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsL1cHealthForSVResult::GetGpsL1cHealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetGpsL1cHealthForSVResultPtr GetGpsL1cHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsL1cHealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetGpsL1cHealthForSVResultPtr GetGpsL1cHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL1cHealthForSVResult>(ptr);
    }

    bool GetGpsL1cHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsL1cHealthForSVResult::documentation() const { return Documentation; }


    int GetGpsL1cHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL1cHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsL1cHealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsL1cHealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsL1cHealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsL1cHealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsAntiSpoofingFlagForSV
///
#include "gen/SetGpsAntiSpoofingFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsAntiSpoofingFlagForSV::CmdName = "SetGpsAntiSpoofingFlagForSV";
    const char* const SetGpsAntiSpoofingFlagForSV::Documentation = "Set GPS Anti-Spoofing Flag";

    REGISTER_COMMAND_FACTORY(SetGpsAntiSpoofingFlagForSV);


    SetGpsAntiSpoofingFlagForSV::SetGpsAntiSpoofingFlagForSV()
      : CommandBase(CmdName)
    {}

    SetGpsAntiSpoofingFlagForSV::SetGpsAntiSpoofingFlagForSV(int svId, const Sdx::GpsASFlag& antiSpoofing, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAntiSpoofing(antiSpoofing);
      setDataSetName(dataSetName);
    }


    SetGpsAntiSpoofingFlagForSVPtr SetGpsAntiSpoofingFlagForSV::create(int svId, const Sdx::GpsASFlag& antiSpoofing, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsAntiSpoofingFlagForSV>(svId, antiSpoofing, dataSetName);
    }

    SetGpsAntiSpoofingFlagForSVPtr SetGpsAntiSpoofingFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsAntiSpoofingFlagForSV>(ptr);
    }

    bool SetGpsAntiSpoofingFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::GpsASFlag>::is_valid(m_values["AntiSpoofing"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsAntiSpoofingFlagForSV::documentation() const { return Documentation; }


    int SetGpsAntiSpoofingFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsAntiSpoofingFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsAntiSpoofingFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GpsASFlag SetGpsAntiSpoofingFlagForSV::antiSpoofing() const
    {
      return parse_json<Sdx::GpsASFlag>::parse(m_values["AntiSpoofing"]);
    }

    void SetGpsAntiSpoofingFlagForSV::setAntiSpoofing(const Sdx::GpsASFlag& antiSpoofing)
    {
      m_values.AddMember("AntiSpoofing", parse_json<Sdx::GpsASFlag>::format(antiSpoofing, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsAntiSpoofingFlagForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsAntiSpoofingFlagForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsAntiSpoofingFlagForSV
///
#include "gen/GetGpsAntiSpoofingFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsAntiSpoofingFlagForSV::CmdName = "GetGpsAntiSpoofingFlagForSV";
    const char* const GetGpsAntiSpoofingFlagForSV::Documentation = "Get GPS Anti-Spoofing Flag";

    REGISTER_COMMAND_FACTORY(GetGpsAntiSpoofingFlagForSV);


    GetGpsAntiSpoofingFlagForSV::GetGpsAntiSpoofingFlagForSV()
      : CommandBase(CmdName)
    {}

    GetGpsAntiSpoofingFlagForSV::GetGpsAntiSpoofingFlagForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsAntiSpoofingFlagForSVPtr GetGpsAntiSpoofingFlagForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsAntiSpoofingFlagForSV>(svId, dataSetName);
    }

    GetGpsAntiSpoofingFlagForSVPtr GetGpsAntiSpoofingFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsAntiSpoofingFlagForSV>(ptr);
    }

    bool GetGpsAntiSpoofingFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsAntiSpoofingFlagForSV::documentation() const { return Documentation; }


    int GetGpsAntiSpoofingFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsAntiSpoofingFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsAntiSpoofingFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsAntiSpoofingFlagForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsAntiSpoofingFlagForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsAntiSpoofingFlagForSVResult
///
#include "gen/GetGpsAntiSpoofingFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsAntiSpoofingFlagForSVResult::CmdName = "GetGpsAntiSpoofingFlagForSVResult";
    const char* const GetGpsAntiSpoofingFlagForSVResult::Documentation = "Result of GetGpsAntiSpoofingFlagForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsAntiSpoofingFlagForSVResult);


    GetGpsAntiSpoofingFlagForSVResult::GetGpsAntiSpoofingFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsAntiSpoofingFlagForSVResult::GetGpsAntiSpoofingFlagForSVResult(CommandBasePtr relatedCommand, int svId, const Sdx::GpsASFlag& antiSpoofing, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAntiSpoofing(antiSpoofing);
      setDataSetName(dataSetName);
    }


    GetGpsAntiSpoofingFlagForSVResultPtr GetGpsAntiSpoofingFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, const Sdx::GpsASFlag& antiSpoofing, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsAntiSpoofingFlagForSVResult>(relatedCommand, svId, antiSpoofing, dataSetName);
    }

    GetGpsAntiSpoofingFlagForSVResultPtr GetGpsAntiSpoofingFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsAntiSpoofingFlagForSVResult>(ptr);
    }

    bool GetGpsAntiSpoofingFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::GpsASFlag>::is_valid(m_values["AntiSpoofing"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsAntiSpoofingFlagForSVResult::documentation() const { return Documentation; }


    int GetGpsAntiSpoofingFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsAntiSpoofingFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GpsASFlag GetGpsAntiSpoofingFlagForSVResult::antiSpoofing() const
    {
      return parse_json<Sdx::GpsASFlag>::parse(m_values["AntiSpoofing"]);
    }

    void GetGpsAntiSpoofingFlagForSVResult::setAntiSpoofing(const Sdx::GpsASFlag& antiSpoofing)
    {
      m_values.AddMember("AntiSpoofing", parse_json<Sdx::GpsASFlag>::format(antiSpoofing, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsAntiSpoofingFlagForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsAntiSpoofingFlagForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsNavAlertFlagForSV
///
#include "gen/SetGpsNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsNavAlertFlagForSV::CmdName = "SetGpsNavAlertFlagForSV";
    const char* const SetGpsNavAlertFlagForSV::Documentation = "Set GPS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetGpsNavAlertFlagForSV);


    SetGpsNavAlertFlagForSV::SetGpsNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    SetGpsNavAlertFlagForSV::SetGpsNavAlertFlagForSV(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    SetGpsNavAlertFlagForSVPtr SetGpsNavAlertFlagForSV::create(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsNavAlertFlagForSV>(svId, alert, dataSetName);
    }

    SetGpsNavAlertFlagForSVPtr SetGpsNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsNavAlertFlagForSV>(ptr);
    }

    bool SetGpsNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsNavAlertFlagForSV::documentation() const { return Documentation; }


    int SetGpsNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsNavAlertFlagForSV::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetGpsNavAlertFlagForSV::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsNavAlertFlagForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsNavAlertFlagForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsNavAlertFlagForSV
///
#include "gen/GetGpsNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsNavAlertFlagForSV::CmdName = "GetGpsNavAlertFlagForSV";
    const char* const GetGpsNavAlertFlagForSV::Documentation = "Get GPS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetGpsNavAlertFlagForSV);


    GetGpsNavAlertFlagForSV::GetGpsNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    GetGpsNavAlertFlagForSV::GetGpsNavAlertFlagForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsNavAlertFlagForSVPtr GetGpsNavAlertFlagForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsNavAlertFlagForSV>(svId, dataSetName);
    }

    GetGpsNavAlertFlagForSVPtr GetGpsNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsNavAlertFlagForSV>(ptr);
    }

    bool GetGpsNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsNavAlertFlagForSV::documentation() const { return Documentation; }


    int GetGpsNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsNavAlertFlagForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsNavAlertFlagForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsNavAlertFlagForSVResult
///
#include "gen/GetGpsNavAlertFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsNavAlertFlagForSVResult::CmdName = "GetGpsNavAlertFlagForSVResult";
    const char* const GetGpsNavAlertFlagForSVResult::Documentation = "Result of GetGpsNavAlertFlagForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsNavAlertFlagForSVResult);


    GetGpsNavAlertFlagForSVResult::GetGpsNavAlertFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsNavAlertFlagForSVResult::GetGpsNavAlertFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    GetGpsNavAlertFlagForSVResultPtr GetGpsNavAlertFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsNavAlertFlagForSVResult>(relatedCommand, svId, alert, dataSetName);
    }

    GetGpsNavAlertFlagForSVResultPtr GetGpsNavAlertFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsNavAlertFlagForSVResult>(ptr);
    }

    bool GetGpsNavAlertFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsNavAlertFlagForSVResult::documentation() const { return Documentation; }


    int GetGpsNavAlertFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsNavAlertFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsNavAlertFlagForSVResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetGpsNavAlertFlagForSVResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsNavAlertFlagForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsNavAlertFlagForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsCNavAlertFlagToSV
///
#include "gen/SetGpsCNavAlertFlagToSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsCNavAlertFlagToSV::CmdName = "SetGpsCNavAlertFlagToSV";
    const char* const SetGpsCNavAlertFlagToSV::Documentation = "Set GPS CNAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetGpsCNavAlertFlagToSV);


    SetGpsCNavAlertFlagToSV::SetGpsCNavAlertFlagToSV()
      : CommandBase(CmdName)
    {}

    SetGpsCNavAlertFlagToSV::SetGpsCNavAlertFlagToSV(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    SetGpsCNavAlertFlagToSVPtr SetGpsCNavAlertFlagToSV::create(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsCNavAlertFlagToSV>(svId, alert, dataSetName);
    }

    SetGpsCNavAlertFlagToSVPtr SetGpsCNavAlertFlagToSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsCNavAlertFlagToSV>(ptr);
    }

    bool SetGpsCNavAlertFlagToSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsCNavAlertFlagToSV::documentation() const { return Documentation; }


    int SetGpsCNavAlertFlagToSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsCNavAlertFlagToSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsCNavAlertFlagToSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsCNavAlertFlagToSV::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetGpsCNavAlertFlagToSV::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsCNavAlertFlagToSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsCNavAlertFlagToSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNavAlertFlagToSV
///
#include "gen/GetGpsCNavAlertFlagToSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNavAlertFlagToSV::CmdName = "GetGpsCNavAlertFlagToSV";
    const char* const GetGpsCNavAlertFlagToSV::Documentation = "Get GPS CNAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetGpsCNavAlertFlagToSV);


    GetGpsCNavAlertFlagToSV::GetGpsCNavAlertFlagToSV()
      : CommandBase(CmdName)
    {}

    GetGpsCNavAlertFlagToSV::GetGpsCNavAlertFlagToSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetGpsCNavAlertFlagToSVPtr GetGpsCNavAlertFlagToSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsCNavAlertFlagToSV>(svId, dataSetName);
    }

    GetGpsCNavAlertFlagToSVPtr GetGpsCNavAlertFlagToSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNavAlertFlagToSV>(ptr);
    }

    bool GetGpsCNavAlertFlagToSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsCNavAlertFlagToSV::documentation() const { return Documentation; }


    int GetGpsCNavAlertFlagToSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsCNavAlertFlagToSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsCNavAlertFlagToSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsCNavAlertFlagToSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsCNavAlertFlagToSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNavAlertFlagToSVResult
///
#include "gen/GetGpsCNavAlertFlagToSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNavAlertFlagToSVResult::CmdName = "GetGpsCNavAlertFlagToSVResult";
    const char* const GetGpsCNavAlertFlagToSVResult::Documentation = "Result of GetGpsCNavAlertFlagToSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsCNavAlertFlagToSVResult);


    GetGpsCNavAlertFlagToSVResult::GetGpsCNavAlertFlagToSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsCNavAlertFlagToSVResult::GetGpsCNavAlertFlagToSVResult(CommandBasePtr relatedCommand, int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    GetGpsCNavAlertFlagToSVResultPtr GetGpsCNavAlertFlagToSVResult::create(CommandBasePtr relatedCommand, int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsCNavAlertFlagToSVResult>(relatedCommand, svId, alert, dataSetName);
    }

    GetGpsCNavAlertFlagToSVResultPtr GetGpsCNavAlertFlagToSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNavAlertFlagToSVResult>(ptr);
    }

    bool GetGpsCNavAlertFlagToSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsCNavAlertFlagToSVResult::documentation() const { return Documentation; }


    int GetGpsCNavAlertFlagToSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsCNavAlertFlagToSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsCNavAlertFlagToSVResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetGpsCNavAlertFlagToSVResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsCNavAlertFlagToSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsCNavAlertFlagToSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouHealthInfoForSV
///
#include "gen/SetBeiDouHealthInfoForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouHealthInfoForSV::CmdName = "SetBeiDouHealthInfoForSV";
    const char* const SetBeiDouHealthInfoForSV::Documentation = "Set BeiDou satellite health info";

    REGISTER_COMMAND_FACTORY(SetBeiDouHealthInfoForSV);


    SetBeiDouHealthInfoForSV::SetBeiDouHealthInfoForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouHealthInfoForSV::SetBeiDouHealthInfoForSV(int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetBeiDouHealthInfoForSVPtr SetBeiDouHealthInfoForSV::create(int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouHealthInfoForSV>(svId, health, dataSetName);
    }

    SetBeiDouHealthInfoForSVPtr SetBeiDouHealthInfoForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouHealthInfoForSV>(ptr);
    }

    bool SetBeiDouHealthInfoForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouHealthInfoForSV::documentation() const { return Documentation; }


    int SetBeiDouHealthInfoForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouHealthInfoForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouHealthInfoForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouHealthInfoForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetBeiDouHealthInfoForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouHealthInfoForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouHealthInfoForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouHealthInfoForSV
///
#include "gen/GetBeiDouHealthInfoForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouHealthInfoForSV::CmdName = "GetBeiDouHealthInfoForSV";
    const char* const GetBeiDouHealthInfoForSV::Documentation = "Get BeiDou satellite health info";

    REGISTER_COMMAND_FACTORY(GetBeiDouHealthInfoForSV);


    GetBeiDouHealthInfoForSV::GetBeiDouHealthInfoForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouHealthInfoForSV::GetBeiDouHealthInfoForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetBeiDouHealthInfoForSVPtr GetBeiDouHealthInfoForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouHealthInfoForSV>(svId, dataSetName);
    }

    GetBeiDouHealthInfoForSVPtr GetBeiDouHealthInfoForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouHealthInfoForSV>(ptr);
    }

    bool GetBeiDouHealthInfoForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouHealthInfoForSV::documentation() const { return Documentation; }


    int GetBeiDouHealthInfoForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouHealthInfoForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouHealthInfoForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouHealthInfoForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouHealthInfoForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouHealthInfoForSVResult
///
#include "gen/GetBeiDouHealthInfoForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouHealthInfoForSVResult::CmdName = "GetBeiDouHealthInfoForSVResult";
    const char* const GetBeiDouHealthInfoForSVResult::Documentation = "Result of GetBeiDouHealthInfoForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouHealthInfoForSVResult);


    GetBeiDouHealthInfoForSVResult::GetBeiDouHealthInfoForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouHealthInfoForSVResult::GetBeiDouHealthInfoForSVResult(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetBeiDouHealthInfoForSVResultPtr GetBeiDouHealthInfoForSVResult::create(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouHealthInfoForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetBeiDouHealthInfoForSVResultPtr GetBeiDouHealthInfoForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouHealthInfoForSVResult>(ptr);
    }

    bool GetBeiDouHealthInfoForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouHealthInfoForSVResult::documentation() const { return Documentation; }


    int GetBeiDouHealthInfoForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouHealthInfoForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouHealthInfoForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetBeiDouHealthInfoForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouHealthInfoForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouHealthInfoForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouAutonomousHealthForSV
///
#include "gen/SetBeiDouAutonomousHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouAutonomousHealthForSV::CmdName = "SetBeiDouAutonomousHealthForSV";
    const char* const SetBeiDouAutonomousHealthForSV::Documentation = "Set BeiDou satellite autonomous health";

    REGISTER_COMMAND_FACTORY(SetBeiDouAutonomousHealthForSV);


    SetBeiDouAutonomousHealthForSV::SetBeiDouAutonomousHealthForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouAutonomousHealthForSV::SetBeiDouAutonomousHealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetBeiDouAutonomousHealthForSVPtr SetBeiDouAutonomousHealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouAutonomousHealthForSV>(svId, health, dataSetName);
    }

    SetBeiDouAutonomousHealthForSVPtr SetBeiDouAutonomousHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouAutonomousHealthForSV>(ptr);
    }

    bool SetBeiDouAutonomousHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouAutonomousHealthForSV::documentation() const { return Documentation; }


    int SetBeiDouAutonomousHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouAutonomousHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouAutonomousHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetBeiDouAutonomousHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetBeiDouAutonomousHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouAutonomousHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouAutonomousHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouAutonomousHealthForSV
///
#include "gen/GetBeiDouAutonomousHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouAutonomousHealthForSV::CmdName = "GetBeiDouAutonomousHealthForSV";
    const char* const GetBeiDouAutonomousHealthForSV::Documentation = "Get BeiDou satellite autonomous health";

    REGISTER_COMMAND_FACTORY(GetBeiDouAutonomousHealthForSV);


    GetBeiDouAutonomousHealthForSV::GetBeiDouAutonomousHealthForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouAutonomousHealthForSV::GetBeiDouAutonomousHealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetBeiDouAutonomousHealthForSVPtr GetBeiDouAutonomousHealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouAutonomousHealthForSV>(svId, dataSetName);
    }

    GetBeiDouAutonomousHealthForSVPtr GetBeiDouAutonomousHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouAutonomousHealthForSV>(ptr);
    }

    bool GetBeiDouAutonomousHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouAutonomousHealthForSV::documentation() const { return Documentation; }


    int GetBeiDouAutonomousHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouAutonomousHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouAutonomousHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouAutonomousHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouAutonomousHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouAutonomousHealthForSVResult
///
#include "gen/GetBeiDouAutonomousHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouAutonomousHealthForSVResult::CmdName = "GetBeiDouAutonomousHealthForSVResult";
    const char* const GetBeiDouAutonomousHealthForSVResult::Documentation = "Result of GetBeiDouAutonomousHealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouAutonomousHealthForSVResult);


    GetBeiDouAutonomousHealthForSVResult::GetBeiDouAutonomousHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouAutonomousHealthForSVResult::GetBeiDouAutonomousHealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetBeiDouAutonomousHealthForSVResultPtr GetBeiDouAutonomousHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouAutonomousHealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetBeiDouAutonomousHealthForSVResultPtr GetBeiDouAutonomousHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouAutonomousHealthForSVResult>(ptr);
    }

    bool GetBeiDouAutonomousHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouAutonomousHealthForSVResult::documentation() const { return Documentation; }


    int GetBeiDouAutonomousHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouAutonomousHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouAutonomousHealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetBeiDouAutonomousHealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouAutonomousHealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouAutonomousHealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouCNavHealthInfoForSV
///
#include "gen/SetBeiDouCNavHealthInfoForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouCNavHealthInfoForSV::CmdName = "SetBeiDouCNavHealthInfoForSV";
    const char* const SetBeiDouCNavHealthInfoForSV::Documentation = "Set BeiDou CNav satellite health info";

    REGISTER_COMMAND_FACTORY(SetBeiDouCNavHealthInfoForSV);


    SetBeiDouCNavHealthInfoForSV::SetBeiDouCNavHealthInfoForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouCNavHealthInfoForSV::SetBeiDouCNavHealthInfoForSV(int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetBeiDouCNavHealthInfoForSVPtr SetBeiDouCNavHealthInfoForSV::create(int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouCNavHealthInfoForSV>(svId, health, dataSetName);
    }

    SetBeiDouCNavHealthInfoForSVPtr SetBeiDouCNavHealthInfoForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouCNavHealthInfoForSV>(ptr);
    }

    bool SetBeiDouCNavHealthInfoForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouCNavHealthInfoForSV::documentation() const { return Documentation; }


    int SetBeiDouCNavHealthInfoForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouCNavHealthInfoForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouCNavHealthInfoForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouCNavHealthInfoForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetBeiDouCNavHealthInfoForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouCNavHealthInfoForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouCNavHealthInfoForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNavHealthInfoForSV
///
#include "gen/GetBeiDouCNavHealthInfoForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNavHealthInfoForSV::CmdName = "GetBeiDouCNavHealthInfoForSV";
    const char* const GetBeiDouCNavHealthInfoForSV::Documentation = "Get BeiDou CNav satellite health info";

    REGISTER_COMMAND_FACTORY(GetBeiDouCNavHealthInfoForSV);


    GetBeiDouCNavHealthInfoForSV::GetBeiDouCNavHealthInfoForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouCNavHealthInfoForSV::GetBeiDouCNavHealthInfoForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetBeiDouCNavHealthInfoForSVPtr GetBeiDouCNavHealthInfoForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouCNavHealthInfoForSV>(svId, dataSetName);
    }

    GetBeiDouCNavHealthInfoForSVPtr GetBeiDouCNavHealthInfoForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNavHealthInfoForSV>(ptr);
    }

    bool GetBeiDouCNavHealthInfoForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouCNavHealthInfoForSV::documentation() const { return Documentation; }


    int GetBeiDouCNavHealthInfoForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouCNavHealthInfoForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouCNavHealthInfoForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouCNavHealthInfoForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouCNavHealthInfoForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNavHealthInfoForSVResult
///
#include "gen/GetBeiDouCNavHealthInfoForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNavHealthInfoForSVResult::CmdName = "GetBeiDouCNavHealthInfoForSVResult";
    const char* const GetBeiDouCNavHealthInfoForSVResult::Documentation = "Result of GetBeiDouCNavHealthInfoForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouCNavHealthInfoForSVResult);


    GetBeiDouCNavHealthInfoForSVResult::GetBeiDouCNavHealthInfoForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouCNavHealthInfoForSVResult::GetBeiDouCNavHealthInfoForSVResult(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetBeiDouCNavHealthInfoForSVResultPtr GetBeiDouCNavHealthInfoForSVResult::create(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouCNavHealthInfoForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetBeiDouCNavHealthInfoForSVResultPtr GetBeiDouCNavHealthInfoForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNavHealthInfoForSVResult>(ptr);
    }

    bool GetBeiDouCNavHealthInfoForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouCNavHealthInfoForSVResult::documentation() const { return Documentation; }


    int GetBeiDouCNavHealthInfoForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouCNavHealthInfoForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouCNavHealthInfoForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetBeiDouCNavHealthInfoForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouCNavHealthInfoForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouCNavHealthInfoForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouHealthStatusForSV
///
#include "gen/SetBeiDouHealthStatusForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouHealthStatusForSV::CmdName = "SetBeiDouHealthStatusForSV";
    const char* const SetBeiDouHealthStatusForSV::Documentation = "Set BeiDou satellite health status";

    REGISTER_COMMAND_FACTORY(SetBeiDouHealthStatusForSV);


    SetBeiDouHealthStatusForSV::SetBeiDouHealthStatusForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouHealthStatusForSV::SetBeiDouHealthStatusForSV(int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetBeiDouHealthStatusForSVPtr SetBeiDouHealthStatusForSV::create(int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouHealthStatusForSV>(svId, health, dataSetName);
    }

    SetBeiDouHealthStatusForSVPtr SetBeiDouHealthStatusForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouHealthStatusForSV>(ptr);
    }

    bool SetBeiDouHealthStatusForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouHealthStatusForSV::documentation() const { return Documentation; }


    int SetBeiDouHealthStatusForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouHealthStatusForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouHealthStatusForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouHealthStatusForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetBeiDouHealthStatusForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouHealthStatusForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouHealthStatusForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouHealthStatusForSV
///
#include "gen/GetBeiDouHealthStatusForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouHealthStatusForSV::CmdName = "GetBeiDouHealthStatusForSV";
    const char* const GetBeiDouHealthStatusForSV::Documentation = "Get BeiDou satellite health status";

    REGISTER_COMMAND_FACTORY(GetBeiDouHealthStatusForSV);


    GetBeiDouHealthStatusForSV::GetBeiDouHealthStatusForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouHealthStatusForSV::GetBeiDouHealthStatusForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetBeiDouHealthStatusForSVPtr GetBeiDouHealthStatusForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouHealthStatusForSV>(svId, dataSetName);
    }

    GetBeiDouHealthStatusForSVPtr GetBeiDouHealthStatusForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouHealthStatusForSV>(ptr);
    }

    bool GetBeiDouHealthStatusForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouHealthStatusForSV::documentation() const { return Documentation; }


    int GetBeiDouHealthStatusForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouHealthStatusForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouHealthStatusForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouHealthStatusForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouHealthStatusForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouHealthStatusForSVResult
///
#include "gen/GetBeiDouHealthStatusForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouHealthStatusForSVResult::CmdName = "GetBeiDouHealthStatusForSVResult";
    const char* const GetBeiDouHealthStatusForSVResult::Documentation = "Result of GetBeiDouHealthStatusForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouHealthStatusForSVResult);


    GetBeiDouHealthStatusForSVResult::GetBeiDouHealthStatusForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouHealthStatusForSVResult::GetBeiDouHealthStatusForSVResult(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetBeiDouHealthStatusForSVResultPtr GetBeiDouHealthStatusForSVResult::create(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouHealthStatusForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetBeiDouHealthStatusForSVResultPtr GetBeiDouHealthStatusForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouHealthStatusForSVResult>(ptr);
    }

    bool GetBeiDouHealthStatusForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouHealthStatusForSVResult::documentation() const { return Documentation; }


    int GetBeiDouHealthStatusForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouHealthStatusForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouHealthStatusForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetBeiDouHealthStatusForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouHealthStatusForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouHealthStatusForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassEphemerisHealthFlagForSV
///
#include "gen/SetGlonassEphemerisHealthFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassEphemerisHealthFlagForSV::CmdName = "SetGlonassEphemerisHealthFlagForSV";
    const char* const SetGlonassEphemerisHealthFlagForSV::Documentation = "Set GLONASS satellite Ephemeris Health Flag Bn(ln)";

    REGISTER_COMMAND_FACTORY(SetGlonassEphemerisHealthFlagForSV);


    SetGlonassEphemerisHealthFlagForSV::SetGlonassEphemerisHealthFlagForSV()
      : CommandBase(CmdName)
    {}

    SetGlonassEphemerisHealthFlagForSV::SetGlonassEphemerisHealthFlagForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGlonassEphemerisHealthFlagForSVPtr SetGlonassEphemerisHealthFlagForSV::create(int svId, bool health)
    {
      return std::make_shared<SetGlonassEphemerisHealthFlagForSV>(svId, health);
    }

    SetGlonassEphemerisHealthFlagForSVPtr SetGlonassEphemerisHealthFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassEphemerisHealthFlagForSV>(ptr);
    }

    bool SetGlonassEphemerisHealthFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGlonassEphemerisHealthFlagForSV::documentation() const { return Documentation; }


    int SetGlonassEphemerisHealthFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGlonassEphemerisHealthFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGlonassEphemerisHealthFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGlonassEphemerisHealthFlagForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGlonassEphemerisHealthFlagForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphemerisHealthFlagForSV
///
#include "gen/GetGlonassEphemerisHealthFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphemerisHealthFlagForSV::CmdName = "GetGlonassEphemerisHealthFlagForSV";
    const char* const GetGlonassEphemerisHealthFlagForSV::Documentation = "Get GLONASS satellite Ephemeris Health Flag Bn(ln)";

    REGISTER_COMMAND_FACTORY(GetGlonassEphemerisHealthFlagForSV);


    GetGlonassEphemerisHealthFlagForSV::GetGlonassEphemerisHealthFlagForSV()
      : CommandBase(CmdName)
    {}

    GetGlonassEphemerisHealthFlagForSV::GetGlonassEphemerisHealthFlagForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGlonassEphemerisHealthFlagForSVPtr GetGlonassEphemerisHealthFlagForSV::create(int svId)
    {
      return std::make_shared<GetGlonassEphemerisHealthFlagForSV>(svId);
    }

    GetGlonassEphemerisHealthFlagForSVPtr GetGlonassEphemerisHealthFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphemerisHealthFlagForSV>(ptr);
    }

    bool GetGlonassEphemerisHealthFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGlonassEphemerisHealthFlagForSV::documentation() const { return Documentation; }


    int GetGlonassEphemerisHealthFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassEphemerisHealthFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassEphemerisHealthFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphemerisHealthFlagForSVResult
///
#include "gen/GetGlonassEphemerisHealthFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphemerisHealthFlagForSVResult::CmdName = "GetGlonassEphemerisHealthFlagForSVResult";
    const char* const GetGlonassEphemerisHealthFlagForSVResult::Documentation = "Result of GetGlonassEphemerisHealthFlagForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassEphemerisHealthFlagForSVResult);


    GetGlonassEphemerisHealthFlagForSVResult::GetGlonassEphemerisHealthFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetGlonassEphemerisHealthFlagForSVResult::GetGlonassEphemerisHealthFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGlonassEphemerisHealthFlagForSVResultPtr GetGlonassEphemerisHealthFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return std::make_shared<GetGlonassEphemerisHealthFlagForSVResult>(relatedCommand, svId, health);
    }

    GetGlonassEphemerisHealthFlagForSVResultPtr GetGlonassEphemerisHealthFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphemerisHealthFlagForSVResult>(ptr);
    }

    bool GetGlonassEphemerisHealthFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGlonassEphemerisHealthFlagForSVResult::documentation() const { return Documentation; }


    int GetGlonassEphemerisHealthFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassEphemerisHealthFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGlonassEphemerisHealthFlagForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGlonassEphemerisHealthFlagForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassAlmanacUnhealthyFlagForSV
///
#include "gen/SetGlonassAlmanacUnhealthyFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassAlmanacUnhealthyFlagForSV::CmdName = "SetGlonassAlmanacUnhealthyFlagForSV";
    const char* const SetGlonassAlmanacUnhealthyFlagForSV::Documentation = "Set GLONASS satellite Almanac Unhealthy Flag Cn";

    REGISTER_COMMAND_FACTORY(SetGlonassAlmanacUnhealthyFlagForSV);


    SetGlonassAlmanacUnhealthyFlagForSV::SetGlonassAlmanacUnhealthyFlagForSV()
      : CommandBase(CmdName)
    {}

    SetGlonassAlmanacUnhealthyFlagForSV::SetGlonassAlmanacUnhealthyFlagForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGlonassAlmanacUnhealthyFlagForSVPtr SetGlonassAlmanacUnhealthyFlagForSV::create(int svId, bool health)
    {
      return std::make_shared<SetGlonassAlmanacUnhealthyFlagForSV>(svId, health);
    }

    SetGlonassAlmanacUnhealthyFlagForSVPtr SetGlonassAlmanacUnhealthyFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassAlmanacUnhealthyFlagForSV>(ptr);
    }

    bool SetGlonassAlmanacUnhealthyFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGlonassAlmanacUnhealthyFlagForSV::documentation() const { return Documentation; }


    int SetGlonassAlmanacUnhealthyFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGlonassAlmanacUnhealthyFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGlonassAlmanacUnhealthyFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGlonassAlmanacUnhealthyFlagForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGlonassAlmanacUnhealthyFlagForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassAlmanacUnhealthyFlagForSV
///
#include "gen/GetGlonassAlmanacUnhealthyFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassAlmanacUnhealthyFlagForSV::CmdName = "GetGlonassAlmanacUnhealthyFlagForSV";
    const char* const GetGlonassAlmanacUnhealthyFlagForSV::Documentation = "Get GLONASS satellite Almanac Unhealthy Flag Cn";

    REGISTER_COMMAND_FACTORY(GetGlonassAlmanacUnhealthyFlagForSV);


    GetGlonassAlmanacUnhealthyFlagForSV::GetGlonassAlmanacUnhealthyFlagForSV()
      : CommandBase(CmdName)
    {}

    GetGlonassAlmanacUnhealthyFlagForSV::GetGlonassAlmanacUnhealthyFlagForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGlonassAlmanacUnhealthyFlagForSVPtr GetGlonassAlmanacUnhealthyFlagForSV::create(int svId)
    {
      return std::make_shared<GetGlonassAlmanacUnhealthyFlagForSV>(svId);
    }

    GetGlonassAlmanacUnhealthyFlagForSVPtr GetGlonassAlmanacUnhealthyFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassAlmanacUnhealthyFlagForSV>(ptr);
    }

    bool GetGlonassAlmanacUnhealthyFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGlonassAlmanacUnhealthyFlagForSV::documentation() const { return Documentation; }


    int GetGlonassAlmanacUnhealthyFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassAlmanacUnhealthyFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassAlmanacUnhealthyFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassAlmanacUnhealthyFlagForSVResult
///
#include "gen/GetGlonassAlmanacUnhealthyFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassAlmanacUnhealthyFlagForSVResult::CmdName = "GetGlonassAlmanacUnhealthyFlagForSVResult";
    const char* const GetGlonassAlmanacUnhealthyFlagForSVResult::Documentation = "Result of GetGlonassAlmanacUnhealthyFlagForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassAlmanacUnhealthyFlagForSVResult);


    GetGlonassAlmanacUnhealthyFlagForSVResult::GetGlonassAlmanacUnhealthyFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetGlonassAlmanacUnhealthyFlagForSVResult::GetGlonassAlmanacUnhealthyFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGlonassAlmanacUnhealthyFlagForSVResultPtr GetGlonassAlmanacUnhealthyFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return std::make_shared<GetGlonassAlmanacUnhealthyFlagForSVResult>(relatedCommand, svId, health);
    }

    GetGlonassAlmanacUnhealthyFlagForSVResultPtr GetGlonassAlmanacUnhealthyFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassAlmanacUnhealthyFlagForSVResult>(ptr);
    }

    bool GetGlonassAlmanacUnhealthyFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGlonassAlmanacUnhealthyFlagForSVResult::documentation() const { return Documentation; }


    int GetGlonassAlmanacUnhealthyFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassAlmanacUnhealthyFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGlonassAlmanacUnhealthyFlagForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGlonassAlmanacUnhealthyFlagForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL1DataHealthForSV
///
#include "gen/SetQzssL1DataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL1DataHealthForSV::CmdName = "SetQzssL1DataHealthForSV";
    const char* const SetQzssL1DataHealthForSV::Documentation = "Set QZSS L1 C/A nav data health";

    REGISTER_COMMAND_FACTORY(SetQzssL1DataHealthForSV);


    SetQzssL1DataHealthForSV::SetQzssL1DataHealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL1DataHealthForSV::SetQzssL1DataHealthForSV(int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssL1DataHealthForSVPtr SetQzssL1DataHealthForSV::create(int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssL1DataHealthForSV>(svId, health, dataSetName);
    }

    SetQzssL1DataHealthForSVPtr SetQzssL1DataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL1DataHealthForSV>(ptr);
    }

    bool SetQzssL1DataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssL1DataHealthForSV::documentation() const { return Documentation; }


    int SetQzssL1DataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL1DataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL1DataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssL1DataHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetQzssL1DataHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssL1DataHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssL1DataHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL1DataHealth
///
#include "gen/SetQzssSatelliteL1DataHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL1DataHealth::CmdName = "SetQzssSatelliteL1DataHealth";
    const char* const SetQzssSatelliteL1DataHealth::Documentation = "Please note the command SetQzssSatelliteL1DataHealth is deprecated since 21.3. You may use SetQzssL1DataHealthForSV.\n\nSet QZSS L1 C/A nav data health";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL1DataHealth);


    SetQzssSatelliteL1DataHealth::SetQzssSatelliteL1DataHealth()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL1DataHealth::SetQzssSatelliteL1DataHealth(int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssSatelliteL1DataHealthPtr SetQzssSatelliteL1DataHealth::create(int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssSatelliteL1DataHealth>(svId, health, dataSetName);
    }

    SetQzssSatelliteL1DataHealthPtr SetQzssSatelliteL1DataHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL1DataHealth>(ptr);
    }

    bool SetQzssSatelliteL1DataHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssSatelliteL1DataHealth::documentation() const { return Documentation; }


    int SetQzssSatelliteL1DataHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL1DataHealth::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL1DataHealth::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssSatelliteL1DataHealth::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL1DataHealth::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssSatelliteL1DataHealth::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssSatelliteL1DataHealth::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1DataHealthForSV
///
#include "gen/GetQzssL1DataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1DataHealthForSV::CmdName = "GetQzssL1DataHealthForSV";
    const char* const GetQzssL1DataHealthForSV::Documentation = "Get QZSS L1 C/A nav data health";

    REGISTER_COMMAND_FACTORY(GetQzssL1DataHealthForSV);


    GetQzssL1DataHealthForSV::GetQzssL1DataHealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL1DataHealthForSV::GetQzssL1DataHealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssL1DataHealthForSVPtr GetQzssL1DataHealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL1DataHealthForSV>(svId, dataSetName);
    }

    GetQzssL1DataHealthForSVPtr GetQzssL1DataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1DataHealthForSV>(ptr);
    }

    bool GetQzssL1DataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL1DataHealthForSV::documentation() const { return Documentation; }


    int GetQzssL1DataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL1DataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1DataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL1DataHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL1DataHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL1DataHealth
///
#include "gen/GetQzssSatelliteL1DataHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL1DataHealth::CmdName = "GetQzssSatelliteL1DataHealth";
    const char* const GetQzssSatelliteL1DataHealth::Documentation = "Please note the command GetQzssSatelliteL1DataHealth is deprecated since 21.3. You may use GetQzssL1DataHealthForSV.\n\nGet QZSS L1 C/A nav data health";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL1DataHealth);


    GetQzssSatelliteL1DataHealth::GetQzssSatelliteL1DataHealth()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL1DataHealth::GetQzssSatelliteL1DataHealth(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssSatelliteL1DataHealthPtr GetQzssSatelliteL1DataHealth::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssSatelliteL1DataHealth>(svId, dataSetName);
    }

    GetQzssSatelliteL1DataHealthPtr GetQzssSatelliteL1DataHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL1DataHealth>(ptr);
    }

    bool GetQzssSatelliteL1DataHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssSatelliteL1DataHealth::documentation() const { return Documentation; }


    int GetQzssSatelliteL1DataHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL1DataHealth::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL1DataHealth::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssSatelliteL1DataHealth::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssSatelliteL1DataHealth::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1DataHealthForSVResult
///
#include "gen/GetQzssL1DataHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1DataHealthForSVResult::CmdName = "GetQzssL1DataHealthForSVResult";
    const char* const GetQzssL1DataHealthForSVResult::Documentation = "Result of GetQzssL1DataHealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1DataHealthForSVResult);


    GetQzssL1DataHealthForSVResult::GetQzssL1DataHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1DataHealthForSVResult::GetQzssL1DataHealthForSVResult(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetQzssL1DataHealthForSVResultPtr GetQzssL1DataHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, int health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL1DataHealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetQzssL1DataHealthForSVResultPtr GetQzssL1DataHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1DataHealthForSVResult>(ptr);
    }

    bool GetQzssL1DataHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL1DataHealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL1DataHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1DataHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssL1DataHealthForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetQzssL1DataHealthForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL1DataHealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL1DataHealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL1HealthForSV
///
#include "gen/SetQzssL1HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL1HealthForSV::CmdName = "SetQzssL1HealthForSV";
    const char* const SetQzssL1HealthForSV::Documentation = "Set QZSS L1 health (Health of L1C/A signal)";

    REGISTER_COMMAND_FACTORY(SetQzssL1HealthForSV);


    SetQzssL1HealthForSV::SetQzssL1HealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL1HealthForSV::SetQzssL1HealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssL1HealthForSVPtr SetQzssL1HealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssL1HealthForSV>(svId, health, dataSetName);
    }

    SetQzssL1HealthForSVPtr SetQzssL1HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL1HealthForSV>(ptr);
    }

    bool SetQzssL1HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssL1HealthForSV::documentation() const { return Documentation; }


    int SetQzssL1HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL1HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL1HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL1HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssL1HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssL1HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssL1HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL1Health
///
#include "gen/SetQzssSatelliteL1Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL1Health::CmdName = "SetQzssSatelliteL1Health";
    const char* const SetQzssSatelliteL1Health::Documentation = "Please note the command SetQzssSatelliteL1Health is deprecated since 21.3. You may use SetQzssL1HealthForSV.\n\nSet QZSS L1 health (Health of L1C/A signal)";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL1Health);


    SetQzssSatelliteL1Health::SetQzssSatelliteL1Health()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL1Health::SetQzssSatelliteL1Health(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssSatelliteL1HealthPtr SetQzssSatelliteL1Health::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssSatelliteL1Health>(svId, health, dataSetName);
    }

    SetQzssSatelliteL1HealthPtr SetQzssSatelliteL1Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL1Health>(ptr);
    }

    bool SetQzssSatelliteL1Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssSatelliteL1Health::documentation() const { return Documentation; }


    int SetQzssSatelliteL1Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL1Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL1Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteL1Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL1Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssSatelliteL1Health::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssSatelliteL1Health::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1HealthForSV
///
#include "gen/GetQzssL1HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1HealthForSV::CmdName = "GetQzssL1HealthForSV";
    const char* const GetQzssL1HealthForSV::Documentation = "Get QZSS L1 health (Health of L1C/A signal)";

    REGISTER_COMMAND_FACTORY(GetQzssL1HealthForSV);


    GetQzssL1HealthForSV::GetQzssL1HealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL1HealthForSV::GetQzssL1HealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssL1HealthForSVPtr GetQzssL1HealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL1HealthForSV>(svId, dataSetName);
    }

    GetQzssL1HealthForSVPtr GetQzssL1HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1HealthForSV>(ptr);
    }

    bool GetQzssL1HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL1HealthForSV::documentation() const { return Documentation; }


    int GetQzssL1HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL1HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL1HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL1HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL1Health
///
#include "gen/GetQzssSatelliteL1Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL1Health::CmdName = "GetQzssSatelliteL1Health";
    const char* const GetQzssSatelliteL1Health::Documentation = "Please note the command GetQzssSatelliteL1Health is deprecated since 21.3. You may use GetQzssL1HealthForSV.\n\nGet QZSS L1 health (Health of L1C/A signal)";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL1Health);


    GetQzssSatelliteL1Health::GetQzssSatelliteL1Health()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL1Health::GetQzssSatelliteL1Health(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssSatelliteL1HealthPtr GetQzssSatelliteL1Health::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssSatelliteL1Health>(svId, dataSetName);
    }

    GetQzssSatelliteL1HealthPtr GetQzssSatelliteL1Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL1Health>(ptr);
    }

    bool GetQzssSatelliteL1Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssSatelliteL1Health::documentation() const { return Documentation; }


    int GetQzssSatelliteL1Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL1Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL1Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssSatelliteL1Health::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssSatelliteL1Health::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1HealthForSVResult
///
#include "gen/GetQzssL1HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1HealthForSVResult::CmdName = "GetQzssL1HealthForSVResult";
    const char* const GetQzssL1HealthForSVResult::Documentation = "Result of GetQzssL1HealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1HealthForSVResult);


    GetQzssL1HealthForSVResult::GetQzssL1HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1HealthForSVResult::GetQzssL1HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetQzssL1HealthForSVResultPtr GetQzssL1HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL1HealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetQzssL1HealthForSVResultPtr GetQzssL1HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1HealthForSVResult>(ptr);
    }

    bool GetQzssL1HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL1HealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL1HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL1HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetQzssL1HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL1HealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL1HealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL2HealthForSV
///
#include "gen/SetQzssL2HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL2HealthForSV::CmdName = "SetQzssL2HealthForSV";
    const char* const SetQzssL2HealthForSV::Documentation = "Set QZSS L2 health (Health of L2C signal)";

    REGISTER_COMMAND_FACTORY(SetQzssL2HealthForSV);


    SetQzssL2HealthForSV::SetQzssL2HealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL2HealthForSV::SetQzssL2HealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssL2HealthForSVPtr SetQzssL2HealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssL2HealthForSV>(svId, health, dataSetName);
    }

    SetQzssL2HealthForSVPtr SetQzssL2HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL2HealthForSV>(ptr);
    }

    bool SetQzssL2HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssL2HealthForSV::documentation() const { return Documentation; }


    int SetQzssL2HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL2HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL2HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL2HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssL2HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssL2HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssL2HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL2Health
///
#include "gen/SetQzssSatelliteL2Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL2Health::CmdName = "SetQzssSatelliteL2Health";
    const char* const SetQzssSatelliteL2Health::Documentation = "Please note the command SetQzssSatelliteL2Health is deprecated since 21.3. You may use SetQzssL2HealthForSV.\n\nSet QZSS L2 health (Health of L2C signal)";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL2Health);


    SetQzssSatelliteL2Health::SetQzssSatelliteL2Health()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL2Health::SetQzssSatelliteL2Health(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssSatelliteL2HealthPtr SetQzssSatelliteL2Health::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssSatelliteL2Health>(svId, health, dataSetName);
    }

    SetQzssSatelliteL2HealthPtr SetQzssSatelliteL2Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL2Health>(ptr);
    }

    bool SetQzssSatelliteL2Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssSatelliteL2Health::documentation() const { return Documentation; }


    int SetQzssSatelliteL2Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL2Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL2Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteL2Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL2Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssSatelliteL2Health::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssSatelliteL2Health::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL2HealthForSV
///
#include "gen/GetQzssL2HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL2HealthForSV::CmdName = "GetQzssL2HealthForSV";
    const char* const GetQzssL2HealthForSV::Documentation = "Get QZSS L2 health (Health of L2C signal)";

    REGISTER_COMMAND_FACTORY(GetQzssL2HealthForSV);


    GetQzssL2HealthForSV::GetQzssL2HealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL2HealthForSV::GetQzssL2HealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssL2HealthForSVPtr GetQzssL2HealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL2HealthForSV>(svId, dataSetName);
    }

    GetQzssL2HealthForSVPtr GetQzssL2HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL2HealthForSV>(ptr);
    }

    bool GetQzssL2HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL2HealthForSV::documentation() const { return Documentation; }


    int GetQzssL2HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL2HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL2HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL2HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL2HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL2Health
///
#include "gen/GetQzssSatelliteL2Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL2Health::CmdName = "GetQzssSatelliteL2Health";
    const char* const GetQzssSatelliteL2Health::Documentation = "Please note the command GetQzssSatelliteL2Health is deprecated since 21.3. You may use GetQzssL2HealthForSV.\n\nGet QZSS L2 health (Health of L2C signal)";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL2Health);


    GetQzssSatelliteL2Health::GetQzssSatelliteL2Health()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL2Health::GetQzssSatelliteL2Health(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssSatelliteL2HealthPtr GetQzssSatelliteL2Health::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssSatelliteL2Health>(svId, dataSetName);
    }

    GetQzssSatelliteL2HealthPtr GetQzssSatelliteL2Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL2Health>(ptr);
    }

    bool GetQzssSatelliteL2Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssSatelliteL2Health::documentation() const { return Documentation; }


    int GetQzssSatelliteL2Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL2Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL2Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssSatelliteL2Health::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssSatelliteL2Health::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL2HealthForSVResult
///
#include "gen/GetQzssL2HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL2HealthForSVResult::CmdName = "GetQzssL2HealthForSVResult";
    const char* const GetQzssL2HealthForSVResult::Documentation = "Result of GetQzssL2HealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL2HealthForSVResult);


    GetQzssL2HealthForSVResult::GetQzssL2HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL2HealthForSVResult::GetQzssL2HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetQzssL2HealthForSVResultPtr GetQzssL2HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL2HealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetQzssL2HealthForSVResultPtr GetQzssL2HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL2HealthForSVResult>(ptr);
    }

    bool GetQzssL2HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL2HealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL2HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL2HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL2HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetQzssL2HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL2HealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL2HealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL5HealthForSV
///
#include "gen/SetQzssL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL5HealthForSV::CmdName = "SetQzssL5HealthForSV";
    const char* const SetQzssL5HealthForSV::Documentation = "Set QZSS L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(SetQzssL5HealthForSV);


    SetQzssL5HealthForSV::SetQzssL5HealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL5HealthForSV::SetQzssL5HealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssL5HealthForSVPtr SetQzssL5HealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssL5HealthForSV>(svId, health, dataSetName);
    }

    SetQzssL5HealthForSVPtr SetQzssL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL5HealthForSV>(ptr);
    }

    bool SetQzssL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssL5HealthForSV::documentation() const { return Documentation; }


    int SetQzssL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL5HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssL5HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssL5HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssL5HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL5Health
///
#include "gen/SetQzssSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL5Health::CmdName = "SetQzssSatelliteL5Health";
    const char* const SetQzssSatelliteL5Health::Documentation = "Please note the command SetQzssSatelliteL5Health is deprecated since 21.3. You may use SetQzssL5HealthForSV.\n\nSet QZSS L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL5Health);


    SetQzssSatelliteL5Health::SetQzssSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL5Health::SetQzssSatelliteL5Health(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssSatelliteL5HealthPtr SetQzssSatelliteL5Health::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssSatelliteL5Health>(svId, health, dataSetName);
    }

    SetQzssSatelliteL5HealthPtr SetQzssSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL5Health>(ptr);
    }

    bool SetQzssSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssSatelliteL5Health::documentation() const { return Documentation; }


    int SetQzssSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL5Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL5Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteL5Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL5Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssSatelliteL5Health::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssSatelliteL5Health::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL5HealthForSV
///
#include "gen/GetQzssL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL5HealthForSV::CmdName = "GetQzssL5HealthForSV";
    const char* const GetQzssL5HealthForSV::Documentation = "Get QZSS L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(GetQzssL5HealthForSV);


    GetQzssL5HealthForSV::GetQzssL5HealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL5HealthForSV::GetQzssL5HealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssL5HealthForSVPtr GetQzssL5HealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL5HealthForSV>(svId, dataSetName);
    }

    GetQzssL5HealthForSVPtr GetQzssL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL5HealthForSV>(ptr);
    }

    bool GetQzssL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL5HealthForSV::documentation() const { return Documentation; }


    int GetQzssL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL5HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL5HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL5Health
///
#include "gen/GetQzssSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL5Health::CmdName = "GetQzssSatelliteL5Health";
    const char* const GetQzssSatelliteL5Health::Documentation = "Please note the command GetQzssSatelliteL5Health is deprecated since 21.3. You may use GetQzssL5HealthForSV.\n\nGet QZSS L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL5Health);


    GetQzssSatelliteL5Health::GetQzssSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL5Health::GetQzssSatelliteL5Health(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssSatelliteL5HealthPtr GetQzssSatelliteL5Health::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssSatelliteL5Health>(svId, dataSetName);
    }

    GetQzssSatelliteL5HealthPtr GetQzssSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL5Health>(ptr);
    }

    bool GetQzssSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssSatelliteL5Health::documentation() const { return Documentation; }


    int GetQzssSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL5Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL5Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssSatelliteL5Health::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssSatelliteL5Health::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL5HealthForSVResult
///
#include "gen/GetQzssL5HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL5HealthForSVResult::CmdName = "GetQzssL5HealthForSVResult";
    const char* const GetQzssL5HealthForSVResult::Documentation = "Result of GetQzssL5HealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL5HealthForSVResult);


    GetQzssL5HealthForSVResult::GetQzssL5HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL5HealthForSVResult::GetQzssL5HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetQzssL5HealthForSVResultPtr GetQzssL5HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL5HealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetQzssL5HealthForSVResultPtr GetQzssL5HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL5HealthForSVResult>(ptr);
    }

    bool GetQzssL5HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL5HealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL5HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL5HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL5HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetQzssL5HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL5HealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL5HealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL1cHealthForSV
///
#include "gen/SetQzssL1cHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL1cHealthForSV::CmdName = "SetQzssL1cHealthForSV";
    const char* const SetQzssL1cHealthForSV::Documentation = "Set QZSS L1C health (Health of L1C signal)";

    REGISTER_COMMAND_FACTORY(SetQzssL1cHealthForSV);


    SetQzssL1cHealthForSV::SetQzssL1cHealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL1cHealthForSV::SetQzssL1cHealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssL1cHealthForSVPtr SetQzssL1cHealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssL1cHealthForSV>(svId, health, dataSetName);
    }

    SetQzssL1cHealthForSVPtr SetQzssL1cHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL1cHealthForSV>(ptr);
    }

    bool SetQzssL1cHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssL1cHealthForSV::documentation() const { return Documentation; }


    int SetQzssL1cHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL1cHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL1cHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL1cHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssL1cHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssL1cHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssL1cHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL1cHealth
///
#include "gen/SetQzssSatelliteL1cHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL1cHealth::CmdName = "SetQzssSatelliteL1cHealth";
    const char* const SetQzssSatelliteL1cHealth::Documentation = "Please note the command SetQzssSatelliteL1cHealth is deprecated since 21.3. You may use SetQzssL1cHealthForSV.\n\nSet QZSS L1C health (Health of L1C signal)";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL1cHealth);


    SetQzssSatelliteL1cHealth::SetQzssSatelliteL1cHealth()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL1cHealth::SetQzssSatelliteL1cHealth(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetQzssSatelliteL1cHealthPtr SetQzssSatelliteL1cHealth::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssSatelliteL1cHealth>(svId, health, dataSetName);
    }

    SetQzssSatelliteL1cHealthPtr SetQzssSatelliteL1cHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL1cHealth>(ptr);
    }

    bool SetQzssSatelliteL1cHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssSatelliteL1cHealth::documentation() const { return Documentation; }


    int SetQzssSatelliteL1cHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL1cHealth::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL1cHealth::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteL1cHealth::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL1cHealth::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssSatelliteL1cHealth::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssSatelliteL1cHealth::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1cHealthForSV
///
#include "gen/GetQzssL1cHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1cHealthForSV::CmdName = "GetQzssL1cHealthForSV";
    const char* const GetQzssL1cHealthForSV::Documentation = "Get QZSS L1C health (Health of L1C signal)";

    REGISTER_COMMAND_FACTORY(GetQzssL1cHealthForSV);


    GetQzssL1cHealthForSV::GetQzssL1cHealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL1cHealthForSV::GetQzssL1cHealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssL1cHealthForSVPtr GetQzssL1cHealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL1cHealthForSV>(svId, dataSetName);
    }

    GetQzssL1cHealthForSVPtr GetQzssL1cHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1cHealthForSV>(ptr);
    }

    bool GetQzssL1cHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL1cHealthForSV::documentation() const { return Documentation; }


    int GetQzssL1cHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL1cHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1cHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL1cHealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL1cHealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL1cHealth
///
#include "gen/GetQzssSatelliteL1cHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL1cHealth::CmdName = "GetQzssSatelliteL1cHealth";
    const char* const GetQzssSatelliteL1cHealth::Documentation = "Please note the command GetQzssSatelliteL1cHealth is deprecated since 21.3. You may use GetQzssL1cHealthForSV.\n\nGet QZSS L1C health (Health of L1C signal)";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL1cHealth);


    GetQzssSatelliteL1cHealth::GetQzssSatelliteL1cHealth()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL1cHealth::GetQzssSatelliteL1cHealth(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssSatelliteL1cHealthPtr GetQzssSatelliteL1cHealth::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssSatelliteL1cHealth>(svId, dataSetName);
    }

    GetQzssSatelliteL1cHealthPtr GetQzssSatelliteL1cHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL1cHealth>(ptr);
    }

    bool GetQzssSatelliteL1cHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssSatelliteL1cHealth::documentation() const { return Documentation; }


    int GetQzssSatelliteL1cHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL1cHealth::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL1cHealth::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssSatelliteL1cHealth::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssSatelliteL1cHealth::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1cHealthForSVResult
///
#include "gen/GetQzssL1cHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1cHealthForSVResult::CmdName = "GetQzssL1cHealthForSVResult";
    const char* const GetQzssL1cHealthForSVResult::Documentation = "Result of GetQzssL1cHealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1cHealthForSVResult);


    GetQzssL1cHealthForSVResult::GetQzssL1cHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1cHealthForSVResult::GetQzssL1cHealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetQzssL1cHealthForSVResultPtr GetQzssL1cHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssL1cHealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetQzssL1cHealthForSVResultPtr GetQzssL1cHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1cHealthForSVResult>(ptr);
    }

    bool GetQzssL1cHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssL1cHealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL1cHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1cHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL1cHealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetQzssL1cHealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssL1cHealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssL1cHealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssNavAlertFlagForSV
///
#include "gen/SetQzssNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssNavAlertFlagForSV::CmdName = "SetQzssNavAlertFlagForSV";
    const char* const SetQzssNavAlertFlagForSV::Documentation = "Set QZSS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetQzssNavAlertFlagForSV);


    SetQzssNavAlertFlagForSV::SetQzssNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    SetQzssNavAlertFlagForSV::SetQzssNavAlertFlagForSV(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    SetQzssNavAlertFlagForSVPtr SetQzssNavAlertFlagForSV::create(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssNavAlertFlagForSV>(svId, alert, dataSetName);
    }

    SetQzssNavAlertFlagForSVPtr SetQzssNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssNavAlertFlagForSV>(ptr);
    }

    bool SetQzssNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssNavAlertFlagForSV::documentation() const { return Documentation; }


    int SetQzssNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssNavAlertFlagForSV::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetQzssNavAlertFlagForSV::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssNavAlertFlagForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssNavAlertFlagForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteNavAlertFlag
///
#include "gen/SetQzssSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteNavAlertFlag::CmdName = "SetQzssSatelliteNavAlertFlag";
    const char* const SetQzssSatelliteNavAlertFlag::Documentation = "Please note the command SetQzssSatelliteNavAlertFlag is deprecated since 21.3. You may use SetQzssNavAlertFlagForSV.\n\nSet QZSS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteNavAlertFlag);


    SetQzssSatelliteNavAlertFlag::SetQzssSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteNavAlertFlag::SetQzssSatelliteNavAlertFlag(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    SetQzssSatelliteNavAlertFlagPtr SetQzssSatelliteNavAlertFlag::create(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssSatelliteNavAlertFlag>(svId, alert, dataSetName);
    }

    SetQzssSatelliteNavAlertFlagPtr SetQzssSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteNavAlertFlag>(ptr);
    }

    bool SetQzssSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int SetQzssSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteNavAlertFlag::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteNavAlertFlag::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteNavAlertFlag::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetQzssSatelliteNavAlertFlag::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssSatelliteNavAlertFlag::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssSatelliteNavAlertFlag::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssNavAlertFlagForSV
///
#include "gen/GetQzssNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssNavAlertFlagForSV::CmdName = "GetQzssNavAlertFlagForSV";
    const char* const GetQzssNavAlertFlagForSV::Documentation = "Get QZSS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetQzssNavAlertFlagForSV);


    GetQzssNavAlertFlagForSV::GetQzssNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    GetQzssNavAlertFlagForSV::GetQzssNavAlertFlagForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssNavAlertFlagForSVPtr GetQzssNavAlertFlagForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssNavAlertFlagForSV>(svId, dataSetName);
    }

    GetQzssNavAlertFlagForSVPtr GetQzssNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssNavAlertFlagForSV>(ptr);
    }

    bool GetQzssNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssNavAlertFlagForSV::documentation() const { return Documentation; }


    int GetQzssNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssNavAlertFlagForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssNavAlertFlagForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteNavAlertFlag
///
#include "gen/GetQzssSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteNavAlertFlag::CmdName = "GetQzssSatelliteNavAlertFlag";
    const char* const GetQzssSatelliteNavAlertFlag::Documentation = "Please note the command GetQzssSatelliteNavAlertFlag is deprecated since 21.3. You may use GetQzssNavAlertFlagForSV.\n\nGet QZSS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteNavAlertFlag);


    GetQzssSatelliteNavAlertFlag::GetQzssSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteNavAlertFlag::GetQzssSatelliteNavAlertFlag(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetQzssSatelliteNavAlertFlagPtr GetQzssSatelliteNavAlertFlag::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssSatelliteNavAlertFlag>(svId, dataSetName);
    }

    GetQzssSatelliteNavAlertFlagPtr GetQzssSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteNavAlertFlag>(ptr);
    }

    bool GetQzssSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int GetQzssSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteNavAlertFlag::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteNavAlertFlag::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssSatelliteNavAlertFlag::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssSatelliteNavAlertFlag::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssNavAlertFlagForSVResult
///
#include "gen/GetQzssNavAlertFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssNavAlertFlagForSVResult::CmdName = "GetQzssNavAlertFlagForSVResult";
    const char* const GetQzssNavAlertFlagForSVResult::Documentation = "Result of GetQzssNavAlertFlagForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssNavAlertFlagForSVResult);


    GetQzssNavAlertFlagForSVResult::GetQzssNavAlertFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssNavAlertFlagForSVResult::GetQzssNavAlertFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    GetQzssNavAlertFlagForSVResultPtr GetQzssNavAlertFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssNavAlertFlagForSVResult>(relatedCommand, svId, alert, dataSetName);
    }

    GetQzssNavAlertFlagForSVResultPtr GetQzssNavAlertFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssNavAlertFlagForSVResult>(ptr);
    }

    bool GetQzssNavAlertFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssNavAlertFlagForSVResult::documentation() const { return Documentation; }


    int GetQzssNavAlertFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssNavAlertFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssNavAlertFlagForSVResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetQzssNavAlertFlagForSVResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssNavAlertFlagForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssNavAlertFlagForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICL5HealthForSV
///
#include "gen/SetNavICL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICL5HealthForSV::CmdName = "SetNavICL5HealthForSV";
    const char* const SetNavICL5HealthForSV::Documentation = "Set NavIC L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(SetNavICL5HealthForSV);


    SetNavICL5HealthForSV::SetNavICL5HealthForSV()
      : CommandBase(CmdName)
    {}

    SetNavICL5HealthForSV::SetNavICL5HealthForSV(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetNavICL5HealthForSVPtr SetNavICL5HealthForSV::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICL5HealthForSV>(svId, health, dataSetName);
    }

    SetNavICL5HealthForSVPtr SetNavICL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICL5HealthForSV>(ptr);
    }

    bool SetNavICL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICL5HealthForSV::documentation() const { return Documentation; }


    int SetNavICL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetNavICL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetNavICL5HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetNavICL5HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICL5HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICL5HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICSatelliteL5Health
///
#include "gen/SetNavICSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICSatelliteL5Health::CmdName = "SetNavICSatelliteL5Health";
    const char* const SetNavICSatelliteL5Health::Documentation = "Please note the command SetNavICSatelliteL5Health is deprecated since 21.3. You may use SetNavICL5HealthForSV.\n\nSet NavIC L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(SetNavICSatelliteL5Health);


    SetNavICSatelliteL5Health::SetNavICSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    SetNavICSatelliteL5Health::SetNavICSatelliteL5Health(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    SetNavICSatelliteL5HealthPtr SetNavICSatelliteL5Health::create(int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICSatelliteL5Health>(svId, health, dataSetName);
    }

    SetNavICSatelliteL5HealthPtr SetNavICSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICSatelliteL5Health>(ptr);
    }

    bool SetNavICSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICSatelliteL5Health::documentation() const { return Documentation; }


    int SetNavICSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetNavICSatelliteL5Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICSatelliteL5Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetNavICSatelliteL5Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetNavICSatelliteL5Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICSatelliteL5Health::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICSatelliteL5Health::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICL5HealthForSV
///
#include "gen/GetNavICL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICL5HealthForSV::CmdName = "GetNavICL5HealthForSV";
    const char* const GetNavICL5HealthForSV::Documentation = "Get NavIC L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(GetNavICL5HealthForSV);


    GetNavICL5HealthForSV::GetNavICL5HealthForSV()
      : CommandBase(CmdName)
    {}

    GetNavICL5HealthForSV::GetNavICL5HealthForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetNavICL5HealthForSVPtr GetNavICL5HealthForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICL5HealthForSV>(svId, dataSetName);
    }

    GetNavICL5HealthForSVPtr GetNavICL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICL5HealthForSV>(ptr);
    }

    bool GetNavICL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICL5HealthForSV::documentation() const { return Documentation; }


    int GetNavICL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICL5HealthForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICL5HealthForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICSatelliteL5Health
///
#include "gen/GetNavICSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICSatelliteL5Health::CmdName = "GetNavICSatelliteL5Health";
    const char* const GetNavICSatelliteL5Health::Documentation = "Please note the command GetNavICSatelliteL5Health is deprecated since 21.3. You may use GetNavICL5HealthForSV.\n\nGet NavIC L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(GetNavICSatelliteL5Health);


    GetNavICSatelliteL5Health::GetNavICSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    GetNavICSatelliteL5Health::GetNavICSatelliteL5Health(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetNavICSatelliteL5HealthPtr GetNavICSatelliteL5Health::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICSatelliteL5Health>(svId, dataSetName);
    }

    GetNavICSatelliteL5HealthPtr GetNavICSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICSatelliteL5Health>(ptr);
    }

    bool GetNavICSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICSatelliteL5Health::documentation() const { return Documentation; }


    int GetNavICSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICSatelliteL5Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICSatelliteL5Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICSatelliteL5Health::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICSatelliteL5Health::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICL5HealthForSVResult
///
#include "gen/GetNavICL5HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICL5HealthForSVResult::CmdName = "GetNavICL5HealthForSVResult";
    const char* const GetNavICL5HealthForSVResult::Documentation = "Result of GetNavICL5HealthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetNavICL5HealthForSVResult);


    GetNavICL5HealthForSVResult::GetNavICL5HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetNavICL5HealthForSVResult::GetNavICL5HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
      setDataSetName(dataSetName);
    }


    GetNavICL5HealthForSVResultPtr GetNavICL5HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICL5HealthForSVResult>(relatedCommand, svId, health, dataSetName);
    }

    GetNavICL5HealthForSVResultPtr GetNavICL5HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICL5HealthForSVResult>(ptr);
    }

    bool GetNavICL5HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICL5HealthForSVResult::documentation() const { return Documentation; }


    int GetNavICL5HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICL5HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetNavICL5HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetNavICL5HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICL5HealthForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICL5HealthForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICNavAlertFlagForSV
///
#include "gen/SetNavICNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICNavAlertFlagForSV::CmdName = "SetNavICNavAlertFlagForSV";
    const char* const SetNavICNavAlertFlagForSV::Documentation = "Set NavIC NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetNavICNavAlertFlagForSV);


    SetNavICNavAlertFlagForSV::SetNavICNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    SetNavICNavAlertFlagForSV::SetNavICNavAlertFlagForSV(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    SetNavICNavAlertFlagForSVPtr SetNavICNavAlertFlagForSV::create(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICNavAlertFlagForSV>(svId, alert, dataSetName);
    }

    SetNavICNavAlertFlagForSVPtr SetNavICNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICNavAlertFlagForSV>(ptr);
    }

    bool SetNavICNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICNavAlertFlagForSV::documentation() const { return Documentation; }


    int SetNavICNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetNavICNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetNavICNavAlertFlagForSV::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetNavICNavAlertFlagForSV::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICNavAlertFlagForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICNavAlertFlagForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICSatelliteNavAlertFlag
///
#include "gen/SetNavICSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICSatelliteNavAlertFlag::CmdName = "SetNavICSatelliteNavAlertFlag";
    const char* const SetNavICSatelliteNavAlertFlag::Documentation = "Please note the command SetNavICSatelliteNavAlertFlag is deprecated since 21.3. You may use SetNavICNavAlertFlagForSV.\n\nSet NavIC NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetNavICSatelliteNavAlertFlag);


    SetNavICSatelliteNavAlertFlag::SetNavICSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    SetNavICSatelliteNavAlertFlag::SetNavICSatelliteNavAlertFlag(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    SetNavICSatelliteNavAlertFlagPtr SetNavICSatelliteNavAlertFlag::create(int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICSatelliteNavAlertFlag>(svId, alert, dataSetName);
    }

    SetNavICSatelliteNavAlertFlagPtr SetNavICSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICSatelliteNavAlertFlag>(ptr);
    }

    bool SetNavICSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int SetNavICSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetNavICSatelliteNavAlertFlag::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICSatelliteNavAlertFlag::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetNavICSatelliteNavAlertFlag::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetNavICSatelliteNavAlertFlag::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICSatelliteNavAlertFlag::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICSatelliteNavAlertFlag::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICNavAlertFlagForSV
///
#include "gen/GetNavICNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICNavAlertFlagForSV::CmdName = "GetNavICNavAlertFlagForSV";
    const char* const GetNavICNavAlertFlagForSV::Documentation = "Get NavIC NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetNavICNavAlertFlagForSV);


    GetNavICNavAlertFlagForSV::GetNavICNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    GetNavICNavAlertFlagForSV::GetNavICNavAlertFlagForSV(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetNavICNavAlertFlagForSVPtr GetNavICNavAlertFlagForSV::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICNavAlertFlagForSV>(svId, dataSetName);
    }

    GetNavICNavAlertFlagForSVPtr GetNavICNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICNavAlertFlagForSV>(ptr);
    }

    bool GetNavICNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICNavAlertFlagForSV::documentation() const { return Documentation; }


    int GetNavICNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICNavAlertFlagForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICNavAlertFlagForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICSatelliteNavAlertFlag
///
#include "gen/GetNavICSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICSatelliteNavAlertFlag::CmdName = "GetNavICSatelliteNavAlertFlag";
    const char* const GetNavICSatelliteNavAlertFlag::Documentation = "Please note the command GetNavICSatelliteNavAlertFlag is deprecated since 21.3. You may use GetNavICNavAlertFlagForSV.\n\nGet NavIC NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetNavICSatelliteNavAlertFlag);


    GetNavICSatelliteNavAlertFlag::GetNavICSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    GetNavICSatelliteNavAlertFlag::GetNavICSatelliteNavAlertFlag(int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetNavICSatelliteNavAlertFlagPtr GetNavICSatelliteNavAlertFlag::create(int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICSatelliteNavAlertFlag>(svId, dataSetName);
    }

    GetNavICSatelliteNavAlertFlagPtr GetNavICSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICSatelliteNavAlertFlag>(ptr);
    }

    bool GetNavICSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int GetNavICSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICSatelliteNavAlertFlag::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICSatelliteNavAlertFlag::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICSatelliteNavAlertFlag::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICSatelliteNavAlertFlag::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICNavAlertFlagForSVResult
///
#include "gen/GetNavICNavAlertFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICNavAlertFlagForSVResult::CmdName = "GetNavICNavAlertFlagForSVResult";
    const char* const GetNavICNavAlertFlagForSVResult::Documentation = "Result of GetNavICNavAlertFlagForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetNavICNavAlertFlagForSVResult);


    GetNavICNavAlertFlagForSVResult::GetNavICNavAlertFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetNavICNavAlertFlagForSVResult::GetNavICNavAlertFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAlert(alert);
      setDataSetName(dataSetName);
    }


    GetNavICNavAlertFlagForSVResultPtr GetNavICNavAlertFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool alert, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICNavAlertFlagForSVResult>(relatedCommand, svId, alert, dataSetName);
    }

    GetNavICNavAlertFlagForSVResultPtr GetNavICNavAlertFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICNavAlertFlagForSVResult>(ptr);
    }

    bool GetNavICNavAlertFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICNavAlertFlagForSVResult::documentation() const { return Documentation; }


    int GetNavICNavAlertFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICNavAlertFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetNavICNavAlertFlagForSVResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetNavICNavAlertFlagForSVResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICNavAlertFlagForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICNavAlertFlagForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlobalPowerOffset
///
#include "gen/SetGlobalPowerOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlobalPowerOffset::CmdName = "SetGlobalPowerOffset";
    const char* const SetGlobalPowerOffset::Documentation = "Set global power offset default value for all signals and all systems";

    REGISTER_COMMAND_FACTORY(SetGlobalPowerOffset);


    SetGlobalPowerOffset::SetGlobalPowerOffset()
      : CommandBase(CmdName)
    {}

    SetGlobalPowerOffset::SetGlobalPowerOffset(double offset)
      : CommandBase(CmdName)
    {

      setOffset(offset);
    }


    SetGlobalPowerOffsetPtr SetGlobalPowerOffset::create(double offset)
    {
      return std::make_shared<SetGlobalPowerOffset>(offset);
    }

    SetGlobalPowerOffsetPtr SetGlobalPowerOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlobalPowerOffset>(ptr);
    }

    bool SetGlobalPowerOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetGlobalPowerOffset::documentation() const { return Documentation; }


    int SetGlobalPowerOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetGlobalPowerOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetGlobalPowerOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPowerGlobalOffset
///
#include "gen/SetPowerGlobalOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPowerGlobalOffset::CmdName = "SetPowerGlobalOffset";
    const char* const SetPowerGlobalOffset::Documentation = "Please note the command SetPowerGlobalOffset is deprecated since 21.7. You may use SetGlobalPowerOffset.\n\nSet global power offset default value for all signals and all systems";

    REGISTER_COMMAND_FACTORY(SetPowerGlobalOffset);


    SetPowerGlobalOffset::SetPowerGlobalOffset()
      : CommandBase(CmdName)
    {}

    SetPowerGlobalOffset::SetPowerGlobalOffset(double offset)
      : CommandBase(CmdName)
    {

      setOffset(offset);
    }


    SetPowerGlobalOffsetPtr SetPowerGlobalOffset::create(double offset)
    {
      return std::make_shared<SetPowerGlobalOffset>(offset);
    }

    SetPowerGlobalOffsetPtr SetPowerGlobalOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPowerGlobalOffset>(ptr);
    }

    bool SetPowerGlobalOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPowerGlobalOffset::documentation() const { return Documentation; }


    int SetPowerGlobalOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetPowerGlobalOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPowerGlobalOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlobalPowerOffset
///
#include "gen/GetGlobalPowerOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlobalPowerOffset::CmdName = "GetGlobalPowerOffset";
    const char* const GetGlobalPowerOffset::Documentation = "Get global power offset default value for all signals and all systems";

    REGISTER_COMMAND_FACTORY(GetGlobalPowerOffset);


    GetGlobalPowerOffset::GetGlobalPowerOffset()
      : CommandBase(CmdName)
    {

    }


    GetGlobalPowerOffsetPtr GetGlobalPowerOffset::create()
    {
      return std::make_shared<GetGlobalPowerOffset>();
    }

    GetGlobalPowerOffsetPtr GetGlobalPowerOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlobalPowerOffset>(ptr);
    }

    bool GetGlobalPowerOffset::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGlobalPowerOffset::documentation() const { return Documentation; }


    int GetGlobalPowerOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetPowerGlobalOffset
///
#include "gen/GetPowerGlobalOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerGlobalOffset::CmdName = "GetPowerGlobalOffset";
    const char* const GetPowerGlobalOffset::Documentation = "Please note the command GetPowerGlobalOffset is deprecated since 21.7. You may use GetGlobalPowerOffset.\n\nGet global power offset default value for all signals and all systems";

    REGISTER_COMMAND_FACTORY(GetPowerGlobalOffset);


    GetPowerGlobalOffset::GetPowerGlobalOffset()
      : CommandBase(CmdName)
    {

    }


    GetPowerGlobalOffsetPtr GetPowerGlobalOffset::create()
    {
      return std::make_shared<GetPowerGlobalOffset>();
    }

    GetPowerGlobalOffsetPtr GetPowerGlobalOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerGlobalOffset>(ptr);
    }

    bool GetPowerGlobalOffset::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetPowerGlobalOffset::documentation() const { return Documentation; }


    int GetPowerGlobalOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGlobalPowerOffsetResult
///
#include "gen/GetGlobalPowerOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlobalPowerOffsetResult::CmdName = "GetGlobalPowerOffsetResult";
    const char* const GetGlobalPowerOffsetResult::Documentation = "Result of GetGlobalPowerOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlobalPowerOffsetResult);


    GetGlobalPowerOffsetResult::GetGlobalPowerOffsetResult()
      : CommandResult(CmdName)
    {}

    GetGlobalPowerOffsetResult::GetGlobalPowerOffsetResult(CommandBasePtr relatedCommand, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setOffset(offset);
    }


    GetGlobalPowerOffsetResultPtr GetGlobalPowerOffsetResult::create(CommandBasePtr relatedCommand, double offset)
    {
      return std::make_shared<GetGlobalPowerOffsetResult>(relatedCommand, offset);
    }

    GetGlobalPowerOffsetResultPtr GetGlobalPowerOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlobalPowerOffsetResult>(ptr);
    }

    bool GetGlobalPowerOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetGlobalPowerOffsetResult::documentation() const { return Documentation; }


    double GetGlobalPowerOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetGlobalPowerOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSignalPowerOffset
///
#include "gen/SetSignalPowerOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSignalPowerOffset::CmdName = "SetSignalPowerOffset";
    const char* const SetSignalPowerOffset::Documentation = "Set power offset default value for the signal given in argument";

    REGISTER_COMMAND_FACTORY(SetSignalPowerOffset);


    SetSignalPowerOffset::SetSignalPowerOffset()
      : CommandBase(CmdName)
    {}

    SetSignalPowerOffset::SetSignalPowerOffset(const std::string& signal, double offset)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setOffset(offset);
    }


    SetSignalPowerOffsetPtr SetSignalPowerOffset::create(const std::string& signal, double offset)
    {
      return std::make_shared<SetSignalPowerOffset>(signal, offset);
    }

    SetSignalPowerOffsetPtr SetSignalPowerOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSignalPowerOffset>(ptr);
    }

    bool SetSignalPowerOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetSignalPowerOffset::documentation() const { return Documentation; }


    int SetSignalPowerOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetSignalPowerOffset::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetSignalPowerOffset::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSignalPowerOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetSignalPowerOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPowerOffset
///
#include "gen/SetPowerOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPowerOffset::CmdName = "SetPowerOffset";
    const char* const SetPowerOffset::Documentation = "Please note the command SetPowerOffset is deprecated since 21.7. You may use SetSignalPowerOffset.\n\nSet power offset default value for the signal given in argument";

    REGISTER_COMMAND_FACTORY(SetPowerOffset);


    SetPowerOffset::SetPowerOffset()
      : CommandBase(CmdName)
    {}

    SetPowerOffset::SetPowerOffset(const std::string& signal, double offset)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setOffset(offset);
    }


    SetPowerOffsetPtr SetPowerOffset::create(const std::string& signal, double offset)
    {
      return std::make_shared<SetPowerOffset>(signal, offset);
    }

    SetPowerOffsetPtr SetPowerOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPowerOffset>(ptr);
    }

    bool SetPowerOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPowerOffset::documentation() const { return Documentation; }


    int SetPowerOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetPowerOffset::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetPowerOffset::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPowerOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPowerOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSignalPowerOffset
///
#include "gen/GetSignalPowerOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSignalPowerOffset::CmdName = "GetSignalPowerOffset";
    const char* const GetSignalPowerOffset::Documentation = "Get power offset default value for the signal given in argument";

    REGISTER_COMMAND_FACTORY(GetSignalPowerOffset);


    GetSignalPowerOffset::GetSignalPowerOffset()
      : CommandBase(CmdName)
    {}

    GetSignalPowerOffset::GetSignalPowerOffset(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetSignalPowerOffsetPtr GetSignalPowerOffset::create(const std::string& signal)
    {
      return std::make_shared<GetSignalPowerOffset>(signal);
    }

    GetSignalPowerOffsetPtr GetSignalPowerOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSignalPowerOffset>(ptr);
    }

    bool GetSignalPowerOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetSignalPowerOffset::documentation() const { return Documentation; }


    int GetSignalPowerOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSignalPowerOffset::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetSignalPowerOffset::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerOffset
///
#include "gen/GetPowerOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerOffset::CmdName = "GetPowerOffset";
    const char* const GetPowerOffset::Documentation = "Please note the command GetPowerOffset is deprecated since 21.7. You may use GetSignalPowerOffset.\n\nGet power offset default value for the signal given in argument";

    REGISTER_COMMAND_FACTORY(GetPowerOffset);


    GetPowerOffset::GetPowerOffset()
      : CommandBase(CmdName)
    {}

    GetPowerOffset::GetPowerOffset(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetPowerOffsetPtr GetPowerOffset::create(const std::string& signal)
    {
      return std::make_shared<GetPowerOffset>(signal);
    }

    GetPowerOffsetPtr GetPowerOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerOffset>(ptr);
    }

    bool GetPowerOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetPowerOffset::documentation() const { return Documentation; }


    int GetPowerOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPowerOffset::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPowerOffset::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSignalPowerOffsetResult
///
#include "gen/GetSignalPowerOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSignalPowerOffsetResult::CmdName = "GetSignalPowerOffsetResult";
    const char* const GetSignalPowerOffsetResult::Documentation = "Result of GetSignalPowerOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSignalPowerOffsetResult);


    GetSignalPowerOffsetResult::GetSignalPowerOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSignalPowerOffsetResult::GetSignalPowerOffsetResult(CommandBasePtr relatedCommand, const std::string& signal, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setOffset(offset);
    }


    GetSignalPowerOffsetResultPtr GetSignalPowerOffsetResult::create(CommandBasePtr relatedCommand, const std::string& signal, double offset)
    {
      return std::make_shared<GetSignalPowerOffsetResult>(relatedCommand, signal, offset);
    }

    GetSignalPowerOffsetResultPtr GetSignalPowerOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSignalPowerOffsetResult>(ptr);
    }

    bool GetSignalPowerOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetSignalPowerOffsetResult::documentation() const { return Documentation; }


    std::string GetSignalPowerOffsetResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetSignalPowerOffsetResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSignalPowerOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetSignalPowerOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPowerSbasOffset
///
#include "gen/SetPowerSbasOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPowerSbasOffset::CmdName = "SetPowerSbasOffset";
    const char* const SetPowerSbasOffset::Documentation = "Set power offset default value for the SBAS Service Provider given in argument";

    REGISTER_COMMAND_FACTORY(SetPowerSbasOffset);


    SetPowerSbasOffset::SetPowerSbasOffset()
      : CommandBase(CmdName)
    {}

    SetPowerSbasOffset::SetPowerSbasOffset(const std::string& serviceProvider, double offset)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setOffset(offset);
    }


    SetPowerSbasOffsetPtr SetPowerSbasOffset::create(const std::string& serviceProvider, double offset)
    {
      return std::make_shared<SetPowerSbasOffset>(serviceProvider, offset);
    }

    SetPowerSbasOffsetPtr SetPowerSbasOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPowerSbasOffset>(ptr);
    }

    bool SetPowerSbasOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPowerSbasOffset::documentation() const { return Documentation; }


    int SetPowerSbasOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetPowerSbasOffset::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void SetPowerSbasOffset::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPowerSbasOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPowerSbasOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerSbasOffset
///
#include "gen/GetPowerSbasOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerSbasOffset::CmdName = "GetPowerSbasOffset";
    const char* const GetPowerSbasOffset::Documentation = "Get power offset default value for the SBAS Service Provider given in argument";

    REGISTER_COMMAND_FACTORY(GetPowerSbasOffset);


    GetPowerSbasOffset::GetPowerSbasOffset()
      : CommandBase(CmdName)
    {}

    GetPowerSbasOffset::GetPowerSbasOffset(const std::string& serviceProvider)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
    }


    GetPowerSbasOffsetPtr GetPowerSbasOffset::create(const std::string& serviceProvider)
    {
      return std::make_shared<GetPowerSbasOffset>(serviceProvider);
    }

    GetPowerSbasOffsetPtr GetPowerSbasOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerSbasOffset>(ptr);
    }

    bool GetPowerSbasOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetPowerSbasOffset::documentation() const { return Documentation; }


    int GetPowerSbasOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPowerSbasOffset::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetPowerSbasOffset::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerSbasOffsetResult
///
#include "gen/GetPowerSbasOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerSbasOffsetResult::CmdName = "GetPowerSbasOffsetResult";
    const char* const GetPowerSbasOffsetResult::Documentation = "Result of GetPowerSbasOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPowerSbasOffsetResult);


    GetPowerSbasOffsetResult::GetPowerSbasOffsetResult()
      : CommandResult(CmdName)
    {}

    GetPowerSbasOffsetResult::GetPowerSbasOffsetResult(CommandBasePtr relatedCommand, const std::string& serviceProvider, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setServiceProvider(serviceProvider);
      setOffset(offset);
    }


    GetPowerSbasOffsetResultPtr GetPowerSbasOffsetResult::create(CommandBasePtr relatedCommand, const std::string& serviceProvider, double offset)
    {
      return std::make_shared<GetPowerSbasOffsetResult>(relatedCommand, serviceProvider, offset);
    }

    GetPowerSbasOffsetResultPtr GetPowerSbasOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerSbasOffsetResult>(ptr);
    }

    bool GetPowerSbasOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPowerSbasOffsetResult::documentation() const { return Documentation; }


    std::string GetPowerSbasOffsetResult::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetPowerSbasOffsetResult::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerSbasOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPowerSbasOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModulationTarget
///
#include "gen/SetModulationTarget.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModulationTarget::CmdName = "SetModulationTarget";
    const char* const SetModulationTarget::Documentation = "Set a modulation target.\nIf Id is not set, or if new, a new target is added.\nFor setter : If the Id is already used, the corresponding target is updated.";

    REGISTER_COMMAND_FACTORY(SetModulationTarget);


    SetModulationTarget::SetModulationTarget()
      : CommandBase(CmdName)
    {}

    SetModulationTarget::SetModulationTarget(const std::string& type, const std::string& path, const std::string& address, bool clockIsExternal, const std::string& id)
      : CommandBase(CmdName)
    {

      setType(type);
      setPath(path);
      setAddress(address);
      setClockIsExternal(clockIsExternal);
      setId(id);
    }


    SetModulationTargetPtr SetModulationTarget::create(const std::string& type, const std::string& path, const std::string& address, bool clockIsExternal, const std::string& id)
    {
      return std::make_shared<SetModulationTarget>(type, path, address, clockIsExternal, id);
    }

    SetModulationTargetPtr SetModulationTarget::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModulationTarget>(ptr);
    }

    bool SetModulationTarget::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<bool>::is_valid(m_values["ClockIsExternal"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModulationTarget::documentation() const { return Documentation; }


    int SetModulationTarget::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetModulationTarget::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetModulationTarget::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModulationTarget::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void SetModulationTarget::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModulationTarget::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void SetModulationTarget::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModulationTarget::clockIsExternal() const
    {
      return parse_json<bool>::parse(m_values["ClockIsExternal"]);
    }

    void SetModulationTarget::setClockIsExternal(bool clockIsExternal)
    {
      m_values.AddMember("ClockIsExternal", parse_json<bool>::format(clockIsExternal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModulationTarget::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModulationTarget::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTarget
///
#include "gen/GetModulationTarget.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTarget::CmdName = "GetModulationTarget";
    const char* const GetModulationTarget::Documentation = "Get a modulation target.\nIf Id is not set, or if new, a new target is added.\nFor setter : If the Id is already used, the corresponding target is updated.";

    REGISTER_COMMAND_FACTORY(GetModulationTarget);


    GetModulationTarget::GetModulationTarget()
      : CommandBase(CmdName)
    {}

    GetModulationTarget::GetModulationTarget(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetModulationTargetPtr GetModulationTarget::create(const std::string& id)
    {
      return std::make_shared<GetModulationTarget>(id);
    }

    GetModulationTargetPtr GetModulationTarget::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTarget>(ptr);
    }

    bool GetModulationTarget::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetModulationTarget::documentation() const { return Documentation; }


    int GetModulationTarget::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetModulationTarget::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTarget::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetResult
///
#include "gen/GetModulationTargetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetResult::CmdName = "GetModulationTargetResult";
    const char* const GetModulationTargetResult::Documentation = "Result of GetModulationTarget.";

    REGISTER_COMMAND_RESULT_FACTORY(GetModulationTargetResult);


    GetModulationTargetResult::GetModulationTargetResult()
      : CommandResult(CmdName)
    {}

    GetModulationTargetResult::GetModulationTargetResult(CommandBasePtr relatedCommand, const std::string& type, const std::string& path, const std::string& address, bool clockIsExternal, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setPath(path);
      setAddress(address);
      setClockIsExternal(clockIsExternal);
      setId(id);
    }


    GetModulationTargetResultPtr GetModulationTargetResult::create(CommandBasePtr relatedCommand, const std::string& type, const std::string& path, const std::string& address, bool clockIsExternal, const std::string& id)
    {
      return std::make_shared<GetModulationTargetResult>(relatedCommand, type, path, address, clockIsExternal, id);
    }

    GetModulationTargetResultPtr GetModulationTargetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetResult>(ptr);
    }

    bool GetModulationTargetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<bool>::is_valid(m_values["ClockIsExternal"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetModulationTargetResult::documentation() const { return Documentation; }


    std::string GetModulationTargetResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetModulationTargetResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetResult::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void GetModulationTargetResult::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetResult::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void GetModulationTargetResult::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetModulationTargetResult::clockIsExternal() const
    {
      return parse_json<bool>::parse(m_values["ClockIsExternal"]);
    }

    void GetModulationTargetResult::setClockIsExternal(bool clockIsExternal)
    {
      m_values.AddMember("ClockIsExternal", parse_json<bool>::format(clockIsExternal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpu
///
#include "gen/SetGpu.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpu::CmdName = "SetGpu";
    const char* const SetGpu::Documentation = "Set the GPU associated with a RF output of a modulation target.";

    REGISTER_COMMAND_FACTORY(SetGpu);


    SetGpu::SetGpu()
      : CommandBase(CmdName)
    {}

    SetGpu::SetGpu(int gpuIdx, int output, const std::string& id)
      : CommandBase(CmdName)
    {

      setGpuIdx(gpuIdx);
      setOutput(output);
      setId(id);
    }


    SetGpuPtr SetGpu::create(int gpuIdx, int output, const std::string& id)
    {
      return std::make_shared<SetGpu>(gpuIdx, output, id);
    }

    SetGpuPtr SetGpu::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpu>(ptr);
    }

    bool SetGpu::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["GpuIdx"])
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetGpu::documentation() const { return Documentation; }


    int SetGpu::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpu::gpuIdx() const
    {
      return parse_json<int>::parse(m_values["GpuIdx"]);
    }

    void SetGpu::setGpuIdx(int gpuIdx)
    {
      m_values.AddMember("GpuIdx", parse_json<int>::format(gpuIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpu::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void SetGpu::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGpu::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetGpu::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpu
///
#include "gen/GetGpu.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpu::CmdName = "GetGpu";
    const char* const GetGpu::Documentation = "Get the GPU associated with a RF output of a modulation target.";

    REGISTER_COMMAND_FACTORY(GetGpu);


    GetGpu::GetGpu()
      : CommandBase(CmdName)
    {}

    GetGpu::GetGpu(int output, const std::string& id)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setId(id);
    }


    GetGpuPtr GetGpu::create(int output, const std::string& id)
    {
      return std::make_shared<GetGpu>(output, id);
    }

    GetGpuPtr GetGpu::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpu>(ptr);
    }

    bool GetGpu::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpu::documentation() const { return Documentation; }


    int GetGpu::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpu::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetGpu::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpu::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpu::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpuResult
///
#include "gen/GetGpuResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpuResult::CmdName = "GetGpuResult";
    const char* const GetGpuResult::Documentation = "Result of GetGpu.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpuResult);


    GetGpuResult::GetGpuResult()
      : CommandResult(CmdName)
    {}

    GetGpuResult::GetGpuResult(CommandBasePtr relatedCommand, int gpuIdx, int output, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setGpuIdx(gpuIdx);
      setOutput(output);
      setId(id);
    }


    GetGpuResultPtr GetGpuResult::create(CommandBasePtr relatedCommand, int gpuIdx, int output, const std::string& id)
    {
      return std::make_shared<GetGpuResult>(relatedCommand, gpuIdx, output, id);
    }

    GetGpuResultPtr GetGpuResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpuResult>(ptr);
    }

    bool GetGpuResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["GpuIdx"])
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpuResult::documentation() const { return Documentation; }


    int GetGpuResult::gpuIdx() const
    {
      return parse_json<int>::parse(m_values["GpuIdx"]);
    }

    void GetGpuResult::setGpuIdx(int gpuIdx)
    {
      m_values.AddMember("GpuIdx", parse_json<int>::format(gpuIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpuResult::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetGpuResult::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpuResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpuResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllModulationTargets
///
#include "gen/GetAllModulationTargets.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllModulationTargets::CmdName = "GetAllModulationTargets";
    const char* const GetAllModulationTargets::Documentation = "Get all the modulation targets IDs";

    REGISTER_COMMAND_FACTORY(GetAllModulationTargets);


    GetAllModulationTargets::GetAllModulationTargets()
      : CommandBase(CmdName)
    {

    }


    GetAllModulationTargetsPtr GetAllModulationTargets::create()
    {
      return std::make_shared<GetAllModulationTargets>();
    }

    GetAllModulationTargetsPtr GetAllModulationTargets::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllModulationTargets>(ptr);
    }

    bool GetAllModulationTargets::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAllModulationTargets::documentation() const { return Documentation; }


    int GetAllModulationTargets::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAllModulationTargetsResult
///
#include "gen/GetAllModulationTargetsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllModulationTargetsResult::CmdName = "GetAllModulationTargetsResult";
    const char* const GetAllModulationTargetsResult::Documentation = "Result of GetAllModulationTargets.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllModulationTargetsResult);


    GetAllModulationTargetsResult::GetAllModulationTargetsResult()
      : CommandResult(CmdName)
    {}

    GetAllModulationTargetsResult::GetAllModulationTargetsResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllModulationTargetsResultPtr GetAllModulationTargetsResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return std::make_shared<GetAllModulationTargetsResult>(relatedCommand, ids);
    }

    GetAllModulationTargetsResultPtr GetAllModulationTargetsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllModulationTargetsResult>(ptr);
    }

    bool GetAllModulationTargetsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllModulationTargetsResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllModulationTargetsResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllModulationTargetsResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModulationTarget
///
#include "gen/RemoveModulationTarget.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModulationTarget::CmdName = "RemoveModulationTarget";
    const char* const RemoveModulationTarget::Documentation = "Remove a modulation target.";

    REGISTER_COMMAND_FACTORY(RemoveModulationTarget);


    RemoveModulationTarget::RemoveModulationTarget()
      : CommandBase(CmdName)
    {}

    RemoveModulationTarget::RemoveModulationTarget(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModulationTargetPtr RemoveModulationTarget::create(const std::string& id)
    {
      return std::make_shared<RemoveModulationTarget>(id);
    }

    RemoveModulationTargetPtr RemoveModulationTarget::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModulationTarget>(ptr);
    }

    bool RemoveModulationTarget::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModulationTarget::documentation() const { return Documentation; }


    int RemoveModulationTarget::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModulationTarget::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModulationTarget::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllModulationTargets
///
#include "gen/RemoveAllModulationTargets.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllModulationTargets::CmdName = "RemoveAllModulationTargets";
    const char* const RemoveAllModulationTargets::Documentation = "Remove all modulation targets.";

    REGISTER_COMMAND_FACTORY(RemoveAllModulationTargets);


    RemoveAllModulationTargets::RemoveAllModulationTargets()
      : CommandBase(CmdName)
    {

    }


    RemoveAllModulationTargetsPtr RemoveAllModulationTargets::create()
    {
      return std::make_shared<RemoveAllModulationTargets>();
    }

    RemoveAllModulationTargetsPtr RemoveAllModulationTargets::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllModulationTargets>(ptr);
    }

    bool RemoveAllModulationTargets::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllModulationTargets::documentation() const { return Documentation; }


    int RemoveAllModulationTargets::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of ChangeModulationTargetName
///
#include "gen/ChangeModulationTargetName.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeModulationTargetName::CmdName = "ChangeModulationTargetName";
    const char* const ChangeModulationTargetName::Documentation = "Change the modulation target name. The name is only used for display purpose.";

    REGISTER_COMMAND_FACTORY(ChangeModulationTargetName);


    ChangeModulationTargetName::ChangeModulationTargetName()
      : CommandBase(CmdName)
    {}

    ChangeModulationTargetName::ChangeModulationTargetName(const std::string& targetName, const std::string& id)
      : CommandBase(CmdName)
    {

      setTargetName(targetName);
      setId(id);
    }


    ChangeModulationTargetNamePtr ChangeModulationTargetName::create(const std::string& targetName, const std::string& id)
    {
      return std::make_shared<ChangeModulationTargetName>(targetName, id);
    }

    ChangeModulationTargetNamePtr ChangeModulationTargetName::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeModulationTargetName>(ptr);
    }

    bool ChangeModulationTargetName::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TargetName"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ChangeModulationTargetName::documentation() const { return Documentation; }


    int ChangeModulationTargetName::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ChangeModulationTargetName::targetName() const
    {
      return parse_json<std::string>::parse(m_values["TargetName"]);
    }

    void ChangeModulationTargetName::setTargetName(const std::string& targetName)
    {
      m_values.AddMember("TargetName", parse_json<std::string>::format(targetName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetName::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeModulationTargetName::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeModulationTargetSignals
///
#include "gen/ChangeModulationTargetSignals.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeModulationTargetSignals::CmdName = "ChangeModulationTargetSignals";
    const char* const ChangeModulationTargetSignals::Documentation = "Set the signals for the specified target and output index.\nSkydel tries to keep the sampling rate as low as possible,\nbut it is possible to set constaints with MinRate and MaxRate.";

    REGISTER_COMMAND_FACTORY(ChangeModulationTargetSignals);


    ChangeModulationTargetSignals::ChangeModulationTargetSignals()
      : CommandBase(CmdName)
    {}

    ChangeModulationTargetSignals::ChangeModulationTargetSignals(int output, int minRate, int maxRate, const std::string& band, const std::string& signal, int gain, bool gaussianNoise, const std::string& id, const Sdx::optional<double>& centralFrequency)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setMinRate(minRate);
      setMaxRate(maxRate);
      setBand(band);
      setSignal(signal);
      setGain(gain);
      setGaussianNoise(gaussianNoise);
      setId(id);
      setCentralFrequency(centralFrequency);
    }


    ChangeModulationTargetSignalsPtr ChangeModulationTargetSignals::create(int output, int minRate, int maxRate, const std::string& band, const std::string& signal, int gain, bool gaussianNoise, const std::string& id, const Sdx::optional<double>& centralFrequency)
    {
      return std::make_shared<ChangeModulationTargetSignals>(output, minRate, maxRate, band, signal, gain, gaussianNoise, id, centralFrequency);
    }

    ChangeModulationTargetSignalsPtr ChangeModulationTargetSignals::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeModulationTargetSignals>(ptr);
    }

    bool ChangeModulationTargetSignals::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<int>::is_valid(m_values["MinRate"])
          && parse_json<int>::is_valid(m_values["MaxRate"])
          && parse_json<std::string>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Gain"])
          && parse_json<bool>::is_valid(m_values["GaussianNoise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["CentralFrequency"])
        ;

    }

    std::string ChangeModulationTargetSignals::documentation() const { return Documentation; }


    int ChangeModulationTargetSignals::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ChangeModulationTargetSignals::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void ChangeModulationTargetSignals::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetSignals::minRate() const
    {
      return parse_json<int>::parse(m_values["MinRate"]);
    }

    void ChangeModulationTargetSignals::setMinRate(int minRate)
    {
      m_values.AddMember("MinRate", parse_json<int>::format(minRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetSignals::maxRate() const
    {
      return parse_json<int>::parse(m_values["MaxRate"]);
    }

    void ChangeModulationTargetSignals::setMaxRate(int maxRate)
    {
      m_values.AddMember("MaxRate", parse_json<int>::format(maxRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetSignals::band() const
    {
      return parse_json<std::string>::parse(m_values["Band"]);
    }

    void ChangeModulationTargetSignals::setBand(const std::string& band)
    {
      m_values.AddMember("Band", parse_json<std::string>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetSignals::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void ChangeModulationTargetSignals::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetSignals::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void ChangeModulationTargetSignals::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ChangeModulationTargetSignals::gaussianNoise() const
    {
      return parse_json<bool>::parse(m_values["GaussianNoise"]);
    }

    void ChangeModulationTargetSignals::setGaussianNoise(bool gaussianNoise)
    {
      m_values.AddMember("GaussianNoise", parse_json<bool>::format(gaussianNoise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetSignals::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeModulationTargetSignals::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> ChangeModulationTargetSignals::centralFrequency() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["CentralFrequency"]);
    }

    void ChangeModulationTargetSignals::setCentralFrequency(const Sdx::optional<double>& centralFrequency)
    {
      m_values.AddMember("CentralFrequency", parse_json<Sdx::optional<double>>::format(centralFrequency, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetSignals
///
#include "gen/GetModulationTargetSignals.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetSignals::CmdName = "GetModulationTargetSignals";
    const char* const GetModulationTargetSignals::Documentation = "Get the signals for the specified target and output index.\nSkydel tries to keep the sampling rate as low as possible,\nbut it is possible to set constaints with MinRate and MaxRate.";

    REGISTER_COMMAND_FACTORY(GetModulationTargetSignals);


    GetModulationTargetSignals::GetModulationTargetSignals()
      : CommandBase(CmdName)
    {}

    GetModulationTargetSignals::GetModulationTargetSignals(int output, const std::string& id)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setId(id);
    }


    GetModulationTargetSignalsPtr GetModulationTargetSignals::create(int output, const std::string& id)
    {
      return std::make_shared<GetModulationTargetSignals>(output, id);
    }

    GetModulationTargetSignalsPtr GetModulationTargetSignals::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetSignals>(ptr);
    }

    bool GetModulationTargetSignals::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetModulationTargetSignals::documentation() const { return Documentation; }


    int GetModulationTargetSignals::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetModulationTargetSignals::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetModulationTargetSignals::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetSignals::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetSignals::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetSignalsResult
///
#include "gen/GetModulationTargetSignalsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetSignalsResult::CmdName = "GetModulationTargetSignalsResult";
    const char* const GetModulationTargetSignalsResult::Documentation = "Result of GetModulationTargetSignals.";

    REGISTER_COMMAND_RESULT_FACTORY(GetModulationTargetSignalsResult);


    GetModulationTargetSignalsResult::GetModulationTargetSignalsResult()
      : CommandResult(CmdName)
    {}

    GetModulationTargetSignalsResult::GetModulationTargetSignalsResult(CommandBasePtr relatedCommand, int output, int minRate, int maxRate, const std::string& band, const std::string& signal, int gain, bool gaussianNoise, const std::string& id, const Sdx::optional<double>& centralFrequency)
      : CommandResult(CmdName, relatedCommand)
    {

      setOutput(output);
      setMinRate(minRate);
      setMaxRate(maxRate);
      setBand(band);
      setSignal(signal);
      setGain(gain);
      setGaussianNoise(gaussianNoise);
      setId(id);
      setCentralFrequency(centralFrequency);
    }


    GetModulationTargetSignalsResultPtr GetModulationTargetSignalsResult::create(CommandBasePtr relatedCommand, int output, int minRate, int maxRate, const std::string& band, const std::string& signal, int gain, bool gaussianNoise, const std::string& id, const Sdx::optional<double>& centralFrequency)
    {
      return std::make_shared<GetModulationTargetSignalsResult>(relatedCommand, output, minRate, maxRate, band, signal, gain, gaussianNoise, id, centralFrequency);
    }

    GetModulationTargetSignalsResultPtr GetModulationTargetSignalsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetSignalsResult>(ptr);
    }

    bool GetModulationTargetSignalsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<int>::is_valid(m_values["MinRate"])
          && parse_json<int>::is_valid(m_values["MaxRate"])
          && parse_json<std::string>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Gain"])
          && parse_json<bool>::is_valid(m_values["GaussianNoise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["CentralFrequency"])
        ;

    }

    std::string GetModulationTargetSignalsResult::documentation() const { return Documentation; }


    int GetModulationTargetSignalsResult::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetModulationTargetSignalsResult::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetSignalsResult::minRate() const
    {
      return parse_json<int>::parse(m_values["MinRate"]);
    }

    void GetModulationTargetSignalsResult::setMinRate(int minRate)
    {
      m_values.AddMember("MinRate", parse_json<int>::format(minRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetSignalsResult::maxRate() const
    {
      return parse_json<int>::parse(m_values["MaxRate"]);
    }

    void GetModulationTargetSignalsResult::setMaxRate(int maxRate)
    {
      m_values.AddMember("MaxRate", parse_json<int>::format(maxRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetSignalsResult::band() const
    {
      return parse_json<std::string>::parse(m_values["Band"]);
    }

    void GetModulationTargetSignalsResult::setBand(const std::string& band)
    {
      m_values.AddMember("Band", parse_json<std::string>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetSignalsResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetModulationTargetSignalsResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetSignalsResult::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void GetModulationTargetSignalsResult::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetModulationTargetSignalsResult::gaussianNoise() const
    {
      return parse_json<bool>::parse(m_values["GaussianNoise"]);
    }

    void GetModulationTargetSignalsResult::setGaussianNoise(bool gaussianNoise)
    {
      m_values.AddMember("GaussianNoise", parse_json<bool>::format(gaussianNoise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetSignalsResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetSignalsResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetModulationTargetSignalsResult::centralFrequency() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["CentralFrequency"]);
    }

    void GetModulationTargetSignalsResult::setCentralFrequency(const Sdx::optional<double>& centralFrequency)
    {
      m_values.AddMember("CentralFrequency", parse_json<Sdx::optional<double>>::format(centralFrequency, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeModulationTargetInterference
///
#include "gen/ChangeModulationTargetInterference.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeModulationTargetInterference::CmdName = "ChangeModulationTargetInterference";
    const char* const ChangeModulationTargetInterference::Documentation = "Set the specified target and output index to a group of interferences.\nAn interference transmitter is mapped to a specific RF output by using the same Interference Group Number.\nSkydel tries to keep the sampling rate as low as possible,\nbut it is possible to set constaints with MinRate and MaxRate.";

    REGISTER_COMMAND_FACTORY(ChangeModulationTargetInterference);


    ChangeModulationTargetInterference::ChangeModulationTargetInterference()
      : CommandBase(CmdName)
    {}

    ChangeModulationTargetInterference::ChangeModulationTargetInterference(int output, int minRate, int maxRate, int group, double centralFreq, int gain, const std::string& id, const Sdx::optional<std::string>& signal)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setMinRate(minRate);
      setMaxRate(maxRate);
      setGroup(group);
      setCentralFreq(centralFreq);
      setGain(gain);
      setId(id);
      setSignal(signal);
    }


    ChangeModulationTargetInterferencePtr ChangeModulationTargetInterference::create(int output, int minRate, int maxRate, int group, double centralFreq, int gain, const std::string& id, const Sdx::optional<std::string>& signal)
    {
      return std::make_shared<ChangeModulationTargetInterference>(output, minRate, maxRate, group, centralFreq, gain, id, signal);
    }

    ChangeModulationTargetInterferencePtr ChangeModulationTargetInterference::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeModulationTargetInterference>(ptr);
    }

    bool ChangeModulationTargetInterference::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<int>::is_valid(m_values["MinRate"])
          && parse_json<int>::is_valid(m_values["MaxRate"])
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<int>::is_valid(m_values["Gain"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Signal"])
        ;

    }

    std::string ChangeModulationTargetInterference::documentation() const { return Documentation; }


    int ChangeModulationTargetInterference::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ChangeModulationTargetInterference::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void ChangeModulationTargetInterference::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetInterference::minRate() const
    {
      return parse_json<int>::parse(m_values["MinRate"]);
    }

    void ChangeModulationTargetInterference::setMinRate(int minRate)
    {
      m_values.AddMember("MinRate", parse_json<int>::format(minRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetInterference::maxRate() const
    {
      return parse_json<int>::parse(m_values["MaxRate"]);
    }

    void ChangeModulationTargetInterference::setMaxRate(int maxRate)
    {
      m_values.AddMember("MaxRate", parse_json<int>::format(maxRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetInterference::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void ChangeModulationTargetInterference::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double ChangeModulationTargetInterference::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void ChangeModulationTargetInterference::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetInterference::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void ChangeModulationTargetInterference::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetInterference::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeModulationTargetInterference::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ChangeModulationTargetInterference::signal() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Signal"]);
    }

    void ChangeModulationTargetInterference::setSignal(const Sdx::optional<std::string>& signal)
    {
      m_values.AddMember("Signal", parse_json<Sdx::optional<std::string>>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetInterferences
///
#include "gen/GetModulationTargetInterferences.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetInterferences::CmdName = "GetModulationTargetInterferences";
    const char* const GetModulationTargetInterferences::Documentation = "Get the specified target and output index to a group of interferences.\nAn interference transmitter is mapped to a specific RF output by using the same Interference Group Number.\nSkydel tries to keep the sampling rate as low as possible,\nbut it is possible to set constaints with MinRate and MaxRate.";

    REGISTER_COMMAND_FACTORY(GetModulationTargetInterferences);


    GetModulationTargetInterferences::GetModulationTargetInterferences()
      : CommandBase(CmdName)
    {}

    GetModulationTargetInterferences::GetModulationTargetInterferences(int output, const std::string& id)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setId(id);
    }


    GetModulationTargetInterferencesPtr GetModulationTargetInterferences::create(int output, const std::string& id)
    {
      return std::make_shared<GetModulationTargetInterferences>(output, id);
    }

    GetModulationTargetInterferencesPtr GetModulationTargetInterferences::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetInterferences>(ptr);
    }

    bool GetModulationTargetInterferences::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetModulationTargetInterferences::documentation() const { return Documentation; }


    int GetModulationTargetInterferences::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetModulationTargetInterferences::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetModulationTargetInterferences::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetInterferences::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetInterferences::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetInterferencesResult
///
#include "gen/GetModulationTargetInterferencesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetInterferencesResult::CmdName = "GetModulationTargetInterferencesResult";
    const char* const GetModulationTargetInterferencesResult::Documentation = "Result of GetModulationTargetInterferences.";

    REGISTER_COMMAND_RESULT_FACTORY(GetModulationTargetInterferencesResult);


    GetModulationTargetInterferencesResult::GetModulationTargetInterferencesResult()
      : CommandResult(CmdName)
    {}

    GetModulationTargetInterferencesResult::GetModulationTargetInterferencesResult(CommandBasePtr relatedCommand, int output, int minRate, int maxRate, int group, double centralFreq, int gain, const std::string& id, const Sdx::optional<std::string>& signal)
      : CommandResult(CmdName, relatedCommand)
    {

      setOutput(output);
      setMinRate(minRate);
      setMaxRate(maxRate);
      setGroup(group);
      setCentralFreq(centralFreq);
      setGain(gain);
      setId(id);
      setSignal(signal);
    }


    GetModulationTargetInterferencesResultPtr GetModulationTargetInterferencesResult::create(CommandBasePtr relatedCommand, int output, int minRate, int maxRate, int group, double centralFreq, int gain, const std::string& id, const Sdx::optional<std::string>& signal)
    {
      return std::make_shared<GetModulationTargetInterferencesResult>(relatedCommand, output, minRate, maxRate, group, centralFreq, gain, id, signal);
    }

    GetModulationTargetInterferencesResultPtr GetModulationTargetInterferencesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetInterferencesResult>(ptr);
    }

    bool GetModulationTargetInterferencesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<int>::is_valid(m_values["MinRate"])
          && parse_json<int>::is_valid(m_values["MaxRate"])
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<int>::is_valid(m_values["Gain"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetModulationTargetInterferencesResult::documentation() const { return Documentation; }


    int GetModulationTargetInterferencesResult::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetModulationTargetInterferencesResult::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetInterferencesResult::minRate() const
    {
      return parse_json<int>::parse(m_values["MinRate"]);
    }

    void GetModulationTargetInterferencesResult::setMinRate(int minRate)
    {
      m_values.AddMember("MinRate", parse_json<int>::format(minRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetInterferencesResult::maxRate() const
    {
      return parse_json<int>::parse(m_values["MaxRate"]);
    }

    void GetModulationTargetInterferencesResult::setMaxRate(int maxRate)
    {
      m_values.AddMember("MaxRate", parse_json<int>::format(maxRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetInterferencesResult::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void GetModulationTargetInterferencesResult::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetModulationTargetInterferencesResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetModulationTargetInterferencesResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetInterferencesResult::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void GetModulationTargetInterferencesResult::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetInterferencesResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetInterferencesResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetModulationTargetInterferencesResult::signal() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Signal"]);
    }

    void GetModulationTargetInterferencesResult::setSignal(const Sdx::optional<std::string>& signal)
    {
      m_values.AddMember("Signal", parse_json<Sdx::optional<std::string>>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeModulationAnechoicTargetInterference
///
#include "gen/ChangeModulationAnechoicTargetInterference.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeModulationAnechoicTargetInterference::CmdName = "ChangeModulationAnechoicTargetInterference";
    const char* const ChangeModulationAnechoicTargetInterference::Documentation = "Assign an output to a specific interference group. This command works only\nfor Anechoic Chamber target.";

    REGISTER_COMMAND_FACTORY(ChangeModulationAnechoicTargetInterference);


    ChangeModulationAnechoicTargetInterference::ChangeModulationAnechoicTargetInterference()
      : CommandBase(CmdName)
    {}

    ChangeModulationAnechoicTargetInterference::ChangeModulationAnechoicTargetInterference(int group, const std::string& output, double centralFreq)
      : CommandBase(CmdName)
    {

      setGroup(group);
      setOutput(output);
      setCentralFreq(centralFreq);
    }


    ChangeModulationAnechoicTargetInterferencePtr ChangeModulationAnechoicTargetInterference::create(int group, const std::string& output, double centralFreq)
    {
      return std::make_shared<ChangeModulationAnechoicTargetInterference>(group, output, centralFreq);
    }

    ChangeModulationAnechoicTargetInterferencePtr ChangeModulationAnechoicTargetInterference::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeModulationAnechoicTargetInterference>(ptr);
    }

    bool ChangeModulationAnechoicTargetInterference::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<std::string>::is_valid(m_values["Output"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
        ;

    }

    std::string ChangeModulationAnechoicTargetInterference::documentation() const { return Documentation; }


    int ChangeModulationAnechoicTargetInterference::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ChangeModulationAnechoicTargetInterference::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void ChangeModulationAnechoicTargetInterference::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationAnechoicTargetInterference::output() const
    {
      return parse_json<std::string>::parse(m_values["Output"]);
    }

    void ChangeModulationAnechoicTargetInterference::setOutput(const std::string& output)
    {
      m_values.AddMember("Output", parse_json<std::string>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double ChangeModulationAnechoicTargetInterference::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void ChangeModulationAnechoicTargetInterference::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModulationAnechoicTargetInterference
///
#include "gen/RemoveModulationAnechoicTargetInterference.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModulationAnechoicTargetInterference::CmdName = "RemoveModulationAnechoicTargetInterference";
    const char* const RemoveModulationAnechoicTargetInterference::Documentation = "Remove output assignation. This command works only for Anechoic Chamber\ntarget.";

    REGISTER_COMMAND_FACTORY(RemoveModulationAnechoicTargetInterference);


    RemoveModulationAnechoicTargetInterference::RemoveModulationAnechoicTargetInterference()
      : CommandBase(CmdName)
    {}

    RemoveModulationAnechoicTargetInterference::RemoveModulationAnechoicTargetInterference(int group)
      : CommandBase(CmdName)
    {

      setGroup(group);
    }


    RemoveModulationAnechoicTargetInterferencePtr RemoveModulationAnechoicTargetInterference::create(int group)
    {
      return std::make_shared<RemoveModulationAnechoicTargetInterference>(group);
    }

    RemoveModulationAnechoicTargetInterferencePtr RemoveModulationAnechoicTargetInterference::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModulationAnechoicTargetInterference>(ptr);
    }

    bool RemoveModulationAnechoicTargetInterference::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Group"])
        ;

    }

    std::string RemoveModulationAnechoicTargetInterference::documentation() const { return Documentation; }


    int RemoveModulationAnechoicTargetInterference::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int RemoveModulationAnechoicTargetInterference::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void RemoveModulationAnechoicTargetInterference::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetRfGain
///
#include "gen/SetRfGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetRfGain::CmdName = "SetRfGain";
    const char* const SetRfGain::Documentation = "USE AT YOUR OWN RISKS. Set the RF Gain of the SDR";

    REGISTER_COMMAND_FACTORY(SetRfGain);


    SetRfGain::SetRfGain()
      : CommandBase(CmdName)
    {}

    SetRfGain::SetRfGain(int output, double gain)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setGain(gain);
    }


    SetRfGainPtr SetRfGain::create(int output, double gain)
    {
      return std::make_shared<SetRfGain>(output, gain);
    }

    SetRfGainPtr SetRfGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetRfGain>(ptr);
    }

    bool SetRfGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<double>::is_valid(m_values["Gain"])
        ;

    }

    std::string SetRfGain::documentation() const { return Documentation; }


    int SetRfGain::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetRfGain::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void SetRfGain::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetRfGain::gain() const
    {
      return parse_json<double>::parse(m_values["Gain"]);
    }

    void SetRfGain::setGain(double gain)
    {
      m_values.AddMember("Gain", parse_json<double>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportConstellationParameters
///
#include "gen/ImportConstellationParameters.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportConstellationParameters::CmdName = "ImportConstellationParameters";
    const char* const ImportConstellationParameters::Documentation = "Import navigation message file for the specified constellation. This could be Rinex, SEM or YUMA file for GPS. Only Rinex for the others.";

    REGISTER_COMMAND_FACTORY(ImportConstellationParameters);


    ImportConstellationParameters::ImportConstellationParameters()
      : CommandBase(CmdName)
    {}

    ImportConstellationParameters::ImportConstellationParameters(const std::string& system, const std::string& path, const Sdx::optional<int>& rollover, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPath(path);
      setRollover(rollover);
      setDataSetName(dataSetName);
    }


    ImportConstellationParametersPtr ImportConstellationParameters::create(const std::string& system, const std::string& path, const Sdx::optional<int>& rollover, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<ImportConstellationParameters>(system, path, rollover, dataSetName);
    }

    ImportConstellationParametersPtr ImportConstellationParameters::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportConstellationParameters>(ptr);
    }

    bool ImportConstellationParameters::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Rollover"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string ImportConstellationParameters::documentation() const { return Documentation; }


    int ImportConstellationParameters::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportConstellationParameters::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ImportConstellationParameters::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportConstellationParameters::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportConstellationParameters::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> ImportConstellationParameters::rollover() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Rollover"]);
    }

    void ImportConstellationParameters::setRollover(const Sdx::optional<int>& rollover)
    {
      m_values.AddMember("Rollover", parse_json<Sdx::optional<int>>::format(rollover, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ImportConstellationParameters::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void ImportConstellationParameters::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportIonoParameters
///
#include "gen/ImportIonoParameters.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportIonoParameters::CmdName = "ImportIonoParameters";
    const char* const ImportIonoParameters::Documentation = "Import ionospheric parameters from a Rinex file.";

    REGISTER_COMMAND_FACTORY(ImportIonoParameters);


    ImportIonoParameters::ImportIonoParameters()
      : CommandBase(CmdName)
    {}

    ImportIonoParameters::ImportIonoParameters(const std::string& path, const Sdx::optional<std::string>& type)
      : CommandBase(CmdName)
    {

      setPath(path);
      setType(type);
    }


    ImportIonoParametersPtr ImportIonoParameters::create(const std::string& path, const Sdx::optional<std::string>& type)
    {
      return std::make_shared<ImportIonoParameters>(path, type);
    }

    ImportIonoParametersPtr ImportIonoParameters::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportIonoParameters>(ptr);
    }

    bool ImportIonoParameters::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Type"])
        ;

    }

    std::string ImportIonoParameters::documentation() const { return Documentation; }


    int ImportIonoParameters::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportIonoParameters::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportIonoParameters::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ImportIonoParameters::type() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Type"]);
    }

    void ImportIonoParameters::setType(const Sdx::optional<std::string>& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::optional<std::string>>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportMODIPFile
///
#include "gen/ImportMODIPFile.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportMODIPFile::CmdName = "ImportMODIPFile";
    const char* const ImportMODIPFile::Documentation = "Import MODIP data file.";

    REGISTER_COMMAND_FACTORY(ImportMODIPFile);


    ImportMODIPFile::ImportMODIPFile()
      : CommandBase(CmdName)
    {}

    ImportMODIPFile::ImportMODIPFile(const std::string& path)
      : CommandBase(CmdName)
    {

      setPath(path);
    }


    ImportMODIPFilePtr ImportMODIPFile::create(const std::string& path)
    {
      return std::make_shared<ImportMODIPFile>(path);
    }

    ImportMODIPFilePtr ImportMODIPFile::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportMODIPFile>(ptr);
    }

    bool ImportMODIPFile::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportMODIPFile::documentation() const { return Documentation; }


    int ImportMODIPFile::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportMODIPFile::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportMODIPFile::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportCCIRFilesFromDirectory
///
#include "gen/ImportCCIRFilesFromDirectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportCCIRFilesFromDirectory::CmdName = "ImportCCIRFilesFromDirectory";
    const char* const ImportCCIRFilesFromDirectory::Documentation = "Import all the CCIR data files from the specified directory.";

    REGISTER_COMMAND_FACTORY(ImportCCIRFilesFromDirectory);


    ImportCCIRFilesFromDirectory::ImportCCIRFilesFromDirectory()
      : CommandBase(CmdName)
    {}

    ImportCCIRFilesFromDirectory::ImportCCIRFilesFromDirectory(const std::string& path)
      : CommandBase(CmdName)
    {

      setPath(path);
    }


    ImportCCIRFilesFromDirectoryPtr ImportCCIRFilesFromDirectory::create(const std::string& path)
    {
      return std::make_shared<ImportCCIRFilesFromDirectory>(path);
    }

    ImportCCIRFilesFromDirectoryPtr ImportCCIRFilesFromDirectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportCCIRFilesFromDirectory>(ptr);
    }

    bool ImportCCIRFilesFromDirectory::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportCCIRFilesFromDirectory::documentation() const { return Documentation; }


    int ImportCCIRFilesFromDirectory::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportCCIRFilesFromDirectory::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportCCIRFilesFromDirectory::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportGlonassAlmanac
///
#include "gen/ImportGlonassAlmanac.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportGlonassAlmanac::CmdName = "ImportGlonassAlmanac";
    const char* const ImportGlonassAlmanac::Documentation = "Import GLONASS almanac file";

    REGISTER_COMMAND_FACTORY(ImportGlonassAlmanac);


    ImportGlonassAlmanac::ImportGlonassAlmanac()
      : CommandBase(CmdName)
    {}

    ImportGlonassAlmanac::ImportGlonassAlmanac(const std::string& path)
      : CommandBase(CmdName)
    {

      setPath(path);
    }


    ImportGlonassAlmanacPtr ImportGlonassAlmanac::create(const std::string& path)
    {
      return std::make_shared<ImportGlonassAlmanac>(path);
    }

    ImportGlonassAlmanacPtr ImportGlonassAlmanac::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportGlonassAlmanac>(ptr);
    }

    bool ImportGlonassAlmanac::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportGlonassAlmanac::documentation() const { return Documentation; }


    int ImportGlonassAlmanac::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportGlonassAlmanac::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportGlonassAlmanac::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportNmeaTrack
///
#include "gen/ImportNmeaTrack.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportNmeaTrack::CmdName = "ImportNmeaTrack";
    const char* const ImportNmeaTrack::Documentation = "Import NMEA track file";

    REGISTER_COMMAND_FACTORY(ImportNmeaTrack);


    ImportNmeaTrack::ImportNmeaTrack()
      : CommandBase(CmdName)
    {}

    ImportNmeaTrack::ImportNmeaTrack(const std::string& path)
      : CommandBase(CmdName)
    {

      setPath(path);
    }


    ImportNmeaTrackPtr ImportNmeaTrack::create(const std::string& path)
    {
      return std::make_shared<ImportNmeaTrack>(path);
    }

    ImportNmeaTrackPtr ImportNmeaTrack::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportNmeaTrack>(ptr);
    }

    bool ImportNmeaTrack::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportNmeaTrack::documentation() const { return Documentation; }


    int ImportNmeaTrack::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportNmeaTrack::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportNmeaTrack::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearVehiculeTrajectory
///
#include "gen/ClearVehiculeTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearVehiculeTrajectory::CmdName = "ClearVehiculeTrajectory";
    const char* const ClearVehiculeTrajectory::Documentation = "Clear NMEA trajectory file";

    REGISTER_COMMAND_FACTORY(ClearVehiculeTrajectory);


    ClearVehiculeTrajectory::ClearVehiculeTrajectory()
      : CommandBase(CmdName)
    {

    }


    ClearVehiculeTrajectoryPtr ClearVehiculeTrajectory::create()
    {
      return std::make_shared<ClearVehiculeTrajectory>();
    }

    ClearVehiculeTrajectoryPtr ClearVehiculeTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearVehiculeTrajectory>(ptr);
    }

    bool ClearVehiculeTrajectory::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearVehiculeTrajectory::documentation() const { return Documentation; }


    int ClearVehiculeTrajectory::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of SetDefaultVehicleAntennaModel
///
#include "gen/SetDefaultVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetDefaultVehicleAntennaModel::CmdName = "SetDefaultVehicleAntennaModel";
    const char* const SetDefaultVehicleAntennaModel::Documentation = "Set the default vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(SetDefaultVehicleAntennaModel);


    SetDefaultVehicleAntennaModel::SetDefaultVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    SetDefaultVehicleAntennaModel::SetDefaultVehicleAntennaModel(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    SetDefaultVehicleAntennaModelPtr SetDefaultVehicleAntennaModel::create(const std::string& name)
    {
      return std::make_shared<SetDefaultVehicleAntennaModel>(name);
    }

    SetDefaultVehicleAntennaModelPtr SetDefaultVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetDefaultVehicleAntennaModel>(ptr);
    }

    bool SetDefaultVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string SetDefaultVehicleAntennaModel::documentation() const { return Documentation; }


    int SetDefaultVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetDefaultVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void SetDefaultVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetDefaultVehicleAntennaModel
///
#include "gen/GetDefaultVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDefaultVehicleAntennaModel::CmdName = "GetDefaultVehicleAntennaModel";
    const char* const GetDefaultVehicleAntennaModel::Documentation = "Get the default vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(GetDefaultVehicleAntennaModel);


    GetDefaultVehicleAntennaModel::GetDefaultVehicleAntennaModel()
      : CommandBase(CmdName)
    {

    }


    GetDefaultVehicleAntennaModelPtr GetDefaultVehicleAntennaModel::create()
    {
      return std::make_shared<GetDefaultVehicleAntennaModel>();
    }

    GetDefaultVehicleAntennaModelPtr GetDefaultVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDefaultVehicleAntennaModel>(ptr);
    }

    bool GetDefaultVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetDefaultVehicleAntennaModel::documentation() const { return Documentation; }


    int GetDefaultVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetDefaultVehicleAntennaModelResult
///
#include "gen/GetDefaultVehicleAntennaModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDefaultVehicleAntennaModelResult::CmdName = "GetDefaultVehicleAntennaModelResult";
    const char* const GetDefaultVehicleAntennaModelResult::Documentation = "Result of GetDefaultVehicleAntennaModel.";

    REGISTER_COMMAND_RESULT_FACTORY(GetDefaultVehicleAntennaModelResult);


    GetDefaultVehicleAntennaModelResult::GetDefaultVehicleAntennaModelResult()
      : CommandResult(CmdName)
    {}

    GetDefaultVehicleAntennaModelResult::GetDefaultVehicleAntennaModelResult(CommandBasePtr relatedCommand, const std::string& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setName(name);
    }


    GetDefaultVehicleAntennaModelResultPtr GetDefaultVehicleAntennaModelResult::create(CommandBasePtr relatedCommand, const std::string& name)
    {
      return std::make_shared<GetDefaultVehicleAntennaModelResult>(relatedCommand, name);
    }

    GetDefaultVehicleAntennaModelResultPtr GetDefaultVehicleAntennaModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDefaultVehicleAntennaModelResult>(ptr);
    }

    bool GetDefaultVehicleAntennaModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string GetDefaultVehicleAntennaModelResult::documentation() const { return Documentation; }


    std::string GetDefaultVehicleAntennaModelResult::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void GetDefaultVehicleAntennaModelResult::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllVehicleAntennaNames
///
#include "gen/GetAllVehicleAntennaNames.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllVehicleAntennaNames::CmdName = "GetAllVehicleAntennaNames";
    const char* const GetAllVehicleAntennaNames::Documentation = "Get a list of all vehicle antenna names";

    REGISTER_COMMAND_FACTORY(GetAllVehicleAntennaNames);


    GetAllVehicleAntennaNames::GetAllVehicleAntennaNames()
      : CommandBase(CmdName)
    {

    }


    GetAllVehicleAntennaNamesPtr GetAllVehicleAntennaNames::create()
    {
      return std::make_shared<GetAllVehicleAntennaNames>();
    }

    GetAllVehicleAntennaNamesPtr GetAllVehicleAntennaNames::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllVehicleAntennaNames>(ptr);
    }

    bool GetAllVehicleAntennaNames::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAllVehicleAntennaNames::documentation() const { return Documentation; }


    int GetAllVehicleAntennaNames::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAllVehicleAntennaNamesResult
///
#include "gen/GetAllVehicleAntennaNamesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllVehicleAntennaNamesResult::CmdName = "GetAllVehicleAntennaNamesResult";
    const char* const GetAllVehicleAntennaNamesResult::Documentation = "Result of GetAllVehicleAntennaNames.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllVehicleAntennaNamesResult);


    GetAllVehicleAntennaNamesResult::GetAllVehicleAntennaNamesResult()
      : CommandResult(CmdName)
    {}

    GetAllVehicleAntennaNamesResult::GetAllVehicleAntennaNamesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& antennaNames)
      : CommandResult(CmdName, relatedCommand)
    {

      setAntennaNames(antennaNames);
    }


    GetAllVehicleAntennaNamesResultPtr GetAllVehicleAntennaNamesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& antennaNames)
    {
      return std::make_shared<GetAllVehicleAntennaNamesResult>(relatedCommand, antennaNames);
    }

    GetAllVehicleAntennaNamesResultPtr GetAllVehicleAntennaNamesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllVehicleAntennaNamesResult>(ptr);
    }

    bool GetAllVehicleAntennaNamesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaNames"])
        ;

    }

    std::string GetAllVehicleAntennaNamesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllVehicleAntennaNamesResult::antennaNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaNames"]);
    }

    void GetAllVehicleAntennaNamesResult::setAntennaNames(const std::vector<std::string>& antennaNames)
    {
      m_values.AddMember("AntennaNames", parse_json<std::vector<std::string>>::format(antennaNames, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaGain
///
#include "gen/SetVehicleAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaGain::CmdName = "SetVehicleAntennaGain";
    const char* const SetVehicleAntennaGain::Documentation = "Set Vehicle gain antenna pattern. If no name is specified, the command is aplied to Basic vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaGain);


    SetVehicleAntennaGain::SetVehicleAntennaGain()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaGain::SetVehicleAntennaGain(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setGain(gain);
      setType(type);
      setBand(band);
      setName(name);
    }


    SetVehicleAntennaGainPtr SetVehicleAntennaGain::create(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<SetVehicleAntennaGain>(gain, type, band, name);
    }

    SetVehicleAntennaGainPtr SetVehicleAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaGain>(ptr);
    }

    bool SetVehicleAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaGain::documentation() const { return Documentation; }


    int SetVehicleAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetVehicleAntennaGain::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void SetVehicleAntennaGain::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetVehicleAntennaGain::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetVehicleAntennaGain::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetVehicleAntennaGain::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetVehicleAntennaGain::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaGain::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaGain::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaGain
///
#include "gen/GetVehicleAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaGain::CmdName = "GetVehicleAntennaGain";
    const char* const GetVehicleAntennaGain::Documentation = "Get Vehicle gain antenna pattern. If no name is specified, the command is aplied to Basic vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(GetVehicleAntennaGain);


    GetVehicleAntennaGain::GetVehicleAntennaGain()
      : CommandBase(CmdName)
    {}

    GetVehicleAntennaGain::GetVehicleAntennaGain(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setBand(band);
      setName(name);
    }


    GetVehicleAntennaGainPtr GetVehicleAntennaGain::create(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetVehicleAntennaGain>(band, name);
    }

    GetVehicleAntennaGainPtr GetVehicleAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaGain>(ptr);
    }

    bool GetVehicleAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaGain::documentation() const { return Documentation; }


    int GetVehicleAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetVehicleAntennaGain::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleAntennaGain::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaGain::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaGain::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaGainResult
///
#include "gen/GetVehicleAntennaGainResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaGainResult::CmdName = "GetVehicleAntennaGainResult";
    const char* const GetVehicleAntennaGainResult::Documentation = "Result of GetVehicleAntennaGain.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleAntennaGainResult);


    GetVehicleAntennaGainResult::GetVehicleAntennaGainResult()
      : CommandResult(CmdName)
    {}

    GetVehicleAntennaGainResult::GetVehicleAntennaGainResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
      setType(type);
      setBand(band);
      setName(name);
    }


    GetVehicleAntennaGainResultPtr GetVehicleAntennaGainResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetVehicleAntennaGainResult>(relatedCommand, gain, type, band, name);
    }

    GetVehicleAntennaGainResultPtr GetVehicleAntennaGainResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaGainResult>(ptr);
    }

    bool GetVehicleAntennaGainResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaGainResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetVehicleAntennaGainResult::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void GetVehicleAntennaGainResult::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaGainResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetVehicleAntennaGainResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand GetVehicleAntennaGainResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleAntennaGainResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaGainResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaGainResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaPhaseOffset
///
#include "gen/SetVehicleAntennaPhaseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaPhaseOffset::CmdName = "SetVehicleAntennaPhaseOffset";
    const char* const SetVehicleAntennaPhaseOffset::Documentation = "Set Vehicle phase offset antenna pattern. If no name is specified, the command is aplied to Basic Vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaPhaseOffset);


    SetVehicleAntennaPhaseOffset::SetVehicleAntennaPhaseOffset()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaPhaseOffset::SetVehicleAntennaPhaseOffset(const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setPhaseOffset(phaseOffset);
      setType(type);
      setBand(band);
      setName(name);
    }


    SetVehicleAntennaPhaseOffsetPtr SetVehicleAntennaPhaseOffset::create(const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<SetVehicleAntennaPhaseOffset>(phaseOffset, type, band, name);
    }

    SetVehicleAntennaPhaseOffsetPtr SetVehicleAntennaPhaseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaPhaseOffset>(ptr);
    }

    bool SetVehicleAntennaPhaseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffset"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaPhaseOffset::documentation() const { return Documentation; }


    int SetVehicleAntennaPhaseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetVehicleAntennaPhaseOffset::phaseOffset() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffset"]);
    }

    void SetVehicleAntennaPhaseOffset::setPhaseOffset(const std::vector<std::vector<double>>& phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<std::vector<std::vector<double>>>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetVehicleAntennaPhaseOffset::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetVehicleAntennaPhaseOffset::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetVehicleAntennaPhaseOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetVehicleAntennaPhaseOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaPhaseOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaPhaseOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaPhaseOffset
///
#include "gen/GetVehicleAntennaPhaseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaPhaseOffset::CmdName = "GetVehicleAntennaPhaseOffset";
    const char* const GetVehicleAntennaPhaseOffset::Documentation = "Get Vehicle phase offset antenna pattern. If no name is specified, the command is aplied to Basic Vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(GetVehicleAntennaPhaseOffset);


    GetVehicleAntennaPhaseOffset::GetVehicleAntennaPhaseOffset()
      : CommandBase(CmdName)
    {}

    GetVehicleAntennaPhaseOffset::GetVehicleAntennaPhaseOffset(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setBand(band);
      setName(name);
    }


    GetVehicleAntennaPhaseOffsetPtr GetVehicleAntennaPhaseOffset::create(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetVehicleAntennaPhaseOffset>(band, name);
    }

    GetVehicleAntennaPhaseOffsetPtr GetVehicleAntennaPhaseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaPhaseOffset>(ptr);
    }

    bool GetVehicleAntennaPhaseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaPhaseOffset::documentation() const { return Documentation; }


    int GetVehicleAntennaPhaseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetVehicleAntennaPhaseOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleAntennaPhaseOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaPhaseOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaPhaseOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaPhaseOffsetResult
///
#include "gen/GetVehicleAntennaPhaseOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaPhaseOffsetResult::CmdName = "GetVehicleAntennaPhaseOffsetResult";
    const char* const GetVehicleAntennaPhaseOffsetResult::Documentation = "Result of GetVehicleAntennaPhaseOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleAntennaPhaseOffsetResult);


    GetVehicleAntennaPhaseOffsetResult::GetVehicleAntennaPhaseOffsetResult()
      : CommandResult(CmdName)
    {}

    GetVehicleAntennaPhaseOffsetResult::GetVehicleAntennaPhaseOffsetResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setPhaseOffset(phaseOffset);
      setType(type);
      setBand(band);
      setName(name);
    }


    GetVehicleAntennaPhaseOffsetResultPtr GetVehicleAntennaPhaseOffsetResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetVehicleAntennaPhaseOffsetResult>(relatedCommand, phaseOffset, type, band, name);
    }

    GetVehicleAntennaPhaseOffsetResultPtr GetVehicleAntennaPhaseOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaPhaseOffsetResult>(ptr);
    }

    bool GetVehicleAntennaPhaseOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffset"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaPhaseOffsetResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetVehicleAntennaPhaseOffsetResult::phaseOffset() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffset"]);
    }

    void GetVehicleAntennaPhaseOffsetResult::setPhaseOffset(const std::vector<std::vector<double>>& phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<std::vector<std::vector<double>>>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaPhaseOffsetResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetVehicleAntennaPhaseOffsetResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand GetVehicleAntennaPhaseOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleAntennaPhaseOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaPhaseOffsetResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaPhaseOffsetResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaGainCSV
///
#include "gen/SetVehicleAntennaGainCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaGainCSV::CmdName = "SetVehicleAntennaGainCSV";
    const char* const SetVehicleAntennaGainCSV::Documentation = "Set vehicle gain antenna pattern from a CSV file. If no name is specified, the command is aplied to Basic vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaGainCSV);


    SetVehicleAntennaGainCSV::SetVehicleAntennaGainCSV()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaGainCSV::SetVehicleAntennaGainCSV(const std::string& filePath, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setType(type);
      setBand(band);
      setName(name);
    }


    SetVehicleAntennaGainCSVPtr SetVehicleAntennaGainCSV::create(const std::string& filePath, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<SetVehicleAntennaGainCSV>(filePath, type, band, name);
    }

    SetVehicleAntennaGainCSVPtr SetVehicleAntennaGainCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaGainCSV>(ptr);
    }

    bool SetVehicleAntennaGainCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaGainCSV::documentation() const { return Documentation; }


    int SetVehicleAntennaGainCSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleAntennaGainCSV::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void SetVehicleAntennaGainCSV::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetVehicleAntennaGainCSV::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetVehicleAntennaGainCSV::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetVehicleAntennaGainCSV::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetVehicleAntennaGainCSV::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaGainCSV::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaGainCSV::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaPhaseOffsetCSV
///
#include "gen/SetVehicleAntennaPhaseOffsetCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaPhaseOffsetCSV::CmdName = "SetVehicleAntennaPhaseOffsetCSV";
    const char* const SetVehicleAntennaPhaseOffsetCSV::Documentation = "Set vehicle phase offset antenna pattern from a CSV file. If no name is specified, the command is aplied to Basic vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaPhaseOffsetCSV);


    SetVehicleAntennaPhaseOffsetCSV::SetVehicleAntennaPhaseOffsetCSV()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaPhaseOffsetCSV::SetVehicleAntennaPhaseOffsetCSV(const std::string& filePath, const Sdx::AntennaPatternFileType& fileFormat, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setFileFormat(fileFormat);
      setType(type);
      setBand(band);
      setName(name);
    }


    SetVehicleAntennaPhaseOffsetCSVPtr SetVehicleAntennaPhaseOffsetCSV::create(const std::string& filePath, const Sdx::AntennaPatternFileType& fileFormat, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<SetVehicleAntennaPhaseOffsetCSV>(filePath, fileFormat, type, band, name);
    }

    SetVehicleAntennaPhaseOffsetCSVPtr SetVehicleAntennaPhaseOffsetCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaPhaseOffsetCSV>(ptr);
    }

    bool SetVehicleAntennaPhaseOffsetCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<Sdx::AntennaPatternFileType>::is_valid(m_values["FileFormat"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaPhaseOffsetCSV::documentation() const { return Documentation; }


    int SetVehicleAntennaPhaseOffsetCSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleAntennaPhaseOffsetCSV::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternFileType SetVehicleAntennaPhaseOffsetCSV::fileFormat() const
    {
      return parse_json<Sdx::AntennaPatternFileType>::parse(m_values["FileFormat"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setFileFormat(const Sdx::AntennaPatternFileType& fileFormat)
    {
      m_values.AddMember("FileFormat", parse_json<Sdx::AntennaPatternFileType>::format(fileFormat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetVehicleAntennaPhaseOffsetCSV::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetVehicleAntennaPhaseOffsetCSV::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaPhaseOffsetCSV::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddVehicleGainPatternOffset
///
#include "gen/AddVehicleGainPatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddVehicleGainPatternOffset::CmdName = "AddVehicleGainPatternOffset";
    const char* const AddVehicleGainPatternOffset::Documentation = "Add an offset (in db) for all values of the pattern.";

    REGISTER_COMMAND_FACTORY(AddVehicleGainPatternOffset);


    AddVehicleGainPatternOffset::AddVehicleGainPatternOffset()
      : CommandBase(CmdName)
    {}

    AddVehicleGainPatternOffset::AddVehicleGainPatternOffset(const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    AddVehicleGainPatternOffsetPtr AddVehicleGainPatternOffset::create(const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<AddVehicleGainPatternOffset>(band, offset, antennaName);
    }

    AddVehicleGainPatternOffsetPtr AddVehicleGainPatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddVehicleGainPatternOffset>(ptr);
    }

    bool AddVehicleGainPatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string AddVehicleGainPatternOffset::documentation() const { return Documentation; }


    int AddVehicleGainPatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand AddVehicleGainPatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void AddVehicleGainPatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddVehicleGainPatternOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void AddVehicleGainPatternOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> AddVehicleGainPatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void AddVehicleGainPatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleGainPatternOffset
///
#include "gen/GetVehicleGainPatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleGainPatternOffset::CmdName = "GetVehicleGainPatternOffset";
    const char* const GetVehicleGainPatternOffset::Documentation = "Get the offset (in dB) for the antenna gain pattern of the band.";

    REGISTER_COMMAND_FACTORY(GetVehicleGainPatternOffset);


    GetVehicleGainPatternOffset::GetVehicleGainPatternOffset()
      : CommandBase(CmdName)
    {}

    GetVehicleGainPatternOffset::GetVehicleGainPatternOffset(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setAntennaName(antennaName);
    }


    GetVehicleGainPatternOffsetPtr GetVehicleGainPatternOffset::create(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<GetVehicleGainPatternOffset>(band, antennaName);
    }

    GetVehicleGainPatternOffsetPtr GetVehicleGainPatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleGainPatternOffset>(ptr);
    }

    bool GetVehicleGainPatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetVehicleGainPatternOffset::documentation() const { return Documentation; }


    int GetVehicleGainPatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetVehicleGainPatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleGainPatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleGainPatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetVehicleGainPatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleGainPatternOffsetResult
///
#include "gen/GetVehicleGainPatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleGainPatternOffsetResult::CmdName = "GetVehicleGainPatternOffsetResult";
    const char* const GetVehicleGainPatternOffsetResult::Documentation = "Result of GetVehicleGainPatternOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleGainPatternOffsetResult);


    GetVehicleGainPatternOffsetResult::GetVehicleGainPatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetVehicleGainPatternOffsetResult::GetVehicleGainPatternOffsetResult(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    GetVehicleGainPatternOffsetResultPtr GetVehicleGainPatternOffsetResult::create(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<GetVehicleGainPatternOffsetResult>(relatedCommand, band, offset, antennaName);
    }

    GetVehicleGainPatternOffsetResultPtr GetVehicleGainPatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleGainPatternOffsetResult>(ptr);
    }

    bool GetVehicleGainPatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetVehicleGainPatternOffsetResult::documentation() const { return Documentation; }


    Sdx::GNSSBand GetVehicleGainPatternOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleGainPatternOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleGainPatternOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetVehicleGainPatternOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleGainPatternOffsetResult::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetVehicleGainPatternOffsetResult::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddVehiclePhasePatternOffset
///
#include "gen/AddVehiclePhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddVehiclePhasePatternOffset::CmdName = "AddVehiclePhasePatternOffset";
    const char* const AddVehiclePhasePatternOffset::Documentation = "Add an offset (in rad) for all values of the phase pattern.";

    REGISTER_COMMAND_FACTORY(AddVehiclePhasePatternOffset);


    AddVehiclePhasePatternOffset::AddVehiclePhasePatternOffset()
      : CommandBase(CmdName)
    {}

    AddVehiclePhasePatternOffset::AddVehiclePhasePatternOffset(const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    AddVehiclePhasePatternOffsetPtr AddVehiclePhasePatternOffset::create(const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<AddVehiclePhasePatternOffset>(band, offset, antennaName);
    }

    AddVehiclePhasePatternOffsetPtr AddVehiclePhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddVehiclePhasePatternOffset>(ptr);
    }

    bool AddVehiclePhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string AddVehiclePhasePatternOffset::documentation() const { return Documentation; }


    int AddVehiclePhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand AddVehiclePhasePatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void AddVehiclePhasePatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddVehiclePhasePatternOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void AddVehiclePhasePatternOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> AddVehiclePhasePatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void AddVehiclePhasePatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehiclePhasePatternOffset
///
#include "gen/GetVehiclePhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehiclePhasePatternOffset::CmdName = "GetVehiclePhasePatternOffset";
    const char* const GetVehiclePhasePatternOffset::Documentation = "Get the offset (in rad) for the antenna phase pattern of the band.";

    REGISTER_COMMAND_FACTORY(GetVehiclePhasePatternOffset);


    GetVehiclePhasePatternOffset::GetVehiclePhasePatternOffset()
      : CommandBase(CmdName)
    {}

    GetVehiclePhasePatternOffset::GetVehiclePhasePatternOffset(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setAntennaName(antennaName);
    }


    GetVehiclePhasePatternOffsetPtr GetVehiclePhasePatternOffset::create(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<GetVehiclePhasePatternOffset>(band, antennaName);
    }

    GetVehiclePhasePatternOffsetPtr GetVehiclePhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehiclePhasePatternOffset>(ptr);
    }

    bool GetVehiclePhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetVehiclePhasePatternOffset::documentation() const { return Documentation; }


    int GetVehiclePhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetVehiclePhasePatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehiclePhasePatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehiclePhasePatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetVehiclePhasePatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehiclePhasePatternOffsetResult
///
#include "gen/GetVehiclePhasePatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehiclePhasePatternOffsetResult::CmdName = "GetVehiclePhasePatternOffsetResult";
    const char* const GetVehiclePhasePatternOffsetResult::Documentation = "Result of GetVehiclePhasePatternOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehiclePhasePatternOffsetResult);


    GetVehiclePhasePatternOffsetResult::GetVehiclePhasePatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetVehiclePhasePatternOffsetResult::GetVehiclePhasePatternOffsetResult(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    GetVehiclePhasePatternOffsetResultPtr GetVehiclePhasePatternOffsetResult::create(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<GetVehiclePhasePatternOffsetResult>(relatedCommand, band, offset, antennaName);
    }

    GetVehiclePhasePatternOffsetResultPtr GetVehiclePhasePatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehiclePhasePatternOffsetResult>(ptr);
    }

    bool GetVehiclePhasePatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetVehiclePhasePatternOffsetResult::documentation() const { return Documentation; }


    Sdx::GNSSBand GetVehiclePhasePatternOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehiclePhasePatternOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehiclePhasePatternOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetVehiclePhasePatternOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehiclePhasePatternOffsetResult::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetVehiclePhasePatternOffsetResult::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaOffset
///
#include "gen/SetVehicleAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaOffset::CmdName = "SetVehicleAntennaOffset";
    const char* const SetVehicleAntennaOffset::Documentation = "Set antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the vehicle trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaOffset);


    SetVehicleAntennaOffset::SetVehicleAntennaOffset()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaOffset::SetVehicleAntennaOffset(double x, double y, double z, double yaw, double pitch, double roll, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setName(name);
    }


    SetVehicleAntennaOffsetPtr SetVehicleAntennaOffset::create(double x, double y, double z, double yaw, double pitch, double roll, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<SetVehicleAntennaOffset>(x, y, z, yaw, pitch, roll, name);
    }

    SetVehicleAntennaOffsetPtr SetVehicleAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaOffset>(ptr);
    }

    bool SetVehicleAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaOffset::documentation() const { return Documentation; }


    int SetVehicleAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetVehicleAntennaOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetVehicleAntennaOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetVehicleAntennaOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetVehicleAntennaOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetVehicleAntennaOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetVehicleAntennaOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetVehicleAntennaOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaOffset
///
#include "gen/GetVehicleAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaOffset::CmdName = "GetVehicleAntennaOffset";
    const char* const GetVehicleAntennaOffset::Documentation = "Get the vehicle antenna offset infos. If no name is specified, the default vehicle antenna is get.";

    REGISTER_COMMAND_FACTORY(GetVehicleAntennaOffset);


    GetVehicleAntennaOffset::GetVehicleAntennaOffset(const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    GetVehicleAntennaOffsetPtr GetVehicleAntennaOffset::create(const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetVehicleAntennaOffset>(name);
    }

    GetVehicleAntennaOffsetPtr GetVehicleAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaOffset>(ptr);
    }

    bool GetVehicleAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaOffset::documentation() const { return Documentation; }


    int GetVehicleAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::optional<std::string> GetVehicleAntennaOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaOffsetResult
///
#include "gen/GetVehicleAntennaOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaOffsetResult::CmdName = "GetVehicleAntennaOffsetResult";
    const char* const GetVehicleAntennaOffsetResult::Documentation = "Result of GetVehicleAntennaOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleAntennaOffsetResult);


    GetVehicleAntennaOffsetResult::GetVehicleAntennaOffsetResult()
      : CommandResult(CmdName)
    {}

    GetVehicleAntennaOffsetResult::GetVehicleAntennaOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setName(name);
    }


    GetVehicleAntennaOffsetResultPtr GetVehicleAntennaOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetVehicleAntennaOffsetResult>(relatedCommand, x, y, z, yaw, pitch, roll, name);
    }

    GetVehicleAntennaOffsetResultPtr GetVehicleAntennaOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaOffsetResult>(ptr);
    }

    bool GetVehicleAntennaOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaOffsetResult::documentation() const { return Documentation; }


    double GetVehicleAntennaOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetVehicleAntennaOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetVehicleAntennaOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetVehicleAntennaOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetVehicleAntennaOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetVehicleAntennaOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetVehicleAntennaOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaOffsetResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaOffsetResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddEmptyVehicleAntennaModel
///
#include "gen/AddEmptyVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddEmptyVehicleAntennaModel::CmdName = "AddEmptyVehicleAntennaModel";
    const char* const AddEmptyVehicleAntennaModel::Documentation = "Create an empty vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(AddEmptyVehicleAntennaModel);


    AddEmptyVehicleAntennaModel::AddEmptyVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    AddEmptyVehicleAntennaModel::AddEmptyVehicleAntennaModel(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    AddEmptyVehicleAntennaModelPtr AddEmptyVehicleAntennaModel::create(const std::string& name)
    {
      return std::make_shared<AddEmptyVehicleAntennaModel>(name);
    }

    AddEmptyVehicleAntennaModelPtr AddEmptyVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddEmptyVehicleAntennaModel>(ptr);
    }

    bool AddEmptyVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string AddEmptyVehicleAntennaModel::documentation() const { return Documentation; }


    int AddEmptyVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddEmptyVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void AddEmptyVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of DeleteVehicleAntennaModel
///
#include "gen/DeleteVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const DeleteVehicleAntennaModel::CmdName = "DeleteVehicleAntennaModel";
    const char* const DeleteVehicleAntennaModel::Documentation = "Delete a vehicle antenna model. The default vehicle antenna model can't be deleted.";

    REGISTER_COMMAND_FACTORY(DeleteVehicleAntennaModel);


    DeleteVehicleAntennaModel::DeleteVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    DeleteVehicleAntennaModel::DeleteVehicleAntennaModel(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    DeleteVehicleAntennaModelPtr DeleteVehicleAntennaModel::create(const std::string& name)
    {
      return std::make_shared<DeleteVehicleAntennaModel>(name);
    }

    DeleteVehicleAntennaModelPtr DeleteVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<DeleteVehicleAntennaModel>(ptr);
    }

    bool DeleteVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string DeleteVehicleAntennaModel::documentation() const { return Documentation; }


    int DeleteVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string DeleteVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void DeleteVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RenameVehicleAntennaModel
///
#include "gen/RenameVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RenameVehicleAntennaModel::CmdName = "RenameVehicleAntennaModel";
    const char* const RenameVehicleAntennaModel::Documentation = "Rename a vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(RenameVehicleAntennaModel);


    RenameVehicleAntennaModel::RenameVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    RenameVehicleAntennaModel::RenameVehicleAntennaModel(const std::string& name, const std::string& newName)
      : CommandBase(CmdName)
    {

      setName(name);
      setNewName(newName);
    }


    RenameVehicleAntennaModelPtr RenameVehicleAntennaModel::create(const std::string& name, const std::string& newName)
    {
      return std::make_shared<RenameVehicleAntennaModel>(name, newName);
    }

    RenameVehicleAntennaModelPtr RenameVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RenameVehicleAntennaModel>(ptr);
    }

    bool RenameVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["NewName"])
        ;

    }

    std::string RenameVehicleAntennaModel::documentation() const { return Documentation; }


    int RenameVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RenameVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void RenameVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameVehicleAntennaModel::newName() const
    {
      return parse_json<std::string>::parse(m_values["NewName"]);
    }

    void RenameVehicleAntennaModel::setNewName(const std::string& newName)
    {
      m_values.AddMember("NewName", parse_json<std::string>::format(newName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CopyVehicleAntennaModel
///
#include "gen/CopyVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CopyVehicleAntennaModel::CmdName = "CopyVehicleAntennaModel";
    const char* const CopyVehicleAntennaModel::Documentation = "Copy a vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(CopyVehicleAntennaModel);


    CopyVehicleAntennaModel::CopyVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    CopyVehicleAntennaModel::CopyVehicleAntennaModel(const std::string& name, const std::string& copyName)
      : CommandBase(CmdName)
    {

      setName(name);
      setCopyName(copyName);
    }


    CopyVehicleAntennaModelPtr CopyVehicleAntennaModel::create(const std::string& name, const std::string& copyName)
    {
      return std::make_shared<CopyVehicleAntennaModel>(name, copyName);
    }

    CopyVehicleAntennaModelPtr CopyVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CopyVehicleAntennaModel>(ptr);
    }

    bool CopyVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["CopyName"])
        ;

    }

    std::string CopyVehicleAntennaModel::documentation() const { return Documentation; }


    int CopyVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string CopyVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void CopyVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string CopyVehicleAntennaModel::copyName() const
    {
      return parse_json<std::string>::parse(m_values["CopyName"]);
    }

    void CopyVehicleAntennaModel::setCopyName(const std::string& copyName)
    {
      m_values.AddMember("CopyName", parse_json<std::string>::format(copyName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaModel
///
#include "gen/GetVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaModel::CmdName = "GetVehicleAntennaModel";
    const char* const GetVehicleAntennaModel::Documentation = "Get  all infos about this antenna model.";

    REGISTER_COMMAND_FACTORY(GetVehicleAntennaModel);


    GetVehicleAntennaModel::GetVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    GetVehicleAntennaModel::GetVehicleAntennaModel(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    GetVehicleAntennaModelPtr GetVehicleAntennaModel::create(const std::string& name)
    {
      return std::make_shared<GetVehicleAntennaModel>(name);
    }

    GetVehicleAntennaModelPtr GetVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaModel>(ptr);
    }

    bool GetVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaModel::documentation() const { return Documentation; }


    int GetVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaModelResult
///
#include "gen/GetVehicleAntennaModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaModelResult::CmdName = "GetVehicleAntennaModelResult";
    const char* const GetVehicleAntennaModelResult::Documentation = "Result of GetVehicleAntennaModel.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleAntennaModelResult);


    GetVehicleAntennaModelResult::GetVehicleAntennaModelResult()
      : CommandResult(CmdName)
    {}

    GetVehicleAntennaModelResult::GetVehicleAntennaModelResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gainL1, const Sdx::AntennaPatternType& gainTypeL1, double gainOffsetL1, const std::vector<std::vector<double>>& gainL2, const Sdx::AntennaPatternType& gainTypeL2, double gainOffsetL2, const std::vector<std::vector<double>>& gainL5, const Sdx::AntennaPatternType& gainTypeL5, double gainOffsetL5, const std::vector<std::vector<double>>& gainE6, const Sdx::AntennaPatternType& gainTypeE6, double gainOffsetE6, const std::vector<std::vector<double>>& phaseOffsetL1, const Sdx::AntennaPatternType& phaseOffsetTypeL1, double phasePatternOffsetL1, const std::vector<std::vector<double>>& phaseOffsetL2, const Sdx::AntennaPatternType& phaseOffsetTypeL2, double phasePatternOffsetL2, const std::vector<std::vector<double>>& phaseOffsetL5, const Sdx::AntennaPatternType& phaseOffsetTypeL5, double phasePatternOffsetL5, const std::vector<std::vector<double>>& phaseOffsetE6, const Sdx::AntennaPatternType& phaseOffsetTypeE6, double phasePatternOffsetE6, double x, double y, double z, double yaw, double pitch, double roll, const std::string& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setGainL1(gainL1);
      setGainTypeL1(gainTypeL1);
      setGainOffsetL1(gainOffsetL1);
      setGainL2(gainL2);
      setGainTypeL2(gainTypeL2);
      setGainOffsetL2(gainOffsetL2);
      setGainL5(gainL5);
      setGainTypeL5(gainTypeL5);
      setGainOffsetL5(gainOffsetL5);
      setGainE6(gainE6);
      setGainTypeE6(gainTypeE6);
      setGainOffsetE6(gainOffsetE6);
      setPhaseOffsetL1(phaseOffsetL1);
      setPhaseOffsetTypeL1(phaseOffsetTypeL1);
      setPhasePatternOffsetL1(phasePatternOffsetL1);
      setPhaseOffsetL2(phaseOffsetL2);
      setPhaseOffsetTypeL2(phaseOffsetTypeL2);
      setPhasePatternOffsetL2(phasePatternOffsetL2);
      setPhaseOffsetL5(phaseOffsetL5);
      setPhaseOffsetTypeL5(phaseOffsetTypeL5);
      setPhasePatternOffsetL5(phasePatternOffsetL5);
      setPhaseOffsetE6(phaseOffsetE6);
      setPhaseOffsetTypeE6(phaseOffsetTypeE6);
      setPhasePatternOffsetE6(phasePatternOffsetE6);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setName(name);
    }


    GetVehicleAntennaModelResultPtr GetVehicleAntennaModelResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gainL1, const Sdx::AntennaPatternType& gainTypeL1, double gainOffsetL1, const std::vector<std::vector<double>>& gainL2, const Sdx::AntennaPatternType& gainTypeL2, double gainOffsetL2, const std::vector<std::vector<double>>& gainL5, const Sdx::AntennaPatternType& gainTypeL5, double gainOffsetL5, const std::vector<std::vector<double>>& gainE6, const Sdx::AntennaPatternType& gainTypeE6, double gainOffsetE6, const std::vector<std::vector<double>>& phaseOffsetL1, const Sdx::AntennaPatternType& phaseOffsetTypeL1, double phasePatternOffsetL1, const std::vector<std::vector<double>>& phaseOffsetL2, const Sdx::AntennaPatternType& phaseOffsetTypeL2, double phasePatternOffsetL2, const std::vector<std::vector<double>>& phaseOffsetL5, const Sdx::AntennaPatternType& phaseOffsetTypeL5, double phasePatternOffsetL5, const std::vector<std::vector<double>>& phaseOffsetE6, const Sdx::AntennaPatternType& phaseOffsetTypeE6, double phasePatternOffsetE6, double x, double y, double z, double yaw, double pitch, double roll, const std::string& name)
    {
      return std::make_shared<GetVehicleAntennaModelResult>(relatedCommand, gainL1, gainTypeL1, gainOffsetL1, gainL2, gainTypeL2, gainOffsetL2, gainL5, gainTypeL5, gainOffsetL5, gainE6, gainTypeE6, gainOffsetE6, phaseOffsetL1, phaseOffsetTypeL1, phasePatternOffsetL1, phaseOffsetL2, phaseOffsetTypeL2, phasePatternOffsetL2, phaseOffsetL5, phaseOffsetTypeL5, phasePatternOffsetL5, phaseOffsetE6, phaseOffsetTypeE6, phasePatternOffsetE6, x, y, z, yaw, pitch, roll, name);
    }

    GetVehicleAntennaModelResultPtr GetVehicleAntennaModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaModelResult>(ptr);
    }

    bool GetVehicleAntennaModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["GainL1"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["GainTypeL1"])
          && parse_json<double>::is_valid(m_values["GainOffsetL1"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["GainL2"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["GainTypeL2"])
          && parse_json<double>::is_valid(m_values["GainOffsetL2"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["GainL5"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["GainTypeL5"])
          && parse_json<double>::is_valid(m_values["GainOffsetL5"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["GainE6"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["GainTypeE6"])
          && parse_json<double>::is_valid(m_values["GainOffsetE6"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffsetL1"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["PhaseOffsetTypeL1"])
          && parse_json<double>::is_valid(m_values["PhasePatternOffsetL1"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffsetL2"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["PhaseOffsetTypeL2"])
          && parse_json<double>::is_valid(m_values["PhasePatternOffsetL2"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffsetL5"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["PhaseOffsetTypeL5"])
          && parse_json<double>::is_valid(m_values["PhasePatternOffsetL5"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffsetE6"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["PhaseOffsetTypeE6"])
          && parse_json<double>::is_valid(m_values["PhasePatternOffsetE6"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaModelResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetVehicleAntennaModelResult::gainL1() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["GainL1"]);
    }

    void GetVehicleAntennaModelResult::setGainL1(const std::vector<std::vector<double>>& gainL1)
    {
      m_values.AddMember("GainL1", parse_json<std::vector<std::vector<double>>>::format(gainL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::gainTypeL1() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["GainTypeL1"]);
    }

    void GetVehicleAntennaModelResult::setGainTypeL1(const Sdx::AntennaPatternType& gainTypeL1)
    {
      m_values.AddMember("GainTypeL1", parse_json<Sdx::AntennaPatternType>::format(gainTypeL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::gainOffsetL1() const
    {
      return parse_json<double>::parse(m_values["GainOffsetL1"]);
    }

    void GetVehicleAntennaModelResult::setGainOffsetL1(double gainOffsetL1)
    {
      m_values.AddMember("GainOffsetL1", parse_json<double>::format(gainOffsetL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::gainL2() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["GainL2"]);
    }

    void GetVehicleAntennaModelResult::setGainL2(const std::vector<std::vector<double>>& gainL2)
    {
      m_values.AddMember("GainL2", parse_json<std::vector<std::vector<double>>>::format(gainL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::gainTypeL2() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["GainTypeL2"]);
    }

    void GetVehicleAntennaModelResult::setGainTypeL2(const Sdx::AntennaPatternType& gainTypeL2)
    {
      m_values.AddMember("GainTypeL2", parse_json<Sdx::AntennaPatternType>::format(gainTypeL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::gainOffsetL2() const
    {
      return parse_json<double>::parse(m_values["GainOffsetL2"]);
    }

    void GetVehicleAntennaModelResult::setGainOffsetL2(double gainOffsetL2)
    {
      m_values.AddMember("GainOffsetL2", parse_json<double>::format(gainOffsetL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::gainL5() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["GainL5"]);
    }

    void GetVehicleAntennaModelResult::setGainL5(const std::vector<std::vector<double>>& gainL5)
    {
      m_values.AddMember("GainL5", parse_json<std::vector<std::vector<double>>>::format(gainL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::gainTypeL5() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["GainTypeL5"]);
    }

    void GetVehicleAntennaModelResult::setGainTypeL5(const Sdx::AntennaPatternType& gainTypeL5)
    {
      m_values.AddMember("GainTypeL5", parse_json<Sdx::AntennaPatternType>::format(gainTypeL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::gainOffsetL5() const
    {
      return parse_json<double>::parse(m_values["GainOffsetL5"]);
    }

    void GetVehicleAntennaModelResult::setGainOffsetL5(double gainOffsetL5)
    {
      m_values.AddMember("GainOffsetL5", parse_json<double>::format(gainOffsetL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::gainE6() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["GainE6"]);
    }

    void GetVehicleAntennaModelResult::setGainE6(const std::vector<std::vector<double>>& gainE6)
    {
      m_values.AddMember("GainE6", parse_json<std::vector<std::vector<double>>>::format(gainE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::gainTypeE6() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["GainTypeE6"]);
    }

    void GetVehicleAntennaModelResult::setGainTypeE6(const Sdx::AntennaPatternType& gainTypeE6)
    {
      m_values.AddMember("GainTypeE6", parse_json<Sdx::AntennaPatternType>::format(gainTypeE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::gainOffsetE6() const
    {
      return parse_json<double>::parse(m_values["GainOffsetE6"]);
    }

    void GetVehicleAntennaModelResult::setGainOffsetE6(double gainOffsetE6)
    {
      m_values.AddMember("GainOffsetE6", parse_json<double>::format(gainOffsetE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::phaseOffsetL1() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffsetL1"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetL1(const std::vector<std::vector<double>>& phaseOffsetL1)
    {
      m_values.AddMember("PhaseOffsetL1", parse_json<std::vector<std::vector<double>>>::format(phaseOffsetL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::phaseOffsetTypeL1() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["PhaseOffsetTypeL1"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetTypeL1(const Sdx::AntennaPatternType& phaseOffsetTypeL1)
    {
      m_values.AddMember("PhaseOffsetTypeL1", parse_json<Sdx::AntennaPatternType>::format(phaseOffsetTypeL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::phasePatternOffsetL1() const
    {
      return parse_json<double>::parse(m_values["PhasePatternOffsetL1"]);
    }

    void GetVehicleAntennaModelResult::setPhasePatternOffsetL1(double phasePatternOffsetL1)
    {
      m_values.AddMember("PhasePatternOffsetL1", parse_json<double>::format(phasePatternOffsetL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::phaseOffsetL2() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffsetL2"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetL2(const std::vector<std::vector<double>>& phaseOffsetL2)
    {
      m_values.AddMember("PhaseOffsetL2", parse_json<std::vector<std::vector<double>>>::format(phaseOffsetL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::phaseOffsetTypeL2() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["PhaseOffsetTypeL2"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetTypeL2(const Sdx::AntennaPatternType& phaseOffsetTypeL2)
    {
      m_values.AddMember("PhaseOffsetTypeL2", parse_json<Sdx::AntennaPatternType>::format(phaseOffsetTypeL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::phasePatternOffsetL2() const
    {
      return parse_json<double>::parse(m_values["PhasePatternOffsetL2"]);
    }

    void GetVehicleAntennaModelResult::setPhasePatternOffsetL2(double phasePatternOffsetL2)
    {
      m_values.AddMember("PhasePatternOffsetL2", parse_json<double>::format(phasePatternOffsetL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::phaseOffsetL5() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffsetL5"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetL5(const std::vector<std::vector<double>>& phaseOffsetL5)
    {
      m_values.AddMember("PhaseOffsetL5", parse_json<std::vector<std::vector<double>>>::format(phaseOffsetL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::phaseOffsetTypeL5() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["PhaseOffsetTypeL5"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetTypeL5(const Sdx::AntennaPatternType& phaseOffsetTypeL5)
    {
      m_values.AddMember("PhaseOffsetTypeL5", parse_json<Sdx::AntennaPatternType>::format(phaseOffsetTypeL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::phasePatternOffsetL5() const
    {
      return parse_json<double>::parse(m_values["PhasePatternOffsetL5"]);
    }

    void GetVehicleAntennaModelResult::setPhasePatternOffsetL5(double phasePatternOffsetL5)
    {
      m_values.AddMember("PhasePatternOffsetL5", parse_json<double>::format(phasePatternOffsetL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::phaseOffsetE6() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffsetE6"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetE6(const std::vector<std::vector<double>>& phaseOffsetE6)
    {
      m_values.AddMember("PhaseOffsetE6", parse_json<std::vector<std::vector<double>>>::format(phaseOffsetE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::phaseOffsetTypeE6() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["PhaseOffsetTypeE6"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetTypeE6(const Sdx::AntennaPatternType& phaseOffsetTypeE6)
    {
      m_values.AddMember("PhaseOffsetTypeE6", parse_json<Sdx::AntennaPatternType>::format(phaseOffsetTypeE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::phasePatternOffsetE6() const
    {
      return parse_json<double>::parse(m_values["PhasePatternOffsetE6"]);
    }

    void GetVehicleAntennaModelResult::setPhasePatternOffsetE6(double phasePatternOffsetE6)
    {
      m_values.AddMember("PhasePatternOffsetE6", parse_json<double>::format(phasePatternOffsetE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetVehicleAntennaModelResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetVehicleAntennaModelResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetVehicleAntennaModelResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetVehicleAntennaModelResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetVehicleAntennaModelResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetVehicleAntennaModelResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetVehicleAntennaModelResult::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaModelResult::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportVehicleAntennaModel
///
#include "gen/ImportVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportVehicleAntennaModel::CmdName = "ImportVehicleAntennaModel";
    const char* const ImportVehicleAntennaModel::Documentation = "Import a vehicle antenna model from a XML file.";

    REGISTER_COMMAND_FACTORY(ImportVehicleAntennaModel);


    ImportVehicleAntennaModel::ImportVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    ImportVehicleAntennaModel::ImportVehicleAntennaModel(const std::string& filePath)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
    }


    ImportVehicleAntennaModelPtr ImportVehicleAntennaModel::create(const std::string& filePath)
    {
      return std::make_shared<ImportVehicleAntennaModel>(filePath);
    }

    ImportVehicleAntennaModelPtr ImportVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportVehicleAntennaModel>(ptr);
    }

    bool ImportVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
        ;

    }

    std::string ImportVehicleAntennaModel::documentation() const { return Documentation; }


    int ImportVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportVehicleAntennaModel::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void ImportVehicleAntennaModel::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportVehicleAntennaModel
///
#include "gen/ExportVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportVehicleAntennaModel::CmdName = "ExportVehicleAntennaModel";
    const char* const ExportVehicleAntennaModel::Documentation = "Export a vehicle antenna model in a XML file.";

    REGISTER_COMMAND_FACTORY(ExportVehicleAntennaModel);


    ExportVehicleAntennaModel::ExportVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    ExportVehicleAntennaModel::ExportVehicleAntennaModel(const std::string& antennaName, const std::string& filePath, bool overwriting)
      : CommandBase(CmdName)
    {

      setAntennaName(antennaName);
      setFilePath(filePath);
      setOverwriting(overwriting);
    }


    ExportVehicleAntennaModelPtr ExportVehicleAntennaModel::create(const std::string& antennaName, const std::string& filePath, bool overwriting)
    {
      return std::make_shared<ExportVehicleAntennaModel>(antennaName, filePath, overwriting);
    }

    ExportVehicleAntennaModelPtr ExportVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportVehicleAntennaModel>(ptr);
    }

    bool ExportVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["AntennaName"])
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
        ;

    }

    std::string ExportVehicleAntennaModel::documentation() const { return Documentation; }


    int ExportVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ExportVehicleAntennaModel::antennaName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaName"]);
    }

    void ExportVehicleAntennaModel::setAntennaName(const std::string& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<std::string>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportVehicleAntennaModel::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void ExportVehicleAntennaModel::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ExportVehicleAntennaModel::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportVehicleAntennaModel::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAntennaChange
///
#include "gen/SetAntennaChange.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAntennaChange::CmdName = "SetAntennaChange";
    const char* const SetAntennaChange::Documentation = "Add/edit an antenna change.";

    REGISTER_COMMAND_FACTORY(SetAntennaChange);


    SetAntennaChange::SetAntennaChange()
      : CommandBase(CmdName)
    {}

    SetAntennaChange::SetAntennaChange(double startTime, const std::string& antenna, const std::string& id)
      : CommandBase(CmdName)
    {

      setStartTime(startTime);
      setAntenna(antenna);
      setId(id);
    }


    SetAntennaChangePtr SetAntennaChange::create(double startTime, const std::string& antenna, const std::string& id)
    {
      return std::make_shared<SetAntennaChange>(startTime, antenna, id);
    }

    SetAntennaChangePtr SetAntennaChange::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAntennaChange>(ptr);
    }

    bool SetAntennaChange::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["StartTime"])
          && parse_json<std::string>::is_valid(m_values["Antenna"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetAntennaChange::documentation() const { return Documentation; }


    int SetAntennaChange::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetAntennaChange::startTime() const
    {
      return parse_json<double>::parse(m_values["StartTime"]);
    }

    void SetAntennaChange::setStartTime(double startTime)
    {
      m_values.AddMember("StartTime", parse_json<double>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetAntennaChange::antenna() const
    {
      return parse_json<std::string>::parse(m_values["Antenna"]);
    }

    void SetAntennaChange::setAntenna(const std::string& antenna)
    {
      m_values.AddMember("Antenna", parse_json<std::string>::format(antenna, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetAntennaChange::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetAntennaChange::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAntennaChange
///
#include "gen/GetAntennaChange.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAntennaChange::CmdName = "GetAntennaChange";
    const char* const GetAntennaChange::Documentation = "Get an antenna change.";

    REGISTER_COMMAND_FACTORY(GetAntennaChange);


    GetAntennaChange::GetAntennaChange()
      : CommandBase(CmdName)
    {}

    GetAntennaChange::GetAntennaChange(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetAntennaChangePtr GetAntennaChange::create(const std::string& id)
    {
      return std::make_shared<GetAntennaChange>(id);
    }

    GetAntennaChangePtr GetAntennaChange::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAntennaChange>(ptr);
    }

    bool GetAntennaChange::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetAntennaChange::documentation() const { return Documentation; }


    int GetAntennaChange::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAntennaChange::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetAntennaChange::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAntennaChangeResult
///
#include "gen/GetAntennaChangeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAntennaChangeResult::CmdName = "GetAntennaChangeResult";
    const char* const GetAntennaChangeResult::Documentation = "Result of GetAntennaChange.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAntennaChangeResult);


    GetAntennaChangeResult::GetAntennaChangeResult()
      : CommandResult(CmdName)
    {}

    GetAntennaChangeResult::GetAntennaChangeResult(CommandBasePtr relatedCommand, double startTime, const std::string& antenna, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setStartTime(startTime);
      setAntenna(antenna);
      setId(id);
    }


    GetAntennaChangeResultPtr GetAntennaChangeResult::create(CommandBasePtr relatedCommand, double startTime, const std::string& antenna, const std::string& id)
    {
      return std::make_shared<GetAntennaChangeResult>(relatedCommand, startTime, antenna, id);
    }

    GetAntennaChangeResultPtr GetAntennaChangeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAntennaChangeResult>(ptr);
    }

    bool GetAntennaChangeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["StartTime"])
          && parse_json<std::string>::is_valid(m_values["Antenna"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetAntennaChangeResult::documentation() const { return Documentation; }


    double GetAntennaChangeResult::startTime() const
    {
      return parse_json<double>::parse(m_values["StartTime"]);
    }

    void GetAntennaChangeResult::setStartTime(double startTime)
    {
      m_values.AddMember("StartTime", parse_json<double>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetAntennaChangeResult::antenna() const
    {
      return parse_json<std::string>::parse(m_values["Antenna"]);
    }

    void GetAntennaChangeResult::setAntenna(const std::string& antenna)
    {
      m_values.AddMember("Antenna", parse_json<std::string>::format(antenna, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetAntennaChangeResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetAntennaChangeResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAntennaChange
///
#include "gen/RemoveAntennaChange.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAntennaChange::CmdName = "RemoveAntennaChange";
    const char* const RemoveAntennaChange::Documentation = "Removes an antenna change.";

    REGISTER_COMMAND_FACTORY(RemoveAntennaChange);


    RemoveAntennaChange::RemoveAntennaChange()
      : CommandBase(CmdName)
    {}

    RemoveAntennaChange::RemoveAntennaChange(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveAntennaChangePtr RemoveAntennaChange::create(const std::string& id)
    {
      return std::make_shared<RemoveAntennaChange>(id);
    }

    RemoveAntennaChangePtr RemoveAntennaChange::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAntennaChange>(ptr);
    }

    bool RemoveAntennaChange::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveAntennaChange::documentation() const { return Documentation; }


    int RemoveAntennaChange::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAntennaChange::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveAntennaChange::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllAntennaChanges
///
#include "gen/ClearAllAntennaChanges.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllAntennaChanges::CmdName = "ClearAllAntennaChanges";
    const char* const ClearAllAntennaChanges::Documentation = "Clear all antenna changes.";

    REGISTER_COMMAND_FACTORY(ClearAllAntennaChanges);


    ClearAllAntennaChanges::ClearAllAntennaChanges()
      : CommandBase(CmdName)
    {

    }


    ClearAllAntennaChangesPtr ClearAllAntennaChanges::create()
    {
      return std::make_shared<ClearAllAntennaChanges>();
    }

    ClearAllAntennaChangesPtr ClearAllAntennaChanges::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllAntennaChanges>(ptr);
    }

    bool ClearAllAntennaChanges::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllAntennaChanges::documentation() const { return Documentation; }


    int ClearAllAntennaChanges::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of SetWFAntennaOffset
///
#include "gen/SetWFAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaOffset::CmdName = "SetWFAntennaOffset";
    const char* const SetWFAntennaOffset::Documentation = "Set WF antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the vehicle trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(SetWFAntennaOffset);


    SetWFAntennaOffset::SetWFAntennaOffset()
      : CommandBase(CmdName)
    {}

    SetWFAntennaOffset::SetWFAntennaOffset(double x, double y, double z, double yaw, double pitch, double roll)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    SetWFAntennaOffsetPtr SetWFAntennaOffset::create(double x, double y, double z, double yaw, double pitch, double roll)
    {
      return std::make_shared<SetWFAntennaOffset>(x, y, z, yaw, pitch, roll);
    }

    SetWFAntennaOffsetPtr SetWFAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaOffset>(ptr);
    }

    bool SetWFAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string SetWFAntennaOffset::documentation() const { return Documentation; }


    int SetWFAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetWFAntennaOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetWFAntennaOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetWFAntennaOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetWFAntennaOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetWFAntennaOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetWFAntennaOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetWFAntennaOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaOffset
///
#include "gen/GetWFAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaOffset::CmdName = "GetWFAntennaOffset";
    const char* const GetWFAntennaOffset::Documentation = "Get the WF antenna offset infos.";

    REGISTER_COMMAND_FACTORY(GetWFAntennaOffset);


    GetWFAntennaOffset::GetWFAntennaOffset()
      : CommandBase(CmdName)
    {

    }


    GetWFAntennaOffsetPtr GetWFAntennaOffset::create()
    {
      return std::make_shared<GetWFAntennaOffset>();
    }

    GetWFAntennaOffsetPtr GetWFAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaOffset>(ptr);
    }

    bool GetWFAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetWFAntennaOffset::documentation() const { return Documentation; }


    int GetWFAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetWFAntennaOffsetResult
///
#include "gen/GetWFAntennaOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaOffsetResult::CmdName = "GetWFAntennaOffsetResult";
    const char* const GetWFAntennaOffsetResult::Documentation = "Result of GetWFAntennaOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaOffsetResult);


    GetWFAntennaOffsetResult::GetWFAntennaOffsetResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaOffsetResult::GetWFAntennaOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    GetWFAntennaOffsetResultPtr GetWFAntennaOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll)
    {
      return std::make_shared<GetWFAntennaOffsetResult>(relatedCommand, x, y, z, yaw, pitch, roll);
    }

    GetWFAntennaOffsetResultPtr GetWFAntennaOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaOffsetResult>(ptr);
    }

    bool GetWFAntennaOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string GetWFAntennaOffsetResult::documentation() const { return Documentation; }


    double GetWFAntennaOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetWFAntennaOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetWFAntennaOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetWFAntennaOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetWFAntennaOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetWFAntennaOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetWFAntennaOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaElementOffset
///
#include "gen/SetWFAntennaElementOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaElementOffset::CmdName = "SetWFAntennaElementOffset";
    const char* const SetWFAntennaElementOffset::Documentation = "Set WF antenna offset and orientation relative to CRPA Antenna frame for the specified element index.";

    REGISTER_COMMAND_FACTORY(SetWFAntennaElementOffset);


    SetWFAntennaElementOffset::SetWFAntennaElementOffset()
      : CommandBase(CmdName)
    {}

    SetWFAntennaElementOffset::SetWFAntennaElementOffset(double x, double y, double z, double yaw, double pitch, double roll, int element)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setElement(element);
    }


    SetWFAntennaElementOffsetPtr SetWFAntennaElementOffset::create(double x, double y, double z, double yaw, double pitch, double roll, int element)
    {
      return std::make_shared<SetWFAntennaElementOffset>(x, y, z, yaw, pitch, roll, element);
    }

    SetWFAntennaElementOffsetPtr SetWFAntennaElementOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaElementOffset>(ptr);
    }

    bool SetWFAntennaElementOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string SetWFAntennaElementOffset::documentation() const { return Documentation; }


    int SetWFAntennaElementOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetWFAntennaElementOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetWFAntennaElementOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetWFAntennaElementOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetWFAntennaElementOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetWFAntennaElementOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetWFAntennaElementOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetWFAntennaElementOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetWFAntennaElementOffset::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void SetWFAntennaElementOffset::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementOffset
///
#include "gen/GetWFAntennaElementOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementOffset::CmdName = "GetWFAntennaElementOffset";
    const char* const GetWFAntennaElementOffset::Documentation = "Get the WF antenna offset infos for this element.";

    REGISTER_COMMAND_FACTORY(GetWFAntennaElementOffset);


    GetWFAntennaElementOffset::GetWFAntennaElementOffset()
      : CommandBase(CmdName)
    {}

    GetWFAntennaElementOffset::GetWFAntennaElementOffset(int element)
      : CommandBase(CmdName)
    {

      setElement(element);
    }


    GetWFAntennaElementOffsetPtr GetWFAntennaElementOffset::create(int element)
    {
      return std::make_shared<GetWFAntennaElementOffset>(element);
    }

    GetWFAntennaElementOffsetPtr GetWFAntennaElementOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementOffset>(ptr);
    }

    bool GetWFAntennaElementOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementOffset::documentation() const { return Documentation; }


    int GetWFAntennaElementOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetWFAntennaElementOffset::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementOffset::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementOffsetResult
///
#include "gen/GetWFAntennaElementOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementOffsetResult::CmdName = "GetWFAntennaElementOffsetResult";
    const char* const GetWFAntennaElementOffsetResult::Documentation = "Result of GetWFAntennaElementOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaElementOffsetResult);


    GetWFAntennaElementOffsetResult::GetWFAntennaElementOffsetResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaElementOffsetResult::GetWFAntennaElementOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, int element)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setElement(element);
    }


    GetWFAntennaElementOffsetResultPtr GetWFAntennaElementOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, int element)
    {
      return std::make_shared<GetWFAntennaElementOffsetResult>(relatedCommand, x, y, z, yaw, pitch, roll, element);
    }

    GetWFAntennaElementOffsetResultPtr GetWFAntennaElementOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementOffsetResult>(ptr);
    }

    bool GetWFAntennaElementOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementOffsetResult::documentation() const { return Documentation; }


    double GetWFAntennaElementOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetWFAntennaElementOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetWFAntennaElementOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetWFAntennaElementOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetWFAntennaElementOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetWFAntennaElementOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetWFAntennaElementOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetWFAntennaElementOffsetResult::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementOffsetResult::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaElementModel
///
#include "gen/SetWFAntennaElementModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaElementModel::CmdName = "SetWFAntennaElementModel";
    const char* const SetWFAntennaElementModel::Documentation = "Set WF Antenna model for this element";

    REGISTER_COMMAND_FACTORY(SetWFAntennaElementModel);


    SetWFAntennaElementModel::SetWFAntennaElementModel()
      : CommandBase(CmdName)
    {}

    SetWFAntennaElementModel::SetWFAntennaElementModel(const std::string& antennaModelName, int element)
      : CommandBase(CmdName)
    {

      setAntennaModelName(antennaModelName);
      setElement(element);
    }


    SetWFAntennaElementModelPtr SetWFAntennaElementModel::create(const std::string& antennaModelName, int element)
    {
      return std::make_shared<SetWFAntennaElementModel>(antennaModelName, element);
    }

    SetWFAntennaElementModelPtr SetWFAntennaElementModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaElementModel>(ptr);
    }

    bool SetWFAntennaElementModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string SetWFAntennaElementModel::documentation() const { return Documentation; }


    int SetWFAntennaElementModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetWFAntennaElementModel::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void SetWFAntennaElementModel::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetWFAntennaElementModel::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void SetWFAntennaElementModel::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementModel
///
#include "gen/GetWFAntennaElementModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementModel::CmdName = "GetWFAntennaElementModel";
    const char* const GetWFAntennaElementModel::Documentation = "Get WF Antenna model for this element";

    REGISTER_COMMAND_FACTORY(GetWFAntennaElementModel);


    GetWFAntennaElementModel::GetWFAntennaElementModel()
      : CommandBase(CmdName)
    {}

    GetWFAntennaElementModel::GetWFAntennaElementModel(int element)
      : CommandBase(CmdName)
    {

      setElement(element);
    }


    GetWFAntennaElementModelPtr GetWFAntennaElementModel::create(int element)
    {
      return std::make_shared<GetWFAntennaElementModel>(element);
    }

    GetWFAntennaElementModelPtr GetWFAntennaElementModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementModel>(ptr);
    }

    bool GetWFAntennaElementModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementModel::documentation() const { return Documentation; }


    int GetWFAntennaElementModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetWFAntennaElementModel::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementModel::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementModelResult
///
#include "gen/GetWFAntennaElementModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementModelResult::CmdName = "GetWFAntennaElementModelResult";
    const char* const GetWFAntennaElementModelResult::Documentation = "Result of GetWFAntennaElementModel.";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaElementModelResult);


    GetWFAntennaElementModelResult::GetWFAntennaElementModelResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaElementModelResult::GetWFAntennaElementModelResult(CommandBasePtr relatedCommand, const std::string& antennaModelName, int element)
      : CommandResult(CmdName, relatedCommand)
    {

      setAntennaModelName(antennaModelName);
      setElement(element);
    }


    GetWFAntennaElementModelResultPtr GetWFAntennaElementModelResult::create(CommandBasePtr relatedCommand, const std::string& antennaModelName, int element)
    {
      return std::make_shared<GetWFAntennaElementModelResult>(relatedCommand, antennaModelName, element);
    }

    GetWFAntennaElementModelResultPtr GetWFAntennaElementModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementModelResult>(ptr);
    }

    bool GetWFAntennaElementModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementModelResult::documentation() const { return Documentation; }


    std::string GetWFAntennaElementModelResult::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void GetWFAntennaElementModelResult::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetWFAntennaElementModelResult::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementModelResult::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaElementPhasePatternOffset
///
#include "gen/SetWFAntennaElementPhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaElementPhasePatternOffset::CmdName = "SetWFAntennaElementPhasePatternOffset";
    const char* const SetWFAntennaElementPhasePatternOffset::Documentation = "Set WF Antenna phase pattern offset (in rad) for this element";

    REGISTER_COMMAND_FACTORY(SetWFAntennaElementPhasePatternOffset);


    SetWFAntennaElementPhasePatternOffset::SetWFAntennaElementPhasePatternOffset()
      : CommandBase(CmdName)
    {}

    SetWFAntennaElementPhasePatternOffset::SetWFAntennaElementPhasePatternOffset(double phaseOffset, int element)
      : CommandBase(CmdName)
    {

      setPhaseOffset(phaseOffset);
      setElement(element);
    }


    SetWFAntennaElementPhasePatternOffsetPtr SetWFAntennaElementPhasePatternOffset::create(double phaseOffset, int element)
    {
      return std::make_shared<SetWFAntennaElementPhasePatternOffset>(phaseOffset, element);
    }

    SetWFAntennaElementPhasePatternOffsetPtr SetWFAntennaElementPhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaElementPhasePatternOffset>(ptr);
    }

    bool SetWFAntennaElementPhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["PhaseOffset"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string SetWFAntennaElementPhasePatternOffset::documentation() const { return Documentation; }


    int SetWFAntennaElementPhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetWFAntennaElementPhasePatternOffset::phaseOffset() const
    {
      return parse_json<double>::parse(m_values["PhaseOffset"]);
    }

    void SetWFAntennaElementPhasePatternOffset::setPhaseOffset(double phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<double>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetWFAntennaElementPhasePatternOffset::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void SetWFAntennaElementPhasePatternOffset::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementPhasePatternOffset
///
#include "gen/GetWFAntennaElementPhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementPhasePatternOffset::CmdName = "GetWFAntennaElementPhasePatternOffset";
    const char* const GetWFAntennaElementPhasePatternOffset::Documentation = "Get WF Antenna phase pattern offset (in rad) for this element";

    REGISTER_COMMAND_FACTORY(GetWFAntennaElementPhasePatternOffset);


    GetWFAntennaElementPhasePatternOffset::GetWFAntennaElementPhasePatternOffset()
      : CommandBase(CmdName)
    {}

    GetWFAntennaElementPhasePatternOffset::GetWFAntennaElementPhasePatternOffset(int element)
      : CommandBase(CmdName)
    {

      setElement(element);
    }


    GetWFAntennaElementPhasePatternOffsetPtr GetWFAntennaElementPhasePatternOffset::create(int element)
    {
      return std::make_shared<GetWFAntennaElementPhasePatternOffset>(element);
    }

    GetWFAntennaElementPhasePatternOffsetPtr GetWFAntennaElementPhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementPhasePatternOffset>(ptr);
    }

    bool GetWFAntennaElementPhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementPhasePatternOffset::documentation() const { return Documentation; }


    int GetWFAntennaElementPhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetWFAntennaElementPhasePatternOffset::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementPhasePatternOffset::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementPhasePatternOffsetResult
///
#include "gen/GetWFAntennaElementPhasePatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementPhasePatternOffsetResult::CmdName = "GetWFAntennaElementPhasePatternOffsetResult";
    const char* const GetWFAntennaElementPhasePatternOffsetResult::Documentation = "Result of GetWFAntennaElementPhasePatternOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaElementPhasePatternOffsetResult);


    GetWFAntennaElementPhasePatternOffsetResult::GetWFAntennaElementPhasePatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaElementPhasePatternOffsetResult::GetWFAntennaElementPhasePatternOffsetResult(CommandBasePtr relatedCommand, double phaseOffset, int element)
      : CommandResult(CmdName, relatedCommand)
    {

      setPhaseOffset(phaseOffset);
      setElement(element);
    }


    GetWFAntennaElementPhasePatternOffsetResultPtr GetWFAntennaElementPhasePatternOffsetResult::create(CommandBasePtr relatedCommand, double phaseOffset, int element)
    {
      return std::make_shared<GetWFAntennaElementPhasePatternOffsetResult>(relatedCommand, phaseOffset, element);
    }

    GetWFAntennaElementPhasePatternOffsetResultPtr GetWFAntennaElementPhasePatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementPhasePatternOffsetResult>(ptr);
    }

    bool GetWFAntennaElementPhasePatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["PhaseOffset"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementPhasePatternOffsetResult::documentation() const { return Documentation; }


    double GetWFAntennaElementPhasePatternOffsetResult::phaseOffset() const
    {
      return parse_json<double>::parse(m_values["PhaseOffset"]);
    }

    void GetWFAntennaElementPhasePatternOffsetResult::setPhaseOffset(double phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<double>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetWFAntennaElementPhasePatternOffsetResult::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementPhasePatternOffsetResult::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaElementEnabled
///
#include "gen/SetWFAntennaElementEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaElementEnabled::CmdName = "SetWFAntennaElementEnabled";
    const char* const SetWFAntennaElementEnabled::Documentation = "Set WF antenna element enabled or disabled. A disabled antenna element is not simulated at all.";

    REGISTER_COMMAND_FACTORY(SetWFAntennaElementEnabled);


    SetWFAntennaElementEnabled::SetWFAntennaElementEnabled()
      : CommandBase(CmdName)
    {}

    SetWFAntennaElementEnabled::SetWFAntennaElementEnabled(int element, bool enabled)
      : CommandBase(CmdName)
    {

      setElement(element);
      setEnabled(enabled);
    }


    SetWFAntennaElementEnabledPtr SetWFAntennaElementEnabled::create(int element, bool enabled)
    {
      return std::make_shared<SetWFAntennaElementEnabled>(element, enabled);
    }

    SetWFAntennaElementEnabledPtr SetWFAntennaElementEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaElementEnabled>(ptr);
    }

    bool SetWFAntennaElementEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string SetWFAntennaElementEnabled::documentation() const { return Documentation; }


    int SetWFAntennaElementEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetWFAntennaElementEnabled::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void SetWFAntennaElementEnabled::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetWFAntennaElementEnabled::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetWFAntennaElementEnabled::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsWFAntennaElementEnabled
///
#include "gen/IsWFAntennaElementEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsWFAntennaElementEnabled::CmdName = "IsWFAntennaElementEnabled";
    const char* const IsWFAntennaElementEnabled::Documentation = "Get whether an antenna element is enabled or disabled.";

    REGISTER_COMMAND_FACTORY(IsWFAntennaElementEnabled);


    IsWFAntennaElementEnabled::IsWFAntennaElementEnabled()
      : CommandBase(CmdName)
    {}

    IsWFAntennaElementEnabled::IsWFAntennaElementEnabled(int element)
      : CommandBase(CmdName)
    {

      setElement(element);
    }


    IsWFAntennaElementEnabledPtr IsWFAntennaElementEnabled::create(int element)
    {
      return std::make_shared<IsWFAntennaElementEnabled>(element);
    }

    IsWFAntennaElementEnabledPtr IsWFAntennaElementEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsWFAntennaElementEnabled>(ptr);
    }

    bool IsWFAntennaElementEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string IsWFAntennaElementEnabled::documentation() const { return Documentation; }


    int IsWFAntennaElementEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int IsWFAntennaElementEnabled::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void IsWFAntennaElementEnabled::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsWFAntennaElementEnabledResult
///
#include "gen/IsWFAntennaElementEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsWFAntennaElementEnabledResult::CmdName = "IsWFAntennaElementEnabledResult";
    const char* const IsWFAntennaElementEnabledResult::Documentation = "Result of IsWFAntennaElementEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsWFAntennaElementEnabledResult);


    IsWFAntennaElementEnabledResult::IsWFAntennaElementEnabledResult()
      : CommandResult(CmdName)
    {}

    IsWFAntennaElementEnabledResult::IsWFAntennaElementEnabledResult(CommandBasePtr relatedCommand, int element, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setElement(element);
      setEnabled(enabled);
    }


    IsWFAntennaElementEnabledResultPtr IsWFAntennaElementEnabledResult::create(CommandBasePtr relatedCommand, int element, bool enabled)
    {
      return std::make_shared<IsWFAntennaElementEnabledResult>(relatedCommand, element, enabled);
    }

    IsWFAntennaElementEnabledResultPtr IsWFAntennaElementEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsWFAntennaElementEnabledResult>(ptr);
    }

    bool IsWFAntennaElementEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsWFAntennaElementEnabledResult::documentation() const { return Documentation; }


    int IsWFAntennaElementEnabledResult::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void IsWFAntennaElementEnabledResult::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsWFAntennaElementEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsWFAntennaElementEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSVAntennaNames
///
#include "gen/GetAllSVAntennaNames.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSVAntennaNames::CmdName = "GetAllSVAntennaNames";
    const char* const GetAllSVAntennaNames::Documentation = "Get a list of all space vehicle antenna names.";

    REGISTER_COMMAND_FACTORY(GetAllSVAntennaNames);


    GetAllSVAntennaNames::GetAllSVAntennaNames()
      : CommandBase(CmdName)
    {}

    GetAllSVAntennaNames::GetAllSVAntennaNames(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetAllSVAntennaNamesPtr GetAllSVAntennaNames::create(const std::string& system)
    {
      return std::make_shared<GetAllSVAntennaNames>(system);
    }

    GetAllSVAntennaNamesPtr GetAllSVAntennaNames::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSVAntennaNames>(ptr);
    }

    bool GetAllSVAntennaNames::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetAllSVAntennaNames::documentation() const { return Documentation; }


    int GetAllSVAntennaNames::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSVAntennaNames::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSVAntennaNames::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSVAntennaNamesResult
///
#include "gen/GetAllSVAntennaNamesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSVAntennaNamesResult::CmdName = "GetAllSVAntennaNamesResult";
    const char* const GetAllSVAntennaNamesResult::Documentation = "Result of GetAllSVAntennaNames.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllSVAntennaNamesResult);


    GetAllSVAntennaNamesResult::GetAllSVAntennaNamesResult()
      : CommandResult(CmdName)
    {}

    GetAllSVAntennaNamesResult::GetAllSVAntennaNamesResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<std::string>& antennaNames)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setAntennaNames(antennaNames);
    }


    GetAllSVAntennaNamesResultPtr GetAllSVAntennaNamesResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<std::string>& antennaNames)
    {
      return std::make_shared<GetAllSVAntennaNamesResult>(relatedCommand, system, antennaNames);
    }

    GetAllSVAntennaNamesResultPtr GetAllSVAntennaNamesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSVAntennaNamesResult>(ptr);
    }

    bool GetAllSVAntennaNamesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaNames"])
        ;

    }

    std::string GetAllSVAntennaNamesResult::documentation() const { return Documentation; }


    std::string GetAllSVAntennaNamesResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSVAntennaNamesResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetAllSVAntennaNamesResult::antennaNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaNames"]);
    }

    void GetAllSVAntennaNamesResult::setAntennaNames(const std::vector<std::string>& antennaNames)
    {
      m_values.AddMember("AntennaNames", parse_json<std::vector<std::string>>::format(antennaNames, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddSVGainPatternOffset
///
#include "gen/AddSVGainPatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddSVGainPatternOffset::CmdName = "AddSVGainPatternOffset";
    const char* const AddSVGainPatternOffset::Documentation = "Add an offset (in dB) for all values of the pattern.";

    REGISTER_COMMAND_FACTORY(AddSVGainPatternOffset);


    AddSVGainPatternOffset::AddSVGainPatternOffset()
      : CommandBase(CmdName)
    {}

    AddSVGainPatternOffset::AddSVGainPatternOffset(const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    AddSVGainPatternOffsetPtr AddSVGainPatternOffset::create(const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<AddSVGainPatternOffset>(band, system, offset, antennaName);
    }

    AddSVGainPatternOffsetPtr AddSVGainPatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddSVGainPatternOffset>(ptr);
    }

    bool AddSVGainPatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string AddSVGainPatternOffset::documentation() const { return Documentation; }


    int AddSVGainPatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand AddSVGainPatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void AddSVGainPatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddSVGainPatternOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void AddSVGainPatternOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddSVGainPatternOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void AddSVGainPatternOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> AddSVGainPatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void AddSVGainPatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVGainPatternOffset
///
#include "gen/GetSVGainPatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVGainPatternOffset::CmdName = "GetSVGainPatternOffset";
    const char* const GetSVGainPatternOffset::Documentation = "Get the offset (in dB) for the antenna gain pattern of the band.";

    REGISTER_COMMAND_FACTORY(GetSVGainPatternOffset);


    GetSVGainPatternOffset::GetSVGainPatternOffset()
      : CommandBase(CmdName)
    {}

    GetSVGainPatternOffset::GetSVGainPatternOffset(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setAntennaName(antennaName);
    }


    GetSVGainPatternOffsetPtr GetSVGainPatternOffset::create(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<GetSVGainPatternOffset>(band, system, antennaName);
    }

    GetSVGainPatternOffsetPtr GetSVGainPatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVGainPatternOffset>(ptr);
    }

    bool GetSVGainPatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetSVGainPatternOffset::documentation() const { return Documentation; }


    int GetSVGainPatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetSVGainPatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVGainPatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVGainPatternOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVGainPatternOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVGainPatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetSVGainPatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVGainPatternOffsetResult
///
#include "gen/GetSVGainPatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVGainPatternOffsetResult::CmdName = "GetSVGainPatternOffsetResult";
    const char* const GetSVGainPatternOffsetResult::Documentation = "Result of GetSVGainPatternOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVGainPatternOffsetResult);


    GetSVGainPatternOffsetResult::GetSVGainPatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSVGainPatternOffsetResult::GetSVGainPatternOffsetResult(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setSystem(system);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    GetSVGainPatternOffsetResultPtr GetSVGainPatternOffsetResult::create(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<GetSVGainPatternOffsetResult>(relatedCommand, band, system, offset, antennaName);
    }

    GetSVGainPatternOffsetResultPtr GetSVGainPatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVGainPatternOffsetResult>(ptr);
    }

    bool GetSVGainPatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetSVGainPatternOffsetResult::documentation() const { return Documentation; }


    Sdx::GNSSBand GetSVGainPatternOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVGainPatternOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVGainPatternOffsetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVGainPatternOffsetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSVGainPatternOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetSVGainPatternOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVGainPatternOffsetResult::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetSVGainPatternOffsetResult::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddSVPhasePatternOffset
///
#include "gen/AddSVPhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddSVPhasePatternOffset::CmdName = "AddSVPhasePatternOffset";
    const char* const AddSVPhasePatternOffset::Documentation = "Add an offset (in rad) for all values of the phase pattern.";

    REGISTER_COMMAND_FACTORY(AddSVPhasePatternOffset);


    AddSVPhasePatternOffset::AddSVPhasePatternOffset()
      : CommandBase(CmdName)
    {}

    AddSVPhasePatternOffset::AddSVPhasePatternOffset(const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    AddSVPhasePatternOffsetPtr AddSVPhasePatternOffset::create(const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<AddSVPhasePatternOffset>(band, system, offset, antennaName);
    }

    AddSVPhasePatternOffsetPtr AddSVPhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddSVPhasePatternOffset>(ptr);
    }

    bool AddSVPhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string AddSVPhasePatternOffset::documentation() const { return Documentation; }


    int AddSVPhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand AddSVPhasePatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void AddSVPhasePatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddSVPhasePatternOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void AddSVPhasePatternOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddSVPhasePatternOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void AddSVPhasePatternOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> AddSVPhasePatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void AddSVPhasePatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVPhasePatternOffset
///
#include "gen/GetSVPhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVPhasePatternOffset::CmdName = "GetSVPhasePatternOffset";
    const char* const GetSVPhasePatternOffset::Documentation = "Get the offset (in rad) for the antenna phase pattern of the band.";

    REGISTER_COMMAND_FACTORY(GetSVPhasePatternOffset);


    GetSVPhasePatternOffset::GetSVPhasePatternOffset()
      : CommandBase(CmdName)
    {}

    GetSVPhasePatternOffset::GetSVPhasePatternOffset(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setAntennaName(antennaName);
    }


    GetSVPhasePatternOffsetPtr GetSVPhasePatternOffset::create(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<GetSVPhasePatternOffset>(band, system, antennaName);
    }

    GetSVPhasePatternOffsetPtr GetSVPhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVPhasePatternOffset>(ptr);
    }

    bool GetSVPhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetSVPhasePatternOffset::documentation() const { return Documentation; }


    int GetSVPhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetSVPhasePatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVPhasePatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVPhasePatternOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVPhasePatternOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVPhasePatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetSVPhasePatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVPhasePatternOffsetResult
///
#include "gen/GetSVPhasePatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVPhasePatternOffsetResult::CmdName = "GetSVPhasePatternOffsetResult";
    const char* const GetSVPhasePatternOffsetResult::Documentation = "Result of GetSVPhasePatternOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVPhasePatternOffsetResult);


    GetSVPhasePatternOffsetResult::GetSVPhasePatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSVPhasePatternOffsetResult::GetSVPhasePatternOffsetResult(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setSystem(system);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    GetSVPhasePatternOffsetResultPtr GetSVPhasePatternOffsetResult::create(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return std::make_shared<GetSVPhasePatternOffsetResult>(relatedCommand, band, system, offset, antennaName);
    }

    GetSVPhasePatternOffsetResultPtr GetSVPhasePatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVPhasePatternOffsetResult>(ptr);
    }

    bool GetSVPhasePatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetSVPhasePatternOffsetResult::documentation() const { return Documentation; }


    Sdx::GNSSBand GetSVPhasePatternOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVPhasePatternOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVPhasePatternOffsetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVPhasePatternOffsetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSVPhasePatternOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetSVPhasePatternOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVPhasePatternOffsetResult::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetSVPhasePatternOffsetResult::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaGain
///
#include "gen/SetSVAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaGain::CmdName = "SetSVAntennaGain";
    const char* const SetSVAntennaGain::Documentation = "Set space vehicle gain antenna pattern. If no name is specified, the command is aplied to Basic SV Antenna.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaGain);


    SetSVAntennaGain::SetSVAntennaGain()
      : CommandBase(CmdName)
    {}

    SetSVAntennaGain::SetSVAntennaGain(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setGain(gain);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    SetSVAntennaGainPtr SetSVAntennaGain::create(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<SetSVAntennaGain>(gain, type, band, system, name);
    }

    SetSVAntennaGainPtr SetSVAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaGain>(ptr);
    }

    bool SetSVAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetSVAntennaGain::documentation() const { return Documentation; }


    int SetSVAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetSVAntennaGain::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void SetSVAntennaGain::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSVAntennaGain::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSVAntennaGain::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetSVAntennaGain::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetSVAntennaGain::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaGain::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaGain::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetSVAntennaGain::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetSVAntennaGain::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaGain
///
#include "gen/GetSVAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaGain::CmdName = "GetSVAntennaGain";
    const char* const GetSVAntennaGain::Documentation = "Get space vehicle gain antenna pattern. If no name is specified, the command is aplied to Basic SV Antenna.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaGain);


    GetSVAntennaGain::GetSVAntennaGain()
      : CommandBase(CmdName)
    {}

    GetSVAntennaGain::GetSVAntennaGain(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setName(name);
    }


    GetSVAntennaGainPtr GetSVAntennaGain::create(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetSVAntennaGain>(band, system, name);
    }

    GetSVAntennaGainPtr GetSVAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaGain>(ptr);
    }

    bool GetSVAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetSVAntennaGain::documentation() const { return Documentation; }


    int GetSVAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetSVAntennaGain::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVAntennaGain::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaGain::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaGain::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVAntennaGain::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetSVAntennaGain::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaGainResult
///
#include "gen/GetSVAntennaGainResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaGainResult::CmdName = "GetSVAntennaGainResult";
    const char* const GetSVAntennaGainResult::Documentation = "Result of GetSVAntennaGain.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaGainResult);


    GetSVAntennaGainResult::GetSVAntennaGainResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaGainResult::GetSVAntennaGainResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    GetSVAntennaGainResultPtr GetSVAntennaGainResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetSVAntennaGainResult>(relatedCommand, gain, type, band, system, name);
    }

    GetSVAntennaGainResultPtr GetSVAntennaGainResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaGainResult>(ptr);
    }

    bool GetSVAntennaGainResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetSVAntennaGainResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetSVAntennaGainResult::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void GetSVAntennaGainResult::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetSVAntennaGainResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetSVAntennaGainResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand GetSVAntennaGainResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVAntennaGainResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaGainResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaGainResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVAntennaGainResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetSVAntennaGainResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaPhaseOffset
///
#include "gen/SetSVAntennaPhaseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaPhaseOffset::CmdName = "SetSVAntennaPhaseOffset";
    const char* const SetSVAntennaPhaseOffset::Documentation = "Set space vehicle phase offset antenna pattern. If no name is specified, the command is aplied to Basic Vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaPhaseOffset);


    SetSVAntennaPhaseOffset::SetSVAntennaPhaseOffset()
      : CommandBase(CmdName)
    {}

    SetSVAntennaPhaseOffset::SetSVAntennaPhaseOffset(const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setPhaseOffset(phaseOffset);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    SetSVAntennaPhaseOffsetPtr SetSVAntennaPhaseOffset::create(const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<SetSVAntennaPhaseOffset>(phaseOffset, type, band, system, name);
    }

    SetSVAntennaPhaseOffsetPtr SetSVAntennaPhaseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaPhaseOffset>(ptr);
    }

    bool SetSVAntennaPhaseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffset"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetSVAntennaPhaseOffset::documentation() const { return Documentation; }


    int SetSVAntennaPhaseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetSVAntennaPhaseOffset::phaseOffset() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffset"]);
    }

    void SetSVAntennaPhaseOffset::setPhaseOffset(const std::vector<std::vector<double>>& phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<std::vector<std::vector<double>>>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSVAntennaPhaseOffset::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSVAntennaPhaseOffset::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetSVAntennaPhaseOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetSVAntennaPhaseOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaPhaseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaPhaseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetSVAntennaPhaseOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetSVAntennaPhaseOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaPhaseOffset
///
#include "gen/GetSVAntennaPhaseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaPhaseOffset::CmdName = "GetSVAntennaPhaseOffset";
    const char* const GetSVAntennaPhaseOffset::Documentation = "Get space vehicle phase offset antenna pattern. If no name is specified, the command is aplied to Basic Vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaPhaseOffset);


    GetSVAntennaPhaseOffset::GetSVAntennaPhaseOffset()
      : CommandBase(CmdName)
    {}

    GetSVAntennaPhaseOffset::GetSVAntennaPhaseOffset(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setName(name);
    }


    GetSVAntennaPhaseOffsetPtr GetSVAntennaPhaseOffset::create(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetSVAntennaPhaseOffset>(band, system, name);
    }

    GetSVAntennaPhaseOffsetPtr GetSVAntennaPhaseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaPhaseOffset>(ptr);
    }

    bool GetSVAntennaPhaseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetSVAntennaPhaseOffset::documentation() const { return Documentation; }


    int GetSVAntennaPhaseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetSVAntennaPhaseOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVAntennaPhaseOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaPhaseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaPhaseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVAntennaPhaseOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetSVAntennaPhaseOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaPhaseOffsetResult
///
#include "gen/GetSVAntennaPhaseOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaPhaseOffsetResult::CmdName = "GetSVAntennaPhaseOffsetResult";
    const char* const GetSVAntennaPhaseOffsetResult::Documentation = "Result of GetSVAntennaPhaseOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaPhaseOffsetResult);


    GetSVAntennaPhaseOffsetResult::GetSVAntennaPhaseOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaPhaseOffsetResult::GetSVAntennaPhaseOffsetResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setPhaseOffset(phaseOffset);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    GetSVAntennaPhaseOffsetResultPtr GetSVAntennaPhaseOffsetResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<GetSVAntennaPhaseOffsetResult>(relatedCommand, phaseOffset, type, band, system, name);
    }

    GetSVAntennaPhaseOffsetResultPtr GetSVAntennaPhaseOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaPhaseOffsetResult>(ptr);
    }

    bool GetSVAntennaPhaseOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffset"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetSVAntennaPhaseOffsetResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetSVAntennaPhaseOffsetResult::phaseOffset() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffset"]);
    }

    void GetSVAntennaPhaseOffsetResult::setPhaseOffset(const std::vector<std::vector<double>>& phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<std::vector<std::vector<double>>>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetSVAntennaPhaseOffsetResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetSVAntennaPhaseOffsetResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand GetSVAntennaPhaseOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVAntennaPhaseOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaPhaseOffsetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaPhaseOffsetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVAntennaPhaseOffsetResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetSVAntennaPhaseOffsetResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaGainCSV
///
#include "gen/SetSVAntennaGainCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaGainCSV::CmdName = "SetSVAntennaGainCSV";
    const char* const SetSVAntennaGainCSV::Documentation = "Set space vehicle gain antenna pattern from a CSV file. If no name is specified, the command is aplied to Basic SV Antenna.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaGainCSV);


    SetSVAntennaGainCSV::SetSVAntennaGainCSV()
      : CommandBase(CmdName)
    {}

    SetSVAntennaGainCSV::SetSVAntennaGainCSV(const std::string& filePath, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    SetSVAntennaGainCSVPtr SetSVAntennaGainCSV::create(const std::string& filePath, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<SetSVAntennaGainCSV>(filePath, type, band, system, name);
    }

    SetSVAntennaGainCSVPtr SetSVAntennaGainCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaGainCSV>(ptr);
    }

    bool SetSVAntennaGainCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetSVAntennaGainCSV::documentation() const { return Documentation; }


    int SetSVAntennaGainCSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVAntennaGainCSV::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void SetSVAntennaGainCSV::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSVAntennaGainCSV::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSVAntennaGainCSV::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetSVAntennaGainCSV::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetSVAntennaGainCSV::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaGainCSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaGainCSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetSVAntennaGainCSV::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetSVAntennaGainCSV::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaPhaseOffsetCSV
///
#include "gen/SetSVAntennaPhaseOffsetCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaPhaseOffsetCSV::CmdName = "SetSVAntennaPhaseOffsetCSV";
    const char* const SetSVAntennaPhaseOffsetCSV::Documentation = "Set space vehicle phase offset antenna pattern from a CSV file. If no name is specified, the command is aplied to Basic SV Antenna.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaPhaseOffsetCSV);


    SetSVAntennaPhaseOffsetCSV::SetSVAntennaPhaseOffsetCSV()
      : CommandBase(CmdName)
    {}

    SetSVAntennaPhaseOffsetCSV::SetSVAntennaPhaseOffsetCSV(const std::string& filePath, const Sdx::AntennaPatternFileType& fileFormat, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setFileFormat(fileFormat);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    SetSVAntennaPhaseOffsetCSVPtr SetSVAntennaPhaseOffsetCSV::create(const std::string& filePath, const Sdx::AntennaPatternFileType& fileFormat, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return std::make_shared<SetSVAntennaPhaseOffsetCSV>(filePath, fileFormat, type, band, system, name);
    }

    SetSVAntennaPhaseOffsetCSVPtr SetSVAntennaPhaseOffsetCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaPhaseOffsetCSV>(ptr);
    }

    bool SetSVAntennaPhaseOffsetCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<Sdx::AntennaPatternFileType>::is_valid(m_values["FileFormat"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetSVAntennaPhaseOffsetCSV::documentation() const { return Documentation; }


    int SetSVAntennaPhaseOffsetCSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVAntennaPhaseOffsetCSV::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternFileType SetSVAntennaPhaseOffsetCSV::fileFormat() const
    {
      return parse_json<Sdx::AntennaPatternFileType>::parse(m_values["FileFormat"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setFileFormat(const Sdx::AntennaPatternFileType& fileFormat)
    {
      m_values.AddMember("FileFormat", parse_json<Sdx::AntennaPatternFileType>::format(fileFormat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSVAntennaPhaseOffsetCSV::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetSVAntennaPhaseOffsetCSV::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaPhaseOffsetCSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetSVAntennaPhaseOffsetCSV::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddEmptySVAntennaModel
///
#include "gen/AddEmptySVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddEmptySVAntennaModel::CmdName = "AddEmptySVAntennaModel";
    const char* const AddEmptySVAntennaModel::Documentation = "Create an empty space vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(AddEmptySVAntennaModel);


    AddEmptySVAntennaModel::AddEmptySVAntennaModel()
      : CommandBase(CmdName)
    {}

    AddEmptySVAntennaModel::AddEmptySVAntennaModel(const std::string& name, const std::string& system)
      : CommandBase(CmdName)
    {

      setName(name);
      setSystem(system);
    }


    AddEmptySVAntennaModelPtr AddEmptySVAntennaModel::create(const std::string& name, const std::string& system)
    {
      return std::make_shared<AddEmptySVAntennaModel>(name, system);
    }

    AddEmptySVAntennaModelPtr AddEmptySVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddEmptySVAntennaModel>(ptr);
    }

    bool AddEmptySVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string AddEmptySVAntennaModel::documentation() const { return Documentation; }


    int AddEmptySVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddEmptySVAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void AddEmptySVAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddEmptySVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void AddEmptySVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of DeleteSVAntennaModel
///
#include "gen/DeleteSVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const DeleteSVAntennaModel::CmdName = "DeleteSVAntennaModel";
    const char* const DeleteSVAntennaModel::Documentation = "Delete a space vehicle antenna model. The default SV antenna model can't be deleted.";

    REGISTER_COMMAND_FACTORY(DeleteSVAntennaModel);


    DeleteSVAntennaModel::DeleteSVAntennaModel()
      : CommandBase(CmdName)
    {}

    DeleteSVAntennaModel::DeleteSVAntennaModel(const std::string& name, const std::string& system)
      : CommandBase(CmdName)
    {

      setName(name);
      setSystem(system);
    }


    DeleteSVAntennaModelPtr DeleteSVAntennaModel::create(const std::string& name, const std::string& system)
    {
      return std::make_shared<DeleteSVAntennaModel>(name, system);
    }

    DeleteSVAntennaModelPtr DeleteSVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<DeleteSVAntennaModel>(ptr);
    }

    bool DeleteSVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string DeleteSVAntennaModel::documentation() const { return Documentation; }


    int DeleteSVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string DeleteSVAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void DeleteSVAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string DeleteSVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void DeleteSVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RenameSVAntennaModel
///
#include "gen/RenameSVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RenameSVAntennaModel::CmdName = "RenameSVAntennaModel";
    const char* const RenameSVAntennaModel::Documentation = "Rename a space vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(RenameSVAntennaModel);


    RenameSVAntennaModel::RenameSVAntennaModel()
      : CommandBase(CmdName)
    {}

    RenameSVAntennaModel::RenameSVAntennaModel(const std::string& name, const std::string& newName, const std::string& system)
      : CommandBase(CmdName)
    {

      setName(name);
      setNewName(newName);
      setSystem(system);
    }


    RenameSVAntennaModelPtr RenameSVAntennaModel::create(const std::string& name, const std::string& newName, const std::string& system)
    {
      return std::make_shared<RenameSVAntennaModel>(name, newName, system);
    }

    RenameSVAntennaModelPtr RenameSVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RenameSVAntennaModel>(ptr);
    }

    bool RenameSVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["NewName"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RenameSVAntennaModel::documentation() const { return Documentation; }


    int RenameSVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RenameSVAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void RenameSVAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameSVAntennaModel::newName() const
    {
      return parse_json<std::string>::parse(m_values["NewName"]);
    }

    void RenameSVAntennaModel::setNewName(const std::string& newName)
    {
      m_values.AddMember("NewName", parse_json<std::string>::format(newName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameSVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RenameSVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CopySVAntennaModel
///
#include "gen/CopySVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CopySVAntennaModel::CmdName = "CopySVAntennaModel";
    const char* const CopySVAntennaModel::Documentation = "Copy a space vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(CopySVAntennaModel);


    CopySVAntennaModel::CopySVAntennaModel()
      : CommandBase(CmdName)
    {}

    CopySVAntennaModel::CopySVAntennaModel(const std::string& name, const std::string& copyName, const std::string& system)
      : CommandBase(CmdName)
    {

      setName(name);
      setCopyName(copyName);
      setSystem(system);
    }


    CopySVAntennaModelPtr CopySVAntennaModel::create(const std::string& name, const std::string& copyName, const std::string& system)
    {
      return std::make_shared<CopySVAntennaModel>(name, copyName, system);
    }

    CopySVAntennaModelPtr CopySVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CopySVAntennaModel>(ptr);
    }

    bool CopySVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["CopyName"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string CopySVAntennaModel::documentation() const { return Documentation; }


    int CopySVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string CopySVAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void CopySVAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string CopySVAntennaModel::copyName() const
    {
      return parse_json<std::string>::parse(m_values["CopyName"]);
    }

    void CopySVAntennaModel::setCopyName(const std::string& copyName)
    {
      m_values.AddMember("CopyName", parse_json<std::string>::format(copyName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string CopySVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void CopySVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportSVAntennaModel
///
#include "gen/ImportSVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportSVAntennaModel::CmdName = "ImportSVAntennaModel";
    const char* const ImportSVAntennaModel::Documentation = "Import a space vehicle antenna model from a XML file.";

    REGISTER_COMMAND_FACTORY(ImportSVAntennaModel);


    ImportSVAntennaModel::ImportSVAntennaModel()
      : CommandBase(CmdName)
    {}

    ImportSVAntennaModel::ImportSVAntennaModel(const std::string& filePath, const std::string& system)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setSystem(system);
    }


    ImportSVAntennaModelPtr ImportSVAntennaModel::create(const std::string& filePath, const std::string& system)
    {
      return std::make_shared<ImportSVAntennaModel>(filePath, system);
    }

    ImportSVAntennaModelPtr ImportSVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportSVAntennaModel>(ptr);
    }

    bool ImportSVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string ImportSVAntennaModel::documentation() const { return Documentation; }


    int ImportSVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportSVAntennaModel::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void ImportSVAntennaModel::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportSVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ImportSVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportSVAntennaModel
///
#include "gen/ExportSVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportSVAntennaModel::CmdName = "ExportSVAntennaModel";
    const char* const ExportSVAntennaModel::Documentation = "Export a space vehicle antenna model in a XML file.";

    REGISTER_COMMAND_FACTORY(ExportSVAntennaModel);


    ExportSVAntennaModel::ExportSVAntennaModel()
      : CommandBase(CmdName)
    {}

    ExportSVAntennaModel::ExportSVAntennaModel(const std::string& antennaName, const std::string& system, const std::string& filePath, bool overwriting)
      : CommandBase(CmdName)
    {

      setAntennaName(antennaName);
      setSystem(system);
      setFilePath(filePath);
      setOverwriting(overwriting);
    }


    ExportSVAntennaModelPtr ExportSVAntennaModel::create(const std::string& antennaName, const std::string& system, const std::string& filePath, bool overwriting)
    {
      return std::make_shared<ExportSVAntennaModel>(antennaName, system, filePath, overwriting);
    }

    ExportSVAntennaModelPtr ExportSVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportSVAntennaModel>(ptr);
    }

    bool ExportSVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["AntennaName"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
        ;

    }

    std::string ExportSVAntennaModel::documentation() const { return Documentation; }


    int ExportSVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ExportSVAntennaModel::antennaName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaName"]);
    }

    void ExportSVAntennaModel::setAntennaName(const std::string& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<std::string>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportSVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ExportSVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportSVAntennaModel::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void ExportSVAntennaModel::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ExportSVAntennaModel::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportSVAntennaModel::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaModelForSV
///
#include "gen/SetSVAntennaModelForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaModelForSV::CmdName = "SetSVAntennaModelForSV";
    const char* const SetSVAntennaModelForSV::Documentation = "Set the antenna model used by the SV.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaModelForSV);


    SetSVAntennaModelForSV::SetSVAntennaModelForSV()
      : CommandBase(CmdName)
    {}

    SetSVAntennaModelForSV::SetSVAntennaModelForSV(const std::string& system, int svId, const std::string& antennaModelName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setAntennaModelName(antennaModelName);
    }


    SetSVAntennaModelForSVPtr SetSVAntennaModelForSV::create(const std::string& system, int svId, const std::string& antennaModelName)
    {
      return std::make_shared<SetSVAntennaModelForSV>(system, svId, antennaModelName);
    }

    SetSVAntennaModelForSVPtr SetSVAntennaModelForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaModelForSV>(ptr);
    }

    bool SetSVAntennaModelForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
        ;

    }

    std::string SetSVAntennaModelForSV::documentation() const { return Documentation; }


    int SetSVAntennaModelForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVAntennaModelForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaModelForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSVAntennaModelForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSVAntennaModelForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaModelForSV::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void SetSVAntennaModelForSV::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForSV
///
#include "gen/GetSVAntennaModelForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForSV::CmdName = "GetSVAntennaModelForSV";
    const char* const GetSVAntennaModelForSV::Documentation = "Get the antenna model used by the SV.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaModelForSV);


    GetSVAntennaModelForSV::GetSVAntennaModelForSV()
      : CommandBase(CmdName)
    {}

    GetSVAntennaModelForSV::GetSVAntennaModelForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetSVAntennaModelForSVPtr GetSVAntennaModelForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<GetSVAntennaModelForSV>(system, svId);
    }

    GetSVAntennaModelForSVPtr GetSVAntennaModelForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForSV>(ptr);
    }

    bool GetSVAntennaModelForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetSVAntennaModelForSV::documentation() const { return Documentation; }


    int GetSVAntennaModelForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSVAntennaModelForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVAntennaModelForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSVAntennaModelForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForSVResult
///
#include "gen/GetSVAntennaModelForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForSVResult::CmdName = "GetSVAntennaModelForSVResult";
    const char* const GetSVAntennaModelForSVResult::Documentation = "Result of GetSVAntennaModelForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaModelForSVResult);


    GetSVAntennaModelForSVResult::GetSVAntennaModelForSVResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaModelForSVResult::GetSVAntennaModelForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::string& antennaModelName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setAntennaModelName(antennaModelName);
    }


    GetSVAntennaModelForSVResultPtr GetSVAntennaModelForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::string& antennaModelName)
    {
      return std::make_shared<GetSVAntennaModelForSVResult>(relatedCommand, system, svId, antennaModelName);
    }

    GetSVAntennaModelForSVResultPtr GetSVAntennaModelForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForSVResult>(ptr);
    }

    bool GetSVAntennaModelForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
        ;

    }

    std::string GetSVAntennaModelForSVResult::documentation() const { return Documentation; }


    std::string GetSVAntennaModelForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVAntennaModelForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSVAntennaModelForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaModelForSVResult::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void GetSVAntennaModelForSVResult::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaModelForEachSV
///
#include "gen/SetSVAntennaModelForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaModelForEachSV::CmdName = "SetSVAntennaModelForEachSV";
    const char* const SetSVAntennaModelForEachSV::Documentation = "Set the antenna model for all satellites.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaModelForEachSV);


    SetSVAntennaModelForEachSV::SetSVAntennaModelForEachSV()
      : CommandBase(CmdName)
    {}

    SetSVAntennaModelForEachSV::SetSVAntennaModelForEachSV(const std::string& system, const std::vector<std::string>& antennaModelNames)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setAntennaModelNames(antennaModelNames);
    }


    SetSVAntennaModelForEachSVPtr SetSVAntennaModelForEachSV::create(const std::string& system, const std::vector<std::string>& antennaModelNames)
    {
      return std::make_shared<SetSVAntennaModelForEachSV>(system, antennaModelNames);
    }

    SetSVAntennaModelForEachSVPtr SetSVAntennaModelForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaModelForEachSV>(ptr);
    }

    bool SetSVAntennaModelForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaModelNames"])
        ;

    }

    std::string SetSVAntennaModelForEachSV::documentation() const { return Documentation; }


    int SetSVAntennaModelForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVAntennaModelForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaModelForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> SetSVAntennaModelForEachSV::antennaModelNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaModelNames"]);
    }

    void SetSVAntennaModelForEachSV::setAntennaModelNames(const std::vector<std::string>& antennaModelNames)
    {
      m_values.AddMember("AntennaModelNames", parse_json<std::vector<std::string>>::format(antennaModelNames, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForEachSV
///
#include "gen/GetSVAntennaModelForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForEachSV::CmdName = "GetSVAntennaModelForEachSV";
    const char* const GetSVAntennaModelForEachSV::Documentation = "Get the antenna model for all satellites.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaModelForEachSV);


    GetSVAntennaModelForEachSV::GetSVAntennaModelForEachSV()
      : CommandBase(CmdName)
    {}

    GetSVAntennaModelForEachSV::GetSVAntennaModelForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetSVAntennaModelForEachSVPtr GetSVAntennaModelForEachSV::create(const std::string& system)
    {
      return std::make_shared<GetSVAntennaModelForEachSV>(system);
    }

    GetSVAntennaModelForEachSVPtr GetSVAntennaModelForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForEachSV>(ptr);
    }

    bool GetSVAntennaModelForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetSVAntennaModelForEachSV::documentation() const { return Documentation; }


    int GetSVAntennaModelForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSVAntennaModelForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForEachSVResult
///
#include "gen/GetSVAntennaModelForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForEachSVResult::CmdName = "GetSVAntennaModelForEachSVResult";
    const char* const GetSVAntennaModelForEachSVResult::Documentation = "Result of GetSVAntennaModelForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaModelForEachSVResult);


    GetSVAntennaModelForEachSVResult::GetSVAntennaModelForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaModelForEachSVResult::GetSVAntennaModelForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<std::string>& antennaModelNames)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setAntennaModelNames(antennaModelNames);
    }


    GetSVAntennaModelForEachSVResultPtr GetSVAntennaModelForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<std::string>& antennaModelNames)
    {
      return std::make_shared<GetSVAntennaModelForEachSVResult>(relatedCommand, system, antennaModelNames);
    }

    GetSVAntennaModelForEachSVResultPtr GetSVAntennaModelForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForEachSVResult>(ptr);
    }

    bool GetSVAntennaModelForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaModelNames"])
        ;

    }

    std::string GetSVAntennaModelForEachSVResult::documentation() const { return Documentation; }


    std::string GetSVAntennaModelForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetSVAntennaModelForEachSVResult::antennaModelNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaModelNames"]);
    }

    void GetSVAntennaModelForEachSVResult::setAntennaModelNames(const std::vector<std::string>& antennaModelNames)
    {
      m_values.AddMember("AntennaModelNames", parse_json<std::vector<std::string>>::format(antennaModelNames, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVType
///
#include "gen/SetSVType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVType::CmdName = "SetSVType";
    const char* const SetSVType::Documentation = "Set the type of a SV.\nSatellite SV ID accepted values (0 for all SVs):\nQZSS 1..10";

    REGISTER_COMMAND_FACTORY(SetSVType);


    SetSVType::SetSVType()
      : CommandBase(CmdName)
    {}

    SetSVType::SetSVType(const std::string& system, int svId, const std::string& svType)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setSvType(svType);
    }


    SetSVTypePtr SetSVType::create(const std::string& system, int svId, const std::string& svType)
    {
      return std::make_shared<SetSVType>(system, svId, svType);
    }

    SetSVTypePtr SetSVType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVType>(ptr);
    }

    bool SetSVType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["SvType"])
        ;

    }

    std::string SetSVType::documentation() const { return Documentation; }


    int SetSVType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVType::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVType::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSVType::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSVType::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVType::svType() const
    {
      return parse_json<std::string>::parse(m_values["SvType"]);
    }

    void SetSVType::setSvType(const std::string& svType)
    {
      m_values.AddMember("SvType", parse_json<std::string>::format(svType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVType
///
#include "gen/GetSVType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVType::CmdName = "GetSVType";
    const char* const GetSVType::Documentation = "Get the type of a SV.\nSatellite SV ID accepted values:\nQZSS 1..10";

    REGISTER_COMMAND_FACTORY(GetSVType);


    GetSVType::GetSVType()
      : CommandBase(CmdName)
    {}

    GetSVType::GetSVType(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetSVTypePtr GetSVType::create(const std::string& system, int svId)
    {
      return std::make_shared<GetSVType>(system, svId);
    }

    GetSVTypePtr GetSVType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVType>(ptr);
    }

    bool GetSVType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetSVType::documentation() const { return Documentation; }


    int GetSVType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSVType::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVType::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVType::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSVType::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVTypeResult
///
#include "gen/GetSVTypeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVTypeResult::CmdName = "GetSVTypeResult";
    const char* const GetSVTypeResult::Documentation = "Result of GetSVType.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVTypeResult);


    GetSVTypeResult::GetSVTypeResult()
      : CommandResult(CmdName)
    {}

    GetSVTypeResult::GetSVTypeResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::string& svType)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setSvType(svType);
    }


    GetSVTypeResultPtr GetSVTypeResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::string& svType)
    {
      return std::make_shared<GetSVTypeResult>(relatedCommand, system, svId, svType);
    }

    GetSVTypeResultPtr GetSVTypeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVTypeResult>(ptr);
    }

    bool GetSVTypeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["SvType"])
        ;

    }

    std::string GetSVTypeResult::documentation() const { return Documentation; }


    std::string GetSVTypeResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVTypeResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVTypeResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSVTypeResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVTypeResult::svType() const
    {
      return parse_json<std::string>::parse(m_values["SvType"]);
    }

    void GetSVTypeResult::setSvType(const std::string& svType)
    {
      m_values.AddMember("SvType", parse_json<std::string>::format(svType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetTransmittedPrnForSV
///
#include "gen/SetTransmittedPrnForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetTransmittedPrnForSV::CmdName = "SetTransmittedPrnForSV";
    const char* const SetTransmittedPrnForSV::Documentation = "Set the PRNs transmitted by the SV ID for these signals.";

    REGISTER_COMMAND_FACTORY(SetTransmittedPrnForSV);


    SetTransmittedPrnForSV::SetTransmittedPrnForSV()
      : CommandBase(CmdName)
    {}

    SetTransmittedPrnForSV::SetTransmittedPrnForSV(int svId, const std::map<std::string, int>& signalPrnDict)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSignalPrnDict(signalPrnDict);
    }


    SetTransmittedPrnForSVPtr SetTransmittedPrnForSV::create(int svId, const std::map<std::string, int>& signalPrnDict)
    {
      return std::make_shared<SetTransmittedPrnForSV>(svId, signalPrnDict);
    }

    SetTransmittedPrnForSVPtr SetTransmittedPrnForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetTransmittedPrnForSV>(ptr);
    }

    bool SetTransmittedPrnForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, int>>::is_valid(m_values["SignalPrnDict"])
        ;

    }

    std::string SetTransmittedPrnForSV::documentation() const { return Documentation; }


    int SetTransmittedPrnForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetTransmittedPrnForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetTransmittedPrnForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, int> SetTransmittedPrnForSV::signalPrnDict() const
    {
      return parse_json<std::map<std::string, int>>::parse(m_values["SignalPrnDict"]);
    }

    void SetTransmittedPrnForSV::setSignalPrnDict(const std::map<std::string, int>& signalPrnDict)
    {
      m_values.AddMember("SignalPrnDict", parse_json<std::map<std::string, int>>::format(signalPrnDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetTransmittedPrnForSV
///
#include "gen/GetTransmittedPrnForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetTransmittedPrnForSV::CmdName = "GetTransmittedPrnForSV";
    const char* const GetTransmittedPrnForSV::Documentation = "Get the PRNs transmitted by the SV ID for these signals.";

    REGISTER_COMMAND_FACTORY(GetTransmittedPrnForSV);


    GetTransmittedPrnForSV::GetTransmittedPrnForSV()
      : CommandBase(CmdName)
    {}

    GetTransmittedPrnForSV::GetTransmittedPrnForSV(int svId, const std::vector<std::string>& signalArray)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSignalArray(signalArray);
    }


    GetTransmittedPrnForSVPtr GetTransmittedPrnForSV::create(int svId, const std::vector<std::string>& signalArray)
    {
      return std::make_shared<GetTransmittedPrnForSV>(svId, signalArray);
    }

    GetTransmittedPrnForSVPtr GetTransmittedPrnForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetTransmittedPrnForSV>(ptr);
    }

    bool GetTransmittedPrnForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
        ;

    }

    std::string GetTransmittedPrnForSV::documentation() const { return Documentation; }


    int GetTransmittedPrnForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetTransmittedPrnForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetTransmittedPrnForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetTransmittedPrnForSV::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetTransmittedPrnForSV::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetTransmittedPrnForSVResult
///
#include "gen/GetTransmittedPrnForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetTransmittedPrnForSVResult::CmdName = "GetTransmittedPrnForSVResult";
    const char* const GetTransmittedPrnForSVResult::Documentation = "Result of GetTransmittedPrnForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetTransmittedPrnForSVResult);


    GetTransmittedPrnForSVResult::GetTransmittedPrnForSVResult()
      : CommandResult(CmdName)
    {}

    GetTransmittedPrnForSVResult::GetTransmittedPrnForSVResult(CommandBasePtr relatedCommand, int svId, const std::map<std::string, int>& signalPrnDict)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setSignalPrnDict(signalPrnDict);
    }


    GetTransmittedPrnForSVResultPtr GetTransmittedPrnForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::map<std::string, int>& signalPrnDict)
    {
      return std::make_shared<GetTransmittedPrnForSVResult>(relatedCommand, svId, signalPrnDict);
    }

    GetTransmittedPrnForSVResultPtr GetTransmittedPrnForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetTransmittedPrnForSVResult>(ptr);
    }

    bool GetTransmittedPrnForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, int>>::is_valid(m_values["SignalPrnDict"])
        ;

    }

    std::string GetTransmittedPrnForSVResult::documentation() const { return Documentation; }


    int GetTransmittedPrnForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetTransmittedPrnForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, int> GetTransmittedPrnForSVResult::signalPrnDict() const
    {
      return parse_json<std::map<std::string, int>>::parse(m_values["SignalPrnDict"]);
    }

    void GetTransmittedPrnForSVResult::setSignalPrnDict(const std::map<std::string, int>& signalPrnDict)
    {
      m_values.AddMember("SignalPrnDict", parse_json<std::map<std::string, int>>::format(signalPrnDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPrnOfSVID
///
#include "gen/SetPrnOfSVID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPrnOfSVID::CmdName = "SetPrnOfSVID";
    const char* const SetPrnOfSVID::Documentation = "Set the PRN transmitted by the SV ID for this signal.";

    REGISTER_COMMAND_FACTORY(SetPrnOfSVID);


    SetPrnOfSVID::SetPrnOfSVID()
      : CommandBase(CmdName)
    {}

    SetPrnOfSVID::SetPrnOfSVID(const std::string& signal, int svId, int prn)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
      setPrn(prn);
    }


    SetPrnOfSVIDPtr SetPrnOfSVID::create(const std::string& signal, int svId, int prn)
    {
      return std::make_shared<SetPrnOfSVID>(signal, svId, prn);
    }

    SetPrnOfSVIDPtr SetPrnOfSVID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPrnOfSVID>(ptr);
    }

    bool SetPrnOfSVID::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string SetPrnOfSVID::documentation() const { return Documentation; }


    int SetPrnOfSVID::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPrnOfSVID::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetPrnOfSVID::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPrnOfSVID::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPrnOfSVID::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPrnOfSVID::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetPrnOfSVID::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnOfSVID
///
#include "gen/GetPrnOfSVID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnOfSVID::CmdName = "GetPrnOfSVID";
    const char* const GetPrnOfSVID::Documentation = "Get the PRN transmitted by the SV ID for this signal.";

    REGISTER_COMMAND_FACTORY(GetPrnOfSVID);


    GetPrnOfSVID::GetPrnOfSVID()
      : CommandBase(CmdName)
    {}

    GetPrnOfSVID::GetPrnOfSVID(const std::string& signal, int svId)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
    }


    GetPrnOfSVIDPtr GetPrnOfSVID::create(const std::string& signal, int svId)
    {
      return std::make_shared<GetPrnOfSVID>(signal, svId);
    }

    GetPrnOfSVIDPtr GetPrnOfSVID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnOfSVID>(ptr);
    }

    bool GetPrnOfSVID::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetPrnOfSVID::documentation() const { return Documentation; }


    int GetPrnOfSVID::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPrnOfSVID::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPrnOfSVID::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPrnOfSVID::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPrnOfSVID::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnOfSVIDResult
///
#include "gen/GetPrnOfSVIDResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnOfSVIDResult::CmdName = "GetPrnOfSVIDResult";
    const char* const GetPrnOfSVIDResult::Documentation = "Result of GetPrnOfSVID.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPrnOfSVIDResult);


    GetPrnOfSVIDResult::GetPrnOfSVIDResult()
      : CommandResult(CmdName)
    {}

    GetPrnOfSVIDResult::GetPrnOfSVIDResult(CommandBasePtr relatedCommand, const std::string& signal, int svId, int prn)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setSvId(svId);
      setPrn(prn);
    }


    GetPrnOfSVIDResultPtr GetPrnOfSVIDResult::create(CommandBasePtr relatedCommand, const std::string& signal, int svId, int prn)
    {
      return std::make_shared<GetPrnOfSVIDResult>(relatedCommand, signal, svId, prn);
    }

    GetPrnOfSVIDResultPtr GetPrnOfSVIDResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnOfSVIDResult>(ptr);
    }

    bool GetPrnOfSVIDResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetPrnOfSVIDResult::documentation() const { return Documentation; }


    std::string GetPrnOfSVIDResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPrnOfSVIDResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPrnOfSVIDResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPrnOfSVIDResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPrnOfSVIDResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetPrnOfSVIDResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPrnForEachSV
///
#include "gen/SetPrnForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPrnForEachSV::CmdName = "SetPrnForEachSV";
    const char* const SetPrnForEachSV::Documentation = "Set the PRN for each satellite for specified signals.";

    REGISTER_COMMAND_FACTORY(SetPrnForEachSV);


    SetPrnForEachSV::SetPrnForEachSV()
      : CommandBase(CmdName)
    {}

    SetPrnForEachSV::SetPrnForEachSV(const std::string& signal, const std::vector<int>& prn)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setPrn(prn);
    }


    SetPrnForEachSVPtr SetPrnForEachSV::create(const std::string& signal, const std::vector<int>& prn)
    {
      return std::make_shared<SetPrnForEachSV>(signal, prn);
    }

    SetPrnForEachSVPtr SetPrnForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPrnForEachSV>(ptr);
    }

    bool SetPrnForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<int>>::is_valid(m_values["Prn"])
        ;

    }

    std::string SetPrnForEachSV::documentation() const { return Documentation; }


    int SetPrnForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPrnForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetPrnForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetPrnForEachSV::prn() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Prn"]);
    }

    void SetPrnForEachSV::setPrn(const std::vector<int>& prn)
    {
      m_values.AddMember("Prn", parse_json<std::vector<int>>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnForEachSV
///
#include "gen/GetPrnForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnForEachSV::CmdName = "GetPrnForEachSV";
    const char* const GetPrnForEachSV::Documentation = "Get the PRN for each satellite for specified signals.";

    REGISTER_COMMAND_FACTORY(GetPrnForEachSV);


    GetPrnForEachSV::GetPrnForEachSV()
      : CommandBase(CmdName)
    {}

    GetPrnForEachSV::GetPrnForEachSV(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetPrnForEachSVPtr GetPrnForEachSV::create(const std::string& signal)
    {
      return std::make_shared<GetPrnForEachSV>(signal);
    }

    GetPrnForEachSVPtr GetPrnForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnForEachSV>(ptr);
    }

    bool GetPrnForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetPrnForEachSV::documentation() const { return Documentation; }


    int GetPrnForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPrnForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPrnForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnForEachSVResult
///
#include "gen/GetPrnForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnForEachSVResult::CmdName = "GetPrnForEachSVResult";
    const char* const GetPrnForEachSVResult::Documentation = "Result of GetPrnForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPrnForEachSVResult);


    GetPrnForEachSVResult::GetPrnForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetPrnForEachSVResult::GetPrnForEachSVResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<int>& prn)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setPrn(prn);
    }


    GetPrnForEachSVResultPtr GetPrnForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<int>& prn)
    {
      return std::make_shared<GetPrnForEachSVResult>(relatedCommand, signal, prn);
    }

    GetPrnForEachSVResultPtr GetPrnForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnForEachSVResult>(ptr);
    }

    bool GetPrnForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<int>>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetPrnForEachSVResult::documentation() const { return Documentation; }


    std::string GetPrnForEachSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPrnForEachSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetPrnForEachSVResult::prn() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Prn"]);
    }

    void GetPrnForEachSVResult::setPrn(const std::vector<int>& prn)
    {
      m_values.AddMember("Prn", parse_json<std::vector<int>>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetToDefaultPrn
///
#include "gen/ResetToDefaultPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetToDefaultPrn::CmdName = "ResetToDefaultPrn";
    const char* const ResetToDefaultPrn::Documentation = "Reset the PRNs of all satellites in specified system, for all signals.";

    REGISTER_COMMAND_FACTORY(ResetToDefaultPrn);


    ResetToDefaultPrn::ResetToDefaultPrn()
      : CommandBase(CmdName)
    {}

    ResetToDefaultPrn::ResetToDefaultPrn(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    ResetToDefaultPrnPtr ResetToDefaultPrn::create(const std::string& system)
    {
      return std::make_shared<ResetToDefaultPrn>(system);
    }

    ResetToDefaultPrnPtr ResetToDefaultPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetToDefaultPrn>(ptr);
    }

    bool ResetToDefaultPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string ResetToDefaultPrn::documentation() const { return Documentation; }


    int ResetToDefaultPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ResetToDefaultPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ResetToDefaultPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableTrajectorySmoothing
///
#include "gen/EnableTrajectorySmoothing.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableTrajectorySmoothing::CmdName = "EnableTrajectorySmoothing";
    const char* const EnableTrajectorySmoothing::Documentation = "Set trajectory smoothing for Track or Route enabled or disabled";

    REGISTER_COMMAND_FACTORY(EnableTrajectorySmoothing);


    EnableTrajectorySmoothing::EnableTrajectorySmoothing()
      : CommandBase(CmdName)
    {}

    EnableTrajectorySmoothing::EnableTrajectorySmoothing(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableTrajectorySmoothingPtr EnableTrajectorySmoothing::create(bool enabled)
    {
      return std::make_shared<EnableTrajectorySmoothing>(enabled);
    }

    EnableTrajectorySmoothingPtr EnableTrajectorySmoothing::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableTrajectorySmoothing>(ptr);
    }

    bool EnableTrajectorySmoothing::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableTrajectorySmoothing::documentation() const { return Documentation; }


    int EnableTrajectorySmoothing::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableTrajectorySmoothing::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableTrajectorySmoothing::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsTrajectorySmoothingEnabled
///
#include "gen/IsTrajectorySmoothingEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTrajectorySmoothingEnabled::CmdName = "IsTrajectorySmoothingEnabled";
    const char* const IsTrajectorySmoothingEnabled::Documentation = "Get trajectory smoothing for Track or Route enabled or disabled";

    REGISTER_COMMAND_FACTORY(IsTrajectorySmoothingEnabled);


    IsTrajectorySmoothingEnabled::IsTrajectorySmoothingEnabled()
      : CommandBase(CmdName)
    {

    }


    IsTrajectorySmoothingEnabledPtr IsTrajectorySmoothingEnabled::create()
    {
      return std::make_shared<IsTrajectorySmoothingEnabled>();
    }

    IsTrajectorySmoothingEnabledPtr IsTrajectorySmoothingEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTrajectorySmoothingEnabled>(ptr);
    }

    bool IsTrajectorySmoothingEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsTrajectorySmoothingEnabled::documentation() const { return Documentation; }


    int IsTrajectorySmoothingEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsTrajectorySmoothingEnabledResult
///
#include "gen/IsTrajectorySmoothingEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTrajectorySmoothingEnabledResult::CmdName = "IsTrajectorySmoothingEnabledResult";
    const char* const IsTrajectorySmoothingEnabledResult::Documentation = "Result of IsTrajectorySmoothingEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsTrajectorySmoothingEnabledResult);


    IsTrajectorySmoothingEnabledResult::IsTrajectorySmoothingEnabledResult()
      : CommandResult(CmdName)
    {}

    IsTrajectorySmoothingEnabledResult::IsTrajectorySmoothingEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsTrajectorySmoothingEnabledResultPtr IsTrajectorySmoothingEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsTrajectorySmoothingEnabledResult>(relatedCommand, enabled);
    }

    IsTrajectorySmoothingEnabledResultPtr IsTrajectorySmoothingEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTrajectorySmoothingEnabledResult>(ptr);
    }

    bool IsTrajectorySmoothingEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsTrajectorySmoothingEnabledResult::documentation() const { return Documentation; }


    bool IsTrajectorySmoothingEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsTrajectorySmoothingEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSimulationStopAtTrajectoryEnd
///
#include "gen/EnableSimulationStopAtTrajectoryEnd.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSimulationStopAtTrajectoryEnd::CmdName = "EnableSimulationStopAtTrajectoryEnd";
    const char* const EnableSimulationStopAtTrajectoryEnd::Documentation = "Set simulation automatic stop when the vehicle reaches trajectory end enabled or disabled. Only effective with Tracks and Routes";

    REGISTER_COMMAND_FACTORY(EnableSimulationStopAtTrajectoryEnd);


    EnableSimulationStopAtTrajectoryEnd::EnableSimulationStopAtTrajectoryEnd()
      : CommandBase(CmdName)
    {}

    EnableSimulationStopAtTrajectoryEnd::EnableSimulationStopAtTrajectoryEnd(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableSimulationStopAtTrajectoryEndPtr EnableSimulationStopAtTrajectoryEnd::create(bool enabled)
    {
      return std::make_shared<EnableSimulationStopAtTrajectoryEnd>(enabled);
    }

    EnableSimulationStopAtTrajectoryEndPtr EnableSimulationStopAtTrajectoryEnd::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSimulationStopAtTrajectoryEnd>(ptr);
    }

    bool EnableSimulationStopAtTrajectoryEnd::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSimulationStopAtTrajectoryEnd::documentation() const { return Documentation; }


    int EnableSimulationStopAtTrajectoryEnd::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableSimulationStopAtTrajectoryEnd::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSimulationStopAtTrajectoryEnd::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSimulationStopAtTrajectoryEndEnabled
///
#include "gen/IsSimulationStopAtTrajectoryEndEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSimulationStopAtTrajectoryEndEnabled::CmdName = "IsSimulationStopAtTrajectoryEndEnabled";
    const char* const IsSimulationStopAtTrajectoryEndEnabled::Documentation = "Get simulation automatic stop when the vehicle reaches trajectory end enabled or disabled. Only effective with Tracks and Routes";

    REGISTER_COMMAND_FACTORY(IsSimulationStopAtTrajectoryEndEnabled);


    IsSimulationStopAtTrajectoryEndEnabled::IsSimulationStopAtTrajectoryEndEnabled()
      : CommandBase(CmdName)
    {

    }


    IsSimulationStopAtTrajectoryEndEnabledPtr IsSimulationStopAtTrajectoryEndEnabled::create()
    {
      return std::make_shared<IsSimulationStopAtTrajectoryEndEnabled>();
    }

    IsSimulationStopAtTrajectoryEndEnabledPtr IsSimulationStopAtTrajectoryEndEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSimulationStopAtTrajectoryEndEnabled>(ptr);
    }

    bool IsSimulationStopAtTrajectoryEndEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsSimulationStopAtTrajectoryEndEnabled::documentation() const { return Documentation; }


    int IsSimulationStopAtTrajectoryEndEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsSimulationStopAtTrajectoryEndEnabledResult
///
#include "gen/IsSimulationStopAtTrajectoryEndEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSimulationStopAtTrajectoryEndEnabledResult::CmdName = "IsSimulationStopAtTrajectoryEndEnabledResult";
    const char* const IsSimulationStopAtTrajectoryEndEnabledResult::Documentation = "Result of IsSimulationStopAtTrajectoryEndEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSimulationStopAtTrajectoryEndEnabledResult);


    IsSimulationStopAtTrajectoryEndEnabledResult::IsSimulationStopAtTrajectoryEndEnabledResult()
      : CommandResult(CmdName)
    {}

    IsSimulationStopAtTrajectoryEndEnabledResult::IsSimulationStopAtTrajectoryEndEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsSimulationStopAtTrajectoryEndEnabledResultPtr IsSimulationStopAtTrajectoryEndEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsSimulationStopAtTrajectoryEndEnabledResult>(relatedCommand, enabled);
    }

    IsSimulationStopAtTrajectoryEndEnabledResultPtr IsSimulationStopAtTrajectoryEndEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSimulationStopAtTrajectoryEndEnabledResult>(ptr);
    }

    bool IsSimulationStopAtTrajectoryEndEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSimulationStopAtTrajectoryEndEnabledResult::documentation() const { return Documentation; }


    bool IsSimulationStopAtTrajectoryEndEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSimulationStopAtTrajectoryEndEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ForceAttitudeToZero
///
#include "gen/ForceAttitudeToZero.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ForceAttitudeToZero::CmdName = "ForceAttitudeToZero";
    const char* const ForceAttitudeToZero::Documentation = "Set force vehicle yaw, pitch and roll to zero enabled or disabled";

    REGISTER_COMMAND_FACTORY(ForceAttitudeToZero);


    ForceAttitudeToZero::ForceAttitudeToZero()
      : CommandBase(CmdName)
    {}

    ForceAttitudeToZero::ForceAttitudeToZero(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    ForceAttitudeToZeroPtr ForceAttitudeToZero::create(bool enabled)
    {
      return std::make_shared<ForceAttitudeToZero>(enabled);
    }

    ForceAttitudeToZeroPtr ForceAttitudeToZero::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ForceAttitudeToZero>(ptr);
    }

    bool ForceAttitudeToZero::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string ForceAttitudeToZero::documentation() const { return Documentation; }


    int ForceAttitudeToZero::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ForceAttitudeToZero::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void ForceAttitudeToZero::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsAttitudeToZeroForced
///
#include "gen/IsAttitudeToZeroForced.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsAttitudeToZeroForced::CmdName = "IsAttitudeToZeroForced";
    const char* const IsAttitudeToZeroForced::Documentation = "Get force vehicle yaw, pitch and roll to zero enabled or disabled";

    REGISTER_COMMAND_FACTORY(IsAttitudeToZeroForced);


    IsAttitudeToZeroForced::IsAttitudeToZeroForced()
      : CommandBase(CmdName)
    {

    }


    IsAttitudeToZeroForcedPtr IsAttitudeToZeroForced::create()
    {
      return std::make_shared<IsAttitudeToZeroForced>();
    }

    IsAttitudeToZeroForcedPtr IsAttitudeToZeroForced::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsAttitudeToZeroForced>(ptr);
    }

    bool IsAttitudeToZeroForced::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsAttitudeToZeroForced::documentation() const { return Documentation; }


    int IsAttitudeToZeroForced::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsAttitudeToZeroForcedResult
///
#include "gen/IsAttitudeToZeroForcedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsAttitudeToZeroForcedResult::CmdName = "IsAttitudeToZeroForcedResult";
    const char* const IsAttitudeToZeroForcedResult::Documentation = "Result of IsAttitudeToZeroForced.";

    REGISTER_COMMAND_RESULT_FACTORY(IsAttitudeToZeroForcedResult);


    IsAttitudeToZeroForcedResult::IsAttitudeToZeroForcedResult()
      : CommandResult(CmdName)
    {}

    IsAttitudeToZeroForcedResult::IsAttitudeToZeroForcedResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsAttitudeToZeroForcedResultPtr IsAttitudeToZeroForcedResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsAttitudeToZeroForcedResult>(relatedCommand, enabled);
    }

    IsAttitudeToZeroForcedResultPtr IsAttitudeToZeroForcedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsAttitudeToZeroForcedResult>(ptr);
    }

    bool IsAttitudeToZeroForcedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsAttitudeToZeroForcedResult::documentation() const { return Documentation; }


    bool IsAttitudeToZeroForcedResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsAttitudeToZeroForcedResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectory
///
#include "gen/SetVehicleTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectory::CmdName = "SetVehicleTrajectory";
    const char* const SetVehicleTrajectory::Documentation = "Set vehicle trajectory type";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectory);


    SetVehicleTrajectory::SetVehicleTrajectory()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectory::SetVehicleTrajectory(const std::string& type)
      : CommandBase(CmdName)
    {

      setType(type);
    }


    SetVehicleTrajectoryPtr SetVehicleTrajectory::create(const std::string& type)
    {
      return std::make_shared<SetVehicleTrajectory>(type);
    }

    SetVehicleTrajectoryPtr SetVehicleTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectory>(ptr);
    }

    bool SetVehicleTrajectory::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string SetVehicleTrajectory::documentation() const { return Documentation; }


    int SetVehicleTrajectory::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectory::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectory::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectory
///
#include "gen/GetVehicleTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectory::CmdName = "GetVehicleTrajectory";
    const char* const GetVehicleTrajectory::Documentation = "Get vehicle trajectory type";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectory);


    GetVehicleTrajectory::GetVehicleTrajectory()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryPtr GetVehicleTrajectory::create()
    {
      return std::make_shared<GetVehicleTrajectory>();
    }

    GetVehicleTrajectoryPtr GetVehicleTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectory>(ptr);
    }

    bool GetVehicleTrajectory::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectory::documentation() const { return Documentation; }


    int GetVehicleTrajectory::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryResult
///
#include "gen/GetVehicleTrajectoryResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryResult::CmdName = "GetVehicleTrajectoryResult";
    const char* const GetVehicleTrajectoryResult::Documentation = "Result of GetVehicleTrajectory.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryResult);


    GetVehicleTrajectoryResult::GetVehicleTrajectoryResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryResult::GetVehicleTrajectoryResult(CommandBasePtr relatedCommand, const std::string& type)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
    }


    GetVehicleTrajectoryResultPtr GetVehicleTrajectoryResult::create(CommandBasePtr relatedCommand, const std::string& type)
    {
      return std::make_shared<GetVehicleTrajectoryResult>(relatedCommand, type);
    }

    GetVehicleTrajectoryResultPtr GetVehicleTrajectoryResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryResult>(ptr);
    }

    bool GetVehicleTrajectoryResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string GetVehicleTrajectoryResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleType
///
#include "gen/SetVehicleType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleType::CmdName = "SetVehicleType";
    const char* const SetVehicleType::Documentation = "Set vehicle type for Route Trajectory";

    REGISTER_COMMAND_FACTORY(SetVehicleType);


    SetVehicleType::SetVehicleType()
      : CommandBase(CmdName)
    {}

    SetVehicleType::SetVehicleType(const std::string& type)
      : CommandBase(CmdName)
    {

      setType(type);
    }


    SetVehicleTypePtr SetVehicleType::create(const std::string& type)
    {
      return std::make_shared<SetVehicleType>(type);
    }

    SetVehicleTypePtr SetVehicleType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleType>(ptr);
    }

    bool SetVehicleType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string SetVehicleType::documentation() const { return Documentation; }


    int SetVehicleType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleType::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleType::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleType
///
#include "gen/GetVehicleType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleType::CmdName = "GetVehicleType";
    const char* const GetVehicleType::Documentation = "Get vehicle type for Route Trajectory";

    REGISTER_COMMAND_FACTORY(GetVehicleType);


    GetVehicleType::GetVehicleType()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTypePtr GetVehicleType::create()
    {
      return std::make_shared<GetVehicleType>();
    }

    GetVehicleTypePtr GetVehicleType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleType>(ptr);
    }

    bool GetVehicleType::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleType::documentation() const { return Documentation; }


    int GetVehicleType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTypeResult
///
#include "gen/GetVehicleTypeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTypeResult::CmdName = "GetVehicleTypeResult";
    const char* const GetVehicleTypeResult::Documentation = "Result of GetVehicleType.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTypeResult);


    GetVehicleTypeResult::GetVehicleTypeResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTypeResult::GetVehicleTypeResult(CommandBasePtr relatedCommand, const std::string& type)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
    }


    GetVehicleTypeResultPtr GetVehicleTypeResult::create(CommandBasePtr relatedCommand, const std::string& type)
    {
      return std::make_shared<GetVehicleTypeResult>(relatedCommand, type);
    }

    GetVehicleTypeResultPtr GetVehicleTypeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTypeResult>(ptr);
    }

    bool GetVehicleTypeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string GetVehicleTypeResult::documentation() const { return Documentation; }


    std::string GetVehicleTypeResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTypeResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BeginTrackDefinition
///
#include "gen/BeginTrackDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BeginTrackDefinition::CmdName = "BeginTrackDefinition";
    const char* const BeginTrackDefinition::Documentation = "Begins a new track definition. Actual track remains unchanged until\nEndTrackDefinition command is sent and successful. After this command, the\nclient must push time and position pairs to form a complete track. Once all the\npositions are sent, the client must send the command EndTrackDefinition.";

    REGISTER_COMMAND_FACTORY(BeginTrackDefinition);


    BeginTrackDefinition::BeginTrackDefinition()
      : CommandBase(CmdName)
    {

    }


    BeginTrackDefinitionPtr BeginTrackDefinition::create()
    {
      return std::make_shared<BeginTrackDefinition>();
    }

    BeginTrackDefinitionPtr BeginTrackDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BeginTrackDefinition>(ptr);
    }

    bool BeginTrackDefinition::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string BeginTrackDefinition::documentation() const { return Documentation; }


    int BeginTrackDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of PushTrackEcef
///
#include "gen/PushTrackEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushTrackEcef::CmdName = "PushTrackEcef";
    const char* const PushTrackEcef::Documentation = "Push a track ecef node. Must be called after BeginTrackDefinition and before EndTrackDefinition.";

    REGISTER_COMMAND_FACTORY(PushTrackEcef);


    PushTrackEcef::PushTrackEcef()
      : CommandBase(CmdName)
    {}

    PushTrackEcef::PushTrackEcef(int time, double x, double y, double z)
      : CommandBase(CmdName)
    {

      setTime(time);
      setX(x);
      setY(y);
      setZ(z);
    }


    PushTrackEcefPtr PushTrackEcef::create(int time, double x, double y, double z)
    {
      return std::make_shared<PushTrackEcef>(time, x, y, z);
    }

    PushTrackEcefPtr PushTrackEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushTrackEcef>(ptr);
    }

    bool PushTrackEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
        ;

    }

    std::string PushTrackEcef::documentation() const { return Documentation; }


    int PushTrackEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int PushTrackEcef::time() const
    {
      return parse_json<int>::parse(m_values["Time"]);
    }

    void PushTrackEcef::setTime(int time)
    {
      m_values.AddMember("Time", parse_json<int>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushTrackEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushTrackEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushTrackEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of PushTrackEcefNed
///
#include "gen/PushTrackEcefNed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushTrackEcefNed::CmdName = "PushTrackEcefNed";
    const char* const PushTrackEcefNed::Documentation = "Push a track ecef and ned attitude node. Must be called after BeginTrackDefinition and before EndTrackDefinition.";

    REGISTER_COMMAND_FACTORY(PushTrackEcefNed);


    PushTrackEcefNed::PushTrackEcefNed()
      : CommandBase(CmdName)
    {}

    PushTrackEcefNed::PushTrackEcefNed(int time, double x, double y, double z, double yaw, double pitch, double roll)
      : CommandBase(CmdName)
    {

      setTime(time);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    PushTrackEcefNedPtr PushTrackEcefNed::create(int time, double x, double y, double z, double yaw, double pitch, double roll)
    {
      return std::make_shared<PushTrackEcefNed>(time, x, y, z, yaw, pitch, roll);
    }

    PushTrackEcefNedPtr PushTrackEcefNed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushTrackEcefNed>(ptr);
    }

    bool PushTrackEcefNed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string PushTrackEcefNed::documentation() const { return Documentation; }


    int PushTrackEcefNed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int PushTrackEcefNed::time() const
    {
      return parse_json<int>::parse(m_values["Time"]);
    }

    void PushTrackEcefNed::setTime(int time)
    {
      m_values.AddMember("Time", parse_json<int>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushTrackEcefNed::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushTrackEcefNed::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushTrackEcefNed::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void PushTrackEcefNed::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void PushTrackEcefNed::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void PushTrackEcefNed::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EndTrackDefinition
///
#include "gen/EndTrackDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndTrackDefinition::CmdName = "EndTrackDefinition";
    const char* const EndTrackDefinition::Documentation = "This command completes the track started with BeginTrackDefinition command. If\nthe track is accepted, the current track in the configuration is replaced with\nthis new track. If the track is not accepted, the current track in the config\nremains unchanged.";

    REGISTER_COMMAND_FACTORY(EndTrackDefinition);


    EndTrackDefinition::EndTrackDefinition()
      : CommandBase(CmdName)
    {

    }


    EndTrackDefinitionPtr EndTrackDefinition::create()
    {
      return std::make_shared<EndTrackDefinition>();
    }

    EndTrackDefinitionPtr EndTrackDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndTrackDefinition>(ptr);
    }

    bool EndTrackDefinition::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string EndTrackDefinition::documentation() const { return Documentation; }


    int EndTrackDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of EndTrackDefinitionResult
///
#include "gen/EndTrackDefinitionResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndTrackDefinitionResult::CmdName = "EndTrackDefinitionResult";
    const char* const EndTrackDefinitionResult::Documentation = "EndTrackDefinition Result with created track informations.";

    REGISTER_COMMAND_RESULT_FACTORY(EndTrackDefinitionResult);


    EndTrackDefinitionResult::EndTrackDefinitionResult()
      : CommandResult(CmdName)
    {}

    EndTrackDefinitionResult::EndTrackDefinitionResult(CommandBasePtr relatedCommand, int count)
      : CommandResult(CmdName, relatedCommand)
    {

      setCount(count);
    }


    EndTrackDefinitionResultPtr EndTrackDefinitionResult::create(CommandBasePtr relatedCommand, int count)
    {
      return std::make_shared<EndTrackDefinitionResult>(relatedCommand, count);
    }

    EndTrackDefinitionResultPtr EndTrackDefinitionResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndTrackDefinitionResult>(ptr);
    }

    bool EndTrackDefinitionResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Count"])
        ;

    }

    std::string EndTrackDefinitionResult::documentation() const { return Documentation; }


    int EndTrackDefinitionResult::count() const
    {
      return parse_json<int>::parse(m_values["Count"]);
    }

    void EndTrackDefinitionResult::setCount(int count)
    {
      m_values.AddMember("Count", parse_json<int>::format(count, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BeginRouteDefinition
///
#include "gen/BeginRouteDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BeginRouteDefinition::CmdName = "BeginRouteDefinition";
    const char* const BeginRouteDefinition::Documentation = "Begins a new route definition. Actual route remains unchanged until\nEndRouteDefinition command is sent and successful. After this command, the\nclient must push time and position pairs to form a complete route. Once all the\npositions are sent, the client must send the command EndRouteDefinition.";

    REGISTER_COMMAND_FACTORY(BeginRouteDefinition);


    BeginRouteDefinition::BeginRouteDefinition()
      : CommandBase(CmdName)
    {

    }


    BeginRouteDefinitionPtr BeginRouteDefinition::create()
    {
      return std::make_shared<BeginRouteDefinition>();
    }

    BeginRouteDefinitionPtr BeginRouteDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BeginRouteDefinition>(ptr);
    }

    bool BeginRouteDefinition::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string BeginRouteDefinition::documentation() const { return Documentation; }


    int BeginRouteDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of PushRouteEcef
///
#include "gen/PushRouteEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushRouteEcef::CmdName = "PushRouteEcef";
    const char* const PushRouteEcef::Documentation = "Push a route ecef node with speed. Must be called after BeginRouteDefinition and before EndRouteDefinition.";

    REGISTER_COMMAND_FACTORY(PushRouteEcef);


    PushRouteEcef::PushRouteEcef()
      : CommandBase(CmdName)
    {}

    PushRouteEcef::PushRouteEcef(double speed, double x, double y, double z)
      : CommandBase(CmdName)
    {

      setSpeed(speed);
      setX(x);
      setY(y);
      setZ(z);
    }


    PushRouteEcefPtr PushRouteEcef::create(double speed, double x, double y, double z)
    {
      return std::make_shared<PushRouteEcef>(speed, x, y, z);
    }

    PushRouteEcefPtr PushRouteEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushRouteEcef>(ptr);
    }

    bool PushRouteEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
        ;

    }

    std::string PushRouteEcef::documentation() const { return Documentation; }


    int PushRouteEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double PushRouteEcef::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void PushRouteEcef::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushRouteEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushRouteEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushRouteEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushRouteEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushRouteEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushRouteEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EndRouteDefinition
///
#include "gen/EndRouteDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndRouteDefinition::CmdName = "EndRouteDefinition";
    const char* const EndRouteDefinition::Documentation = "This command completes the route started with BeginRouteDefinition command. If\nthe route is accepted, the current route in the configuration is replaced with\nthis new route. If the route is not accepted, the current route in the config\nremains unchanged.";

    REGISTER_COMMAND_FACTORY(EndRouteDefinition);


    EndRouteDefinition::EndRouteDefinition()
      : CommandBase(CmdName)
    {

    }


    EndRouteDefinitionPtr EndRouteDefinition::create()
    {
      return std::make_shared<EndRouteDefinition>();
    }

    EndRouteDefinitionPtr EndRouteDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndRouteDefinition>(ptr);
    }

    bool EndRouteDefinition::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string EndRouteDefinition::documentation() const { return Documentation; }


    int EndRouteDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of EndRouteDefinitionResult
///
#include "gen/EndRouteDefinitionResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndRouteDefinitionResult::CmdName = "EndRouteDefinitionResult";
    const char* const EndRouteDefinitionResult::Documentation = "EndRouteDefinition Result with created route informations.";

    REGISTER_COMMAND_RESULT_FACTORY(EndRouteDefinitionResult);


    EndRouteDefinitionResult::EndRouteDefinitionResult()
      : CommandResult(CmdName)
    {}

    EndRouteDefinitionResult::EndRouteDefinitionResult(CommandBasePtr relatedCommand, int count)
      : CommandResult(CmdName, relatedCommand)
    {

      setCount(count);
    }


    EndRouteDefinitionResultPtr EndRouteDefinitionResult::create(CommandBasePtr relatedCommand, int count)
    {
      return std::make_shared<EndRouteDefinitionResult>(relatedCommand, count);
    }

    EndRouteDefinitionResultPtr EndRouteDefinitionResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndRouteDefinitionResult>(ptr);
    }

    bool EndRouteDefinitionResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Count"])
        ;

    }

    std::string EndRouteDefinitionResult::documentation() const { return Documentation; }


    int EndRouteDefinitionResult::count() const
    {
      return parse_json<int>::parse(m_values["Count"]);
    }

    void EndRouteDefinitionResult::setCount(int count)
    {
      m_values.AddMember("Count", parse_json<int>::format(count, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectoryFix
///
#include "gen/SetVehicleTrajectoryFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectoryFix::CmdName = "SetVehicleTrajectoryFix";
    const char* const SetVehicleTrajectoryFix::Documentation = "Set vehicle static position and orientation";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectoryFix);


    SetVehicleTrajectoryFix::SetVehicleTrajectoryFix()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectoryFix::SetVehicleTrajectoryFix(const std::string& type, double lat, double lon, double alt, double yaw, double pitch, double roll)
      : CommandBase(CmdName)
    {

      setType(type);
      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    SetVehicleTrajectoryFixPtr SetVehicleTrajectoryFix::create(const std::string& type, double lat, double lon, double alt, double yaw, double pitch, double roll)
    {
      return std::make_shared<SetVehicleTrajectoryFix>(type, lat, lon, alt, yaw, pitch, roll);
    }

    SetVehicleTrajectoryFixPtr SetVehicleTrajectoryFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectoryFix>(ptr);
    }

    bool SetVehicleTrajectoryFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string SetVehicleTrajectoryFix::documentation() const { return Documentation; }


    int SetVehicleTrajectoryFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectoryFix::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectoryFix::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetVehicleTrajectoryFix::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetVehicleTrajectoryFix::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetVehicleTrajectoryFix::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetVehicleTrajectoryFix::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetVehicleTrajectoryFix::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetVehicleTrajectoryFix::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectoryFix
///
#include "gen/GetVehicleTrajectoryFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryFix::CmdName = "GetVehicleTrajectoryFix";
    const char* const GetVehicleTrajectoryFix::Documentation = "Get vehicle static position and orientation";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectoryFix);


    GetVehicleTrajectoryFix::GetVehicleTrajectoryFix()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryFixPtr GetVehicleTrajectoryFix::create()
    {
      return std::make_shared<GetVehicleTrajectoryFix>();
    }

    GetVehicleTrajectoryFixPtr GetVehicleTrajectoryFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryFix>(ptr);
    }

    bool GetVehicleTrajectoryFix::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectoryFix::documentation() const { return Documentation; }


    int GetVehicleTrajectoryFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryFixResult
///
#include "gen/GetVehicleTrajectoryFixResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryFixResult::CmdName = "GetVehicleTrajectoryFixResult";
    const char* const GetVehicleTrajectoryFixResult::Documentation = "Result of GetVehicleTrajectoryFix.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryFixResult);


    GetVehicleTrajectoryFixResult::GetVehicleTrajectoryFixResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryFixResult::GetVehicleTrajectoryFixResult(CommandBasePtr relatedCommand, const std::string& type, double lat, double lon, double alt, double yaw, double pitch, double roll)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    GetVehicleTrajectoryFixResultPtr GetVehicleTrajectoryFixResult::create(CommandBasePtr relatedCommand, const std::string& type, double lat, double lon, double alt, double yaw, double pitch, double roll)
    {
      return std::make_shared<GetVehicleTrajectoryFixResult>(relatedCommand, type, lat, lon, alt, yaw, pitch, roll);
    }

    GetVehicleTrajectoryFixResultPtr GetVehicleTrajectoryFixResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryFixResult>(ptr);
    }

    bool GetVehicleTrajectoryFixResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string GetVehicleTrajectoryFixResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryFixResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryFixResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetVehicleTrajectoryFixResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetVehicleTrajectoryFixResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetVehicleTrajectoryFixResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetVehicleTrajectoryFixResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetVehicleTrajectoryFixResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetVehicleTrajectoryFixResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectoryFixEcef
///
#include "gen/SetVehicleTrajectoryFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectoryFixEcef::CmdName = "SetVehicleTrajectoryFixEcef";
    const char* const SetVehicleTrajectoryFixEcef::Documentation = "Set vehicle static position and orientation";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectoryFixEcef);


    SetVehicleTrajectoryFixEcef::SetVehicleTrajectoryFixEcef()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectoryFixEcef::SetVehicleTrajectoryFixEcef(const std::string& type, double x, double y, double z, double yaw, double pitch, double roll)
      : CommandBase(CmdName)
    {

      setType(type);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    SetVehicleTrajectoryFixEcefPtr SetVehicleTrajectoryFixEcef::create(const std::string& type, double x, double y, double z, double yaw, double pitch, double roll)
    {
      return std::make_shared<SetVehicleTrajectoryFixEcef>(type, x, y, z, yaw, pitch, roll);
    }

    SetVehicleTrajectoryFixEcefPtr SetVehicleTrajectoryFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectoryFixEcef>(ptr);
    }

    bool SetVehicleTrajectoryFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string SetVehicleTrajectoryFixEcef::documentation() const { return Documentation; }


    int SetVehicleTrajectoryFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectoryFixEcef::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectoryFixEcef::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetVehicleTrajectoryFixEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetVehicleTrajectoryFixEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetVehicleTrajectoryFixEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetVehicleTrajectoryFixEcef::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetVehicleTrajectoryFixEcef::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetVehicleTrajectoryFixEcef::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectoryFixEcef
///
#include "gen/GetVehicleTrajectoryFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryFixEcef::CmdName = "GetVehicleTrajectoryFixEcef";
    const char* const GetVehicleTrajectoryFixEcef::Documentation = "Get vehicle static position and orientation";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectoryFixEcef);


    GetVehicleTrajectoryFixEcef::GetVehicleTrajectoryFixEcef()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryFixEcefPtr GetVehicleTrajectoryFixEcef::create()
    {
      return std::make_shared<GetVehicleTrajectoryFixEcef>();
    }

    GetVehicleTrajectoryFixEcefPtr GetVehicleTrajectoryFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryFixEcef>(ptr);
    }

    bool GetVehicleTrajectoryFixEcef::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectoryFixEcef::documentation() const { return Documentation; }


    int GetVehicleTrajectoryFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryFixEcefResult
///
#include "gen/GetVehicleTrajectoryFixEcefResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryFixEcefResult::CmdName = "GetVehicleTrajectoryFixEcefResult";
    const char* const GetVehicleTrajectoryFixEcefResult::Documentation = "Result of GetVehicleTrajectoryFixEcef.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryFixEcefResult);


    GetVehicleTrajectoryFixEcefResult::GetVehicleTrajectoryFixEcefResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryFixEcefResult::GetVehicleTrajectoryFixEcefResult(CommandBasePtr relatedCommand, const std::string& type, double x, double y, double z, double yaw, double pitch, double roll)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    GetVehicleTrajectoryFixEcefResultPtr GetVehicleTrajectoryFixEcefResult::create(CommandBasePtr relatedCommand, const std::string& type, double x, double y, double z, double yaw, double pitch, double roll)
    {
      return std::make_shared<GetVehicleTrajectoryFixEcefResult>(relatedCommand, type, x, y, z, yaw, pitch, roll);
    }

    GetVehicleTrajectoryFixEcefResultPtr GetVehicleTrajectoryFixEcefResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryFixEcefResult>(ptr);
    }

    bool GetVehicleTrajectoryFixEcefResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string GetVehicleTrajectoryFixEcefResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryFixEcefResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectoryCircular
///
#include "gen/SetVehicleTrajectoryCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectoryCircular::CmdName = "SetVehicleTrajectoryCircular";
    const char* const SetVehicleTrajectoryCircular::Documentation = "Set vehicle circular trajectory";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectoryCircular);


    SetVehicleTrajectoryCircular::SetVehicleTrajectoryCircular()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectoryCircular::SetVehicleTrajectoryCircular(const std::string& type, double lat, double lon, double alt, double radius, double speed, bool clockwise, const Sdx::optional<double>& originAngle)
      : CommandBase(CmdName)
    {

      setType(type);
      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setOriginAngle(originAngle);
    }


    SetVehicleTrajectoryCircularPtr SetVehicleTrajectoryCircular::create(const std::string& type, double lat, double lon, double alt, double radius, double speed, bool clockwise, const Sdx::optional<double>& originAngle)
    {
      return std::make_shared<SetVehicleTrajectoryCircular>(type, lat, lon, alt, radius, speed, clockwise, originAngle);
    }

    SetVehicleTrajectoryCircularPtr SetVehicleTrajectoryCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectoryCircular>(ptr);
    }

    bool SetVehicleTrajectoryCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string SetVehicleTrajectoryCircular::documentation() const { return Documentation; }


    int SetVehicleTrajectoryCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectoryCircular::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectoryCircular::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetVehicleTrajectoryCircular::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetVehicleTrajectoryCircular::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetVehicleTrajectoryCircular::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void SetVehicleTrajectoryCircular::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void SetVehicleTrajectoryCircular::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetVehicleTrajectoryCircular::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void SetVehicleTrajectoryCircular::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> SetVehicleTrajectoryCircular::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void SetVehicleTrajectoryCircular::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectoryCircular
///
#include "gen/GetVehicleTrajectoryCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryCircular::CmdName = "GetVehicleTrajectoryCircular";
    const char* const GetVehicleTrajectoryCircular::Documentation = "Get vehicle circular trajectory";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectoryCircular);


    GetVehicleTrajectoryCircular::GetVehicleTrajectoryCircular()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryCircularPtr GetVehicleTrajectoryCircular::create()
    {
      return std::make_shared<GetVehicleTrajectoryCircular>();
    }

    GetVehicleTrajectoryCircularPtr GetVehicleTrajectoryCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryCircular>(ptr);
    }

    bool GetVehicleTrajectoryCircular::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectoryCircular::documentation() const { return Documentation; }


    int GetVehicleTrajectoryCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryCircularResult
///
#include "gen/GetVehicleTrajectoryCircularResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryCircularResult::CmdName = "GetVehicleTrajectoryCircularResult";
    const char* const GetVehicleTrajectoryCircularResult::Documentation = "Result of GetVehicleTrajectoryCircular.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryCircularResult);


    GetVehicleTrajectoryCircularResult::GetVehicleTrajectoryCircularResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryCircularResult::GetVehicleTrajectoryCircularResult(CommandBasePtr relatedCommand, const std::string& type, double lat, double lon, double alt, double radius, double speed, bool clockwise, const Sdx::optional<double>& originAngle)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setOriginAngle(originAngle);
    }


    GetVehicleTrajectoryCircularResultPtr GetVehicleTrajectoryCircularResult::create(CommandBasePtr relatedCommand, const std::string& type, double lat, double lon, double alt, double radius, double speed, bool clockwise, const Sdx::optional<double>& originAngle)
    {
      return std::make_shared<GetVehicleTrajectoryCircularResult>(relatedCommand, type, lat, lon, alt, radius, speed, clockwise, originAngle);
    }

    GetVehicleTrajectoryCircularResultPtr GetVehicleTrajectoryCircularResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryCircularResult>(ptr);
    }

    bool GetVehicleTrajectoryCircularResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string GetVehicleTrajectoryCircularResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryCircularResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryCircularResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetVehicleTrajectoryCircularResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetVehicleTrajectoryCircularResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetVehicleTrajectoryCircularResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void GetVehicleTrajectoryCircularResult::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void GetVehicleTrajectoryCircularResult::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetVehicleTrajectoryCircularResult::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void GetVehicleTrajectoryCircularResult::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetVehicleTrajectoryCircularResult::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void GetVehicleTrajectoryCircularResult::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectoryOrbit
///
#include "gen/SetVehicleTrajectoryOrbit.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectoryOrbit::CmdName = "SetVehicleTrajectoryOrbit";
    const char* const SetVehicleTrajectoryOrbit::Documentation = "Set earth-orbiting spacecraft trajectory.";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectoryOrbit);


    SetVehicleTrajectoryOrbit::SetVehicleTrajectoryOrbit()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectoryOrbit::SetVehicleTrajectoryOrbit(const std::string& type, const Sdx::DateTime& reference, double semiMajorAxis, double inclination, double rightAscension, double eccentricity, double meanAnomaly, double argumentOfPerigee)
      : CommandBase(CmdName)
    {

      setType(type);
      setReference(reference);
      setSemiMajorAxis(semiMajorAxis);
      setInclination(inclination);
      setRightAscension(rightAscension);
      setEccentricity(eccentricity);
      setMeanAnomaly(meanAnomaly);
      setArgumentOfPerigee(argumentOfPerigee);
    }


    SetVehicleTrajectoryOrbitPtr SetVehicleTrajectoryOrbit::create(const std::string& type, const Sdx::DateTime& reference, double semiMajorAxis, double inclination, double rightAscension, double eccentricity, double meanAnomaly, double argumentOfPerigee)
    {
      return std::make_shared<SetVehicleTrajectoryOrbit>(type, reference, semiMajorAxis, inclination, rightAscension, eccentricity, meanAnomaly, argumentOfPerigee);
    }

    SetVehicleTrajectoryOrbitPtr SetVehicleTrajectoryOrbit::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectoryOrbit>(ptr);
    }

    bool SetVehicleTrajectoryOrbit::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Reference"])
          && parse_json<double>::is_valid(m_values["SemiMajorAxis"])
          && parse_json<double>::is_valid(m_values["Inclination"])
          && parse_json<double>::is_valid(m_values["RightAscension"])
          && parse_json<double>::is_valid(m_values["Eccentricity"])
          && parse_json<double>::is_valid(m_values["MeanAnomaly"])
          && parse_json<double>::is_valid(m_values["ArgumentOfPerigee"])
        ;

    }

    std::string SetVehicleTrajectoryOrbit::documentation() const { return Documentation; }


    int SetVehicleTrajectoryOrbit::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectoryOrbit::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectoryOrbit::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetVehicleTrajectoryOrbit::reference() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Reference"]);
    }

    void SetVehicleTrajectoryOrbit::setReference(const Sdx::DateTime& reference)
    {
      m_values.AddMember("Reference", parse_json<Sdx::DateTime>::format(reference, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::semiMajorAxis() const
    {
      return parse_json<double>::parse(m_values["SemiMajorAxis"]);
    }

    void SetVehicleTrajectoryOrbit::setSemiMajorAxis(double semiMajorAxis)
    {
      m_values.AddMember("SemiMajorAxis", parse_json<double>::format(semiMajorAxis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::inclination() const
    {
      return parse_json<double>::parse(m_values["Inclination"]);
    }

    void SetVehicleTrajectoryOrbit::setInclination(double inclination)
    {
      m_values.AddMember("Inclination", parse_json<double>::format(inclination, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::rightAscension() const
    {
      return parse_json<double>::parse(m_values["RightAscension"]);
    }

    void SetVehicleTrajectoryOrbit::setRightAscension(double rightAscension)
    {
      m_values.AddMember("RightAscension", parse_json<double>::format(rightAscension, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::eccentricity() const
    {
      return parse_json<double>::parse(m_values["Eccentricity"]);
    }

    void SetVehicleTrajectoryOrbit::setEccentricity(double eccentricity)
    {
      m_values.AddMember("Eccentricity", parse_json<double>::format(eccentricity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::meanAnomaly() const
    {
      return parse_json<double>::parse(m_values["MeanAnomaly"]);
    }

    void SetVehicleTrajectoryOrbit::setMeanAnomaly(double meanAnomaly)
    {
      m_values.AddMember("MeanAnomaly", parse_json<double>::format(meanAnomaly, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::argumentOfPerigee() const
    {
      return parse_json<double>::parse(m_values["ArgumentOfPerigee"]);
    }

    void SetVehicleTrajectoryOrbit::setArgumentOfPerigee(double argumentOfPerigee)
    {
      m_values.AddMember("ArgumentOfPerigee", parse_json<double>::format(argumentOfPerigee, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectoryOrbit
///
#include "gen/GetVehicleTrajectoryOrbit.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryOrbit::CmdName = "GetVehicleTrajectoryOrbit";
    const char* const GetVehicleTrajectoryOrbit::Documentation = "Get earth-orbiting spacecraft trajectory.";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectoryOrbit);


    GetVehicleTrajectoryOrbit::GetVehicleTrajectoryOrbit()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryOrbitPtr GetVehicleTrajectoryOrbit::create()
    {
      return std::make_shared<GetVehicleTrajectoryOrbit>();
    }

    GetVehicleTrajectoryOrbitPtr GetVehicleTrajectoryOrbit::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryOrbit>(ptr);
    }

    bool GetVehicleTrajectoryOrbit::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectoryOrbit::documentation() const { return Documentation; }


    int GetVehicleTrajectoryOrbit::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryOrbitResult
///
#include "gen/GetVehicleTrajectoryOrbitResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryOrbitResult::CmdName = "GetVehicleTrajectoryOrbitResult";
    const char* const GetVehicleTrajectoryOrbitResult::Documentation = "Result of GetVehicleTrajectoryOrbit.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryOrbitResult);


    GetVehicleTrajectoryOrbitResult::GetVehicleTrajectoryOrbitResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryOrbitResult::GetVehicleTrajectoryOrbitResult(CommandBasePtr relatedCommand, const std::string& type, const Sdx::DateTime& reference, double semiMajorAxis, double inclination, double rightAscension, double eccentricity, double meanAnomaly, double argumentOfPerigee)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setReference(reference);
      setSemiMajorAxis(semiMajorAxis);
      setInclination(inclination);
      setRightAscension(rightAscension);
      setEccentricity(eccentricity);
      setMeanAnomaly(meanAnomaly);
      setArgumentOfPerigee(argumentOfPerigee);
    }


    GetVehicleTrajectoryOrbitResultPtr GetVehicleTrajectoryOrbitResult::create(CommandBasePtr relatedCommand, const std::string& type, const Sdx::DateTime& reference, double semiMajorAxis, double inclination, double rightAscension, double eccentricity, double meanAnomaly, double argumentOfPerigee)
    {
      return std::make_shared<GetVehicleTrajectoryOrbitResult>(relatedCommand, type, reference, semiMajorAxis, inclination, rightAscension, eccentricity, meanAnomaly, argumentOfPerigee);
    }

    GetVehicleTrajectoryOrbitResultPtr GetVehicleTrajectoryOrbitResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryOrbitResult>(ptr);
    }

    bool GetVehicleTrajectoryOrbitResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Reference"])
          && parse_json<double>::is_valid(m_values["SemiMajorAxis"])
          && parse_json<double>::is_valid(m_values["Inclination"])
          && parse_json<double>::is_valid(m_values["RightAscension"])
          && parse_json<double>::is_valid(m_values["Eccentricity"])
          && parse_json<double>::is_valid(m_values["MeanAnomaly"])
          && parse_json<double>::is_valid(m_values["ArgumentOfPerigee"])
        ;

    }

    std::string GetVehicleTrajectoryOrbitResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryOrbitResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryOrbitResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime GetVehicleTrajectoryOrbitResult::reference() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Reference"]);
    }

    void GetVehicleTrajectoryOrbitResult::setReference(const Sdx::DateTime& reference)
    {
      m_values.AddMember("Reference", parse_json<Sdx::DateTime>::format(reference, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::semiMajorAxis() const
    {
      return parse_json<double>::parse(m_values["SemiMajorAxis"]);
    }

    void GetVehicleTrajectoryOrbitResult::setSemiMajorAxis(double semiMajorAxis)
    {
      m_values.AddMember("SemiMajorAxis", parse_json<double>::format(semiMajorAxis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::inclination() const
    {
      return parse_json<double>::parse(m_values["Inclination"]);
    }

    void GetVehicleTrajectoryOrbitResult::setInclination(double inclination)
    {
      m_values.AddMember("Inclination", parse_json<double>::format(inclination, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::rightAscension() const
    {
      return parse_json<double>::parse(m_values["RightAscension"]);
    }

    void GetVehicleTrajectoryOrbitResult::setRightAscension(double rightAscension)
    {
      m_values.AddMember("RightAscension", parse_json<double>::format(rightAscension, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::eccentricity() const
    {
      return parse_json<double>::parse(m_values["Eccentricity"]);
    }

    void GetVehicleTrajectoryOrbitResult::setEccentricity(double eccentricity)
    {
      m_values.AddMember("Eccentricity", parse_json<double>::format(eccentricity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::meanAnomaly() const
    {
      return parse_json<double>::parse(m_values["MeanAnomaly"]);
    }

    void GetVehicleTrajectoryOrbitResult::setMeanAnomaly(double meanAnomaly)
    {
      m_values.AddMember("MeanAnomaly", parse_json<double>::format(meanAnomaly, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::argumentOfPerigee() const
    {
      return parse_json<double>::parse(m_values["ArgumentOfPerigee"]);
    }

    void GetVehicleTrajectoryOrbitResult::setArgumentOfPerigee(double argumentOfPerigee)
    {
      m_values.AddMember("ArgumentOfPerigee", parse_json<double>::format(argumentOfPerigee, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetHilPort
///
#include "gen/GetHilPort.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetHilPort::CmdName = "GetHilPort";
    const char* const GetHilPort::Documentation = "Get Hardware in the loop trajectory server port.";

    REGISTER_COMMAND_FACTORY(GetHilPort);


    GetHilPort::GetHilPort()
      : CommandBase(CmdName)
    {

    }


    GetHilPortPtr GetHilPort::create()
    {
      return std::make_shared<GetHilPort>();
    }

    GetHilPortPtr GetHilPort::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetHilPort>(ptr);
    }

    bool GetHilPort::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetHilPort::documentation() const { return Documentation; }


    int GetHilPort::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of HilPortResult
///
#include "gen/HilPortResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const HilPortResult::CmdName = "HilPortResult";
    const char* const HilPortResult::Documentation = "Result of GetHilPort.";

    REGISTER_COMMAND_RESULT_FACTORY(HilPortResult);


    HilPortResult::HilPortResult()
      : CommandResult(CmdName)
    {}

    HilPortResult::HilPortResult(CommandBasePtr relatedCommand, int port)
      : CommandResult(CmdName, relatedCommand)
    {

      setPort(port);
    }


    HilPortResultPtr HilPortResult::create(CommandBasePtr relatedCommand, int port)
    {
      return std::make_shared<HilPortResult>(relatedCommand, port);
    }

    HilPortResultPtr HilPortResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<HilPortResult>(ptr);
    }

    bool HilPortResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Port"])
        ;

    }

    std::string HilPortResult::documentation() const { return Documentation; }


    int HilPortResult::port() const
    {
      return parse_json<int>::parse(m_values["Port"]);
    }

    void HilPortResult::setPort(int port)
    {
      m_values.AddMember("Port", parse_json<int>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetHilExtrapolationState
///
#include "gen/GetHilExtrapolationState.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetHilExtrapolationState::CmdName = "GetHilExtrapolationState";
    const char* const GetHilExtrapolationState::Documentation = "Get last Hardware in the loop extrapolation state. The states are defined as\nthe following increasing priority levels: Deterministic, NonDeterministic and Snap.\nThe state will stay on the highest level until polled. Polling the extrapolation state will reset it.\nReturns GetHilExtrapolationStateResult.";

    REGISTER_COMMAND_FACTORY(GetHilExtrapolationState);


    GetHilExtrapolationState::GetHilExtrapolationState()
      : CommandBase(CmdName)
    {

    }


    GetHilExtrapolationStatePtr GetHilExtrapolationState::create()
    {
      return std::make_shared<GetHilExtrapolationState>();
    }

    GetHilExtrapolationStatePtr GetHilExtrapolationState::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetHilExtrapolationState>(ptr);
    }

    bool GetHilExtrapolationState::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetHilExtrapolationState::documentation() const { return Documentation; }


    int GetHilExtrapolationState::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetHilExtrapolationStateResult
///
#include "gen/GetHilExtrapolationStateResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetHilExtrapolationStateResult::CmdName = "GetHilExtrapolationStateResult";
    const char* const GetHilExtrapolationStateResult::Documentation = "Result of GetHilExtrapolationState.";

    REGISTER_COMMAND_RESULT_FACTORY(GetHilExtrapolationStateResult);


    GetHilExtrapolationStateResult::GetHilExtrapolationStateResult()
      : CommandResult(CmdName)
    {}

    GetHilExtrapolationStateResult::GetHilExtrapolationStateResult(CommandBasePtr relatedCommand, const Sdx::HilExtrapolationState& state, int elapsedTime)
      : CommandResult(CmdName, relatedCommand)
    {

      setState(state);
      setElapsedTime(elapsedTime);
    }


    GetHilExtrapolationStateResultPtr GetHilExtrapolationStateResult::create(CommandBasePtr relatedCommand, const Sdx::HilExtrapolationState& state, int elapsedTime)
    {
      return std::make_shared<GetHilExtrapolationStateResult>(relatedCommand, state, elapsedTime);
    }

    GetHilExtrapolationStateResultPtr GetHilExtrapolationStateResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetHilExtrapolationStateResult>(ptr);
    }

    bool GetHilExtrapolationStateResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::HilExtrapolationState>::is_valid(m_values["State"])
          && parse_json<int>::is_valid(m_values["ElapsedTime"])
        ;

    }

    std::string GetHilExtrapolationStateResult::documentation() const { return Documentation; }


    Sdx::HilExtrapolationState GetHilExtrapolationStateResult::state() const
    {
      return parse_json<Sdx::HilExtrapolationState>::parse(m_values["State"]);
    }

    void GetHilExtrapolationStateResult::setState(const Sdx::HilExtrapolationState& state)
    {
      m_values.AddMember("State", parse_json<Sdx::HilExtrapolationState>::format(state, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetHilExtrapolationStateResult::elapsedTime() const
    {
      return parse_json<int>::parse(m_values["ElapsedTime"]);
    }

    void GetHilExtrapolationStateResult::setElapsedTime(int elapsedTime)
    {
      m_values.AddMember("ElapsedTime", parse_json<int>::format(elapsedTime, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetEphemerisReferenceTimeForSV
///
#include "gen/SetEphemerisReferenceTimeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetEphemerisReferenceTimeForSV::CmdName = "SetEphemerisReferenceTimeForSV";
    const char* const SetEphemerisReferenceTimeForSV::Documentation = "Set the ephemeris reference time for the specified constellation.";

    REGISTER_COMMAND_FACTORY(SetEphemerisReferenceTimeForSV);


    SetEphemerisReferenceTimeForSV::SetEphemerisReferenceTimeForSV()
      : CommandBase(CmdName)
    {}

    SetEphemerisReferenceTimeForSV::SetEphemerisReferenceTimeForSV(const std::string& system, int svId, const Sdx::DateTime& time, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setTime(time);
      setDataSetName(dataSetName);
    }


    SetEphemerisReferenceTimeForSVPtr SetEphemerisReferenceTimeForSV::create(const std::string& system, int svId, const Sdx::DateTime& time, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetEphemerisReferenceTimeForSV>(system, svId, time, dataSetName);
    }

    SetEphemerisReferenceTimeForSVPtr SetEphemerisReferenceTimeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetEphemerisReferenceTimeForSV>(ptr);
    }

    bool SetEphemerisReferenceTimeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetEphemerisReferenceTimeForSV::documentation() const { return Documentation; }


    int SetEphemerisReferenceTimeForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetEphemerisReferenceTimeForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetEphemerisReferenceTimeForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetEphemerisReferenceTimeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetEphemerisReferenceTimeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetEphemerisReferenceTimeForSV::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void SetEphemerisReferenceTimeForSV::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetEphemerisReferenceTimeForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetEphemerisReferenceTimeForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetEphemerisReferenceTime
///
#include "gen/SetEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetEphemerisReferenceTime::CmdName = "SetEphemerisReferenceTime";
    const char* const SetEphemerisReferenceTime::Documentation = "Please note the command SetEphemerisReferenceTime is deprecated since 21.3. You may use SetEphemerisReferenceTimeForSV.\n\nSet the ephemeris reference time for the specified constellation.";

    REGISTER_COMMAND_FACTORY(SetEphemerisReferenceTime);


    SetEphemerisReferenceTime::SetEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    SetEphemerisReferenceTime::SetEphemerisReferenceTime(const std::string& system, int svId, const Sdx::DateTime& time, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setTime(time);
      setDataSetName(dataSetName);
    }


    SetEphemerisReferenceTimePtr SetEphemerisReferenceTime::create(const std::string& system, int svId, const Sdx::DateTime& time, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetEphemerisReferenceTime>(system, svId, time, dataSetName);
    }

    SetEphemerisReferenceTimePtr SetEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetEphemerisReferenceTime>(ptr);
    }

    bool SetEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetEphemerisReferenceTime::documentation() const { return Documentation; }


    int SetEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetEphemerisReferenceTime::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetEphemerisReferenceTime::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetEphemerisReferenceTime::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetEphemerisReferenceTime::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetEphemerisReferenceTime::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void SetEphemerisReferenceTime::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetEphemerisReferenceTime::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetEphemerisReferenceTime::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisReferenceTimeForSV
///
#include "gen/GetEphemerisReferenceTimeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisReferenceTimeForSV::CmdName = "GetEphemerisReferenceTimeForSV";
    const char* const GetEphemerisReferenceTimeForSV::Documentation = "Get the ephemeris reference time for the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetEphemerisReferenceTimeForSV);


    GetEphemerisReferenceTimeForSV::GetEphemerisReferenceTimeForSV()
      : CommandBase(CmdName)
    {}

    GetEphemerisReferenceTimeForSV::GetEphemerisReferenceTimeForSV(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetEphemerisReferenceTimeForSVPtr GetEphemerisReferenceTimeForSV::create(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetEphemerisReferenceTimeForSV>(system, svId, dataSetName);
    }

    GetEphemerisReferenceTimeForSVPtr GetEphemerisReferenceTimeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisReferenceTimeForSV>(ptr);
    }

    bool GetEphemerisReferenceTimeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetEphemerisReferenceTimeForSV::documentation() const { return Documentation; }


    int GetEphemerisReferenceTimeForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetEphemerisReferenceTimeForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisReferenceTimeForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisReferenceTimeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisReferenceTimeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetEphemerisReferenceTimeForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetEphemerisReferenceTimeForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisReferenceTime
///
#include "gen/GetEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisReferenceTime::CmdName = "GetEphemerisReferenceTime";
    const char* const GetEphemerisReferenceTime::Documentation = "Please note the command GetEphemerisReferenceTime is deprecated since 21.3. You may use GetEphemerisReferenceTimeForSV.\n\nGet the ephemeris reference time for the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetEphemerisReferenceTime);


    GetEphemerisReferenceTime::GetEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    GetEphemerisReferenceTime::GetEphemerisReferenceTime(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetEphemerisReferenceTimePtr GetEphemerisReferenceTime::create(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetEphemerisReferenceTime>(system, svId, dataSetName);
    }

    GetEphemerisReferenceTimePtr GetEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisReferenceTime>(ptr);
    }

    bool GetEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetEphemerisReferenceTime::documentation() const { return Documentation; }


    int GetEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetEphemerisReferenceTime::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisReferenceTime::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisReferenceTime::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisReferenceTime::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetEphemerisReferenceTime::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetEphemerisReferenceTime::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisReferenceTimeForSVResult
///
#include "gen/GetEphemerisReferenceTimeForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisReferenceTimeForSVResult::CmdName = "GetEphemerisReferenceTimeForSVResult";
    const char* const GetEphemerisReferenceTimeForSVResult::Documentation = "Result of GetEphemerisReferenceTimeForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetEphemerisReferenceTimeForSVResult);


    GetEphemerisReferenceTimeForSVResult::GetEphemerisReferenceTimeForSVResult()
      : CommandResult(CmdName)
    {}

    GetEphemerisReferenceTimeForSVResult::GetEphemerisReferenceTimeForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::DateTime& time, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setTime(time);
      setDataSetName(dataSetName);
    }


    GetEphemerisReferenceTimeForSVResultPtr GetEphemerisReferenceTimeForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::DateTime& time, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetEphemerisReferenceTimeForSVResult>(relatedCommand, system, svId, time, dataSetName);
    }

    GetEphemerisReferenceTimeForSVResultPtr GetEphemerisReferenceTimeForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisReferenceTimeForSVResult>(ptr);
    }

    bool GetEphemerisReferenceTimeForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetEphemerisReferenceTimeForSVResult::documentation() const { return Documentation; }


    std::string GetEphemerisReferenceTimeForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisReferenceTimeForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisReferenceTimeForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisReferenceTimeForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime GetEphemerisReferenceTimeForSVResult::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void GetEphemerisReferenceTimeForSVResult::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetEphemerisReferenceTimeForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetEphemerisReferenceTimeForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphDoubleParamForSV
///
#include "gen/SetGpsEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphDoubleParamForSV::CmdName = "SetGpsEphDoubleParamForSV";
    const char* const SetGpsEphDoubleParamForSV::Documentation = "Set various parameters in the GPS ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"IscL1Ca\"         sec\n  \"IscL2C\"          sec\n  \"IscL5I5\"         sec\n  \"IscL5Q5\"         sec\n  \"IscL1CP\"         sec\n  \"IscL1CD\"         sec";

    REGISTER_COMMAND_FACTORY(SetGpsEphDoubleParamForSV);


    SetGpsEphDoubleParamForSV::SetGpsEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetGpsEphDoubleParamForSV::SetGpsEphDoubleParamForSV(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetGpsEphDoubleParamForSVPtr SetGpsEphDoubleParamForSV::create(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsEphDoubleParamForSV>(svId, paramName, val, dataSetName);
    }

    SetGpsEphDoubleParamForSVPtr SetGpsEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphDoubleParamForSV>(ptr);
    }

    bool SetGpsEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetGpsEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGpsEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGpsEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetGpsEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphDoubleParamForSV
///
#include "gen/GetGpsEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphDoubleParamForSV::CmdName = "GetGpsEphDoubleParamForSV";
    const char* const GetGpsEphDoubleParamForSV::Documentation = "Get various parameters in the GPS ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"IscL1Ca\"         sec\n  \"IscL2C\"          sec\n  \"IscL5I5\"         sec\n  \"IscL5Q5\"         sec\n  \"IscL1CP\"         sec\n  \"IscL1CD\"         sec";

    REGISTER_COMMAND_FACTORY(GetGpsEphDoubleParamForSV);


    GetGpsEphDoubleParamForSV::GetGpsEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetGpsEphDoubleParamForSV::GetGpsEphDoubleParamForSV(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetGpsEphDoubleParamForSVPtr GetGpsEphDoubleParamForSV::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphDoubleParamForSV>(svId, paramName, dataSetName);
    }

    GetGpsEphDoubleParamForSVPtr GetGpsEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphDoubleParamForSV>(ptr);
    }

    bool GetGpsEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetGpsEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphDoubleParamForSVResult
///
#include "gen/GetGpsEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphDoubleParamForSVResult::CmdName = "GetGpsEphDoubleParamForSVResult";
    const char* const GetGpsEphDoubleParamForSVResult::Documentation = "Result of GetGpsEphDoubleParamForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphDoubleParamForSVResult);


    GetGpsEphDoubleParamForSVResult::GetGpsEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphDoubleParamForSVResult::GetGpsEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetGpsEphDoubleParamForSVResultPtr GetGpsEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphDoubleParamForSVResult>(relatedCommand, svId, paramName, val, dataSetName);
    }

    GetGpsEphDoubleParamForSVResultPtr GetGpsEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphDoubleParamForSVResult>(ptr);
    }

    bool GetGpsEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetGpsEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGpsEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetGpsEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphDoubleParamForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphDoubleParamForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoEphDoubleParamForSV
///
#include "gen/SetGalileoEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoEphDoubleParamForSV::CmdName = "SetGalileoEphDoubleParamForSV";
    const char* const SetGalileoEphDoubleParamForSV::Documentation = "Set various parameters in the Galileo ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"BgdE1E5a\"        ns\n  \"BgdE1E5b\"        ns";

    REGISTER_COMMAND_FACTORY(SetGalileoEphDoubleParamForSV);


    SetGalileoEphDoubleParamForSV::SetGalileoEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoEphDoubleParamForSV::SetGalileoEphDoubleParamForSV(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetGalileoEphDoubleParamForSVPtr SetGalileoEphDoubleParamForSV::create(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGalileoEphDoubleParamForSV>(svId, paramName, val, dataSetName);
    }

    SetGalileoEphDoubleParamForSVPtr SetGalileoEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoEphDoubleParamForSV>(ptr);
    }

    bool SetGalileoEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGalileoEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetGalileoEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGalileoEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGalileoEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGalileoEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGalileoEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetGalileoEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGalileoEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGalileoEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphDoubleParamForSV
///
#include "gen/GetGalileoEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphDoubleParamForSV::CmdName = "GetGalileoEphDoubleParamForSV";
    const char* const GetGalileoEphDoubleParamForSV::Documentation = "Get various parameters in the Galileo ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"BgdE1E5a\"        ns\n  \"BgdE1E5b\"        ns";

    REGISTER_COMMAND_FACTORY(GetGalileoEphDoubleParamForSV);


    GetGalileoEphDoubleParamForSV::GetGalileoEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetGalileoEphDoubleParamForSV::GetGalileoEphDoubleParamForSV(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetGalileoEphDoubleParamForSVPtr GetGalileoEphDoubleParamForSV::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGalileoEphDoubleParamForSV>(svId, paramName, dataSetName);
    }

    GetGalileoEphDoubleParamForSVPtr GetGalileoEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphDoubleParamForSV>(ptr);
    }

    bool GetGalileoEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGalileoEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetGalileoEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGalileoEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGalileoEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphDoubleParamForSVResult
///
#include "gen/GetGalileoEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphDoubleParamForSVResult::CmdName = "GetGalileoEphDoubleParamForSVResult";
    const char* const GetGalileoEphDoubleParamForSVResult::Documentation = "Result of GetGalileoEphDoubleParamForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoEphDoubleParamForSVResult);


    GetGalileoEphDoubleParamForSVResult::GetGalileoEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetGalileoEphDoubleParamForSVResult::GetGalileoEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetGalileoEphDoubleParamForSVResultPtr GetGalileoEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGalileoEphDoubleParamForSVResult>(relatedCommand, svId, paramName, val, dataSetName);
    }

    GetGalileoEphDoubleParamForSVResultPtr GetGalileoEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphDoubleParamForSVResult>(ptr);
    }

    bool GetGalileoEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGalileoEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetGalileoEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGalileoEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetGalileoEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGalileoEphDoubleParamForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGalileoEphDoubleParamForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphDoubleParamForSV
///
#include "gen/SetBeiDouEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphDoubleParamForSV::CmdName = "SetBeiDouEphDoubleParamForSV";
    const char* const SetBeiDouEphDoubleParamForSV::Documentation = "Set various parameters in the BeiDou ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd1\"            sec\n  \"Tgd2\"            sec\n  \"TgdB1Cp\"         sec\n  \"TgdB2Ap\"         sec";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphDoubleParamForSV);


    SetBeiDouEphDoubleParamForSV::SetBeiDouEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphDoubleParamForSV::SetBeiDouEphDoubleParamForSV(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetBeiDouEphDoubleParamForSVPtr SetBeiDouEphDoubleParamForSV::create(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouEphDoubleParamForSV>(svId, paramName, val, dataSetName);
    }

    SetBeiDouEphDoubleParamForSVPtr SetBeiDouEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphDoubleParamForSV>(ptr);
    }

    bool SetBeiDouEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetBeiDouEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetBeiDouEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetBeiDouEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetBeiDouEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetBeiDouEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphDoubleParamForSV
///
#include "gen/GetBeiDouEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphDoubleParamForSV::CmdName = "GetBeiDouEphDoubleParamForSV";
    const char* const GetBeiDouEphDoubleParamForSV::Documentation = "Get various parameters in the BeiDou ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd1\"            sec\n  \"Tgd2\"            sec\n  \"TgdB1Cp\"         sec\n  \"TgdB2Ap\"         sec";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphDoubleParamForSV);


    GetBeiDouEphDoubleParamForSV::GetBeiDouEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphDoubleParamForSV::GetBeiDouEphDoubleParamForSV(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphDoubleParamForSVPtr GetBeiDouEphDoubleParamForSV::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphDoubleParamForSV>(svId, paramName, dataSetName);
    }

    GetBeiDouEphDoubleParamForSVPtr GetBeiDouEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphDoubleParamForSV>(ptr);
    }

    bool GetBeiDouEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetBeiDouEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphDoubleParamForSVResult
///
#include "gen/GetBeiDouEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphDoubleParamForSVResult::CmdName = "GetBeiDouEphDoubleParamForSVResult";
    const char* const GetBeiDouEphDoubleParamForSVResult::Documentation = "Result of GetBeiDouEphDoubleParamForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphDoubleParamForSVResult);


    GetBeiDouEphDoubleParamForSVResult::GetBeiDouEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphDoubleParamForSVResult::GetBeiDouEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphDoubleParamForSVResultPtr GetBeiDouEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphDoubleParamForSVResult>(relatedCommand, svId, paramName, val, dataSetName);
    }

    GetBeiDouEphDoubleParamForSVResultPtr GetBeiDouEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphDoubleParamForSVResult>(ptr);
    }

    bool GetBeiDouEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetBeiDouEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetBeiDouEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetBeiDouEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphDoubleParamForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphDoubleParamForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassEphDoubleParamForSV
///
#include "gen/SetGlonassEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassEphDoubleParamForSV::CmdName = "SetGlonassEphDoubleParamForSV";
    const char* const SetGlonassEphDoubleParamForSV::Documentation = "Set various parameters for GLONASS\n\n  ParamName       Unit               Range          Description\n  \"TauC\"          sec                +/- 1          GLONASS time scale correction to UTC(SU) time\n  \"TauGps\"        day                +/- 1.9x10^-3  Correction to GPS time relative to GLONASS time\n  \"TauN\"          sec                +/- 1.9x10^-3  Coarse value of satellite time correction to GLONASS time\n  \"TLambda\"       sec                0..44100       Time of the first ascending node passage\n  \"Lambda\"        semicircle         +/- 1          Longitude of the first ascending node\n  \"DeltaI\"        semicircle         +/- 0.067      Correction to the mean value of inclination\n  \"Omega\"         semicircle         +/- 1          Argument of perigee\n  \"Eccentricity\"  -                  0..0.03        Eccentricity\n  \"DeltaT\"        sec/orb. period    +/- 3.6x10^3   Correction to the mean value of Draconian period\n  \"DeltaTRate\"    sec/orb. period^2  +/- 2^-8       Rate of change of Draconian period";

    REGISTER_COMMAND_FACTORY(SetGlonassEphDoubleParamForSV);


    SetGlonassEphDoubleParamForSV::SetGlonassEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetGlonassEphDoubleParamForSV::SetGlonassEphDoubleParamForSV(int svId, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetGlonassEphDoubleParamForSVPtr SetGlonassEphDoubleParamForSV::create(int svId, const std::string& paramName, double val)
    {
      return std::make_shared<SetGlonassEphDoubleParamForSV>(svId, paramName, val);
    }

    SetGlonassEphDoubleParamForSVPtr SetGlonassEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassEphDoubleParamForSV>(ptr);
    }

    bool SetGlonassEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGlonassEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetGlonassEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGlonassEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGlonassEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGlonassEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGlonassEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGlonassEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetGlonassEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphDoubleParamForSV
///
#include "gen/GetGlonassEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphDoubleParamForSV::CmdName = "GetGlonassEphDoubleParamForSV";
    const char* const GetGlonassEphDoubleParamForSV::Documentation = "Get various parameters for GLONASS\n\n  ParamName       Unit               Range          Description\n  \"TauC\"          sec                +/- 1          GLONASS time scale correction to UTC(SU) time\n  \"TauGps\"        day                +/- 1.9x10^-3  Correction to GPS time relative to GLONASS time\n  \"TauN\"          sec                +/- 1.9x10^-3  Coarse value of satellite time correction to GLONASS time\n  \"TLambda\"       sec                0..44100       Time of the first ascending node passage\n  \"Lambda\"        semicircle         +/- 1          Longitude of the first ascending node\n  \"DeltaI\"        semicircle         +/- 0.067      Correction to the mean value of inclination\n  \"Omega\"         semicircle         +/- 1          Argument of perigee\n  \"Eccentricity\"  -                  0..0.03        Eccentricity\n  \"DeltaT\"        sec/orb. period    +/- 3.6x10^3   Correction to the mean value of Draconian period\n  \"DeltaTRate\"    sec/orb. period^2  +/- 2^-8       Rate of change of Draconian period";

    REGISTER_COMMAND_FACTORY(GetGlonassEphDoubleParamForSV);


    GetGlonassEphDoubleParamForSV::GetGlonassEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetGlonassEphDoubleParamForSV::GetGlonassEphDoubleParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetGlonassEphDoubleParamForSVPtr GetGlonassEphDoubleParamForSV::create(int svId, const std::string& paramName)
    {
      return std::make_shared<GetGlonassEphDoubleParamForSV>(svId, paramName);
    }

    GetGlonassEphDoubleParamForSVPtr GetGlonassEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphDoubleParamForSV>(ptr);
    }

    bool GetGlonassEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGlonassEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetGlonassEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGlonassEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphDoubleParamForSVResult
///
#include "gen/GetGlonassEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphDoubleParamForSVResult::CmdName = "GetGlonassEphDoubleParamForSVResult";
    const char* const GetGlonassEphDoubleParamForSVResult::Documentation = "Result of GetGlonassEphDoubleParamForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassEphDoubleParamForSVResult);


    GetGlonassEphDoubleParamForSVResult::GetGlonassEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetGlonassEphDoubleParamForSVResult::GetGlonassEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetGlonassEphDoubleParamForSVResultPtr GetGlonassEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
    {
      return std::make_shared<GetGlonassEphDoubleParamForSVResult>(relatedCommand, svId, paramName, val);
    }

    GetGlonassEphDoubleParamForSVResultPtr GetGlonassEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphDoubleParamForSVResult>(ptr);
    }

    bool GetGlonassEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGlonassEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetGlonassEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGlonassEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGlonassEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetGlonassEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphDoubleParamForSV
///
#include "gen/SetQzssEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphDoubleParamForSV::CmdName = "SetQzssEphDoubleParamForSV";
    const char* const SetQzssEphDoubleParamForSV::Documentation = "Set various parameters in the QZSS ephemeris.";

    REGISTER_COMMAND_FACTORY(SetQzssEphDoubleParamForSV);


    SetQzssEphDoubleParamForSV::SetQzssEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetQzssEphDoubleParamForSV::SetQzssEphDoubleParamForSV(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetQzssEphDoubleParamForSVPtr SetQzssEphDoubleParamForSV::create(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssEphDoubleParamForSV>(svId, paramName, val, dataSetName);
    }

    SetQzssEphDoubleParamForSVPtr SetQzssEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphDoubleParamForSV>(ptr);
    }

    bool SetQzssEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetQzssEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetQzssEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphemerisDoubleParam
///
#include "gen/SetQzssEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphemerisDoubleParam::CmdName = "SetQzssEphemerisDoubleParam";
    const char* const SetQzssEphemerisDoubleParam::Documentation = "Please note the command SetQzssEphemerisDoubleParam is deprecated since 21.3. You may use SetQzssEphDoubleParamForSV.\n\nSet various parameters in the QZSS ephemeris.";

    REGISTER_COMMAND_FACTORY(SetQzssEphemerisDoubleParam);


    SetQzssEphemerisDoubleParam::SetQzssEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    SetQzssEphemerisDoubleParam::SetQzssEphemerisDoubleParam(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetQzssEphemerisDoubleParamPtr SetQzssEphemerisDoubleParam::create(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssEphemerisDoubleParam>(svId, paramName, val, dataSetName);
    }

    SetQzssEphemerisDoubleParamPtr SetQzssEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphemerisDoubleParam>(ptr);
    }

    bool SetQzssEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssEphemerisDoubleParam::documentation() const { return Documentation; }


    int SetQzssEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssEphemerisDoubleParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssEphemerisDoubleParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssEphemerisDoubleParam::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetQzssEphemerisDoubleParam::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssEphemerisDoubleParam::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssEphemerisDoubleParam::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphDoubleParamForSV
///
#include "gen/GetQzssEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphDoubleParamForSV::CmdName = "GetQzssEphDoubleParamForSV";
    const char* const GetQzssEphDoubleParamForSV::Documentation = "Get various parameters in the QZSS ephemeris.";

    REGISTER_COMMAND_FACTORY(GetQzssEphDoubleParamForSV);


    GetQzssEphDoubleParamForSV::GetQzssEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetQzssEphDoubleParamForSV::GetQzssEphDoubleParamForSV(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetQzssEphDoubleParamForSVPtr GetQzssEphDoubleParamForSV::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphDoubleParamForSV>(svId, paramName, dataSetName);
    }

    GetQzssEphDoubleParamForSVPtr GetQzssEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphDoubleParamForSV>(ptr);
    }

    bool GetQzssEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetQzssEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisDoubleParam
///
#include "gen/GetQzssEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisDoubleParam::CmdName = "GetQzssEphemerisDoubleParam";
    const char* const GetQzssEphemerisDoubleParam::Documentation = "Please note the command GetQzssEphemerisDoubleParam is deprecated since 21.3. You may use GetQzssEphDoubleParamForSV.\n\nGet various parameters in the QZSS ephemeris.";

    REGISTER_COMMAND_FACTORY(GetQzssEphemerisDoubleParam);


    GetQzssEphemerisDoubleParam::GetQzssEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    GetQzssEphemerisDoubleParam::GetQzssEphemerisDoubleParam(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetQzssEphemerisDoubleParamPtr GetQzssEphemerisDoubleParam::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphemerisDoubleParam>(svId, paramName, dataSetName);
    }

    GetQzssEphemerisDoubleParamPtr GetQzssEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisDoubleParam>(ptr);
    }

    bool GetQzssEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphemerisDoubleParam::documentation() const { return Documentation; }


    int GetQzssEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssEphemerisDoubleParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphemerisDoubleParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphemerisDoubleParam::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphemerisDoubleParam::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphDoubleParamForSVResult
///
#include "gen/GetQzssEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphDoubleParamForSVResult::CmdName = "GetQzssEphDoubleParamForSVResult";
    const char* const GetQzssEphDoubleParamForSVResult::Documentation = "Result of GetQzssEphDoubleParamForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssEphDoubleParamForSVResult);


    GetQzssEphDoubleParamForSVResult::GetQzssEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssEphDoubleParamForSVResult::GetQzssEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetQzssEphDoubleParamForSVResultPtr GetQzssEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphDoubleParamForSVResult>(relatedCommand, svId, paramName, val, dataSetName);
    }

    GetQzssEphDoubleParamForSVResultPtr GetQzssEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphDoubleParamForSVResult>(ptr);
    }

    bool GetQzssEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetQzssEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetQzssEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphDoubleParamForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphDoubleParamForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICEphDoubleParamForSV
///
#include "gen/SetNavICEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICEphDoubleParamForSV::CmdName = "SetNavICEphDoubleParamForSV";
    const char* const SetNavICEphDoubleParamForSV::Documentation = "Set various parameters in the NavIC ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec";

    REGISTER_COMMAND_FACTORY(SetNavICEphDoubleParamForSV);


    SetNavICEphDoubleParamForSV::SetNavICEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetNavICEphDoubleParamForSV::SetNavICEphDoubleParamForSV(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetNavICEphDoubleParamForSVPtr SetNavICEphDoubleParamForSV::create(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICEphDoubleParamForSV>(svId, paramName, val, dataSetName);
    }

    SetNavICEphDoubleParamForSVPtr SetNavICEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICEphDoubleParamForSV>(ptr);
    }

    bool SetNavICEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetNavICEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetNavICEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetNavICEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetNavICEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetNavICEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetNavICEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICEphemerisDoubleParam
///
#include "gen/SetNavICEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICEphemerisDoubleParam::CmdName = "SetNavICEphemerisDoubleParam";
    const char* const SetNavICEphemerisDoubleParam::Documentation = "Please note the command SetNavICEphemerisDoubleParam is deprecated since 21.3. You may use SetNavICEphDoubleParamForSV.\n\nSet various parameters in the NavIC ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec";

    REGISTER_COMMAND_FACTORY(SetNavICEphemerisDoubleParam);


    SetNavICEphemerisDoubleParam::SetNavICEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    SetNavICEphemerisDoubleParam::SetNavICEphemerisDoubleParam(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetNavICEphemerisDoubleParamPtr SetNavICEphemerisDoubleParam::create(int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICEphemerisDoubleParam>(svId, paramName, val, dataSetName);
    }

    SetNavICEphemerisDoubleParamPtr SetNavICEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICEphemerisDoubleParam>(ptr);
    }

    bool SetNavICEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICEphemerisDoubleParam::documentation() const { return Documentation; }


    int SetNavICEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetNavICEphemerisDoubleParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICEphemerisDoubleParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetNavICEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetNavICEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetNavICEphemerisDoubleParam::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetNavICEphemerisDoubleParam::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICEphemerisDoubleParam::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICEphemerisDoubleParam::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphDoubleParamForSV
///
#include "gen/GetNavICEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphDoubleParamForSV::CmdName = "GetNavICEphDoubleParamForSV";
    const char* const GetNavICEphDoubleParamForSV::Documentation = "Get various parameters in the NavIC ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec";

    REGISTER_COMMAND_FACTORY(GetNavICEphDoubleParamForSV);


    GetNavICEphDoubleParamForSV::GetNavICEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetNavICEphDoubleParamForSV::GetNavICEphDoubleParamForSV(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetNavICEphDoubleParamForSVPtr GetNavICEphDoubleParamForSV::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICEphDoubleParamForSV>(svId, paramName, dataSetName);
    }

    GetNavICEphDoubleParamForSVPtr GetNavICEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphDoubleParamForSV>(ptr);
    }

    bool GetNavICEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetNavICEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetNavICEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICEphDoubleParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICEphDoubleParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphemerisDoubleParam
///
#include "gen/GetNavICEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphemerisDoubleParam::CmdName = "GetNavICEphemerisDoubleParam";
    const char* const GetNavICEphemerisDoubleParam::Documentation = "Please note the command GetNavICEphemerisDoubleParam is deprecated since 21.3. You may use GetNavICEphDoubleParamForSV.\n\nGet various parameters in the NavIC ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec";

    REGISTER_COMMAND_FACTORY(GetNavICEphemerisDoubleParam);


    GetNavICEphemerisDoubleParam::GetNavICEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    GetNavICEphemerisDoubleParam::GetNavICEphemerisDoubleParam(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetNavICEphemerisDoubleParamPtr GetNavICEphemerisDoubleParam::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICEphemerisDoubleParam>(svId, paramName, dataSetName);
    }

    GetNavICEphemerisDoubleParamPtr GetNavICEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphemerisDoubleParam>(ptr);
    }

    bool GetNavICEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICEphemerisDoubleParam::documentation() const { return Documentation; }


    int GetNavICEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICEphemerisDoubleParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICEphemerisDoubleParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetNavICEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICEphemerisDoubleParam::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICEphemerisDoubleParam::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphDoubleParamForSVResult
///
#include "gen/GetNavICEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphDoubleParamForSVResult::CmdName = "GetNavICEphDoubleParamForSVResult";
    const char* const GetNavICEphDoubleParamForSVResult::Documentation = "Result of GetNavICEphDoubleParamForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetNavICEphDoubleParamForSVResult);


    GetNavICEphDoubleParamForSVResult::GetNavICEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetNavICEphDoubleParamForSVResult::GetNavICEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetNavICEphDoubleParamForSVResultPtr GetNavICEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICEphDoubleParamForSVResult>(relatedCommand, svId, paramName, val, dataSetName);
    }

    GetNavICEphDoubleParamForSVResultPtr GetNavICEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphDoubleParamForSVResult>(ptr);
    }

    bool GetNavICEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetNavICEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetNavICEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetNavICEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetNavICEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICEphDoubleParamForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICEphDoubleParamForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphDoubleParamForEachSV
///
#include "gen/SetGpsEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphDoubleParamForEachSV::CmdName = "SetGpsEphDoubleParamForEachSV";
    const char* const SetGpsEphDoubleParamForEachSV::Documentation = "Set GPS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGpsEphDoubleParamForEachSV);


    SetGpsEphDoubleParamForEachSV::SetGpsEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetGpsEphDoubleParamForEachSV::SetGpsEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetGpsEphDoubleParamForEachSVPtr SetGpsEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsEphDoubleParamForEachSV>(paramName, val, dataSetName);
    }

    SetGpsEphDoubleParamForEachSVPtr SetGpsEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphDoubleParamForEachSV>(ptr);
    }

    bool SetGpsEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetGpsEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGpsEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGpsEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphemerisDoubleParams
///
#include "gen/SetGpsEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphemerisDoubleParams::CmdName = "SetGpsEphemerisDoubleParams";
    const char* const SetGpsEphemerisDoubleParams::Documentation = "Please note the command SetGpsEphemerisDoubleParams is deprecated since 21.3. You may use SetGpsEphDoubleParamForEachSV.\n\nSet GPS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGpsEphemerisDoubleParams);


    SetGpsEphemerisDoubleParams::SetGpsEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetGpsEphemerisDoubleParams::SetGpsEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetGpsEphemerisDoubleParamsPtr SetGpsEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsEphemerisDoubleParams>(paramName, val, dataSetName);
    }

    SetGpsEphemerisDoubleParamsPtr SetGpsEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphemerisDoubleParams>(ptr);
    }

    bool SetGpsEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetGpsEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGpsEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGpsEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphDoubleParamForEachSV
///
#include "gen/GetGpsEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphDoubleParamForEachSV::CmdName = "GetGpsEphDoubleParamForEachSV";
    const char* const GetGpsEphDoubleParamForEachSV::Documentation = "Get GPS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGpsEphDoubleParamForEachSV);


    GetGpsEphDoubleParamForEachSV::GetGpsEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetGpsEphDoubleParamForEachSV::GetGpsEphDoubleParamForEachSV(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetGpsEphDoubleParamForEachSVPtr GetGpsEphDoubleParamForEachSV::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphDoubleParamForEachSV>(paramName, dataSetName);
    }

    GetGpsEphDoubleParamForEachSVPtr GetGpsEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphDoubleParamForEachSV>(ptr);
    }

    bool GetGpsEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetGpsEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisDoubleParams
///
#include "gen/GetGpsEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisDoubleParams::CmdName = "GetGpsEphemerisDoubleParams";
    const char* const GetGpsEphemerisDoubleParams::Documentation = "Please note the command GetGpsEphemerisDoubleParams is deprecated since 21.3. You may use GetGpsEphDoubleParamForEachSV.\n\nGet GPS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGpsEphemerisDoubleParams);


    GetGpsEphemerisDoubleParams::GetGpsEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetGpsEphemerisDoubleParams::GetGpsEphemerisDoubleParams(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetGpsEphemerisDoubleParamsPtr GetGpsEphemerisDoubleParams::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphemerisDoubleParams>(paramName, dataSetName);
    }

    GetGpsEphemerisDoubleParamsPtr GetGpsEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisDoubleParams>(ptr);
    }

    bool GetGpsEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetGpsEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphDoubleParamForEachSVResult
///
#include "gen/GetGpsEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphDoubleParamForEachSVResult::CmdName = "GetGpsEphDoubleParamForEachSVResult";
    const char* const GetGpsEphDoubleParamForEachSVResult::Documentation = "Result of GetGpsEphDoubleParamForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphDoubleParamForEachSVResult);


    GetGpsEphDoubleParamForEachSVResult::GetGpsEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphDoubleParamForEachSVResult::GetGpsEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetGpsEphDoubleParamForEachSVResultPtr GetGpsEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphDoubleParamForEachSVResult>(relatedCommand, paramName, val, dataSetName);
    }

    GetGpsEphDoubleParamForEachSVResultPtr GetGpsEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetGpsEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetGpsEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGpsEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetGpsEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphDoubleParamForEachSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphDoubleParamForEachSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoEphDoubleParamForEachSV
///
#include "gen/SetGalileoEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoEphDoubleParamForEachSV::CmdName = "SetGalileoEphDoubleParamForEachSV";
    const char* const SetGalileoEphDoubleParamForEachSV::Documentation = "Set Galileo ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGalileoEphDoubleParamForEachSV);


    SetGalileoEphDoubleParamForEachSV::SetGalileoEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetGalileoEphDoubleParamForEachSV::SetGalileoEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetGalileoEphDoubleParamForEachSVPtr SetGalileoEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGalileoEphDoubleParamForEachSV>(paramName, val, dataSetName);
    }

    SetGalileoEphDoubleParamForEachSVPtr SetGalileoEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoEphDoubleParamForEachSV>(ptr);
    }

    bool SetGalileoEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGalileoEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetGalileoEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGalileoEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGalileoEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGalileoEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGalileoEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGalileoEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGalileoEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoEphemerisDoubleParams
///
#include "gen/SetGalileoEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoEphemerisDoubleParams::CmdName = "SetGalileoEphemerisDoubleParams";
    const char* const SetGalileoEphemerisDoubleParams::Documentation = "Please note the command SetGalileoEphemerisDoubleParams is deprecated since 21.3. You may use SetGalileoEphDoubleParamForEachSV.\n\nSet Galileo ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGalileoEphemerisDoubleParams);


    SetGalileoEphemerisDoubleParams::SetGalileoEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetGalileoEphemerisDoubleParams::SetGalileoEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetGalileoEphemerisDoubleParamsPtr SetGalileoEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGalileoEphemerisDoubleParams>(paramName, val, dataSetName);
    }

    SetGalileoEphemerisDoubleParamsPtr SetGalileoEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoEphemerisDoubleParams>(ptr);
    }

    bool SetGalileoEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGalileoEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetGalileoEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGalileoEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGalileoEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGalileoEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGalileoEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGalileoEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGalileoEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphDoubleParamForEachSV
///
#include "gen/GetGalileoEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphDoubleParamForEachSV::CmdName = "GetGalileoEphDoubleParamForEachSV";
    const char* const GetGalileoEphDoubleParamForEachSV::Documentation = "Get Galileo ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGalileoEphDoubleParamForEachSV);


    GetGalileoEphDoubleParamForEachSV::GetGalileoEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetGalileoEphDoubleParamForEachSV::GetGalileoEphDoubleParamForEachSV(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetGalileoEphDoubleParamForEachSVPtr GetGalileoEphDoubleParamForEachSV::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGalileoEphDoubleParamForEachSV>(paramName, dataSetName);
    }

    GetGalileoEphDoubleParamForEachSVPtr GetGalileoEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphDoubleParamForEachSV>(ptr);
    }

    bool GetGalileoEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGalileoEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetGalileoEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGalileoEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGalileoEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGalileoEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphemerisDoubleParams
///
#include "gen/GetGalileoEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphemerisDoubleParams::CmdName = "GetGalileoEphemerisDoubleParams";
    const char* const GetGalileoEphemerisDoubleParams::Documentation = "Please note the command GetGalileoEphemerisDoubleParams is deprecated since 21.3. You may use GetGalileoEphDoubleParamForEachSV.\n\nGet Galileo ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGalileoEphemerisDoubleParams);


    GetGalileoEphemerisDoubleParams::GetGalileoEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetGalileoEphemerisDoubleParams::GetGalileoEphemerisDoubleParams(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetGalileoEphemerisDoubleParamsPtr GetGalileoEphemerisDoubleParams::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGalileoEphemerisDoubleParams>(paramName, dataSetName);
    }

    GetGalileoEphemerisDoubleParamsPtr GetGalileoEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphemerisDoubleParams>(ptr);
    }

    bool GetGalileoEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGalileoEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetGalileoEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGalileoEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGalileoEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGalileoEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphDoubleParamForEachSVResult
///
#include "gen/GetGalileoEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphDoubleParamForEachSVResult::CmdName = "GetGalileoEphDoubleParamForEachSVResult";
    const char* const GetGalileoEphDoubleParamForEachSVResult::Documentation = "Result of GetGalileoEphDoubleParamForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoEphDoubleParamForEachSVResult);


    GetGalileoEphDoubleParamForEachSVResult::GetGalileoEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGalileoEphDoubleParamForEachSVResult::GetGalileoEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetGalileoEphDoubleParamForEachSVResultPtr GetGalileoEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGalileoEphDoubleParamForEachSVResult>(relatedCommand, paramName, val, dataSetName);
    }

    GetGalileoEphDoubleParamForEachSVResultPtr GetGalileoEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetGalileoEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGalileoEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetGalileoEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGalileoEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetGalileoEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGalileoEphDoubleParamForEachSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGalileoEphDoubleParamForEachSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphDoubleParamForEachSV
///
#include "gen/SetBeiDouEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphDoubleParamForEachSV::CmdName = "SetBeiDouEphDoubleParamForEachSV";
    const char* const SetBeiDouEphDoubleParamForEachSV::Documentation = "Set BeiDou ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphDoubleParamForEachSV);


    SetBeiDouEphDoubleParamForEachSV::SetBeiDouEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphDoubleParamForEachSV::SetBeiDouEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetBeiDouEphDoubleParamForEachSVPtr SetBeiDouEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouEphDoubleParamForEachSV>(paramName, val, dataSetName);
    }

    SetBeiDouEphDoubleParamForEachSVPtr SetBeiDouEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphDoubleParamForEachSV>(ptr);
    }

    bool SetBeiDouEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetBeiDouEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetBeiDouEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetBeiDouEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetBeiDouEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphemerisDoubleParams
///
#include "gen/SetBeiDouEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphemerisDoubleParams::CmdName = "SetBeiDouEphemerisDoubleParams";
    const char* const SetBeiDouEphemerisDoubleParams::Documentation = "Please note the command SetBeiDouEphemerisDoubleParams is deprecated since 21.3. You may use SetBeiDouEphDoubleParamForEachSV.\n\nSet BeiDou ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphemerisDoubleParams);


    SetBeiDouEphemerisDoubleParams::SetBeiDouEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphemerisDoubleParams::SetBeiDouEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetBeiDouEphemerisDoubleParamsPtr SetBeiDouEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouEphemerisDoubleParams>(paramName, val, dataSetName);
    }

    SetBeiDouEphemerisDoubleParamsPtr SetBeiDouEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphemerisDoubleParams>(ptr);
    }

    bool SetBeiDouEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetBeiDouEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetBeiDouEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetBeiDouEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetBeiDouEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphDoubleParamForEachSV
///
#include "gen/GetBeiDouEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphDoubleParamForEachSV::CmdName = "GetBeiDouEphDoubleParamForEachSV";
    const char* const GetBeiDouEphDoubleParamForEachSV::Documentation = "Get BeiDou ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphDoubleParamForEachSV);


    GetBeiDouEphDoubleParamForEachSV::GetBeiDouEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphDoubleParamForEachSV::GetBeiDouEphDoubleParamForEachSV(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphDoubleParamForEachSVPtr GetBeiDouEphDoubleParamForEachSV::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphDoubleParamForEachSV>(paramName, dataSetName);
    }

    GetBeiDouEphDoubleParamForEachSVPtr GetBeiDouEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphDoubleParamForEachSV>(ptr);
    }

    bool GetBeiDouEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetBeiDouEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisDoubleParams
///
#include "gen/GetBeiDouEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisDoubleParams::CmdName = "GetBeiDouEphemerisDoubleParams";
    const char* const GetBeiDouEphemerisDoubleParams::Documentation = "Please note the command GetBeiDouEphemerisDoubleParams is deprecated since 21.3. You may use GetBeiDouEphDoubleParamForEachSV.\n\nGet BeiDou ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphemerisDoubleParams);


    GetBeiDouEphemerisDoubleParams::GetBeiDouEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphemerisDoubleParams::GetBeiDouEphemerisDoubleParams(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphemerisDoubleParamsPtr GetBeiDouEphemerisDoubleParams::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphemerisDoubleParams>(paramName, dataSetName);
    }

    GetBeiDouEphemerisDoubleParamsPtr GetBeiDouEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisDoubleParams>(ptr);
    }

    bool GetBeiDouEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetBeiDouEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphDoubleParamForEachSVResult
///
#include "gen/GetBeiDouEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphDoubleParamForEachSVResult::CmdName = "GetBeiDouEphDoubleParamForEachSVResult";
    const char* const GetBeiDouEphDoubleParamForEachSVResult::Documentation = "Result of GetBeiDouEphDoubleParamForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphDoubleParamForEachSVResult);


    GetBeiDouEphDoubleParamForEachSVResult::GetBeiDouEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphDoubleParamForEachSVResult::GetBeiDouEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphDoubleParamForEachSVResultPtr GetBeiDouEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphDoubleParamForEachSVResult>(relatedCommand, paramName, val, dataSetName);
    }

    GetBeiDouEphDoubleParamForEachSVResultPtr GetBeiDouEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetBeiDouEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetBeiDouEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetBeiDouEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetBeiDouEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphDoubleParamForEachSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphDoubleParamForEachSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassEphDoubleParamForEachSV
///
#include "gen/SetGlonassEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassEphDoubleParamForEachSV::CmdName = "SetGlonassEphDoubleParamForEachSV";
    const char* const SetGlonassEphDoubleParamForEachSV::Documentation = "Set GLONASS parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGlonassEphDoubleParamForEachSV);


    SetGlonassEphDoubleParamForEachSV::SetGlonassEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetGlonassEphDoubleParamForEachSV::SetGlonassEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGlonassEphDoubleParamForEachSVPtr SetGlonassEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val)
    {
      return std::make_shared<SetGlonassEphDoubleParamForEachSV>(paramName, val);
    }

    SetGlonassEphDoubleParamForEachSVPtr SetGlonassEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassEphDoubleParamForEachSV>(ptr);
    }

    bool SetGlonassEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGlonassEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetGlonassEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGlonassEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGlonassEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGlonassEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGlonassEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassDoubleParams
///
#include "gen/SetGlonassDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassDoubleParams::CmdName = "SetGlonassDoubleParams";
    const char* const SetGlonassDoubleParams::Documentation = "Please note the command SetGlonassDoubleParams is deprecated since 21.3. You may use SetGlonassEphDoubleParamForEachSV.\n\nSet GLONASS parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGlonassDoubleParams);


    SetGlonassDoubleParams::SetGlonassDoubleParams()
      : CommandBase(CmdName)
    {}

    SetGlonassDoubleParams::SetGlonassDoubleParams(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGlonassDoubleParamsPtr SetGlonassDoubleParams::create(const std::string& paramName, const std::vector<double>& val)
    {
      return std::make_shared<SetGlonassDoubleParams>(paramName, val);
    }

    SetGlonassDoubleParamsPtr SetGlonassDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassDoubleParams>(ptr);
    }

    bool SetGlonassDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGlonassDoubleParams::documentation() const { return Documentation; }


    int SetGlonassDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGlonassDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGlonassDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGlonassDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGlonassDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphDoubleParamForEachSV
///
#include "gen/GetGlonassEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphDoubleParamForEachSV::CmdName = "GetGlonassEphDoubleParamForEachSV";
    const char* const GetGlonassEphDoubleParamForEachSV::Documentation = "Get GLONASS parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGlonassEphDoubleParamForEachSV);


    GetGlonassEphDoubleParamForEachSV::GetGlonassEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetGlonassEphDoubleParamForEachSV::GetGlonassEphDoubleParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGlonassEphDoubleParamForEachSVPtr GetGlonassEphDoubleParamForEachSV::create(const std::string& paramName)
    {
      return std::make_shared<GetGlonassEphDoubleParamForEachSV>(paramName);
    }

    GetGlonassEphDoubleParamForEachSVPtr GetGlonassEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphDoubleParamForEachSV>(ptr);
    }

    bool GetGlonassEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGlonassEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetGlonassEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGlonassEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassDoubleParams
///
#include "gen/GetGlonassDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassDoubleParams::CmdName = "GetGlonassDoubleParams";
    const char* const GetGlonassDoubleParams::Documentation = "Please note the command GetGlonassDoubleParams is deprecated since 21.3. You may use GetGlonassEphDoubleParamForEachSV.\n\nGet GLONASS parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGlonassDoubleParams);


    GetGlonassDoubleParams::GetGlonassDoubleParams()
      : CommandBase(CmdName)
    {}

    GetGlonassDoubleParams::GetGlonassDoubleParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGlonassDoubleParamsPtr GetGlonassDoubleParams::create(const std::string& paramName)
    {
      return std::make_shared<GetGlonassDoubleParams>(paramName);
    }

    GetGlonassDoubleParamsPtr GetGlonassDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassDoubleParams>(ptr);
    }

    bool GetGlonassDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGlonassDoubleParams::documentation() const { return Documentation; }


    int GetGlonassDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGlonassDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphDoubleParamForEachSVResult
///
#include "gen/GetGlonassEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphDoubleParamForEachSVResult::CmdName = "GetGlonassEphDoubleParamForEachSVResult";
    const char* const GetGlonassEphDoubleParamForEachSVResult::Documentation = "Result of GetGlonassEphDoubleParamForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassEphDoubleParamForEachSVResult);


    GetGlonassEphDoubleParamForEachSVResult::GetGlonassEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGlonassEphDoubleParamForEachSVResult::GetGlonassEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetGlonassEphDoubleParamForEachSVResultPtr GetGlonassEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
    {
      return std::make_shared<GetGlonassEphDoubleParamForEachSVResult>(relatedCommand, paramName, val);
    }

    GetGlonassEphDoubleParamForEachSVResultPtr GetGlonassEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetGlonassEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGlonassEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetGlonassEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGlonassEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetGlonassEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassFrequencyNumberForEachSV
///
#include "gen/GetGlonassFrequencyNumberForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassFrequencyNumberForEachSV::CmdName = "GetGlonassFrequencyNumberForEachSV";
    const char* const GetGlonassFrequencyNumberForEachSV::Documentation = "Get GLONASS frequency number for all satellites. Return values range from -7 to 13. Value -8 is an invalid value, it indicates that the almanac for the satellite is invalid.";

    REGISTER_COMMAND_FACTORY(GetGlonassFrequencyNumberForEachSV);


    GetGlonassFrequencyNumberForEachSV::GetGlonassFrequencyNumberForEachSV()
      : CommandBase(CmdName)
    {

    }


    GetGlonassFrequencyNumberForEachSVPtr GetGlonassFrequencyNumberForEachSV::create()
    {
      return std::make_shared<GetGlonassFrequencyNumberForEachSV>();
    }

    GetGlonassFrequencyNumberForEachSVPtr GetGlonassFrequencyNumberForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassFrequencyNumberForEachSV>(ptr);
    }

    bool GetGlonassFrequencyNumberForEachSV::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGlonassFrequencyNumberForEachSV::documentation() const { return Documentation; }


    int GetGlonassFrequencyNumberForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGlonassFrequencyNumberForEachSVResult
///
#include "gen/GetGlonassFrequencyNumberForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassFrequencyNumberForEachSVResult::CmdName = "GetGlonassFrequencyNumberForEachSVResult";
    const char* const GetGlonassFrequencyNumberForEachSVResult::Documentation = "Result of GetGlonassFrequencyNumberForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassFrequencyNumberForEachSVResult);


    GetGlonassFrequencyNumberForEachSVResult::GetGlonassFrequencyNumberForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGlonassFrequencyNumberForEachSVResult::GetGlonassFrequencyNumberForEachSVResult(CommandBasePtr relatedCommand, const std::vector<int>& frequencyNumber)
      : CommandResult(CmdName, relatedCommand)
    {

      setFrequencyNumber(frequencyNumber);
    }


    GetGlonassFrequencyNumberForEachSVResultPtr GetGlonassFrequencyNumberForEachSVResult::create(CommandBasePtr relatedCommand, const std::vector<int>& frequencyNumber)
    {
      return std::make_shared<GetGlonassFrequencyNumberForEachSVResult>(relatedCommand, frequencyNumber);
    }

    GetGlonassFrequencyNumberForEachSVResultPtr GetGlonassFrequencyNumberForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassFrequencyNumberForEachSVResult>(ptr);
    }

    bool GetGlonassFrequencyNumberForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["FrequencyNumber"])
        ;

    }

    std::string GetGlonassFrequencyNumberForEachSVResult::documentation() const { return Documentation; }


    std::vector<int> GetGlonassFrequencyNumberForEachSVResult::frequencyNumber() const
    {
      return parse_json<std::vector<int>>::parse(m_values["FrequencyNumber"]);
    }

    void GetGlonassFrequencyNumberForEachSVResult::setFrequencyNumber(const std::vector<int>& frequencyNumber)
    {
      m_values.AddMember("FrequencyNumber", parse_json<std::vector<int>>::format(frequencyNumber, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphDoubleParamForEachSV
///
#include "gen/SetQzssEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphDoubleParamForEachSV::CmdName = "SetQzssEphDoubleParamForEachSV";
    const char* const SetQzssEphDoubleParamForEachSV::Documentation = "Set QZSS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetQzssEphDoubleParamForEachSV);


    SetQzssEphDoubleParamForEachSV::SetQzssEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetQzssEphDoubleParamForEachSV::SetQzssEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetQzssEphDoubleParamForEachSVPtr SetQzssEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssEphDoubleParamForEachSV>(paramName, val, dataSetName);
    }

    SetQzssEphDoubleParamForEachSVPtr SetQzssEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphDoubleParamForEachSV>(ptr);
    }

    bool SetQzssEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetQzssEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetQzssEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetQzssEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphemerisDoubleParams
///
#include "gen/SetQzssEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphemerisDoubleParams::CmdName = "SetQzssEphemerisDoubleParams";
    const char* const SetQzssEphemerisDoubleParams::Documentation = "Please note the command SetQzssEphemerisDoubleParams is deprecated since 21.3. You may use SetQzssEphDoubleParamForEachSV.\n\nSet QZSS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetQzssEphemerisDoubleParams);


    SetQzssEphemerisDoubleParams::SetQzssEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetQzssEphemerisDoubleParams::SetQzssEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetQzssEphemerisDoubleParamsPtr SetQzssEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssEphemerisDoubleParams>(paramName, val, dataSetName);
    }

    SetQzssEphemerisDoubleParamsPtr SetQzssEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphemerisDoubleParams>(ptr);
    }

    bool SetQzssEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetQzssEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetQzssEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetQzssEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphDoubleParamForEachSV
///
#include "gen/GetQzssEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphDoubleParamForEachSV::CmdName = "GetQzssEphDoubleParamForEachSV";
    const char* const GetQzssEphDoubleParamForEachSV::Documentation = "Get QZSS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetQzssEphDoubleParamForEachSV);


    GetQzssEphDoubleParamForEachSV::GetQzssEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetQzssEphDoubleParamForEachSV::GetQzssEphDoubleParamForEachSV(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetQzssEphDoubleParamForEachSVPtr GetQzssEphDoubleParamForEachSV::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphDoubleParamForEachSV>(paramName, dataSetName);
    }

    GetQzssEphDoubleParamForEachSVPtr GetQzssEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphDoubleParamForEachSV>(ptr);
    }

    bool GetQzssEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetQzssEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisDoubleParams
///
#include "gen/GetQzssEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisDoubleParams::CmdName = "GetQzssEphemerisDoubleParams";
    const char* const GetQzssEphemerisDoubleParams::Documentation = "Please note the command GetQzssEphemerisDoubleParams is deprecated since 21.3. You may use GetQzssEphDoubleParamForEachSV.\n\nGet QZSS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetQzssEphemerisDoubleParams);


    GetQzssEphemerisDoubleParams::GetQzssEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetQzssEphemerisDoubleParams::GetQzssEphemerisDoubleParams(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetQzssEphemerisDoubleParamsPtr GetQzssEphemerisDoubleParams::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphemerisDoubleParams>(paramName, dataSetName);
    }

    GetQzssEphemerisDoubleParamsPtr GetQzssEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisDoubleParams>(ptr);
    }

    bool GetQzssEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetQzssEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphDoubleParamForEachSVResult
///
#include "gen/GetQzssEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphDoubleParamForEachSVResult::CmdName = "GetQzssEphDoubleParamForEachSVResult";
    const char* const GetQzssEphDoubleParamForEachSVResult::Documentation = "Result of GetQzssEphDoubleParamForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssEphDoubleParamForEachSVResult);


    GetQzssEphDoubleParamForEachSVResult::GetQzssEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssEphDoubleParamForEachSVResult::GetQzssEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetQzssEphDoubleParamForEachSVResultPtr GetQzssEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphDoubleParamForEachSVResult>(relatedCommand, paramName, val, dataSetName);
    }

    GetQzssEphDoubleParamForEachSVResultPtr GetQzssEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetQzssEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetQzssEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetQzssEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetQzssEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphDoubleParamForEachSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphDoubleParamForEachSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICEphDoubleParamForEachSV
///
#include "gen/SetNavICEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICEphDoubleParamForEachSV::CmdName = "SetNavICEphDoubleParamForEachSV";
    const char* const SetNavICEphDoubleParamForEachSV::Documentation = "Set NavIC ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetNavICEphDoubleParamForEachSV);


    SetNavICEphDoubleParamForEachSV::SetNavICEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetNavICEphDoubleParamForEachSV::SetNavICEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetNavICEphDoubleParamForEachSVPtr SetNavICEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICEphDoubleParamForEachSV>(paramName, val, dataSetName);
    }

    SetNavICEphDoubleParamForEachSVPtr SetNavICEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICEphDoubleParamForEachSV>(ptr);
    }

    bool SetNavICEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetNavICEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetNavICEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetNavICEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetNavICEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetNavICEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICEphemerisDoubleParams
///
#include "gen/SetNavICEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICEphemerisDoubleParams::CmdName = "SetNavICEphemerisDoubleParams";
    const char* const SetNavICEphemerisDoubleParams::Documentation = "Please note the command SetNavICEphemerisDoubleParams is deprecated since 21.3. You may use SetNavICEphDoubleParamForEachSV.\n\nSet NavIC ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetNavICEphemerisDoubleParams);


    SetNavICEphemerisDoubleParams::SetNavICEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetNavICEphemerisDoubleParams::SetNavICEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetNavICEphemerisDoubleParamsPtr SetNavICEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICEphemerisDoubleParams>(paramName, val, dataSetName);
    }

    SetNavICEphemerisDoubleParamsPtr SetNavICEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICEphemerisDoubleParams>(ptr);
    }

    bool SetNavICEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetNavICEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetNavICEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetNavICEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetNavICEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetNavICEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphDoubleParamForEachSV
///
#include "gen/GetNavICEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphDoubleParamForEachSV::CmdName = "GetNavICEphDoubleParamForEachSV";
    const char* const GetNavICEphDoubleParamForEachSV::Documentation = "Get NavIC ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetNavICEphDoubleParamForEachSV);


    GetNavICEphDoubleParamForEachSV::GetNavICEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetNavICEphDoubleParamForEachSV::GetNavICEphDoubleParamForEachSV(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetNavICEphDoubleParamForEachSVPtr GetNavICEphDoubleParamForEachSV::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICEphDoubleParamForEachSV>(paramName, dataSetName);
    }

    GetNavICEphDoubleParamForEachSVPtr GetNavICEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphDoubleParamForEachSV>(ptr);
    }

    bool GetNavICEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetNavICEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetNavICEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICEphDoubleParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICEphDoubleParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphemerisDoubleParams
///
#include "gen/GetNavICEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphemerisDoubleParams::CmdName = "GetNavICEphemerisDoubleParams";
    const char* const GetNavICEphemerisDoubleParams::Documentation = "Please note the command GetNavICEphemerisDoubleParams is deprecated since 21.3. You may use GetNavICEphDoubleParamForEachSV.\n\nGet NavIC ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetNavICEphemerisDoubleParams);


    GetNavICEphemerisDoubleParams::GetNavICEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetNavICEphemerisDoubleParams::GetNavICEphemerisDoubleParams(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetNavICEphemerisDoubleParamsPtr GetNavICEphemerisDoubleParams::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICEphemerisDoubleParams>(paramName, dataSetName);
    }

    GetNavICEphemerisDoubleParamsPtr GetNavICEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphemerisDoubleParams>(ptr);
    }

    bool GetNavICEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetNavICEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetNavICEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICEphemerisDoubleParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICEphemerisDoubleParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphDoubleParamForEachSVResult
///
#include "gen/GetNavICEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphDoubleParamForEachSVResult::CmdName = "GetNavICEphDoubleParamForEachSVResult";
    const char* const GetNavICEphDoubleParamForEachSVResult::Documentation = "Result of GetNavICEphDoubleParamForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetNavICEphDoubleParamForEachSVResult);


    GetNavICEphDoubleParamForEachSVResult::GetNavICEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetNavICEphDoubleParamForEachSVResult::GetNavICEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetNavICEphDoubleParamForEachSVResultPtr GetNavICEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetNavICEphDoubleParamForEachSVResult>(relatedCommand, paramName, val, dataSetName);
    }

    GetNavICEphDoubleParamForEachSVResultPtr GetNavICEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetNavICEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetNavICEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetNavICEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetNavICEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetNavICEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetNavICEphDoubleParamForEachSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetNavICEphDoubleParamForEachSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphBoolParamForSV
///
#include "gen/SetGpsEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphBoolParamForSV::CmdName = "SetGpsEphBoolParamForSV";
    const char* const SetGpsEphBoolParamForSV::Documentation = "Set various boolean parameters in the GPS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(SetGpsEphBoolParamForSV);


    SetGpsEphBoolParamForSV::SetGpsEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    SetGpsEphBoolParamForSV::SetGpsEphBoolParamForSV(int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetGpsEphBoolParamForSVPtr SetGpsEphBoolParamForSV::create(int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsEphBoolParamForSV>(svId, paramName, val, dataSetName);
    }

    SetGpsEphBoolParamForSVPtr SetGpsEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphBoolParamForSV>(ptr);
    }

    bool SetGpsEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsEphBoolParamForSV::documentation() const { return Documentation; }


    int SetGpsEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGpsEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsEphBoolParamForSV::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetGpsEphBoolParamForSV::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsEphBoolParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsEphBoolParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphBoolParamForSV
///
#include "gen/GetGpsEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphBoolParamForSV::CmdName = "GetGpsEphBoolParamForSV";
    const char* const GetGpsEphBoolParamForSV::Documentation = "Get various boolean parameters in the GPS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(GetGpsEphBoolParamForSV);


    GetGpsEphBoolParamForSV::GetGpsEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    GetGpsEphBoolParamForSV::GetGpsEphBoolParamForSV(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetGpsEphBoolParamForSVPtr GetGpsEphBoolParamForSV::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphBoolParamForSV>(svId, paramName, dataSetName);
    }

    GetGpsEphBoolParamForSVPtr GetGpsEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphBoolParamForSV>(ptr);
    }

    bool GetGpsEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphBoolParamForSV::documentation() const { return Documentation; }


    int GetGpsEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphBoolParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphBoolParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphBoolParamForSVResult
///
#include "gen/GetGpsEphBoolParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphBoolParamForSVResult::CmdName = "GetGpsEphBoolParamForSVResult";
    const char* const GetGpsEphBoolParamForSVResult::Documentation = "Result of GetGpsEphBoolParamForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphBoolParamForSVResult);


    GetGpsEphBoolParamForSVResult::GetGpsEphBoolParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphBoolParamForSVResult::GetGpsEphBoolParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetGpsEphBoolParamForSVResultPtr GetGpsEphBoolParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphBoolParamForSVResult>(relatedCommand, svId, paramName, val, dataSetName);
    }

    GetGpsEphBoolParamForSVResultPtr GetGpsEphBoolParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphBoolParamForSVResult>(ptr);
    }

    bool GetGpsEphBoolParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphBoolParamForSVResult::documentation() const { return Documentation; }


    int GetGpsEphBoolParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsEphBoolParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphBoolParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphBoolParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsEphBoolParamForSVResult::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void GetGpsEphBoolParamForSVResult::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphBoolParamForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphBoolParamForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphBoolParamForEachSV
///
#include "gen/SetGpsEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphBoolParamForEachSV::CmdName = "SetGpsEphBoolParamForEachSV";
    const char* const SetGpsEphBoolParamForEachSV::Documentation = "Set GPS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGpsEphBoolParamForEachSV);


    SetGpsEphBoolParamForEachSV::SetGpsEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetGpsEphBoolParamForEachSV::SetGpsEphBoolParamForEachSV(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetGpsEphBoolParamForEachSVPtr SetGpsEphBoolParamForEachSV::create(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsEphBoolParamForEachSV>(paramName, val, dataSetName);
    }

    SetGpsEphBoolParamForEachSVPtr SetGpsEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphBoolParamForEachSV>(ptr);
    }

    bool SetGpsEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsEphBoolParamForEachSV::documentation() const { return Documentation; }


    int SetGpsEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetGpsEphBoolParamForEachSV::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetGpsEphBoolParamForEachSV::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsEphBoolParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsEphBoolParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphemerisBoolParams
///
#include "gen/SetGpsEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphemerisBoolParams::CmdName = "SetGpsEphemerisBoolParams";
    const char* const SetGpsEphemerisBoolParams::Documentation = "Please note the command SetGpsEphemerisBoolParams is deprecated since 21.3. You may use SetGpsEphBoolParamForEachSV.\n\nSet GPS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGpsEphemerisBoolParams);


    SetGpsEphemerisBoolParams::SetGpsEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    SetGpsEphemerisBoolParams::SetGpsEphemerisBoolParams(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetGpsEphemerisBoolParamsPtr SetGpsEphemerisBoolParams::create(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsEphemerisBoolParams>(paramName, val, dataSetName);
    }

    SetGpsEphemerisBoolParamsPtr SetGpsEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphemerisBoolParams>(ptr);
    }

    bool SetGpsEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsEphemerisBoolParams::documentation() const { return Documentation; }


    int SetGpsEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetGpsEphemerisBoolParams::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetGpsEphemerisBoolParams::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsEphemerisBoolParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsEphemerisBoolParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphBoolParamForEachSV
///
#include "gen/GetGpsEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphBoolParamForEachSV::CmdName = "GetGpsEphBoolParamForEachSV";
    const char* const GetGpsEphBoolParamForEachSV::Documentation = "Get GPS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGpsEphBoolParamForEachSV);


    GetGpsEphBoolParamForEachSV::GetGpsEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetGpsEphBoolParamForEachSV::GetGpsEphBoolParamForEachSV(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetGpsEphBoolParamForEachSVPtr GetGpsEphBoolParamForEachSV::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphBoolParamForEachSV>(paramName, dataSetName);
    }

    GetGpsEphBoolParamForEachSVPtr GetGpsEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphBoolParamForEachSV>(ptr);
    }

    bool GetGpsEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphBoolParamForEachSV::documentation() const { return Documentation; }


    int GetGpsEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphBoolParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphBoolParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisBoolParams
///
#include "gen/GetGpsEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisBoolParams::CmdName = "GetGpsEphemerisBoolParams";
    const char* const GetGpsEphemerisBoolParams::Documentation = "Please note the command GetGpsEphemerisBoolParams is deprecated since 21.3. You may use GetGpsEphBoolParamForEachSV.\n\nGet GPS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGpsEphemerisBoolParams);


    GetGpsEphemerisBoolParams::GetGpsEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    GetGpsEphemerisBoolParams::GetGpsEphemerisBoolParams(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetGpsEphemerisBoolParamsPtr GetGpsEphemerisBoolParams::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphemerisBoolParams>(paramName, dataSetName);
    }

    GetGpsEphemerisBoolParamsPtr GetGpsEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisBoolParams>(ptr);
    }

    bool GetGpsEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphemerisBoolParams::documentation() const { return Documentation; }


    int GetGpsEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphemerisBoolParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphemerisBoolParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphBoolParamForEachSVResult
///
#include "gen/GetGpsEphBoolParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphBoolParamForEachSVResult::CmdName = "GetGpsEphBoolParamForEachSVResult";
    const char* const GetGpsEphBoolParamForEachSVResult::Documentation = "Result of GetGpsEphBoolParamForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphBoolParamForEachSVResult);


    GetGpsEphBoolParamForEachSVResult::GetGpsEphBoolParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphBoolParamForEachSVResult::GetGpsEphBoolParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetGpsEphBoolParamForEachSVResultPtr GetGpsEphBoolParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetGpsEphBoolParamForEachSVResult>(relatedCommand, paramName, val, dataSetName);
    }

    GetGpsEphBoolParamForEachSVResultPtr GetGpsEphBoolParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphBoolParamForEachSVResult>(ptr);
    }

    bool GetGpsEphBoolParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetGpsEphBoolParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetGpsEphBoolParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphBoolParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetGpsEphBoolParamForEachSVResult::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void GetGpsEphBoolParamForEachSVResult::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetGpsEphBoolParamForEachSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetGpsEphBoolParamForEachSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphBoolParamForSV
///
#include "gen/SetBeiDouEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphBoolParamForSV::CmdName = "SetBeiDouEphBoolParamForSV";
    const char* const SetBeiDouEphBoolParamForSV::Documentation = "Set various boolean parameters in the BeiDou ephemeris\n\n  ParamName\n\"IscB1CdAvailable\"\n\"IscB2adAvailable\"";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphBoolParamForSV);


    SetBeiDouEphBoolParamForSV::SetBeiDouEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphBoolParamForSV::SetBeiDouEphBoolParamForSV(int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetBeiDouEphBoolParamForSVPtr SetBeiDouEphBoolParamForSV::create(int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouEphBoolParamForSV>(svId, paramName, val, dataSetName);
    }

    SetBeiDouEphBoolParamForSVPtr SetBeiDouEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphBoolParamForSV>(ptr);
    }

    bool SetBeiDouEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouEphBoolParamForSV::documentation() const { return Documentation; }


    int SetBeiDouEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetBeiDouEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetBeiDouEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetBeiDouEphBoolParamForSV::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetBeiDouEphBoolParamForSV::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouEphBoolParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouEphBoolParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphBoolParamForSV
///
#include "gen/GetBeiDouEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphBoolParamForSV::CmdName = "GetBeiDouEphBoolParamForSV";
    const char* const GetBeiDouEphBoolParamForSV::Documentation = "Get various boolean parameters in the BeiDou ephemeris\n\n  ParamName\n\"IscB1CdAvailable\"\n\"IscB2adAvailable\"";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphBoolParamForSV);


    GetBeiDouEphBoolParamForSV::GetBeiDouEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphBoolParamForSV::GetBeiDouEphBoolParamForSV(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphBoolParamForSVPtr GetBeiDouEphBoolParamForSV::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphBoolParamForSV>(svId, paramName, dataSetName);
    }

    GetBeiDouEphBoolParamForSVPtr GetBeiDouEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphBoolParamForSV>(ptr);
    }

    bool GetBeiDouEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphBoolParamForSV::documentation() const { return Documentation; }


    int GetBeiDouEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphBoolParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphBoolParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphBoolParamForSVResult
///
#include "gen/GetBeiDouEphBoolParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphBoolParamForSVResult::CmdName = "GetBeiDouEphBoolParamForSVResult";
    const char* const GetBeiDouEphBoolParamForSVResult::Documentation = "Result of GetBeiDouEphBoolParamForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphBoolParamForSVResult);


    GetBeiDouEphBoolParamForSVResult::GetBeiDouEphBoolParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphBoolParamForSVResult::GetBeiDouEphBoolParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphBoolParamForSVResultPtr GetBeiDouEphBoolParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphBoolParamForSVResult>(relatedCommand, svId, paramName, val, dataSetName);
    }

    GetBeiDouEphBoolParamForSVResultPtr GetBeiDouEphBoolParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphBoolParamForSVResult>(ptr);
    }

    bool GetBeiDouEphBoolParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphBoolParamForSVResult::documentation() const { return Documentation; }


    int GetBeiDouEphBoolParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouEphBoolParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphBoolParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphBoolParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouEphBoolParamForSVResult::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void GetBeiDouEphBoolParamForSVResult::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphBoolParamForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphBoolParamForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphBoolParamForEachSV
///
#include "gen/SetBeiDouEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphBoolParamForEachSV::CmdName = "SetBeiDouEphBoolParamForEachSV";
    const char* const SetBeiDouEphBoolParamForEachSV::Documentation = "Set BeiDou ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphBoolParamForEachSV);


    SetBeiDouEphBoolParamForEachSV::SetBeiDouEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphBoolParamForEachSV::SetBeiDouEphBoolParamForEachSV(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetBeiDouEphBoolParamForEachSVPtr SetBeiDouEphBoolParamForEachSV::create(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouEphBoolParamForEachSV>(paramName, val, dataSetName);
    }

    SetBeiDouEphBoolParamForEachSVPtr SetBeiDouEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphBoolParamForEachSV>(ptr);
    }

    bool SetBeiDouEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouEphBoolParamForEachSV::documentation() const { return Documentation; }


    int SetBeiDouEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetBeiDouEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetBeiDouEphBoolParamForEachSV::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetBeiDouEphBoolParamForEachSV::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouEphBoolParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouEphBoolParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphemerisBoolParams
///
#include "gen/SetBeiDouEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphemerisBoolParams::CmdName = "SetBeiDouEphemerisBoolParams";
    const char* const SetBeiDouEphemerisBoolParams::Documentation = "Please note the command SetBeiDouEphemerisBoolParams is deprecated since 21.3. You may use SetBeiDouEphBoolParamForEachSV.\n\nSet BeiDou ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphemerisBoolParams);


    SetBeiDouEphemerisBoolParams::SetBeiDouEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphemerisBoolParams::SetBeiDouEphemerisBoolParams(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetBeiDouEphemerisBoolParamsPtr SetBeiDouEphemerisBoolParams::create(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouEphemerisBoolParams>(paramName, val, dataSetName);
    }

    SetBeiDouEphemerisBoolParamsPtr SetBeiDouEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphemerisBoolParams>(ptr);
    }

    bool SetBeiDouEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouEphemerisBoolParams::documentation() const { return Documentation; }


    int SetBeiDouEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetBeiDouEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetBeiDouEphemerisBoolParams::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetBeiDouEphemerisBoolParams::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouEphemerisBoolParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouEphemerisBoolParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphBoolParamForEachSV
///
#include "gen/GetBeiDouEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphBoolParamForEachSV::CmdName = "GetBeiDouEphBoolParamForEachSV";
    const char* const GetBeiDouEphBoolParamForEachSV::Documentation = "Get BeiDou ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphBoolParamForEachSV);


    GetBeiDouEphBoolParamForEachSV::GetBeiDouEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphBoolParamForEachSV::GetBeiDouEphBoolParamForEachSV(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphBoolParamForEachSVPtr GetBeiDouEphBoolParamForEachSV::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphBoolParamForEachSV>(paramName, dataSetName);
    }

    GetBeiDouEphBoolParamForEachSVPtr GetBeiDouEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphBoolParamForEachSV>(ptr);
    }

    bool GetBeiDouEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphBoolParamForEachSV::documentation() const { return Documentation; }


    int GetBeiDouEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphBoolParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphBoolParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisBoolParams
///
#include "gen/GetBeiDouEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisBoolParams::CmdName = "GetBeiDouEphemerisBoolParams";
    const char* const GetBeiDouEphemerisBoolParams::Documentation = "Please note the command GetBeiDouEphemerisBoolParams is deprecated since 21.3. You may use GetBeiDouEphBoolParamForEachSV.\n\nGet BeiDou ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphemerisBoolParams);


    GetBeiDouEphemerisBoolParams::GetBeiDouEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphemerisBoolParams::GetBeiDouEphemerisBoolParams(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphemerisBoolParamsPtr GetBeiDouEphemerisBoolParams::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphemerisBoolParams>(paramName, dataSetName);
    }

    GetBeiDouEphemerisBoolParamsPtr GetBeiDouEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisBoolParams>(ptr);
    }

    bool GetBeiDouEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphemerisBoolParams::documentation() const { return Documentation; }


    int GetBeiDouEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphemerisBoolParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphemerisBoolParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphBoolParamForEachSVResult
///
#include "gen/GetBeiDouEphBoolParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphBoolParamForEachSVResult::CmdName = "GetBeiDouEphBoolParamForEachSVResult";
    const char* const GetBeiDouEphBoolParamForEachSVResult::Documentation = "Result of GetBeiDouEphBoolParamForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphBoolParamForEachSVResult);


    GetBeiDouEphBoolParamForEachSVResult::GetBeiDouEphBoolParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphBoolParamForEachSVResult::GetBeiDouEphBoolParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetBeiDouEphBoolParamForEachSVResultPtr GetBeiDouEphBoolParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetBeiDouEphBoolParamForEachSVResult>(relatedCommand, paramName, val, dataSetName);
    }

    GetBeiDouEphBoolParamForEachSVResultPtr GetBeiDouEphBoolParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphBoolParamForEachSVResult>(ptr);
    }

    bool GetBeiDouEphBoolParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetBeiDouEphBoolParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetBeiDouEphBoolParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphBoolParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetBeiDouEphBoolParamForEachSVResult::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void GetBeiDouEphBoolParamForEachSVResult::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetBeiDouEphBoolParamForEachSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetBeiDouEphBoolParamForEachSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphBoolParamForSV
///
#include "gen/SetQzssEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphBoolParamForSV::CmdName = "SetQzssEphBoolParamForSV";
    const char* const SetQzssEphBoolParamForSV::Documentation = "Set various boolean parameters in the QZSS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(SetQzssEphBoolParamForSV);


    SetQzssEphBoolParamForSV::SetQzssEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    SetQzssEphBoolParamForSV::SetQzssEphBoolParamForSV(int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetQzssEphBoolParamForSVPtr SetQzssEphBoolParamForSV::create(int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssEphBoolParamForSV>(svId, paramName, val, dataSetName);
    }

    SetQzssEphBoolParamForSVPtr SetQzssEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphBoolParamForSV>(ptr);
    }

    bool SetQzssEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssEphBoolParamForSV::documentation() const { return Documentation; }


    int SetQzssEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssEphBoolParamForSV::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetQzssEphBoolParamForSV::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssEphBoolParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssEphBoolParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphemerisBoolParam
///
#include "gen/SetQzssEphemerisBoolParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphemerisBoolParam::CmdName = "SetQzssEphemerisBoolParam";
    const char* const SetQzssEphemerisBoolParam::Documentation = "Please note the command SetQzssEphemerisBoolParam is deprecated since 21.3. You may use SetQzssEphBoolParamForSV.\n\nSet various boolean parameters in the QZSS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(SetQzssEphemerisBoolParam);


    SetQzssEphemerisBoolParam::SetQzssEphemerisBoolParam()
      : CommandBase(CmdName)
    {}

    SetQzssEphemerisBoolParam::SetQzssEphemerisBoolParam(int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetQzssEphemerisBoolParamPtr SetQzssEphemerisBoolParam::create(int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssEphemerisBoolParam>(svId, paramName, val, dataSetName);
    }

    SetQzssEphemerisBoolParamPtr SetQzssEphemerisBoolParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphemerisBoolParam>(ptr);
    }

    bool SetQzssEphemerisBoolParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssEphemerisBoolParam::documentation() const { return Documentation; }


    int SetQzssEphemerisBoolParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssEphemerisBoolParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssEphemerisBoolParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssEphemerisBoolParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphemerisBoolParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssEphemerisBoolParam::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetQzssEphemerisBoolParam::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssEphemerisBoolParam::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssEphemerisBoolParam::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphBoolParamForSV
///
#include "gen/GetQzssEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphBoolParamForSV::CmdName = "GetQzssEphBoolParamForSV";
    const char* const GetQzssEphBoolParamForSV::Documentation = "Get various boolean parameters in the QZSS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(GetQzssEphBoolParamForSV);


    GetQzssEphBoolParamForSV::GetQzssEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    GetQzssEphBoolParamForSV::GetQzssEphBoolParamForSV(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetQzssEphBoolParamForSVPtr GetQzssEphBoolParamForSV::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphBoolParamForSV>(svId, paramName, dataSetName);
    }

    GetQzssEphBoolParamForSVPtr GetQzssEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphBoolParamForSV>(ptr);
    }

    bool GetQzssEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphBoolParamForSV::documentation() const { return Documentation; }


    int GetQzssEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphBoolParamForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphBoolParamForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisBoolParam
///
#include "gen/GetQzssEphemerisBoolParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisBoolParam::CmdName = "GetQzssEphemerisBoolParam";
    const char* const GetQzssEphemerisBoolParam::Documentation = "Please note the command GetQzssEphemerisBoolParam is deprecated since 21.3. You may use GetQzssEphBoolParamForSV.\n\nGet various boolean parameters in the QZSS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(GetQzssEphemerisBoolParam);


    GetQzssEphemerisBoolParam::GetQzssEphemerisBoolParam()
      : CommandBase(CmdName)
    {}

    GetQzssEphemerisBoolParam::GetQzssEphemerisBoolParam(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetQzssEphemerisBoolParamPtr GetQzssEphemerisBoolParam::create(int svId, const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphemerisBoolParam>(svId, paramName, dataSetName);
    }

    GetQzssEphemerisBoolParamPtr GetQzssEphemerisBoolParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisBoolParam>(ptr);
    }

    bool GetQzssEphemerisBoolParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphemerisBoolParam::documentation() const { return Documentation; }


    int GetQzssEphemerisBoolParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssEphemerisBoolParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphemerisBoolParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphemerisBoolParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphemerisBoolParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphemerisBoolParam::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphemerisBoolParam::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphBoolParamForSVResult
///
#include "gen/GetQzssEphBoolParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphBoolParamForSVResult::CmdName = "GetQzssEphBoolParamForSVResult";
    const char* const GetQzssEphBoolParamForSVResult::Documentation = "Result of GetQzssEphBoolParamForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssEphBoolParamForSVResult);


    GetQzssEphBoolParamForSVResult::GetQzssEphBoolParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssEphBoolParamForSVResult::GetQzssEphBoolParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetQzssEphBoolParamForSVResultPtr GetQzssEphBoolParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphBoolParamForSVResult>(relatedCommand, svId, paramName, val, dataSetName);
    }

    GetQzssEphBoolParamForSVResultPtr GetQzssEphBoolParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphBoolParamForSVResult>(ptr);
    }

    bool GetQzssEphBoolParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphBoolParamForSVResult::documentation() const { return Documentation; }


    int GetQzssEphBoolParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphBoolParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphBoolParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphBoolParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssEphBoolParamForSVResult::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void GetQzssEphBoolParamForSVResult::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphBoolParamForSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphBoolParamForSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphBoolParamForEachSV
///
#include "gen/SetQzssEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphBoolParamForEachSV::CmdName = "SetQzssEphBoolParamForEachSV";
    const char* const SetQzssEphBoolParamForEachSV::Documentation = "Set QZSS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetQzssEphBoolParamForEachSV);


    SetQzssEphBoolParamForEachSV::SetQzssEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetQzssEphBoolParamForEachSV::SetQzssEphBoolParamForEachSV(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetQzssEphBoolParamForEachSVPtr SetQzssEphBoolParamForEachSV::create(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssEphBoolParamForEachSV>(paramName, val, dataSetName);
    }

    SetQzssEphBoolParamForEachSVPtr SetQzssEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphBoolParamForEachSV>(ptr);
    }

    bool SetQzssEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssEphBoolParamForEachSV::documentation() const { return Documentation; }


    int SetQzssEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetQzssEphBoolParamForEachSV::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetQzssEphBoolParamForEachSV::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssEphBoolParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssEphBoolParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphemerisBoolParams
///
#include "gen/SetQzssEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphemerisBoolParams::CmdName = "SetQzssEphemerisBoolParams";
    const char* const SetQzssEphemerisBoolParams::Documentation = "Please note the command SetQzssEphemerisBoolParams is deprecated since 21.3. You may use SetQzssEphBoolParamForEachSV.\n\nSet QZSS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetQzssEphemerisBoolParams);


    SetQzssEphemerisBoolParams::SetQzssEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    SetQzssEphemerisBoolParams::SetQzssEphemerisBoolParams(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    SetQzssEphemerisBoolParamsPtr SetQzssEphemerisBoolParams::create(const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssEphemerisBoolParams>(paramName, val, dataSetName);
    }

    SetQzssEphemerisBoolParamsPtr SetQzssEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphemerisBoolParams>(ptr);
    }

    bool SetQzssEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssEphemerisBoolParams::documentation() const { return Documentation; }


    int SetQzssEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetQzssEphemerisBoolParams::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetQzssEphemerisBoolParams::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssEphemerisBoolParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssEphemerisBoolParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphBoolParamForEachSV
///
#include "gen/GetQzssEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphBoolParamForEachSV::CmdName = "GetQzssEphBoolParamForEachSV";
    const char* const GetQzssEphBoolParamForEachSV::Documentation = "Get QZSS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetQzssEphBoolParamForEachSV);


    GetQzssEphBoolParamForEachSV::GetQzssEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetQzssEphBoolParamForEachSV::GetQzssEphBoolParamForEachSV(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetQzssEphBoolParamForEachSVPtr GetQzssEphBoolParamForEachSV::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphBoolParamForEachSV>(paramName, dataSetName);
    }

    GetQzssEphBoolParamForEachSVPtr GetQzssEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphBoolParamForEachSV>(ptr);
    }

    bool GetQzssEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphBoolParamForEachSV::documentation() const { return Documentation; }


    int GetQzssEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphBoolParamForEachSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphBoolParamForEachSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisBoolParams
///
#include "gen/GetQzssEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisBoolParams::CmdName = "GetQzssEphemerisBoolParams";
    const char* const GetQzssEphemerisBoolParams::Documentation = "Please note the command GetQzssEphemerisBoolParams is deprecated since 21.3. You may use GetQzssEphBoolParamForEachSV.\n\nGet QZSS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetQzssEphemerisBoolParams);


    GetQzssEphemerisBoolParams::GetQzssEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    GetQzssEphemerisBoolParams::GetQzssEphemerisBoolParams(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setDataSetName(dataSetName);
    }


    GetQzssEphemerisBoolParamsPtr GetQzssEphemerisBoolParams::create(const std::string& paramName, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphemerisBoolParams>(paramName, dataSetName);
    }

    GetQzssEphemerisBoolParamsPtr GetQzssEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisBoolParams>(ptr);
    }

    bool GetQzssEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphemerisBoolParams::documentation() const { return Documentation; }


    int GetQzssEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphemerisBoolParams::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphemerisBoolParams::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphBoolParamForEachSVResult
///
#include "gen/GetQzssEphBoolParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphBoolParamForEachSVResult::CmdName = "GetQzssEphBoolParamForEachSVResult";
    const char* const GetQzssEphBoolParamForEachSVResult::Documentation = "Result of GetQzssEphBoolParamForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssEphBoolParamForEachSVResult);


    GetQzssEphBoolParamForEachSVResult::GetQzssEphBoolParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssEphBoolParamForEachSVResult::GetQzssEphBoolParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
      setDataSetName(dataSetName);
    }


    GetQzssEphBoolParamForEachSVResultPtr GetQzssEphBoolParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetQzssEphBoolParamForEachSVResult>(relatedCommand, paramName, val, dataSetName);
    }

    GetQzssEphBoolParamForEachSVResultPtr GetQzssEphBoolParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphBoolParamForEachSVResult>(ptr);
    }

    bool GetQzssEphBoolParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetQzssEphBoolParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetQzssEphBoolParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphBoolParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetQzssEphBoolParamForEachSVResult::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void GetQzssEphBoolParamForEachSVResult::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetQzssEphBoolParamForEachSVResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetQzssEphBoolParamForEachSVResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasEphParamsForSV
///
#include "gen/SetSbasEphParamsForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasEphParamsForSV::CmdName = "SetSbasEphParamsForSV";
    const char* const SetSbasEphParamsForSV::Documentation = "Set parameters for a SBAS satellite ephemeris (runtime modification only available for health parameter)";

    REGISTER_COMMAND_FACTORY(SetSbasEphParamsForSV);


    SetSbasEphParamsForSV::SetSbasEphParamsForSV()
      : CommandBase(CmdName)
    {}

    SetSbasEphParamsForSV::SetSbasEphParamsForSV(int svId, const std::map<std::string, double>& paramValueDict)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamValueDict(paramValueDict);
    }


    SetSbasEphParamsForSVPtr SetSbasEphParamsForSV::create(int svId, const std::map<std::string, double>& paramValueDict)
    {
      return std::make_shared<SetSbasEphParamsForSV>(svId, paramValueDict);
    }

    SetSbasEphParamsForSVPtr SetSbasEphParamsForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasEphParamsForSV>(ptr);
    }

    bool SetSbasEphParamsForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, double>>::is_valid(m_values["ParamValueDict"])
        ;

    }

    std::string SetSbasEphParamsForSV::documentation() const { return Documentation; }


    int SetSbasEphParamsForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetSbasEphParamsForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasEphParamsForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, double> SetSbasEphParamsForSV::paramValueDict() const
    {
      return parse_json<std::map<std::string, double>>::parse(m_values["ParamValueDict"]);
    }

    void SetSbasEphParamsForSV::setParamValueDict(const std::map<std::string, double>& paramValueDict)
    {
      m_values.AddMember("ParamValueDict", parse_json<std::map<std::string, double>>::format(paramValueDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasEphParamsForSV
///
#include "gen/GetSbasEphParamsForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasEphParamsForSV::CmdName = "GetSbasEphParamsForSV";
    const char* const GetSbasEphParamsForSV::Documentation = "Get parameters for a SBAS satellite ephemeris (runtime modification only available for health parameter)";

    REGISTER_COMMAND_FACTORY(GetSbasEphParamsForSV);


    GetSbasEphParamsForSV::GetSbasEphParamsForSV()
      : CommandBase(CmdName)
    {}

    GetSbasEphParamsForSV::GetSbasEphParamsForSV(int svId, const std::vector<std::string>& paramArray)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamArray(paramArray);
    }


    GetSbasEphParamsForSVPtr GetSbasEphParamsForSV::create(int svId, const std::vector<std::string>& paramArray)
    {
      return std::make_shared<GetSbasEphParamsForSV>(svId, paramArray);
    }

    GetSbasEphParamsForSVPtr GetSbasEphParamsForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasEphParamsForSV>(ptr);
    }

    bool GetSbasEphParamsForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["ParamArray"])
        ;

    }

    std::string GetSbasEphParamsForSV::documentation() const { return Documentation; }


    int GetSbasEphParamsForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetSbasEphParamsForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSbasEphParamsForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetSbasEphParamsForSV::paramArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["ParamArray"]);
    }

    void GetSbasEphParamsForSV::setParamArray(const std::vector<std::string>& paramArray)
    {
      m_values.AddMember("ParamArray", parse_json<std::vector<std::string>>::format(paramArray, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasEphParamsForSVResult
///
#include "gen/GetSbasEphParamsForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasEphParamsForSVResult::CmdName = "GetSbasEphParamsForSVResult";
    const char* const GetSbasEphParamsForSVResult::Documentation = "Result of GetSbasEphParamsForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasEphParamsForSVResult);


    GetSbasEphParamsForSVResult::GetSbasEphParamsForSVResult()
      : CommandResult(CmdName)
    {}

    GetSbasEphParamsForSVResult::GetSbasEphParamsForSVResult(CommandBasePtr relatedCommand, int svId, const std::map<std::string, double>& paramValueDict)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamValueDict(paramValueDict);
    }


    GetSbasEphParamsForSVResultPtr GetSbasEphParamsForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::map<std::string, double>& paramValueDict)
    {
      return std::make_shared<GetSbasEphParamsForSVResult>(relatedCommand, svId, paramValueDict);
    }

    GetSbasEphParamsForSVResultPtr GetSbasEphParamsForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasEphParamsForSVResult>(ptr);
    }

    bool GetSbasEphParamsForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, double>>::is_valid(m_values["ParamValueDict"])
        ;

    }

    std::string GetSbasEphParamsForSVResult::documentation() const { return Documentation; }


    int GetSbasEphParamsForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSbasEphParamsForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, double> GetSbasEphParamsForSVResult::paramValueDict() const
    {
      return parse_json<std::map<std::string, double>>::parse(m_values["ParamValueDict"]);
    }

    void GetSbasEphParamsForSVResult::setParamValueDict(const std::map<std::string, double>& paramValueDict)
    {
      m_values.AddMember("ParamValueDict", parse_json<std::map<std::string, double>>::format(paramValueDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasRangingHealthForSV
///
#include "gen/SetSbasRangingHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasRangingHealthForSV::CmdName = "SetSbasRangingHealthForSV";
    const char* const SetSbasRangingHealthForSV::Documentation = "Apply ranging flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasRangingHealthForSV);


    SetSbasRangingHealthForSV::SetSbasRangingHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasRangingHealthForSV::SetSbasRangingHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasRangingHealthForSVPtr SetSbasRangingHealthForSV::create(int svId, bool health)
    {
      return std::make_shared<SetSbasRangingHealthForSV>(svId, health);
    }

    SetSbasRangingHealthForSVPtr SetSbasRangingHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasRangingHealthForSV>(ptr);
    }

    bool SetSbasRangingHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasRangingHealthForSV::documentation() const { return Documentation; }


    int SetSbasRangingHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasRangingHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasRangingHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasRangingHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasRangingHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasCorrectionsHealthForSV
///
#include "gen/SetSbasCorrectionsHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasCorrectionsHealthForSV::CmdName = "SetSbasCorrectionsHealthForSV";
    const char* const SetSbasCorrectionsHealthForSV::Documentation = "Apply correction flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasCorrectionsHealthForSV);


    SetSbasCorrectionsHealthForSV::SetSbasCorrectionsHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasCorrectionsHealthForSV::SetSbasCorrectionsHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasCorrectionsHealthForSVPtr SetSbasCorrectionsHealthForSV::create(int svId, bool health)
    {
      return std::make_shared<SetSbasCorrectionsHealthForSV>(svId, health);
    }

    SetSbasCorrectionsHealthForSVPtr SetSbasCorrectionsHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasCorrectionsHealthForSV>(ptr);
    }

    bool SetSbasCorrectionsHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasCorrectionsHealthForSV::documentation() const { return Documentation; }


    int SetSbasCorrectionsHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasCorrectionsHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasCorrectionsHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasCorrectionsHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasCorrectionsHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasIntegrityHealthForSV
///
#include "gen/SetSbasIntegrityHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasIntegrityHealthForSV::CmdName = "SetSbasIntegrityHealthForSV";
    const char* const SetSbasIntegrityHealthForSV::Documentation = "Apply integrity flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasIntegrityHealthForSV);


    SetSbasIntegrityHealthForSV::SetSbasIntegrityHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasIntegrityHealthForSV::SetSbasIntegrityHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasIntegrityHealthForSVPtr SetSbasIntegrityHealthForSV::create(int svId, bool health)
    {
      return std::make_shared<SetSbasIntegrityHealthForSV>(svId, health);
    }

    SetSbasIntegrityHealthForSVPtr SetSbasIntegrityHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasIntegrityHealthForSV>(ptr);
    }

    bool SetSbasIntegrityHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasIntegrityHealthForSV::documentation() const { return Documentation; }


    int SetSbasIntegrityHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasIntegrityHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasIntegrityHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasIntegrityHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasIntegrityHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasReservedHealthForSV
///
#include "gen/SetSbasReservedHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasReservedHealthForSV::CmdName = "SetSbasReservedHealthForSV";
    const char* const SetSbasReservedHealthForSV::Documentation = "Apply reserved flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasReservedHealthForSV);


    SetSbasReservedHealthForSV::SetSbasReservedHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasReservedHealthForSV::SetSbasReservedHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasReservedHealthForSVPtr SetSbasReservedHealthForSV::create(int svId, bool health)
    {
      return std::make_shared<SetSbasReservedHealthForSV>(svId, health);
    }

    SetSbasReservedHealthForSVPtr SetSbasReservedHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasReservedHealthForSV>(ptr);
    }

    bool SetSbasReservedHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasReservedHealthForSV::documentation() const { return Documentation; }


    int SetSbasReservedHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasReservedHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasReservedHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasReservedHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasReservedHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasServiceHealthForSV
///
#include "gen/SetSbasServiceHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasServiceHealthForSV::CmdName = "SetSbasServiceHealthForSV";
    const char* const SetSbasServiceHealthForSV::Documentation = "Apply service provider for a satellite";

    REGISTER_COMMAND_FACTORY(SetSbasServiceHealthForSV);


    SetSbasServiceHealthForSV::SetSbasServiceHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasServiceHealthForSV::SetSbasServiceHealthForSV(int svId, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasServiceHealthForSVPtr SetSbasServiceHealthForSV::create(int svId, int health)
    {
      return std::make_shared<SetSbasServiceHealthForSV>(svId, health);
    }

    SetSbasServiceHealthForSVPtr SetSbasServiceHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasServiceHealthForSV>(ptr);
    }

    bool SetSbasServiceHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasServiceHealthForSV::documentation() const { return Documentation; }


    int SetSbasServiceHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetSbasServiceHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasServiceHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSbasServiceHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetSbasServiceHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetPerturbations
///
#include "gen/ResetPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetPerturbations::CmdName = "ResetPerturbations";
    const char* const ResetPerturbations::Documentation = "Set orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) to zero for the specified constellation.";

    REGISTER_COMMAND_FACTORY(ResetPerturbations);


    ResetPerturbations::ResetPerturbations()
      : CommandBase(CmdName)
    {}

    ResetPerturbations::ResetPerturbations(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setDataSetName(dataSetName);
    }


    ResetPerturbationsPtr ResetPerturbations::create(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<ResetPerturbations>(system, svId, dataSetName);
    }

    ResetPerturbationsPtr ResetPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetPerturbations>(ptr);
    }

    bool ResetPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string ResetPerturbations::documentation() const { return Documentation; }


    int ResetPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ResetPerturbations::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ResetPerturbations::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ResetPerturbations::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void ResetPerturbations::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ResetPerturbations::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void ResetPerturbations::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPerturbations
///
#include "gen/SetPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPerturbations::CmdName = "SetPerturbations";
    const char* const SetPerturbations::Documentation = "Set orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for the specified constellation.";

    REGISTER_COMMAND_FACTORY(SetPerturbations);


    SetPerturbations::SetPerturbations()
      : CommandBase(CmdName)
    {}

    SetPerturbations::SetPerturbations(const std::string& system, int svId, double crs, double crc, double cis, double cic, double cus, double cuc, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
      setDataSetName(dataSetName);
    }


    SetPerturbationsPtr SetPerturbations::create(const std::string& system, int svId, double crs, double crc, double cis, double cic, double cus, double cuc, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetPerturbations>(system, svId, crs, crc, cis, cic, cus, cuc, dataSetName);
    }

    SetPerturbationsPtr SetPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPerturbations>(ptr);
    }

    bool SetPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetPerturbations::documentation() const { return Documentation; }


    int SetPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPerturbations::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPerturbations::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPerturbations::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPerturbations::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void SetPerturbations::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void SetPerturbations::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void SetPerturbations::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void SetPerturbations::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void SetPerturbations::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void SetPerturbations::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetPerturbations::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetPerturbations::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPerturbations
///
#include "gen/GetPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPerturbations::CmdName = "GetPerturbations";
    const char* const GetPerturbations::Documentation = "Get orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetPerturbations);


    GetPerturbations::GetPerturbations()
      : CommandBase(CmdName)
    {}

    GetPerturbations::GetPerturbations(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setDataSetName(dataSetName);
    }


    GetPerturbationsPtr GetPerturbations::create(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetPerturbations>(system, svId, dataSetName);
    }

    GetPerturbationsPtr GetPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPerturbations>(ptr);
    }

    bool GetPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetPerturbations::documentation() const { return Documentation; }


    int GetPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPerturbations::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPerturbations::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPerturbations::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPerturbations::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetPerturbations::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetPerturbations::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPerturbationsResult
///
#include "gen/GetPerturbationsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPerturbationsResult::CmdName = "GetPerturbationsResult";
    const char* const GetPerturbationsResult::Documentation = "Result of GetPerturbations.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPerturbationsResult);


    GetPerturbationsResult::GetPerturbationsResult()
      : CommandResult(CmdName)
    {}

    GetPerturbationsResult::GetPerturbationsResult(CommandBasePtr relatedCommand, const std::string& system, int svId, double crs, double crc, double cis, double cic, double cus, double cuc, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
      setDataSetName(dataSetName);
    }


    GetPerturbationsResultPtr GetPerturbationsResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, double crs, double crc, double cis, double cic, double cus, double cuc, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetPerturbationsResult>(relatedCommand, system, svId, crs, crc, cis, cic, cus, cuc, dataSetName);
    }

    GetPerturbationsResultPtr GetPerturbationsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPerturbationsResult>(ptr);
    }

    bool GetPerturbationsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetPerturbationsResult::documentation() const { return Documentation; }


    std::string GetPerturbationsResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPerturbationsResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPerturbationsResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPerturbationsResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void GetPerturbationsResult::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void GetPerturbationsResult::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void GetPerturbationsResult::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void GetPerturbationsResult::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void GetPerturbationsResult::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void GetPerturbationsResult::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetPerturbationsResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetPerturbationsResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPerturbationsForAllSat
///
#include "gen/SetPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPerturbationsForAllSat::CmdName = "SetPerturbationsForAllSat";
    const char* const SetPerturbationsForAllSat::Documentation = "Set orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites of the specified constellation..\nAll parameters are zero based index (index 0 => SV ID 1, index 1 => SV ID 2, etc)";

    REGISTER_COMMAND_FACTORY(SetPerturbationsForAllSat);


    SetPerturbationsForAllSat::SetPerturbationsForAllSat()
      : CommandBase(CmdName)
    {}

    SetPerturbationsForAllSat::SetPerturbationsForAllSat(const std::string& system, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
      setDataSetName(dataSetName);
    }


    SetPerturbationsForAllSatPtr SetPerturbationsForAllSat::create(const std::string& system, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetPerturbationsForAllSat>(system, crs, crc, cis, cic, cus, cuc, dataSetName);
    }

    SetPerturbationsForAllSatPtr SetPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPerturbationsForAllSat>(ptr);
    }

    bool SetPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetPerturbationsForAllSat::documentation() const { return Documentation; }


    int SetPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPerturbationsForAllSat::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPerturbationsForAllSat::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void SetPerturbationsForAllSat::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void SetPerturbationsForAllSat::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void SetPerturbationsForAllSat::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void SetPerturbationsForAllSat::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void SetPerturbationsForAllSat::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void SetPerturbationsForAllSat::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetPerturbationsForAllSat::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetPerturbationsForAllSat::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPerturbationsForAllSat
///
#include "gen/GetPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPerturbationsForAllSat::CmdName = "GetPerturbationsForAllSat";
    const char* const GetPerturbationsForAllSat::Documentation = "Get orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites of the specified constellation..\nAll parameters are zero based index (index 0 => SV ID 1, index 1 => SV ID 2, etc)";

    REGISTER_COMMAND_FACTORY(GetPerturbationsForAllSat);


    GetPerturbationsForAllSat::GetPerturbationsForAllSat()
      : CommandBase(CmdName)
    {}

    GetPerturbationsForAllSat::GetPerturbationsForAllSat(const std::string& system, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setDataSetName(dataSetName);
    }


    GetPerturbationsForAllSatPtr GetPerturbationsForAllSat::create(const std::string& system, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetPerturbationsForAllSat>(system, dataSetName);
    }

    GetPerturbationsForAllSatPtr GetPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPerturbationsForAllSat>(ptr);
    }

    bool GetPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetPerturbationsForAllSat::documentation() const { return Documentation; }


    int GetPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPerturbationsForAllSat::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPerturbationsForAllSat::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetPerturbationsForAllSat::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetPerturbationsForAllSat::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPerturbationsForAllSatResult
///
#include "gen/GetPerturbationsForAllSatResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPerturbationsForAllSatResult::CmdName = "GetPerturbationsForAllSatResult";
    const char* const GetPerturbationsForAllSatResult::Documentation = "Result of GetPerturbationsForAllSat.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPerturbationsForAllSatResult);


    GetPerturbationsForAllSatResult::GetPerturbationsForAllSatResult()
      : CommandResult(CmdName)
    {}

    GetPerturbationsForAllSatResult::GetPerturbationsForAllSatResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
      setDataSetName(dataSetName);
    }


    GetPerturbationsForAllSatResultPtr GetPerturbationsForAllSatResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<GetPerturbationsForAllSatResult>(relatedCommand, system, crs, crc, cis, cic, cus, cuc, dataSetName);
    }

    GetPerturbationsForAllSatResultPtr GetPerturbationsForAllSatResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPerturbationsForAllSatResult>(ptr);
    }

    bool GetPerturbationsForAllSatResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetPerturbationsForAllSatResult::documentation() const { return Documentation; }


    std::string GetPerturbationsForAllSatResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPerturbationsForAllSatResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void GetPerturbationsForAllSatResult::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void GetPerturbationsForAllSatResult::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void GetPerturbationsForAllSatResult::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void GetPerturbationsForAllSatResult::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void GetPerturbationsForAllSatResult::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void GetPerturbationsForAllSatResult::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetPerturbationsForAllSatResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void GetPerturbationsForAllSatResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGpsCNav
///
#include "gen/SetMessageModificationToGpsCNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGpsCNav::CmdName = "SetMessageModificationToGpsCNav";
    const char* const SetMessageModificationToGpsCNav::Documentation = "Set (or Modify) event to change GPS CNAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGpsCNav);


    SetMessageModificationToGpsCNav::SetMessageModificationToGpsCNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGpsCNav::SetMessageModificationToGpsCNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGpsCNavPtr SetMessageModificationToGpsCNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToGpsCNav>(signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToGpsCNavPtr SetMessageModificationToGpsCNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGpsCNav>(ptr);
    }

    bool SetMessageModificationToGpsCNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGpsCNav::documentation() const { return Documentation; }


    int SetMessageModificationToGpsCNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGpsCNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGpsCNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGpsCNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGpsCNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGpsCNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToGpsCNav::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGpsCNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGpsCNav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToGpsCNav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGpsCNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGpsCNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsCNav
///
#include "gen/GetMessageModificationToGpsCNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsCNav::CmdName = "GetMessageModificationToGpsCNav";
    const char* const GetMessageModificationToGpsCNav::Documentation = "Get infos about the GPS CNAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGpsCNav);


    GetMessageModificationToGpsCNav::GetMessageModificationToGpsCNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGpsCNav::GetMessageModificationToGpsCNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGpsCNavPtr GetMessageModificationToGpsCNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGpsCNav>(id);
    }

    GetMessageModificationToGpsCNavPtr GetMessageModificationToGpsCNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsCNav>(ptr);
    }

    bool GetMessageModificationToGpsCNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsCNav::documentation() const { return Documentation; }


    int GetMessageModificationToGpsCNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGpsCNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsCNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsCNavResult
///
#include "gen/GetMessageModificationToGpsCNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsCNavResult::CmdName = "GetMessageModificationToGpsCNavResult";
    const char* const GetMessageModificationToGpsCNavResult::Documentation = "Result of GetMessageModificationToGpsCNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGpsCNavResult);


    GetMessageModificationToGpsCNavResult::GetMessageModificationToGpsCNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGpsCNavResult::GetMessageModificationToGpsCNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGpsCNavResultPtr GetMessageModificationToGpsCNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGpsCNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToGpsCNavResultPtr GetMessageModificationToGpsCNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsCNavResult>(ptr);
    }

    bool GetMessageModificationToGpsCNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsCNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGpsCNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGpsCNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGpsCNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGpsCNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGpsCNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNavResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToGpsCNavResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGpsCNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGpsCNavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToGpsCNavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGpsCNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsCNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGpsMNav
///
#include "gen/SetMessageModificationToGpsMNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGpsMNav::CmdName = "SetMessageModificationToGpsMNav";
    const char* const SetMessageModificationToGpsMNav::Documentation = "Set (or Modify) event to change GPS MNAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGpsMNav);


    SetMessageModificationToGpsMNav::SetMessageModificationToGpsMNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGpsMNav::SetMessageModificationToGpsMNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, int occurrence, const std::string& condition, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setOccurrence(occurrence);
      setCondition(condition);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGpsMNavPtr SetMessageModificationToGpsMNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, int occurrence, const std::string& condition, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToGpsMNav>(signalArray, svId, startTime, stopTime, messageType, occurrence, condition, bitModifications, id);
    }

    SetMessageModificationToGpsMNavPtr SetMessageModificationToGpsMNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGpsMNav>(ptr);
    }

    bool SetMessageModificationToGpsMNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<int>::is_valid(m_values["Occurrence"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGpsMNav::documentation() const { return Documentation; }


    int SetMessageModificationToGpsMNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGpsMNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGpsMNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGpsMNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGpsMNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGpsMNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToGpsMNav::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::occurrence() const
    {
      return parse_json<int>::parse(m_values["Occurrence"]);
    }

    void SetMessageModificationToGpsMNav::setOccurrence(int occurrence)
    {
      m_values.AddMember("Occurrence", parse_json<int>::format(occurrence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsMNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGpsMNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsMNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGpsMNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsMNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGpsMNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsMNav
///
#include "gen/GetMessageModificationToGpsMNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsMNav::CmdName = "GetMessageModificationToGpsMNav";
    const char* const GetMessageModificationToGpsMNav::Documentation = "Get infos about the GPS MNAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGpsMNav);


    GetMessageModificationToGpsMNav::GetMessageModificationToGpsMNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGpsMNav::GetMessageModificationToGpsMNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGpsMNavPtr GetMessageModificationToGpsMNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGpsMNav>(id);
    }

    GetMessageModificationToGpsMNavPtr GetMessageModificationToGpsMNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsMNav>(ptr);
    }

    bool GetMessageModificationToGpsMNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsMNav::documentation() const { return Documentation; }


    int GetMessageModificationToGpsMNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGpsMNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsMNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsMNavResult
///
#include "gen/GetMessageModificationToGpsMNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsMNavResult::CmdName = "GetMessageModificationToGpsMNavResult";
    const char* const GetMessageModificationToGpsMNavResult::Documentation = "Result of GetMessageModificationToGpsMNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGpsMNavResult);


    GetMessageModificationToGpsMNavResult::GetMessageModificationToGpsMNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGpsMNavResult::GetMessageModificationToGpsMNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, int occurrence, const std::string& condition, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setOccurrence(occurrence);
      setCondition(condition);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGpsMNavResultPtr GetMessageModificationToGpsMNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, int occurrence, const std::string& condition, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGpsMNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, messageType, occurrence, condition, bitModifications, id);
    }

    GetMessageModificationToGpsMNavResultPtr GetMessageModificationToGpsMNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsMNavResult>(ptr);
    }

    bool GetMessageModificationToGpsMNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<int>::is_valid(m_values["Occurrence"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsMNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGpsMNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGpsMNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGpsMNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGpsMNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGpsMNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToGpsMNavResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::occurrence() const
    {
      return parse_json<int>::parse(m_values["Occurrence"]);
    }

    void GetMessageModificationToGpsMNavResult::setOccurrence(int occurrence)
    {
      m_values.AddMember("Occurrence", parse_json<int>::format(occurrence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsMNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGpsMNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsMNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGpsMNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsMNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsMNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGpsCNav2
///
#include "gen/SetMessageModificationToGpsCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGpsCNav2::CmdName = "SetMessageModificationToGpsCNav2";
    const char* const SetMessageModificationToGpsCNav2::Documentation = "Set (or Modify) event to change GPS CNAV-2 message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGpsCNav2);


    SetMessageModificationToGpsCNav2::SetMessageModificationToGpsCNav2()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGpsCNav2::SetMessageModificationToGpsCNav2(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGpsCNav2Ptr SetMessageModificationToGpsCNav2::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToGpsCNav2>(signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToGpsCNav2Ptr SetMessageModificationToGpsCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGpsCNav2>(ptr);
    }

    bool SetMessageModificationToGpsCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGpsCNav2::documentation() const { return Documentation; }


    int SetMessageModificationToGpsCNav2::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGpsCNav2::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGpsCNav2::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav2::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGpsCNav2::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav2::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGpsCNav2::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav2::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGpsCNav2::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav2::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToGpsCNav2::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav2::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGpsCNav2::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGpsCNav2::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToGpsCNav2::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav2::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGpsCNav2::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGpsCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsCNav2
///
#include "gen/GetMessageModificationToGpsCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsCNav2::CmdName = "GetMessageModificationToGpsCNav2";
    const char* const GetMessageModificationToGpsCNav2::Documentation = "Get infos about the GPS CNAV-2 message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGpsCNav2);


    GetMessageModificationToGpsCNav2::GetMessageModificationToGpsCNav2()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGpsCNav2::GetMessageModificationToGpsCNav2(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGpsCNav2Ptr GetMessageModificationToGpsCNav2::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGpsCNav2>(id);
    }

    GetMessageModificationToGpsCNav2Ptr GetMessageModificationToGpsCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsCNav2>(ptr);
    }

    bool GetMessageModificationToGpsCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsCNav2::documentation() const { return Documentation; }


    int GetMessageModificationToGpsCNav2::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGpsCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsCNav2Result
///
#include "gen/GetMessageModificationToGpsCNav2Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsCNav2Result::CmdName = "GetMessageModificationToGpsCNav2Result";
    const char* const GetMessageModificationToGpsCNav2Result::Documentation = "Result of GetMessageModificationToGpsCNav2.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGpsCNav2Result);


    GetMessageModificationToGpsCNav2Result::GetMessageModificationToGpsCNav2Result()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGpsCNav2Result::GetMessageModificationToGpsCNav2Result(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGpsCNav2ResultPtr GetMessageModificationToGpsCNav2Result::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGpsCNav2Result>(relatedCommand, signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToGpsCNav2ResultPtr GetMessageModificationToGpsCNav2Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsCNav2Result>(ptr);
    }

    bool GetMessageModificationToGpsCNav2Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsCNav2Result::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGpsCNav2Result::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGpsCNav2Result::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNav2Result::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGpsCNav2Result::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNav2Result::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGpsCNav2Result::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNav2Result::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGpsCNav2Result::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNav2Result::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToGpsCNav2Result::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNav2Result::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGpsCNav2Result::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGpsCNav2Result::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToGpsCNav2Result::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNav2Result::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGpsCNav2Result::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNav2Result::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsCNav2Result::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGpsLNav
///
#include "gen/SetMessageModificationToGpsLNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGpsLNav::CmdName = "SetMessageModificationToGpsLNav";
    const char* const SetMessageModificationToGpsLNav::Documentation = "Set (or Modify) event to change GPS LNAV message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to bits 25..30 will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGpsLNav);


    SetMessageModificationToGpsLNav::SetMessageModificationToGpsLNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGpsLNav::SetMessageModificationToGpsLNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    SetMessageModificationToGpsLNavPtr SetMessageModificationToGpsLNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToGpsLNav>(signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id);
    }

    SetMessageModificationToGpsLNavPtr SetMessageModificationToGpsLNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGpsLNav>(ptr);
    }

    bool SetMessageModificationToGpsLNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGpsLNav::documentation() const { return Documentation; }


    int SetMessageModificationToGpsLNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGpsLNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGpsLNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGpsLNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGpsLNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGpsLNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToGpsLNav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToGpsLNav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetMessageModificationToGpsLNav::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGpsLNav::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetMessageModificationToGpsLNav::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsLNav::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void SetMessageModificationToGpsLNav::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsLNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGpsLNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsLNav
///
#include "gen/GetMessageModificationToGpsLNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsLNav::CmdName = "GetMessageModificationToGpsLNav";
    const char* const GetMessageModificationToGpsLNav::Documentation = "Get infos about the GPS LNAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGpsLNav);


    GetMessageModificationToGpsLNav::GetMessageModificationToGpsLNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGpsLNav::GetMessageModificationToGpsLNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGpsLNavPtr GetMessageModificationToGpsLNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGpsLNav>(id);
    }

    GetMessageModificationToGpsLNavPtr GetMessageModificationToGpsLNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsLNav>(ptr);
    }

    bool GetMessageModificationToGpsLNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsLNav::documentation() const { return Documentation; }


    int GetMessageModificationToGpsLNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGpsLNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsLNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsLNavResult
///
#include "gen/GetMessageModificationToGpsLNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsLNavResult::CmdName = "GetMessageModificationToGpsLNavResult";
    const char* const GetMessageModificationToGpsLNavResult::Documentation = "Result of GetMessageModificationToGpsLNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGpsLNavResult);


    GetMessageModificationToGpsLNavResult::GetMessageModificationToGpsLNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGpsLNavResult::GetMessageModificationToGpsLNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    GetMessageModificationToGpsLNavResultPtr GetMessageModificationToGpsLNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGpsLNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id);
    }

    GetMessageModificationToGpsLNavResultPtr GetMessageModificationToGpsLNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsLNavResult>(ptr);
    }

    bool GetMessageModificationToGpsLNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsLNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGpsLNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGpsLNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGpsLNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGpsLNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGpsLNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToGpsLNavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToGpsLNavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetMessageModificationToGpsLNavResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGpsLNavResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetMessageModificationToGpsLNavResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsLNavResult::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void GetMessageModificationToGpsLNavResult::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsLNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsLNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGalileoCNav
///
#include "gen/SetMessageModificationToGalileoCNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGalileoCNav::CmdName = "SetMessageModificationToGalileoCNav";
    const char* const SetMessageModificationToGalileoCNav::Documentation = "Set (or Modify) event to change Galileo C/NAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGalileoCNav);


    SetMessageModificationToGalileoCNav::SetMessageModificationToGalileoCNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGalileoCNav::SetMessageModificationToGalileoCNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGalileoCNavPtr SetMessageModificationToGalileoCNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToGalileoCNav>(signalArray, svId, startTime, stopTime, updateCRC, bitModifications, id);
    }

    SetMessageModificationToGalileoCNavPtr SetMessageModificationToGalileoCNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGalileoCNav>(ptr);
    }

    bool SetMessageModificationToGalileoCNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGalileoCNav::documentation() const { return Documentation; }


    int SetMessageModificationToGalileoCNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGalileoCNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGalileoCNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoCNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGalileoCNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoCNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGalileoCNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoCNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGalileoCNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGalileoCNav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToGalileoCNav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoCNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGalileoCNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoCNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGalileoCNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoCNav
///
#include "gen/GetMessageModificationToGalileoCNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoCNav::CmdName = "GetMessageModificationToGalileoCNav";
    const char* const GetMessageModificationToGalileoCNav::Documentation = "Get infos about the Galileo C/NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGalileoCNav);


    GetMessageModificationToGalileoCNav::GetMessageModificationToGalileoCNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGalileoCNav::GetMessageModificationToGalileoCNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGalileoCNavPtr GetMessageModificationToGalileoCNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGalileoCNav>(id);
    }

    GetMessageModificationToGalileoCNavPtr GetMessageModificationToGalileoCNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoCNav>(ptr);
    }

    bool GetMessageModificationToGalileoCNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoCNav::documentation() const { return Documentation; }


    int GetMessageModificationToGalileoCNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGalileoCNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoCNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoCNavResult
///
#include "gen/GetMessageModificationToGalileoCNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoCNavResult::CmdName = "GetMessageModificationToGalileoCNavResult";
    const char* const GetMessageModificationToGalileoCNavResult::Documentation = "Result of GetMessageModificationToGalileoCNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGalileoCNavResult);


    GetMessageModificationToGalileoCNavResult::GetMessageModificationToGalileoCNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGalileoCNavResult::GetMessageModificationToGalileoCNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGalileoCNavResultPtr GetMessageModificationToGalileoCNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGalileoCNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, updateCRC, bitModifications, id);
    }

    GetMessageModificationToGalileoCNavResultPtr GetMessageModificationToGalileoCNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoCNavResult>(ptr);
    }

    bool GetMessageModificationToGalileoCNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoCNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGalileoCNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGalileoCNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoCNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGalileoCNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoCNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGalileoCNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoCNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGalileoCNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGalileoCNavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToGalileoCNavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoCNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGalileoCNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoCNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoCNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGalileoFNav
///
#include "gen/SetMessageModificationToGalileoFNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGalileoFNav::CmdName = "SetMessageModificationToGalileoFNav";
    const char* const SetMessageModificationToGalileoFNav::Documentation = "Set (or Modify) event to change Galileo F/NAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGalileoFNav);


    SetMessageModificationToGalileoFNav::SetMessageModificationToGalileoFNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGalileoFNav::SetMessageModificationToGalileoFNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGalileoFNavPtr SetMessageModificationToGalileoFNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToGalileoFNav>(signalArray, svId, startTime, stopTime, subframe, page, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToGalileoFNavPtr SetMessageModificationToGalileoFNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGalileoFNav>(ptr);
    }

    bool SetMessageModificationToGalileoFNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGalileoFNav::documentation() const { return Documentation; }


    int SetMessageModificationToGalileoFNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGalileoFNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGalileoFNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGalileoFNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGalileoFNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGalileoFNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToGalileoFNav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToGalileoFNav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoFNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGalileoFNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGalileoFNav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToGalileoFNav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoFNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGalileoFNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoFNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGalileoFNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoFNav
///
#include "gen/GetMessageModificationToGalileoFNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoFNav::CmdName = "GetMessageModificationToGalileoFNav";
    const char* const GetMessageModificationToGalileoFNav::Documentation = "Get infos about the Galileo F/NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGalileoFNav);


    GetMessageModificationToGalileoFNav::GetMessageModificationToGalileoFNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGalileoFNav::GetMessageModificationToGalileoFNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGalileoFNavPtr GetMessageModificationToGalileoFNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGalileoFNav>(id);
    }

    GetMessageModificationToGalileoFNavPtr GetMessageModificationToGalileoFNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoFNav>(ptr);
    }

    bool GetMessageModificationToGalileoFNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoFNav::documentation() const { return Documentation; }


    int GetMessageModificationToGalileoFNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGalileoFNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoFNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoFNavResult
///
#include "gen/GetMessageModificationToGalileoFNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoFNavResult::CmdName = "GetMessageModificationToGalileoFNavResult";
    const char* const GetMessageModificationToGalileoFNavResult::Documentation = "Result of GetMessageModificationToGalileoFNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGalileoFNavResult);


    GetMessageModificationToGalileoFNavResult::GetMessageModificationToGalileoFNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGalileoFNavResult::GetMessageModificationToGalileoFNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGalileoFNavResultPtr GetMessageModificationToGalileoFNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGalileoFNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToGalileoFNavResultPtr GetMessageModificationToGalileoFNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoFNavResult>(ptr);
    }

    bool GetMessageModificationToGalileoFNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoFNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGalileoFNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGalileoFNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGalileoFNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGalileoFNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGalileoFNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToGalileoFNavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToGalileoFNavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoFNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGalileoFNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGalileoFNavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToGalileoFNavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoFNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGalileoFNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoFNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoFNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGalileoINav
///
#include "gen/SetMessageModificationToGalileoINav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGalileoINav::CmdName = "SetMessageModificationToGalileoINav";
    const char* const SetMessageModificationToGalileoINav::Documentation = "Set (or Modify) event to change Galileo I/NAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGalileoINav);


    SetMessageModificationToGalileoINav::SetMessageModificationToGalileoINav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGalileoINav::SetMessageModificationToGalileoINav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGalileoINavPtr SetMessageModificationToGalileoINav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToGalileoINav>(signalArray, svId, startTime, stopTime, subframe, page, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToGalileoINavPtr SetMessageModificationToGalileoINav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGalileoINav>(ptr);
    }

    bool SetMessageModificationToGalileoINav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGalileoINav::documentation() const { return Documentation; }


    int SetMessageModificationToGalileoINav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGalileoINav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGalileoINav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGalileoINav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGalileoINav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGalileoINav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToGalileoINav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToGalileoINav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoINav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGalileoINav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGalileoINav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToGalileoINav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoINav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGalileoINav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoINav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGalileoINav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoINav
///
#include "gen/GetMessageModificationToGalileoINav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoINav::CmdName = "GetMessageModificationToGalileoINav";
    const char* const GetMessageModificationToGalileoINav::Documentation = "Get infos about the Galileo I/NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGalileoINav);


    GetMessageModificationToGalileoINav::GetMessageModificationToGalileoINav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGalileoINav::GetMessageModificationToGalileoINav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGalileoINavPtr GetMessageModificationToGalileoINav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGalileoINav>(id);
    }

    GetMessageModificationToGalileoINavPtr GetMessageModificationToGalileoINav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoINav>(ptr);
    }

    bool GetMessageModificationToGalileoINav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoINav::documentation() const { return Documentation; }


    int GetMessageModificationToGalileoINav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGalileoINav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoINav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoINavResult
///
#include "gen/GetMessageModificationToGalileoINavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoINavResult::CmdName = "GetMessageModificationToGalileoINavResult";
    const char* const GetMessageModificationToGalileoINavResult::Documentation = "Result of GetMessageModificationToGalileoINav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGalileoINavResult);


    GetMessageModificationToGalileoINavResult::GetMessageModificationToGalileoINavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGalileoINavResult::GetMessageModificationToGalileoINavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGalileoINavResultPtr GetMessageModificationToGalileoINavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGalileoINavResult>(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToGalileoINavResultPtr GetMessageModificationToGalileoINavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoINavResult>(ptr);
    }

    bool GetMessageModificationToGalileoINavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoINavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGalileoINavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGalileoINavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGalileoINavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGalileoINavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGalileoINavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToGalileoINavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToGalileoINavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoINavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGalileoINavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGalileoINavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToGalileoINavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoINavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGalileoINavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoINavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoINavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGlonassNav
///
#include "gen/SetMessageModificationToGlonassNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGlonassNav::CmdName = "SetMessageModificationToGlonassNav";
    const char* const SetMessageModificationToGlonassNav::Documentation = "Set (or Modify) event to change GLONASS NAV message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessage strings. The Modification parameter is a string where the first character applies to bit\n85 of frame string and last character applies to Hamming Code bit 1.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   ' ' white space are ignored (use them to separate the string into bytes to help reading)\n   '-' or any other byte value will have no effect\n\nExample:\n\n\"-0--- 1------- -------- -------- -------- -------- -------- -------- -------- -------- ---1--X-\"\n  |  |                                           |  |\n  |  +- Force bit 80 to '1'               Force Hamming code bit 5 to '1' -+  |\n  |                                               |\n  +------ Force bit 84 to 0                   Negate Hamming code bit 2 ----+\n\nNote: if UpdateHammingCode is true, any modification to bits 1..8 will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGlonassNav);


    SetMessageModificationToGlonassNav::SetMessageModificationToGlonassNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGlonassNav::SetMessageModificationToGlonassNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& stringModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setFrame(frame);
      setStringNumber(stringNumber);
      setUpdateHammingCode(updateHammingCode);
      setStringModification(stringModification);
      setId(id);
    }


    SetMessageModificationToGlonassNavPtr SetMessageModificationToGlonassNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& stringModification, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToGlonassNav>(signalArray, svId, startTime, stopTime, frame, stringNumber, updateHammingCode, stringModification, id);
    }

    SetMessageModificationToGlonassNavPtr SetMessageModificationToGlonassNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGlonassNav>(ptr);
    }

    bool SetMessageModificationToGlonassNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Frame"])
          && parse_json<int>::is_valid(m_values["StringNumber"])
          && parse_json<bool>::is_valid(m_values["UpdateHammingCode"])
          && parse_json<std::string>::is_valid(m_values["StringModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGlonassNav::documentation() const { return Documentation; }


    int SetMessageModificationToGlonassNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGlonassNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGlonassNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGlonassNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGlonassNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGlonassNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::frame() const
    {
      return parse_json<int>::parse(m_values["Frame"]);
    }

    void SetMessageModificationToGlonassNav::setFrame(int frame)
    {
      m_values.AddMember("Frame", parse_json<int>::format(frame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::stringNumber() const
    {
      return parse_json<int>::parse(m_values["StringNumber"]);
    }

    void SetMessageModificationToGlonassNav::setStringNumber(int stringNumber)
    {
      m_values.AddMember("StringNumber", parse_json<int>::format(stringNumber, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGlonassNav::updateHammingCode() const
    {
      return parse_json<bool>::parse(m_values["UpdateHammingCode"]);
    }

    void SetMessageModificationToGlonassNav::setUpdateHammingCode(bool updateHammingCode)
    {
      m_values.AddMember("UpdateHammingCode", parse_json<bool>::format(updateHammingCode, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGlonassNav::stringModification() const
    {
      return parse_json<std::string>::parse(m_values["StringModification"]);
    }

    void SetMessageModificationToGlonassNav::setStringModification(const std::string& stringModification)
    {
      m_values.AddMember("StringModification", parse_json<std::string>::format(stringModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGlonassNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGlonassNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGlonassNav
///
#include "gen/GetMessageModificationToGlonassNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGlonassNav::CmdName = "GetMessageModificationToGlonassNav";
    const char* const GetMessageModificationToGlonassNav::Documentation = "Get infos about the GLONASS NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGlonassNav);


    GetMessageModificationToGlonassNav::GetMessageModificationToGlonassNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGlonassNav::GetMessageModificationToGlonassNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGlonassNavPtr GetMessageModificationToGlonassNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGlonassNav>(id);
    }

    GetMessageModificationToGlonassNavPtr GetMessageModificationToGlonassNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGlonassNav>(ptr);
    }

    bool GetMessageModificationToGlonassNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGlonassNav::documentation() const { return Documentation; }


    int GetMessageModificationToGlonassNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGlonassNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGlonassNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGlonassNavResult
///
#include "gen/GetMessageModificationToGlonassNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGlonassNavResult::CmdName = "GetMessageModificationToGlonassNavResult";
    const char* const GetMessageModificationToGlonassNavResult::Documentation = "Result of GetMessageModificationToGlonassNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGlonassNavResult);


    GetMessageModificationToGlonassNavResult::GetMessageModificationToGlonassNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGlonassNavResult::GetMessageModificationToGlonassNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& stringModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setFrame(frame);
      setStringNumber(stringNumber);
      setUpdateHammingCode(updateHammingCode);
      setStringModification(stringModification);
      setId(id);
    }


    GetMessageModificationToGlonassNavResultPtr GetMessageModificationToGlonassNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& stringModification, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToGlonassNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, frame, stringNumber, updateHammingCode, stringModification, id);
    }

    GetMessageModificationToGlonassNavResultPtr GetMessageModificationToGlonassNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGlonassNavResult>(ptr);
    }

    bool GetMessageModificationToGlonassNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Frame"])
          && parse_json<int>::is_valid(m_values["StringNumber"])
          && parse_json<bool>::is_valid(m_values["UpdateHammingCode"])
          && parse_json<std::string>::is_valid(m_values["StringModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGlonassNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGlonassNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGlonassNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGlonassNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGlonassNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGlonassNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::frame() const
    {
      return parse_json<int>::parse(m_values["Frame"]);
    }

    void GetMessageModificationToGlonassNavResult::setFrame(int frame)
    {
      m_values.AddMember("Frame", parse_json<int>::format(frame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::stringNumber() const
    {
      return parse_json<int>::parse(m_values["StringNumber"]);
    }

    void GetMessageModificationToGlonassNavResult::setStringNumber(int stringNumber)
    {
      m_values.AddMember("StringNumber", parse_json<int>::format(stringNumber, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGlonassNavResult::updateHammingCode() const
    {
      return parse_json<bool>::parse(m_values["UpdateHammingCode"]);
    }

    void GetMessageModificationToGlonassNavResult::setUpdateHammingCode(bool updateHammingCode)
    {
      m_values.AddMember("UpdateHammingCode", parse_json<bool>::format(updateHammingCode, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGlonassNavResult::stringModification() const
    {
      return parse_json<std::string>::parse(m_values["StringModification"]);
    }

    void GetMessageModificationToGlonassNavResult::setStringModification(const std::string& stringModification)
    {
      m_values.AddMember("StringModification", parse_json<std::string>::format(stringModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGlonassNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGlonassNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToBeiDouD1Nav
///
#include "gen/SetMessageModificationToBeiDouD1Nav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToBeiDouD1Nav::CmdName = "SetMessageModificationToBeiDouD1Nav";
    const char* const SetMessageModificationToBeiDouD1Nav::Documentation = "Set (or Modify) event to change BeiDou D1 NAV navigation message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to parity bits will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToBeiDouD1Nav);


    SetMessageModificationToBeiDouD1Nav::SetMessageModificationToBeiDouD1Nav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToBeiDouD1Nav::SetMessageModificationToBeiDouD1Nav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    SetMessageModificationToBeiDouD1NavPtr SetMessageModificationToBeiDouD1Nav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToBeiDouD1Nav>(signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id);
    }

    SetMessageModificationToBeiDouD1NavPtr SetMessageModificationToBeiDouD1Nav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToBeiDouD1Nav>(ptr);
    }

    bool SetMessageModificationToBeiDouD1Nav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToBeiDouD1Nav::documentation() const { return Documentation; }


    int SetMessageModificationToBeiDouD1Nav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToBeiDouD1Nav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToBeiDouD1Nav::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouD1Nav::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouD1Nav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouD1Nav
///
#include "gen/GetMessageModificationToBeiDouD1Nav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouD1Nav::CmdName = "GetMessageModificationToBeiDouD1Nav";
    const char* const GetMessageModificationToBeiDouD1Nav::Documentation = "Get infos about the BeiDou D1 NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToBeiDouD1Nav);


    GetMessageModificationToBeiDouD1Nav::GetMessageModificationToBeiDouD1Nav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToBeiDouD1Nav::GetMessageModificationToBeiDouD1Nav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToBeiDouD1NavPtr GetMessageModificationToBeiDouD1Nav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToBeiDouD1Nav>(id);
    }

    GetMessageModificationToBeiDouD1NavPtr GetMessageModificationToBeiDouD1Nav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouD1Nav>(ptr);
    }

    bool GetMessageModificationToBeiDouD1Nav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouD1Nav::documentation() const { return Documentation; }


    int GetMessageModificationToBeiDouD1Nav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToBeiDouD1Nav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouD1Nav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouD1NavResult
///
#include "gen/GetMessageModificationToBeiDouD1NavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouD1NavResult::CmdName = "GetMessageModificationToBeiDouD1NavResult";
    const char* const GetMessageModificationToBeiDouD1NavResult::Documentation = "Result of GetMessageModificationToBeiDouD1Nav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToBeiDouD1NavResult);


    GetMessageModificationToBeiDouD1NavResult::GetMessageModificationToBeiDouD1NavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToBeiDouD1NavResult::GetMessageModificationToBeiDouD1NavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    GetMessageModificationToBeiDouD1NavResultPtr GetMessageModificationToBeiDouD1NavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToBeiDouD1NavResult>(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id);
    }

    GetMessageModificationToBeiDouD1NavResultPtr GetMessageModificationToBeiDouD1NavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouD1NavResult>(ptr);
    }

    bool GetMessageModificationToBeiDouD1NavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouD1NavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToBeiDouD1NavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToBeiDouD1NavResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouD1NavResult::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouD1NavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToBeiDouD2Nav
///
#include "gen/SetMessageModificationToBeiDouD2Nav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToBeiDouD2Nav::CmdName = "SetMessageModificationToBeiDouD2Nav";
    const char* const SetMessageModificationToBeiDouD2Nav::Documentation = "Set (or Modify) event to change BeiDou D2 NAV message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to parity bits will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToBeiDouD2Nav);


    SetMessageModificationToBeiDouD2Nav::SetMessageModificationToBeiDouD2Nav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToBeiDouD2Nav::SetMessageModificationToBeiDouD2Nav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    SetMessageModificationToBeiDouD2NavPtr SetMessageModificationToBeiDouD2Nav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToBeiDouD2Nav>(signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id);
    }

    SetMessageModificationToBeiDouD2NavPtr SetMessageModificationToBeiDouD2Nav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToBeiDouD2Nav>(ptr);
    }

    bool SetMessageModificationToBeiDouD2Nav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToBeiDouD2Nav::documentation() const { return Documentation; }


    int SetMessageModificationToBeiDouD2Nav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToBeiDouD2Nav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToBeiDouD2Nav::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouD2Nav::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouD2Nav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouD2Nav
///
#include "gen/GetMessageModificationToBeiDouD2Nav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouD2Nav::CmdName = "GetMessageModificationToBeiDouD2Nav";
    const char* const GetMessageModificationToBeiDouD2Nav::Documentation = "Get infos about the BeiDou D2 NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToBeiDouD2Nav);


    GetMessageModificationToBeiDouD2Nav::GetMessageModificationToBeiDouD2Nav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToBeiDouD2Nav::GetMessageModificationToBeiDouD2Nav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToBeiDouD2NavPtr GetMessageModificationToBeiDouD2Nav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToBeiDouD2Nav>(id);
    }

    GetMessageModificationToBeiDouD2NavPtr GetMessageModificationToBeiDouD2Nav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouD2Nav>(ptr);
    }

    bool GetMessageModificationToBeiDouD2Nav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouD2Nav::documentation() const { return Documentation; }


    int GetMessageModificationToBeiDouD2Nav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToBeiDouD2Nav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouD2Nav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouD2NavResult
///
#include "gen/GetMessageModificationToBeiDouD2NavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouD2NavResult::CmdName = "GetMessageModificationToBeiDouD2NavResult";
    const char* const GetMessageModificationToBeiDouD2NavResult::Documentation = "Result of GetMessageModificationToBeiDouD2Nav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToBeiDouD2NavResult);


    GetMessageModificationToBeiDouD2NavResult::GetMessageModificationToBeiDouD2NavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToBeiDouD2NavResult::GetMessageModificationToBeiDouD2NavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    GetMessageModificationToBeiDouD2NavResultPtr GetMessageModificationToBeiDouD2NavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToBeiDouD2NavResult>(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id);
    }

    GetMessageModificationToBeiDouD2NavResultPtr GetMessageModificationToBeiDouD2NavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouD2NavResult>(ptr);
    }

    bool GetMessageModificationToBeiDouD2NavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouD2NavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToBeiDouD2NavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToBeiDouD2NavResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouD2NavResult::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouD2NavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToBeiDouCNav1
///
#include "gen/SetMessageModificationToBeiDouCNav1.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToBeiDouCNav1::CmdName = "SetMessageModificationToBeiDouCNav1";
    const char* const SetMessageModificationToBeiDouCNav1::Documentation = "Set (or Modify) event to change BeiDou CNAV1 message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToBeiDouCNav1);


    SetMessageModificationToBeiDouCNav1::SetMessageModificationToBeiDouCNav1()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToBeiDouCNav1::SetMessageModificationToBeiDouCNav1(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToBeiDouCNav1Ptr SetMessageModificationToBeiDouCNav1::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToBeiDouCNav1>(signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToBeiDouCNav1Ptr SetMessageModificationToBeiDouCNav1::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToBeiDouCNav1>(ptr);
    }

    bool SetMessageModificationToBeiDouCNav1::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToBeiDouCNav1::documentation() const { return Documentation; }


    int SetMessageModificationToBeiDouCNav1::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToBeiDouCNav1::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToBeiDouCNav1::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav1::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToBeiDouCNav1::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav1::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToBeiDouCNav1::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav1::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToBeiDouCNav1::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav1::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToBeiDouCNav1::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav1::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToBeiDouCNav1::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToBeiDouCNav1::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToBeiDouCNav1::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav1::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToBeiDouCNav1::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav1::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToBeiDouCNav1::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouCNav1
///
#include "gen/GetMessageModificationToBeiDouCNav1.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouCNav1::CmdName = "GetMessageModificationToBeiDouCNav1";
    const char* const GetMessageModificationToBeiDouCNav1::Documentation = "Get infos about the BeiDou CNAV1 message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToBeiDouCNav1);


    GetMessageModificationToBeiDouCNav1::GetMessageModificationToBeiDouCNav1()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToBeiDouCNav1::GetMessageModificationToBeiDouCNav1(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToBeiDouCNav1Ptr GetMessageModificationToBeiDouCNav1::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToBeiDouCNav1>(id);
    }

    GetMessageModificationToBeiDouCNav1Ptr GetMessageModificationToBeiDouCNav1::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouCNav1>(ptr);
    }

    bool GetMessageModificationToBeiDouCNav1::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouCNav1::documentation() const { return Documentation; }


    int GetMessageModificationToBeiDouCNav1::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToBeiDouCNav1::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouCNav1::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouCNav1Result
///
#include "gen/GetMessageModificationToBeiDouCNav1Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouCNav1Result::CmdName = "GetMessageModificationToBeiDouCNav1Result";
    const char* const GetMessageModificationToBeiDouCNav1Result::Documentation = "Result of GetMessageModificationToBeiDouCNav1.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToBeiDouCNav1Result);


    GetMessageModificationToBeiDouCNav1Result::GetMessageModificationToBeiDouCNav1Result()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToBeiDouCNav1Result::GetMessageModificationToBeiDouCNav1Result(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToBeiDouCNav1ResultPtr GetMessageModificationToBeiDouCNav1Result::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToBeiDouCNav1Result>(relatedCommand, signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToBeiDouCNav1ResultPtr GetMessageModificationToBeiDouCNav1Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouCNav1Result>(ptr);
    }

    bool GetMessageModificationToBeiDouCNav1Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouCNav1Result::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToBeiDouCNav1Result::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav1Result::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav1Result::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav1Result::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav1Result::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav1Result::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToBeiDouCNav1Result::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav1Result::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav1Result::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToBeiDouCNav2
///
#include "gen/SetMessageModificationToBeiDouCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToBeiDouCNav2::CmdName = "SetMessageModificationToBeiDouCNav2";
    const char* const SetMessageModificationToBeiDouCNav2::Documentation = "Set (or Modify) event to change BeiDou CNAV2 message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToBeiDouCNav2);


    SetMessageModificationToBeiDouCNav2::SetMessageModificationToBeiDouCNav2()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToBeiDouCNav2::SetMessageModificationToBeiDouCNav2(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToBeiDouCNav2Ptr SetMessageModificationToBeiDouCNav2::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToBeiDouCNav2>(signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToBeiDouCNav2Ptr SetMessageModificationToBeiDouCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToBeiDouCNav2>(ptr);
    }

    bool SetMessageModificationToBeiDouCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToBeiDouCNav2::documentation() const { return Documentation; }


    int SetMessageModificationToBeiDouCNav2::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToBeiDouCNav2::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToBeiDouCNav2::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav2::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToBeiDouCNav2::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav2::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToBeiDouCNav2::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav2::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToBeiDouCNav2::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav2::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToBeiDouCNav2::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav2::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToBeiDouCNav2::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToBeiDouCNav2::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToBeiDouCNav2::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav2::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToBeiDouCNav2::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToBeiDouCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouCNav2
///
#include "gen/GetMessageModificationToBeiDouCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouCNav2::CmdName = "GetMessageModificationToBeiDouCNav2";
    const char* const GetMessageModificationToBeiDouCNav2::Documentation = "Get infos about the BeiDou CNAV2 message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToBeiDouCNav2);


    GetMessageModificationToBeiDouCNav2::GetMessageModificationToBeiDouCNav2()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToBeiDouCNav2::GetMessageModificationToBeiDouCNav2(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToBeiDouCNav2Ptr GetMessageModificationToBeiDouCNav2::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToBeiDouCNav2>(id);
    }

    GetMessageModificationToBeiDouCNav2Ptr GetMessageModificationToBeiDouCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouCNav2>(ptr);
    }

    bool GetMessageModificationToBeiDouCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouCNav2::documentation() const { return Documentation; }


    int GetMessageModificationToBeiDouCNav2::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToBeiDouCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouCNav2Result
///
#include "gen/GetMessageModificationToBeiDouCNav2Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouCNav2Result::CmdName = "GetMessageModificationToBeiDouCNav2Result";
    const char* const GetMessageModificationToBeiDouCNav2Result::Documentation = "Result of GetMessageModificationToBeiDouCNav2.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToBeiDouCNav2Result);


    GetMessageModificationToBeiDouCNav2Result::GetMessageModificationToBeiDouCNav2Result()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToBeiDouCNav2Result::GetMessageModificationToBeiDouCNav2Result(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToBeiDouCNav2ResultPtr GetMessageModificationToBeiDouCNav2Result::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToBeiDouCNav2Result>(relatedCommand, signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToBeiDouCNav2ResultPtr GetMessageModificationToBeiDouCNav2Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouCNav2Result>(ptr);
    }

    bool GetMessageModificationToBeiDouCNav2Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouCNav2Result::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToBeiDouCNav2Result::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav2Result::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav2Result::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav2Result::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav2Result::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav2Result::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToBeiDouCNav2Result::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav2Result::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav2Result::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToQzssLNav
///
#include "gen/SetMessageModificationToQzssLNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToQzssLNav::CmdName = "SetMessageModificationToQzssLNav";
    const char* const SetMessageModificationToQzssLNav::Documentation = "Set (or Modify) event to change QZSS LNAV message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to bits 25..30 will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToQzssLNav);


    SetMessageModificationToQzssLNav::SetMessageModificationToQzssLNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToQzssLNav::SetMessageModificationToQzssLNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int lNavSvId, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setLNavSvId(lNavSvId);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    SetMessageModificationToQzssLNavPtr SetMessageModificationToQzssLNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int lNavSvId, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToQzssLNav>(signalArray, svId, startTime, stopTime, subframe, lNavSvId, word, updateParity, wordModification, id);
    }

    SetMessageModificationToQzssLNavPtr SetMessageModificationToQzssLNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToQzssLNav>(ptr);
    }

    bool SetMessageModificationToQzssLNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["LNavSvId"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToQzssLNav::documentation() const { return Documentation; }


    int SetMessageModificationToQzssLNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToQzssLNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToQzssLNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToQzssLNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToQzssLNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToQzssLNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToQzssLNav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::lNavSvId() const
    {
      return parse_json<int>::parse(m_values["LNavSvId"]);
    }

    void SetMessageModificationToQzssLNav::setLNavSvId(int lNavSvId)
    {
      m_values.AddMember("LNavSvId", parse_json<int>::format(lNavSvId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetMessageModificationToQzssLNav::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToQzssLNav::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetMessageModificationToQzssLNav::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssLNav::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void SetMessageModificationToQzssLNav::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssLNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToQzssLNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssLNav
///
#include "gen/GetMessageModificationToQzssLNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssLNav::CmdName = "GetMessageModificationToQzssLNav";
    const char* const GetMessageModificationToQzssLNav::Documentation = "Get infos about the QZSS LNAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToQzssLNav);


    GetMessageModificationToQzssLNav::GetMessageModificationToQzssLNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToQzssLNav::GetMessageModificationToQzssLNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToQzssLNavPtr GetMessageModificationToQzssLNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToQzssLNav>(id);
    }

    GetMessageModificationToQzssLNavPtr GetMessageModificationToQzssLNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssLNav>(ptr);
    }

    bool GetMessageModificationToQzssLNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssLNav::documentation() const { return Documentation; }


    int GetMessageModificationToQzssLNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToQzssLNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssLNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssLNavResult
///
#include "gen/GetMessageModificationToQzssLNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssLNavResult::CmdName = "GetMessageModificationToQzssLNavResult";
    const char* const GetMessageModificationToQzssLNavResult::Documentation = "Result of GetMessageModificationToQzssLNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToQzssLNavResult);


    GetMessageModificationToQzssLNavResult::GetMessageModificationToQzssLNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToQzssLNavResult::GetMessageModificationToQzssLNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int lNavSvId, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setLNavSvId(lNavSvId);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    GetMessageModificationToQzssLNavResultPtr GetMessageModificationToQzssLNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int lNavSvId, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToQzssLNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, subframe, lNavSvId, word, updateParity, wordModification, id);
    }

    GetMessageModificationToQzssLNavResultPtr GetMessageModificationToQzssLNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssLNavResult>(ptr);
    }

    bool GetMessageModificationToQzssLNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["LNavSvId"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssLNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToQzssLNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToQzssLNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToQzssLNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToQzssLNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToQzssLNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToQzssLNavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::lNavSvId() const
    {
      return parse_json<int>::parse(m_values["LNavSvId"]);
    }

    void GetMessageModificationToQzssLNavResult::setLNavSvId(int lNavSvId)
    {
      m_values.AddMember("LNavSvId", parse_json<int>::format(lNavSvId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetMessageModificationToQzssLNavResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToQzssLNavResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetMessageModificationToQzssLNavResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssLNavResult::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void GetMessageModificationToQzssLNavResult::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssLNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssLNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToQzssSlas
///
#include "gen/SetMessageModificationToQzssSlas.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToQzssSlas::CmdName = "SetMessageModificationToQzssSlas";
    const char* const SetMessageModificationToQzssSlas::Documentation = "Set (or Modify) event to change QZSS SLAS message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToQzssSlas);


    SetMessageModificationToQzssSlas::SetMessageModificationToQzssSlas()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToQzssSlas::SetMessageModificationToQzssSlas(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToQzssSlasPtr SetMessageModificationToQzssSlas::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToQzssSlas>(signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToQzssSlasPtr SetMessageModificationToQzssSlas::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToQzssSlas>(ptr);
    }

    bool SetMessageModificationToQzssSlas::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToQzssSlas::documentation() const { return Documentation; }


    int SetMessageModificationToQzssSlas::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToQzssSlas::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToQzssSlas::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssSlas::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToQzssSlas::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssSlas::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToQzssSlas::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssSlas::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToQzssSlas::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssSlas::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToQzssSlas::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssSlas::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToQzssSlas::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToQzssSlas::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToQzssSlas::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssSlas::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToQzssSlas::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssSlas::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToQzssSlas::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssSlas
///
#include "gen/GetMessageModificationToQzssSlas.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssSlas::CmdName = "GetMessageModificationToQzssSlas";
    const char* const GetMessageModificationToQzssSlas::Documentation = "Get infos about the QZSS SLAS message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToQzssSlas);


    GetMessageModificationToQzssSlas::GetMessageModificationToQzssSlas()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToQzssSlas::GetMessageModificationToQzssSlas(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToQzssSlasPtr GetMessageModificationToQzssSlas::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToQzssSlas>(id);
    }

    GetMessageModificationToQzssSlasPtr GetMessageModificationToQzssSlas::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssSlas>(ptr);
    }

    bool GetMessageModificationToQzssSlas::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssSlas::documentation() const { return Documentation; }


    int GetMessageModificationToQzssSlas::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToQzssSlas::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssSlas::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssSlasResult
///
#include "gen/GetMessageModificationToQzssSlasResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssSlasResult::CmdName = "GetMessageModificationToQzssSlasResult";
    const char* const GetMessageModificationToQzssSlasResult::Documentation = "Result of GetMessageModificationToQzssSlas.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToQzssSlasResult);


    GetMessageModificationToQzssSlasResult::GetMessageModificationToQzssSlasResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToQzssSlasResult::GetMessageModificationToQzssSlasResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToQzssSlasResultPtr GetMessageModificationToQzssSlasResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToQzssSlasResult>(relatedCommand, signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToQzssSlasResultPtr GetMessageModificationToQzssSlasResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssSlasResult>(ptr);
    }

    bool GetMessageModificationToQzssSlasResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssSlasResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToQzssSlasResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToQzssSlasResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssSlasResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToQzssSlasResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssSlasResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToQzssSlasResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssSlasResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToQzssSlasResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssSlasResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToQzssSlasResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssSlasResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToQzssSlasResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToQzssSlasResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToQzssSlasResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssSlasResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToQzssSlasResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssSlasResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssSlasResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToQzssCNav
///
#include "gen/SetMessageModificationToQzssCNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToQzssCNav::CmdName = "SetMessageModificationToQzssCNav";
    const char* const SetMessageModificationToQzssCNav::Documentation = "Set (or Modify) event to change QZSS CNAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToQzssCNav);


    SetMessageModificationToQzssCNav::SetMessageModificationToQzssCNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToQzssCNav::SetMessageModificationToQzssCNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToQzssCNavPtr SetMessageModificationToQzssCNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToQzssCNav>(signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToQzssCNavPtr SetMessageModificationToQzssCNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToQzssCNav>(ptr);
    }

    bool SetMessageModificationToQzssCNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToQzssCNav::documentation() const { return Documentation; }


    int SetMessageModificationToQzssCNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToQzssCNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToQzssCNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToQzssCNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToQzssCNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToQzssCNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToQzssCNav::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssCNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToQzssCNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToQzssCNav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToQzssCNav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssCNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToQzssCNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssCNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToQzssCNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssCNav
///
#include "gen/GetMessageModificationToQzssCNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssCNav::CmdName = "GetMessageModificationToQzssCNav";
    const char* const GetMessageModificationToQzssCNav::Documentation = "Get infos about the QZSS CNAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToQzssCNav);


    GetMessageModificationToQzssCNav::GetMessageModificationToQzssCNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToQzssCNav::GetMessageModificationToQzssCNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToQzssCNavPtr GetMessageModificationToQzssCNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToQzssCNav>(id);
    }

    GetMessageModificationToQzssCNavPtr GetMessageModificationToQzssCNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssCNav>(ptr);
    }

    bool GetMessageModificationToQzssCNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssCNav::documentation() const { return Documentation; }


    int GetMessageModificationToQzssCNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToQzssCNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssCNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssCNavResult
///
#include "gen/GetMessageModificationToQzssCNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssCNavResult::CmdName = "GetMessageModificationToQzssCNavResult";
    const char* const GetMessageModificationToQzssCNavResult::Documentation = "Result of GetMessageModificationToQzssCNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToQzssCNavResult);


    GetMessageModificationToQzssCNavResult::GetMessageModificationToQzssCNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToQzssCNavResult::GetMessageModificationToQzssCNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToQzssCNavResultPtr GetMessageModificationToQzssCNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToQzssCNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToQzssCNavResultPtr GetMessageModificationToQzssCNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssCNavResult>(ptr);
    }

    bool GetMessageModificationToQzssCNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssCNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToQzssCNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToQzssCNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToQzssCNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToQzssCNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToQzssCNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNavResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToQzssCNavResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssCNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToQzssCNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToQzssCNavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToQzssCNavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssCNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToQzssCNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssCNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssCNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToQzssCNav2
///
#include "gen/SetMessageModificationToQzssCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToQzssCNav2::CmdName = "SetMessageModificationToQzssCNav2";
    const char* const SetMessageModificationToQzssCNav2::Documentation = "Set (or Modify) event to change QZSS CNAV2 message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToQzssCNav2);


    SetMessageModificationToQzssCNav2::SetMessageModificationToQzssCNav2()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToQzssCNav2::SetMessageModificationToQzssCNav2(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToQzssCNav2Ptr SetMessageModificationToQzssCNav2::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToQzssCNav2>(signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToQzssCNav2Ptr SetMessageModificationToQzssCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToQzssCNav2>(ptr);
    }

    bool SetMessageModificationToQzssCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToQzssCNav2::documentation() const { return Documentation; }


    int SetMessageModificationToQzssCNav2::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToQzssCNav2::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToQzssCNav2::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav2::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToQzssCNav2::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav2::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToQzssCNav2::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav2::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToQzssCNav2::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav2::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToQzssCNav2::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssCNav2::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToQzssCNav2::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToQzssCNav2::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToQzssCNav2::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssCNav2::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToQzssCNav2::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToQzssCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssCNav2
///
#include "gen/GetMessageModificationToQzssCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssCNav2::CmdName = "GetMessageModificationToQzssCNav2";
    const char* const GetMessageModificationToQzssCNav2::Documentation = "Get infos about the QZSS CNAV2 message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToQzssCNav2);


    GetMessageModificationToQzssCNav2::GetMessageModificationToQzssCNav2()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToQzssCNav2::GetMessageModificationToQzssCNav2(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToQzssCNav2Ptr GetMessageModificationToQzssCNav2::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToQzssCNav2>(id);
    }

    GetMessageModificationToQzssCNav2Ptr GetMessageModificationToQzssCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssCNav2>(ptr);
    }

    bool GetMessageModificationToQzssCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssCNav2::documentation() const { return Documentation; }


    int GetMessageModificationToQzssCNav2::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToQzssCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssCNav2Result
///
#include "gen/GetMessageModificationToQzssCNav2Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssCNav2Result::CmdName = "GetMessageModificationToQzssCNav2Result";
    const char* const GetMessageModificationToQzssCNav2Result::Documentation = "Result of GetMessageModificationToQzssCNav2.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToQzssCNav2Result);


    GetMessageModificationToQzssCNav2Result::GetMessageModificationToQzssCNav2Result()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToQzssCNav2Result::GetMessageModificationToQzssCNav2Result(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToQzssCNav2ResultPtr GetMessageModificationToQzssCNav2Result::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToQzssCNav2Result>(relatedCommand, signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToQzssCNav2ResultPtr GetMessageModificationToQzssCNav2Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssCNav2Result>(ptr);
    }

    bool GetMessageModificationToQzssCNav2Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssCNav2Result::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToQzssCNav2Result::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToQzssCNav2Result::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNav2Result::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToQzssCNav2Result::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNav2Result::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToQzssCNav2Result::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNav2Result::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToQzssCNav2Result::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNav2Result::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToQzssCNav2Result::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssCNav2Result::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToQzssCNav2Result::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToQzssCNav2Result::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToQzssCNav2Result::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssCNav2Result::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToQzssCNav2Result::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssCNav2Result::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssCNav2Result::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToNavICNav
///
#include "gen/SetMessageModificationToNavICNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToNavICNav::CmdName = "SetMessageModificationToNavICNav";
    const char* const SetMessageModificationToNavICNav::Documentation = "Set (or Modify) event to change NavIC NAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToNavICNav);


    SetMessageModificationToNavICNav::SetMessageModificationToNavICNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToNavICNav::SetMessageModificationToNavICNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToNavICNavPtr SetMessageModificationToNavICNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToNavICNav>(signalArray, svId, startTime, stopTime, subframe, messageType, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToNavICNavPtr SetMessageModificationToNavICNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToNavICNav>(ptr);
    }

    bool SetMessageModificationToNavICNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToNavICNav::documentation() const { return Documentation; }


    int SetMessageModificationToNavICNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToNavICNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToNavICNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToNavICNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToNavICNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToNavICNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToNavICNav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToNavICNav::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToNavICNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToNavICNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToNavICNav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToNavICNav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToNavICNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToNavICNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToNavICNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToNavICNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToNavICNav
///
#include "gen/GetMessageModificationToNavICNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToNavICNav::CmdName = "GetMessageModificationToNavICNav";
    const char* const GetMessageModificationToNavICNav::Documentation = "Get infos about the NavIC NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToNavICNav);


    GetMessageModificationToNavICNav::GetMessageModificationToNavICNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToNavICNav::GetMessageModificationToNavICNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToNavICNavPtr GetMessageModificationToNavICNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToNavICNav>(id);
    }

    GetMessageModificationToNavICNavPtr GetMessageModificationToNavICNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToNavICNav>(ptr);
    }

    bool GetMessageModificationToNavICNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToNavICNav::documentation() const { return Documentation; }


    int GetMessageModificationToNavICNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToNavICNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToNavICNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToNavICNavResult
///
#include "gen/GetMessageModificationToNavICNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToNavICNavResult::CmdName = "GetMessageModificationToNavICNavResult";
    const char* const GetMessageModificationToNavICNavResult::Documentation = "Result of GetMessageModificationToNavICNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToNavICNavResult);


    GetMessageModificationToNavICNavResult::GetMessageModificationToNavICNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToNavICNavResult::GetMessageModificationToNavICNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToNavICNavResultPtr GetMessageModificationToNavICNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToNavICNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, subframe, messageType, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToNavICNavResultPtr GetMessageModificationToNavICNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToNavICNavResult>(ptr);
    }

    bool GetMessageModificationToNavICNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToNavICNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToNavICNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToNavICNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToNavICNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToNavICNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToNavICNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToNavICNavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToNavICNavResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToNavICNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToNavICNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToNavICNavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToNavICNavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToNavICNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToNavICNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToNavICNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToNavICNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToSbasNav
///
#include "gen/SetMessageModificationToSbasNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToSbasNav::CmdName = "SetMessageModificationToSbasNav";
    const char* const SetMessageModificationToSbasNav::Documentation = "Set (or Modify) event to change SBAS NAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToSbasNav);


    SetMessageModificationToSbasNav::SetMessageModificationToSbasNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToSbasNav::SetMessageModificationToSbasNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToSbasNavPtr SetMessageModificationToSbasNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<SetMessageModificationToSbasNav>(signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    SetMessageModificationToSbasNavPtr SetMessageModificationToSbasNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToSbasNav>(ptr);
    }

    bool SetMessageModificationToSbasNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToSbasNav::documentation() const { return Documentation; }


    int SetMessageModificationToSbasNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToSbasNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToSbasNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToSbasNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToSbasNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToSbasNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToSbasNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToSbasNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToSbasNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToSbasNav::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToSbasNav::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToSbasNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToSbasNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToSbasNav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToSbasNav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToSbasNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToSbasNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToSbasNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToSbasNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToSbasNav
///
#include "gen/GetMessageModificationToSbasNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToSbasNav::CmdName = "GetMessageModificationToSbasNav";
    const char* const GetMessageModificationToSbasNav::Documentation = "Get infos about the SBAS NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToSbasNav);


    GetMessageModificationToSbasNav::GetMessageModificationToSbasNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToSbasNav::GetMessageModificationToSbasNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToSbasNavPtr GetMessageModificationToSbasNav::create(const std::string& id)
    {
      return std::make_shared<GetMessageModificationToSbasNav>(id);
    }

    GetMessageModificationToSbasNavPtr GetMessageModificationToSbasNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToSbasNav>(ptr);
    }

    bool GetMessageModificationToSbasNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToSbasNav::documentation() const { return Documentation; }


    int GetMessageModificationToSbasNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToSbasNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToSbasNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToSbasNavResult
///
#include "gen/GetMessageModificationToSbasNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToSbasNavResult::CmdName = "GetMessageModificationToSbasNavResult";
    const char* const GetMessageModificationToSbasNavResult::Documentation = "Result of GetMessageModificationToSbasNav.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToSbasNavResult);


    GetMessageModificationToSbasNavResult::GetMessageModificationToSbasNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToSbasNavResult::GetMessageModificationToSbasNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToSbasNavResultPtr GetMessageModificationToSbasNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return std::make_shared<GetMessageModificationToSbasNavResult>(relatedCommand, signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id);
    }

    GetMessageModificationToSbasNavResultPtr GetMessageModificationToSbasNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToSbasNavResult>(ptr);
    }

    bool GetMessageModificationToSbasNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToSbasNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToSbasNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToSbasNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToSbasNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToSbasNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToSbasNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToSbasNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToSbasNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToSbasNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToSbasNavResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToSbasNavResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToSbasNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToSbasNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToSbasNavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToSbasNavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToSbasNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToSbasNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToSbasNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToSbasNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveMessageModificationForNavMsgFamily
///
#include "gen/RemoveMessageModificationForNavMsgFamily.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveMessageModificationForNavMsgFamily::CmdName = "RemoveMessageModificationForNavMsgFamily";
    const char* const RemoveMessageModificationForNavMsgFamily::Documentation = "Removes a message modification event for the navigation message family.";

    REGISTER_COMMAND_FACTORY(RemoveMessageModificationForNavMsgFamily);


    RemoveMessageModificationForNavMsgFamily::RemoveMessageModificationForNavMsgFamily()
      : CommandBase(CmdName)
    {}

    RemoveMessageModificationForNavMsgFamily::RemoveMessageModificationForNavMsgFamily(const std::string& navMsgFamily, const std::string& id)
      : CommandBase(CmdName)
    {

      setNavMsgFamily(navMsgFamily);
      setId(id);
    }


    RemoveMessageModificationForNavMsgFamilyPtr RemoveMessageModificationForNavMsgFamily::create(const std::string& navMsgFamily, const std::string& id)
    {
      return std::make_shared<RemoveMessageModificationForNavMsgFamily>(navMsgFamily, id);
    }

    RemoveMessageModificationForNavMsgFamilyPtr RemoveMessageModificationForNavMsgFamily::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveMessageModificationForNavMsgFamily>(ptr);
    }

    bool RemoveMessageModificationForNavMsgFamily::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["NavMsgFamily"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveMessageModificationForNavMsgFamily::documentation() const { return Documentation; }


    int RemoveMessageModificationForNavMsgFamily::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveMessageModificationForNavMsgFamily::navMsgFamily() const
    {
      return parse_json<std::string>::parse(m_values["NavMsgFamily"]);
    }

    void RemoveMessageModificationForNavMsgFamily::setNavMsgFamily(const std::string& navMsgFamily)
    {
      m_values.AddMember("NavMsgFamily", parse_json<std::string>::format(navMsgFamily, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveMessageModificationForNavMsgFamily::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveMessageModificationForNavMsgFamily::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllMessageModificationsForNavMsgFamily
///
#include "gen/ClearAllMessageModificationsForNavMsgFamily.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllMessageModificationsForNavMsgFamily::CmdName = "ClearAllMessageModificationsForNavMsgFamily";
    const char* const ClearAllMessageModificationsForNavMsgFamily::Documentation = "Clear all message modification events for this navigation message family.";

    REGISTER_COMMAND_FACTORY(ClearAllMessageModificationsForNavMsgFamily);


    ClearAllMessageModificationsForNavMsgFamily::ClearAllMessageModificationsForNavMsgFamily()
      : CommandBase(CmdName)
    {}

    ClearAllMessageModificationsForNavMsgFamily::ClearAllMessageModificationsForNavMsgFamily(const std::string& navMsgFamily)
      : CommandBase(CmdName)
    {

      setNavMsgFamily(navMsgFamily);
    }


    ClearAllMessageModificationsForNavMsgFamilyPtr ClearAllMessageModificationsForNavMsgFamily::create(const std::string& navMsgFamily)
    {
      return std::make_shared<ClearAllMessageModificationsForNavMsgFamily>(navMsgFamily);
    }

    ClearAllMessageModificationsForNavMsgFamilyPtr ClearAllMessageModificationsForNavMsgFamily::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllMessageModificationsForNavMsgFamily>(ptr);
    }

    bool ClearAllMessageModificationsForNavMsgFamily::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["NavMsgFamily"])
        ;

    }

    std::string ClearAllMessageModificationsForNavMsgFamily::documentation() const { return Documentation; }


    int ClearAllMessageModificationsForNavMsgFamily::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ClearAllMessageModificationsForNavMsgFamily::navMsgFamily() const
    {
      return parse_json<std::string>::parse(m_values["NavMsgFamily"]);
    }

    void ClearAllMessageModificationsForNavMsgFamily::setNavMsgFamily(const std::string& navMsgFamily)
    {
      m_values.AddMember("NavMsgFamily", parse_json<std::string>::format(navMsgFamily, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMessageModificationIdsForNavMsgFamily
///
#include "gen/GetAllMessageModificationIdsForNavMsgFamily.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMessageModificationIdsForNavMsgFamily::CmdName = "GetAllMessageModificationIdsForNavMsgFamily";
    const char* const GetAllMessageModificationIdsForNavMsgFamily::Documentation = "Get all the message modification event's IDs for this navigation message family and SV ID.";

    REGISTER_COMMAND_FACTORY(GetAllMessageModificationIdsForNavMsgFamily);


    GetAllMessageModificationIdsForNavMsgFamily::GetAllMessageModificationIdsForNavMsgFamily()
      : CommandBase(CmdName)
    {}

    GetAllMessageModificationIdsForNavMsgFamily::GetAllMessageModificationIdsForNavMsgFamily(const std::string& navMsgFamily, int svId)
      : CommandBase(CmdName)
    {

      setNavMsgFamily(navMsgFamily);
      setSvId(svId);
    }


    GetAllMessageModificationIdsForNavMsgFamilyPtr GetAllMessageModificationIdsForNavMsgFamily::create(const std::string& navMsgFamily, int svId)
    {
      return std::make_shared<GetAllMessageModificationIdsForNavMsgFamily>(navMsgFamily, svId);
    }

    GetAllMessageModificationIdsForNavMsgFamilyPtr GetAllMessageModificationIdsForNavMsgFamily::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMessageModificationIdsForNavMsgFamily>(ptr);
    }

    bool GetAllMessageModificationIdsForNavMsgFamily::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["NavMsgFamily"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetAllMessageModificationIdsForNavMsgFamily::documentation() const { return Documentation; }


    int GetAllMessageModificationIdsForNavMsgFamily::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMessageModificationIdsForNavMsgFamily::navMsgFamily() const
    {
      return parse_json<std::string>::parse(m_values["NavMsgFamily"]);
    }

    void GetAllMessageModificationIdsForNavMsgFamily::setNavMsgFamily(const std::string& navMsgFamily)
    {
      m_values.AddMember("NavMsgFamily", parse_json<std::string>::format(navMsgFamily, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllMessageModificationIdsForNavMsgFamily::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllMessageModificationIdsForNavMsgFamily::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMessageModificationIdsForNavMsgFamilyResult
///
#include "gen/GetAllMessageModificationIdsForNavMsgFamilyResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMessageModificationIdsForNavMsgFamilyResult::CmdName = "GetAllMessageModificationIdsForNavMsgFamilyResult";
    const char* const GetAllMessageModificationIdsForNavMsgFamilyResult::Documentation = "Result of GetAllMessageModificationIdsForNavMsgFamily.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllMessageModificationIdsForNavMsgFamilyResult);


    GetAllMessageModificationIdsForNavMsgFamilyResult::GetAllMessageModificationIdsForNavMsgFamilyResult()
      : CommandResult(CmdName)
    {}

    GetAllMessageModificationIdsForNavMsgFamilyResult::GetAllMessageModificationIdsForNavMsgFamilyResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllMessageModificationIdsForNavMsgFamilyResultPtr GetAllMessageModificationIdsForNavMsgFamilyResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return std::make_shared<GetAllMessageModificationIdsForNavMsgFamilyResult>(relatedCommand, ids);
    }

    GetAllMessageModificationIdsForNavMsgFamilyResultPtr GetAllMessageModificationIdsForNavMsgFamilyResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMessageModificationIdsForNavMsgFamilyResult>(ptr);
    }

    bool GetAllMessageModificationIdsForNavMsgFamilyResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllMessageModificationIdsForNavMsgFamilyResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllMessageModificationIdsForNavMsgFamilyResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllMessageModificationIdsForNavMsgFamilyResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveMessageModificationForSignal
///
#include "gen/RemoveMessageModificationForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveMessageModificationForSignal::CmdName = "RemoveMessageModificationForSignal";
    const char* const RemoveMessageModificationForSignal::Documentation = "Removes the signal for the message modification.";

    REGISTER_COMMAND_FACTORY(RemoveMessageModificationForSignal);


    RemoveMessageModificationForSignal::RemoveMessageModificationForSignal()
      : CommandBase(CmdName)
    {}

    RemoveMessageModificationForSignal::RemoveMessageModificationForSignal(const std::string& signal, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setId(id);
    }


    RemoveMessageModificationForSignalPtr RemoveMessageModificationForSignal::create(const std::string& signal, const std::string& id)
    {
      return std::make_shared<RemoveMessageModificationForSignal>(signal, id);
    }

    RemoveMessageModificationForSignalPtr RemoveMessageModificationForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveMessageModificationForSignal>(ptr);
    }

    bool RemoveMessageModificationForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveMessageModificationForSignal::documentation() const { return Documentation; }


    int RemoveMessageModificationForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveMessageModificationForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void RemoveMessageModificationForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveMessageModificationForSignal::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveMessageModificationForSignal::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveMessageModification
///
#include "gen/RemoveMessageModification.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveMessageModification::CmdName = "RemoveMessageModification";
    const char* const RemoveMessageModification::Documentation = "Please note the command RemoveMessageModification is deprecated since 21.3. You may use RemoveMessageModificationForSignal.\n\nRemoves the signal for the message modification.";

    REGISTER_COMMAND_FACTORY(RemoveMessageModification);


    RemoveMessageModification::RemoveMessageModification()
      : CommandBase(CmdName)
    {}

    RemoveMessageModification::RemoveMessageModification(const std::string& signal, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setId(id);
    }


    RemoveMessageModificationPtr RemoveMessageModification::create(const std::string& signal, const std::string& id)
    {
      return std::make_shared<RemoveMessageModification>(signal, id);
    }

    RemoveMessageModificationPtr RemoveMessageModification::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveMessageModification>(ptr);
    }

    bool RemoveMessageModification::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveMessageModification::documentation() const { return Documentation; }


    int RemoveMessageModification::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveMessageModification::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void RemoveMessageModification::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveMessageModification::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveMessageModification::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllMessageModificationsForSignal
///
#include "gen/ClearAllMessageModificationsForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllMessageModificationsForSignal::CmdName = "ClearAllMessageModificationsForSignal";
    const char* const ClearAllMessageModificationsForSignal::Documentation = "Clear the signal for all message modifications.";

    REGISTER_COMMAND_FACTORY(ClearAllMessageModificationsForSignal);


    ClearAllMessageModificationsForSignal::ClearAllMessageModificationsForSignal()
      : CommandBase(CmdName)
    {}

    ClearAllMessageModificationsForSignal::ClearAllMessageModificationsForSignal(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    ClearAllMessageModificationsForSignalPtr ClearAllMessageModificationsForSignal::create(const std::string& signal)
    {
      return std::make_shared<ClearAllMessageModificationsForSignal>(signal);
    }

    ClearAllMessageModificationsForSignalPtr ClearAllMessageModificationsForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllMessageModificationsForSignal>(ptr);
    }

    bool ClearAllMessageModificationsForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string ClearAllMessageModificationsForSignal::documentation() const { return Documentation; }


    int ClearAllMessageModificationsForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ClearAllMessageModificationsForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void ClearAllMessageModificationsForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllMessageModifications
///
#include "gen/ClearAllMessageModifications.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllMessageModifications::CmdName = "ClearAllMessageModifications";
    const char* const ClearAllMessageModifications::Documentation = "Please note the command ClearAllMessageModifications is deprecated since 21.3. You may use ClearAllMessageModificationsForSignal.\n\nClear the signal for all message modifications.";

    REGISTER_COMMAND_FACTORY(ClearAllMessageModifications);


    ClearAllMessageModifications::ClearAllMessageModifications()
      : CommandBase(CmdName)
    {}

    ClearAllMessageModifications::ClearAllMessageModifications(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    ClearAllMessageModificationsPtr ClearAllMessageModifications::create(const std::string& signal)
    {
      return std::make_shared<ClearAllMessageModifications>(signal);
    }

    ClearAllMessageModificationsPtr ClearAllMessageModifications::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllMessageModifications>(ptr);
    }

    bool ClearAllMessageModifications::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string ClearAllMessageModifications::documentation() const { return Documentation; }


    int ClearAllMessageModifications::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ClearAllMessageModifications::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void ClearAllMessageModifications::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMessageModificationIdsForSignal
///
#include "gen/GetAllMessageModificationIdsForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMessageModificationIdsForSignal::CmdName = "GetAllMessageModificationIdsForSignal";
    const char* const GetAllMessageModificationIdsForSignal::Documentation = "Get all the message modification event's IDs for this signal and SV ID.";

    REGISTER_COMMAND_FACTORY(GetAllMessageModificationIdsForSignal);


    GetAllMessageModificationIdsForSignal::GetAllMessageModificationIdsForSignal()
      : CommandBase(CmdName)
    {}

    GetAllMessageModificationIdsForSignal::GetAllMessageModificationIdsForSignal(const std::string& signal, int svId)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
    }


    GetAllMessageModificationIdsForSignalPtr GetAllMessageModificationIdsForSignal::create(const std::string& signal, int svId)
    {
      return std::make_shared<GetAllMessageModificationIdsForSignal>(signal, svId);
    }

    GetAllMessageModificationIdsForSignalPtr GetAllMessageModificationIdsForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMessageModificationIdsForSignal>(ptr);
    }

    bool GetAllMessageModificationIdsForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetAllMessageModificationIdsForSignal::documentation() const { return Documentation; }


    int GetAllMessageModificationIdsForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMessageModificationIdsForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetAllMessageModificationIdsForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllMessageModificationIdsForSignal::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllMessageModificationIdsForSignal::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMessageModificationIdsForSignalResult
///
#include "gen/GetAllMessageModificationIdsForSignalResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMessageModificationIdsForSignalResult::CmdName = "GetAllMessageModificationIdsForSignalResult";
    const char* const GetAllMessageModificationIdsForSignalResult::Documentation = "Result of GetAllMessageModificationIdsForSignal.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllMessageModificationIdsForSignalResult);


    GetAllMessageModificationIdsForSignalResult::GetAllMessageModificationIdsForSignalResult()
      : CommandResult(CmdName)
    {}

    GetAllMessageModificationIdsForSignalResult::GetAllMessageModificationIdsForSignalResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllMessageModificationIdsForSignalResultPtr GetAllMessageModificationIdsForSignalResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return std::make_shared<GetAllMessageModificationIdsForSignalResult>(relatedCommand, ids);
    }

    GetAllMessageModificationIdsForSignalResultPtr GetAllMessageModificationIdsForSignalResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMessageModificationIdsForSignalResult>(ptr);
    }

    bool GetAllMessageModificationIdsForSignalResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllMessageModificationIdsForSignalResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllMessageModificationIdsForSignalResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllMessageModificationIdsForSignalResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetInterferenceCW
///
#include "gen/SetInterferenceCW.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetInterferenceCW::CmdName = "SetInterferenceCW";
    const char* const SetInterferenceCW::Documentation = "Add or update continuous wave interference.";

    REGISTER_COMMAND_FACTORY(SetInterferenceCW);


    SetInterferenceCW::SetInterferenceCW()
      : CommandBase(CmdName)
    {}

    SetInterferenceCW::SetInterferenceCW(int startTime, int stopTime, double centralFreq, double power, bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setStartTime(startTime);
      setStopTime(stopTime);
      setCentralFreq(centralFreq);
      setPower(power);
      setEnabled(enabled);
      setId(id);
    }


    SetInterferenceCWPtr SetInterferenceCW::create(int startTime, int stopTime, double centralFreq, double power, bool enabled, const std::string& id)
    {
      return std::make_shared<SetInterferenceCW>(startTime, stopTime, centralFreq, power, enabled, id);
    }

    SetInterferenceCWPtr SetInterferenceCW::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetInterferenceCW>(ptr);
    }

    bool SetInterferenceCW::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetInterferenceCW::documentation() const { return Documentation; }


    int SetInterferenceCW::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetInterferenceCW::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetInterferenceCW::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetInterferenceCW::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetInterferenceCW::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceCW::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetInterferenceCW::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceCW::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetInterferenceCW::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetInterferenceCW::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetInterferenceCW::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetInterferenceCW::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetInterferenceCW::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetInterferenceChirp
///
#include "gen/SetInterferenceChirp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetInterferenceChirp::CmdName = "SetInterferenceChirp";
    const char* const SetInterferenceChirp::Documentation = "Add or update chirp signal interference.";

    REGISTER_COMMAND_FACTORY(SetInterferenceChirp);


    SetInterferenceChirp::SetInterferenceChirp()
      : CommandBase(CmdName)
    {}

    SetInterferenceChirp::SetInterferenceChirp(int startTime, int stopTime, double centralFreq, double power, double bandwidth, double sweepTime, bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setStartTime(startTime);
      setStopTime(stopTime);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setSweepTime(sweepTime);
      setEnabled(enabled);
      setId(id);
    }


    SetInterferenceChirpPtr SetInterferenceChirp::create(int startTime, int stopTime, double centralFreq, double power, double bandwidth, double sweepTime, bool enabled, const std::string& id)
    {
      return std::make_shared<SetInterferenceChirp>(startTime, stopTime, centralFreq, power, bandwidth, sweepTime, enabled, id);
    }

    SetInterferenceChirpPtr SetInterferenceChirp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetInterferenceChirp>(ptr);
    }

    bool SetInterferenceChirp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<double>::is_valid(m_values["SweepTime"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetInterferenceChirp::documentation() const { return Documentation; }


    int SetInterferenceChirp::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetInterferenceChirp::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetInterferenceChirp::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetInterferenceChirp::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetInterferenceChirp::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceChirp::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetInterferenceChirp::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceChirp::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetInterferenceChirp::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceChirp::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void SetInterferenceChirp::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceChirp::sweepTime() const
    {
      return parse_json<double>::parse(m_values["SweepTime"]);
    }

    void SetInterferenceChirp::setSweepTime(double sweepTime)
    {
      m_values.AddMember("SweepTime", parse_json<double>::format(sweepTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetInterferenceChirp::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetInterferenceChirp::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetInterferenceChirp::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetInterferenceChirp::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveInterference
///
#include "gen/RemoveInterference.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveInterference::CmdName = "RemoveInterference";
    const char* const RemoveInterference::Documentation = "Removes an interference. When adding an event, the simulator\nsets the Id parameter. Use that Id here to remove the associated interference.";

    REGISTER_COMMAND_FACTORY(RemoveInterference);


    RemoveInterference::RemoveInterference()
      : CommandBase(CmdName)
    {}

    RemoveInterference::RemoveInterference(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveInterferencePtr RemoveInterference::create(const std::string& id)
    {
      return std::make_shared<RemoveInterference>(id);
    }

    RemoveInterferencePtr RemoveInterference::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveInterference>(ptr);
    }

    bool RemoveInterference::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveInterference::documentation() const { return Documentation; }


    int RemoveInterference::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveInterference::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveInterference::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllInterferences
///
#include "gen/RemoveAllInterferences.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllInterferences::CmdName = "RemoveAllInterferences";
    const char* const RemoveAllInterferences::Documentation = "Clear all interferences";

    REGISTER_COMMAND_FACTORY(RemoveAllInterferences);


    RemoveAllInterferences::RemoveAllInterferences()
      : CommandBase(CmdName)
    {

    }


    RemoveAllInterferencesPtr RemoveAllInterferences::create()
    {
      return std::make_shared<RemoveAllInterferences>();
    }

    RemoveAllInterferencesPtr RemoveAllInterferences::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllInterferences>(ptr);
    }

    bool RemoveAllInterferences::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllInterferences::documentation() const { return Documentation; }


    int RemoveAllInterferences::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of SetPseudorangeRampForSV
///
#include "gen/SetPseudorangeRampForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeRampForSV::CmdName = "SetPseudorangeRampForSV";
    const char* const SetPseudorangeRampForSV::Documentation = "Set PSR ramp event. This function lets user change the pseudorange of any satellite.\nIf SV ID is set to 0, the change is applied to all satellites.\n\n          Hold Start Time\n          |         Hold Stop Time\n          |         |\n          ...........\n         ..         ...\n        ..            ...\n  .......               .........> Time\n        |               |\n        Start Time      Stop Time\n";

    REGISTER_COMMAND_FACTORY(SetPseudorangeRampForSV);


    SetPseudorangeRampForSV::SetPseudorangeRampForSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeRampForSV::SetPseudorangeRampForSV(const std::string& system, int svId, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setOffset(offset);
      setStartTime(startTime);
      setHoldStartTime(holdStartTime);
      setHoldStopTime(holdStopTime);
      setStopTime(stopTime);
      setId(id);
    }


    SetPseudorangeRampForSVPtr SetPseudorangeRampForSV::create(const std::string& system, int svId, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
    {
      return std::make_shared<SetPseudorangeRampForSV>(system, svId, offset, startTime, holdStartTime, holdStopTime, stopTime, id);
    }

    SetPseudorangeRampForSVPtr SetPseudorangeRampForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeRampForSV>(ptr);
    }

    bool SetPseudorangeRampForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["HoldStartTime"])
          && parse_json<int>::is_valid(m_values["HoldStopTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetPseudorangeRampForSV::documentation() const { return Documentation; }


    int SetPseudorangeRampForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeRampForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeRampForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPseudorangeRampForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeRampForSV::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPseudorangeRampForSV::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetPseudorangeRampForSV::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::holdStartTime() const
    {
      return parse_json<int>::parse(m_values["HoldStartTime"]);
    }

    void SetPseudorangeRampForSV::setHoldStartTime(int holdStartTime)
    {
      m_values.AddMember("HoldStartTime", parse_json<int>::format(holdStartTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::holdStopTime() const
    {
      return parse_json<int>::parse(m_values["HoldStopTime"]);
    }

    void SetPseudorangeRampForSV::setHoldStopTime(int holdStopTime)
    {
      m_values.AddMember("HoldStopTime", parse_json<int>::format(holdStopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetPseudorangeRampForSV::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetPseudorangeRampForSV::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetPseudorangeRampForSV::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeRampForSV
///
#include "gen/GetPseudorangeRampForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeRampForSV::CmdName = "GetPseudorangeRampForSV";
    const char* const GetPseudorangeRampForSV::Documentation = "Get PSR ramp event. This function lets user change the pseudorange of any satellite.\nIf SV ID is set to 0, the change is applied to all satellites.\n\n          Hold Start Time\n          |         Hold Stop Time\n          |         |\n          ...........\n         ..         ...\n        ..            ...\n  .......               .........> Time\n        |               |\n        Start Time      Stop Time\n";

    REGISTER_COMMAND_FACTORY(GetPseudorangeRampForSV);


    GetPseudorangeRampForSV::GetPseudorangeRampForSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeRampForSV::GetPseudorangeRampForSV(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetPseudorangeRampForSVPtr GetPseudorangeRampForSV::create(const std::string& id)
    {
      return std::make_shared<GetPseudorangeRampForSV>(id);
    }

    GetPseudorangeRampForSVPtr GetPseudorangeRampForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeRampForSV>(ptr);
    }

    bool GetPseudorangeRampForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetPseudorangeRampForSV::documentation() const { return Documentation; }


    int GetPseudorangeRampForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeRampForSV::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetPseudorangeRampForSV::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeRampForSVResult
///
#include "gen/GetPseudorangeRampForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeRampForSVResult::CmdName = "GetPseudorangeRampForSVResult";
    const char* const GetPseudorangeRampForSVResult::Documentation = "Result of GetPseudorangeRampForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeRampForSVResult);


    GetPseudorangeRampForSVResult::GetPseudorangeRampForSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeRampForSVResult::GetPseudorangeRampForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setOffset(offset);
      setStartTime(startTime);
      setHoldStartTime(holdStartTime);
      setHoldStopTime(holdStopTime);
      setStopTime(stopTime);
      setId(id);
    }


    GetPseudorangeRampForSVResultPtr GetPseudorangeRampForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
    {
      return std::make_shared<GetPseudorangeRampForSVResult>(relatedCommand, system, svId, offset, startTime, holdStartTime, holdStopTime, stopTime, id);
    }

    GetPseudorangeRampForSVResultPtr GetPseudorangeRampForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeRampForSVResult>(ptr);
    }

    bool GetPseudorangeRampForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["HoldStartTime"])
          && parse_json<int>::is_valid(m_values["HoldStopTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetPseudorangeRampForSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeRampForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeRampForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeRampForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeRampForSVResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPseudorangeRampForSVResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetPseudorangeRampForSVResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::holdStartTime() const
    {
      return parse_json<int>::parse(m_values["HoldStartTime"]);
    }

    void GetPseudorangeRampForSVResult::setHoldStartTime(int holdStartTime)
    {
      m_values.AddMember("HoldStartTime", parse_json<int>::format(holdStartTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::holdStopTime() const
    {
      return parse_json<int>::parse(m_values["HoldStopTime"]);
    }

    void GetPseudorangeRampForSVResult::setHoldStopTime(int holdStopTime)
    {
      m_values.AddMember("HoldStopTime", parse_json<int>::format(holdStopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetPseudorangeRampForSVResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetPseudorangeRampForSVResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetPseudorangeRampForSVResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllPseudorangeRampForSV
///
#include "gen/GetAllPseudorangeRampForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllPseudorangeRampForSV::CmdName = "GetAllPseudorangeRampForSV";
    const char* const GetAllPseudorangeRampForSV::Documentation = "Get a list of all the pseudorange ramps IDs for a system's satellite.";

    REGISTER_COMMAND_FACTORY(GetAllPseudorangeRampForSV);


    GetAllPseudorangeRampForSV::GetAllPseudorangeRampForSV()
      : CommandBase(CmdName)
    {}

    GetAllPseudorangeRampForSV::GetAllPseudorangeRampForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetAllPseudorangeRampForSVPtr GetAllPseudorangeRampForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<GetAllPseudorangeRampForSV>(system, svId);
    }

    GetAllPseudorangeRampForSVPtr GetAllPseudorangeRampForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllPseudorangeRampForSV>(ptr);
    }

    bool GetAllPseudorangeRampForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetAllPseudorangeRampForSV::documentation() const { return Documentation; }


    int GetAllPseudorangeRampForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllPseudorangeRampForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllPseudorangeRampForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllPseudorangeRampForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllPseudorangeRampForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllPseudorangeRampForSVResult
///
#include "gen/GetAllPseudorangeRampForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllPseudorangeRampForSVResult::CmdName = "GetAllPseudorangeRampForSVResult";
    const char* const GetAllPseudorangeRampForSVResult::Documentation = "Result of GetAllPseudorangeRampForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllPseudorangeRampForSVResult);


    GetAllPseudorangeRampForSVResult::GetAllPseudorangeRampForSVResult()
      : CommandResult(CmdName)
    {}

    GetAllPseudorangeRampForSVResult::GetAllPseudorangeRampForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setIds(ids);
    }


    GetAllPseudorangeRampForSVResultPtr GetAllPseudorangeRampForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::vector<std::string>& ids)
    {
      return std::make_shared<GetAllPseudorangeRampForSVResult>(relatedCommand, system, svId, ids);
    }

    GetAllPseudorangeRampForSVResultPtr GetAllPseudorangeRampForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllPseudorangeRampForSVResult>(ptr);
    }

    bool GetAllPseudorangeRampForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllPseudorangeRampForSVResult::documentation() const { return Documentation; }


    std::string GetAllPseudorangeRampForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllPseudorangeRampForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllPseudorangeRampForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllPseudorangeRampForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetAllPseudorangeRampForSVResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllPseudorangeRampForSVResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemovePseudorangeRamp
///
#include "gen/RemovePseudorangeRamp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemovePseudorangeRamp::CmdName = "RemovePseudorangeRamp";
    const char* const RemovePseudorangeRamp::Documentation = "Removes a PSR ramp events. When adding an event, the simulator\nsets the Id parameter. Use that Id here to remove the associated ramp.";

    REGISTER_COMMAND_FACTORY(RemovePseudorangeRamp);


    RemovePseudorangeRamp::RemovePseudorangeRamp()
      : CommandBase(CmdName)
    {}

    RemovePseudorangeRamp::RemovePseudorangeRamp(const std::string& system, const std::string& id)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setId(id);
    }


    RemovePseudorangeRampPtr RemovePseudorangeRamp::create(const std::string& system, const std::string& id)
    {
      return std::make_shared<RemovePseudorangeRamp>(system, id);
    }

    RemovePseudorangeRampPtr RemovePseudorangeRamp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemovePseudorangeRamp>(ptr);
    }

    bool RemovePseudorangeRamp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemovePseudorangeRamp::documentation() const { return Documentation; }


    int RemovePseudorangeRamp::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemovePseudorangeRamp::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemovePseudorangeRamp::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemovePseudorangeRamp::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemovePseudorangeRamp::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllPseudorangeRampForSV
///
#include "gen/RemoveAllPseudorangeRampForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllPseudorangeRampForSV::CmdName = "RemoveAllPseudorangeRampForSV";
    const char* const RemoveAllPseudorangeRampForSV::Documentation = "Remove all PSR Ramps for the specified system's satellite.";

    REGISTER_COMMAND_FACTORY(RemoveAllPseudorangeRampForSV);


    RemoveAllPseudorangeRampForSV::RemoveAllPseudorangeRampForSV()
      : CommandBase(CmdName)
    {}

    RemoveAllPseudorangeRampForSV::RemoveAllPseudorangeRampForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    RemoveAllPseudorangeRampForSVPtr RemoveAllPseudorangeRampForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<RemoveAllPseudorangeRampForSV>(system, svId);
    }

    RemoveAllPseudorangeRampForSVPtr RemoveAllPseudorangeRampForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllPseudorangeRampForSV>(ptr);
    }

    bool RemoveAllPseudorangeRampForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string RemoveAllPseudorangeRampForSV::documentation() const { return Documentation; }


    int RemoveAllPseudorangeRampForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllPseudorangeRampForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllPseudorangeRampForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int RemoveAllPseudorangeRampForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void RemoveAllPseudorangeRampForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllPseudorangeRampForSystem
///
#include "gen/RemoveAllPseudorangeRampForSystem.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllPseudorangeRampForSystem::CmdName = "RemoveAllPseudorangeRampForSystem";
    const char* const RemoveAllPseudorangeRampForSystem::Documentation = "Remove all PSR Ramps for all satellites of the specified system.";

    REGISTER_COMMAND_FACTORY(RemoveAllPseudorangeRampForSystem);


    RemoveAllPseudorangeRampForSystem::RemoveAllPseudorangeRampForSystem()
      : CommandBase(CmdName)
    {}

    RemoveAllPseudorangeRampForSystem::RemoveAllPseudorangeRampForSystem(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    RemoveAllPseudorangeRampForSystemPtr RemoveAllPseudorangeRampForSystem::create(const std::string& system)
    {
      return std::make_shared<RemoveAllPseudorangeRampForSystem>(system);
    }

    RemoveAllPseudorangeRampForSystemPtr RemoveAllPseudorangeRampForSystem::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllPseudorangeRampForSystem>(ptr);
    }

    bool RemoveAllPseudorangeRampForSystem::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RemoveAllPseudorangeRampForSystem::documentation() const { return Documentation; }


    int RemoveAllPseudorangeRampForSystem::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllPseudorangeRampForSystem::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllPseudorangeRampForSystem::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllPseudorangeRamp
///
#include "gen/RemoveAllPseudorangeRamp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllPseudorangeRamp::CmdName = "RemoveAllPseudorangeRamp";
    const char* const RemoveAllPseudorangeRamp::Documentation = "Please note the command RemoveAllPseudorangeRamp is deprecated since 21.3. You may use RemoveAllPseudorangeRampForSystem.\n\nRemove all PSR Ramps for all satellites of the specified system.";

    REGISTER_COMMAND_FACTORY(RemoveAllPseudorangeRamp);


    RemoveAllPseudorangeRamp::RemoveAllPseudorangeRamp()
      : CommandBase(CmdName)
    {}

    RemoveAllPseudorangeRamp::RemoveAllPseudorangeRamp(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    RemoveAllPseudorangeRampPtr RemoveAllPseudorangeRamp::create(const std::string& system)
    {
      return std::make_shared<RemoveAllPseudorangeRamp>(system);
    }

    RemoveAllPseudorangeRampPtr RemoveAllPseudorangeRamp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllPseudorangeRamp>(ptr);
    }

    bool RemoveAllPseudorangeRamp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RemoveAllPseudorangeRamp::documentation() const { return Documentation; }


    int RemoveAllPseudorangeRamp::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllPseudorangeRamp::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllPseudorangeRamp::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAlmanacInitialUploadTimeOffset
///
#include "gen/SetAlmanacInitialUploadTimeOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAlmanacInitialUploadTimeOffset::CmdName = "SetAlmanacInitialUploadTimeOffset";
    const char* const SetAlmanacInitialUploadTimeOffset::Documentation = "Set next almanac upload time relative to simulation start time.";

    REGISTER_COMMAND_FACTORY(SetAlmanacInitialUploadTimeOffset);


    SetAlmanacInitialUploadTimeOffset::SetAlmanacInitialUploadTimeOffset()
      : CommandBase(CmdName)
    {}

    SetAlmanacInitialUploadTimeOffset::SetAlmanacInitialUploadTimeOffset(const std::string& system, int offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setOffset(offset);
    }


    SetAlmanacInitialUploadTimeOffsetPtr SetAlmanacInitialUploadTimeOffset::create(const std::string& system, int offset)
    {
      return std::make_shared<SetAlmanacInitialUploadTimeOffset>(system, offset);
    }

    SetAlmanacInitialUploadTimeOffsetPtr SetAlmanacInitialUploadTimeOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAlmanacInitialUploadTimeOffset>(ptr);
    }

    bool SetAlmanacInitialUploadTimeOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetAlmanacInitialUploadTimeOffset::documentation() const { return Documentation; }


    int SetAlmanacInitialUploadTimeOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAlmanacInitialUploadTimeOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAlmanacInitialUploadTimeOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAlmanacInitialUploadTimeOffset::offset() const
    {
      return parse_json<int>::parse(m_values["Offset"]);
    }

    void SetAlmanacInitialUploadTimeOffset::setOffset(int offset)
    {
      m_values.AddMember("Offset", parse_json<int>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAlmanacInitialUploadTimeOffset
///
#include "gen/GetAlmanacInitialUploadTimeOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAlmanacInitialUploadTimeOffset::CmdName = "GetAlmanacInitialUploadTimeOffset";
    const char* const GetAlmanacInitialUploadTimeOffset::Documentation = "Get next almanac upload time relative to simulation start time.";

    REGISTER_COMMAND_FACTORY(GetAlmanacInitialUploadTimeOffset);


    GetAlmanacInitialUploadTimeOffset::GetAlmanacInitialUploadTimeOffset()
      : CommandBase(CmdName)
    {

    }


    GetAlmanacInitialUploadTimeOffsetPtr GetAlmanacInitialUploadTimeOffset::create()
    {
      return std::make_shared<GetAlmanacInitialUploadTimeOffset>();
    }

    GetAlmanacInitialUploadTimeOffsetPtr GetAlmanacInitialUploadTimeOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAlmanacInitialUploadTimeOffset>(ptr);
    }

    bool GetAlmanacInitialUploadTimeOffset::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAlmanacInitialUploadTimeOffset::documentation() const { return Documentation; }


    int GetAlmanacInitialUploadTimeOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAlmanacInitialUploadTimeOffsetResult
///
#include "gen/GetAlmanacInitialUploadTimeOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAlmanacInitialUploadTimeOffsetResult::CmdName = "GetAlmanacInitialUploadTimeOffsetResult";
    const char* const GetAlmanacInitialUploadTimeOffsetResult::Documentation = "Result of GetAlmanacInitialUploadTimeOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAlmanacInitialUploadTimeOffsetResult);


    GetAlmanacInitialUploadTimeOffsetResult::GetAlmanacInitialUploadTimeOffsetResult()
      : CommandResult(CmdName)
    {}

    GetAlmanacInitialUploadTimeOffsetResult::GetAlmanacInitialUploadTimeOffsetResult(CommandBasePtr relatedCommand, const std::string& system, int offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setOffset(offset);
    }


    GetAlmanacInitialUploadTimeOffsetResultPtr GetAlmanacInitialUploadTimeOffsetResult::create(CommandBasePtr relatedCommand, const std::string& system, int offset)
    {
      return std::make_shared<GetAlmanacInitialUploadTimeOffsetResult>(relatedCommand, system, offset);
    }

    GetAlmanacInitialUploadTimeOffsetResultPtr GetAlmanacInitialUploadTimeOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAlmanacInitialUploadTimeOffsetResult>(ptr);
    }

    bool GetAlmanacInitialUploadTimeOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetAlmanacInitialUploadTimeOffsetResult::documentation() const { return Documentation; }


    std::string GetAlmanacInitialUploadTimeOffsetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAlmanacInitialUploadTimeOffsetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAlmanacInitialUploadTimeOffsetResult::offset() const
    {
      return parse_json<int>::parse(m_values["Offset"]);
    }

    void GetAlmanacInitialUploadTimeOffsetResult::setOffset(int offset)
    {
      m_values.AddMember("Offset", parse_json<int>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAlmanacUploadTimeInterval
///
#include "gen/SetAlmanacUploadTimeInterval.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAlmanacUploadTimeInterval::CmdName = "SetAlmanacUploadTimeInterval";
    const char* const SetAlmanacUploadTimeInterval::Documentation = "Set almanac upload interval in seconds. After the initial upload set with command \nSetAlmanacInitialUploadTimeOffset, the almanac will automatically update at each interval.";

    REGISTER_COMMAND_FACTORY(SetAlmanacUploadTimeInterval);


    SetAlmanacUploadTimeInterval::SetAlmanacUploadTimeInterval()
      : CommandBase(CmdName)
    {}

    SetAlmanacUploadTimeInterval::SetAlmanacUploadTimeInterval(const std::string& system, int interval)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setInterval(interval);
    }


    SetAlmanacUploadTimeIntervalPtr SetAlmanacUploadTimeInterval::create(const std::string& system, int interval)
    {
      return std::make_shared<SetAlmanacUploadTimeInterval>(system, interval);
    }

    SetAlmanacUploadTimeIntervalPtr SetAlmanacUploadTimeInterval::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAlmanacUploadTimeInterval>(ptr);
    }

    bool SetAlmanacUploadTimeInterval::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Interval"])
        ;

    }

    std::string SetAlmanacUploadTimeInterval::documentation() const { return Documentation; }


    int SetAlmanacUploadTimeInterval::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAlmanacUploadTimeInterval::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAlmanacUploadTimeInterval::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAlmanacUploadTimeInterval::interval() const
    {
      return parse_json<int>::parse(m_values["Interval"]);
    }

    void SetAlmanacUploadTimeInterval::setInterval(int interval)
    {
      m_values.AddMember("Interval", parse_json<int>::format(interval, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAlmanacUploadTimeInterval
///
#include "gen/GetAlmanacUploadTimeInterval.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAlmanacUploadTimeInterval::CmdName = "GetAlmanacUploadTimeInterval";
    const char* const GetAlmanacUploadTimeInterval::Documentation = "Get almanac upload interval in seconds. After the initial upload set with command \nSetAlmanacInitialUploadTimeOffset, the almanac will automatically update at each interval.";

    REGISTER_COMMAND_FACTORY(GetAlmanacUploadTimeInterval);


    GetAlmanacUploadTimeInterval::GetAlmanacUploadTimeInterval()
      : CommandBase(CmdName)
    {

    }


    GetAlmanacUploadTimeIntervalPtr GetAlmanacUploadTimeInterval::create()
    {
      return std::make_shared<GetAlmanacUploadTimeInterval>();
    }

    GetAlmanacUploadTimeIntervalPtr GetAlmanacUploadTimeInterval::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAlmanacUploadTimeInterval>(ptr);
    }

    bool GetAlmanacUploadTimeInterval::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAlmanacUploadTimeInterval::documentation() const { return Documentation; }


    int GetAlmanacUploadTimeInterval::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAlmanacUploadTimeIntervalResult
///
#include "gen/GetAlmanacUploadTimeIntervalResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAlmanacUploadTimeIntervalResult::CmdName = "GetAlmanacUploadTimeIntervalResult";
    const char* const GetAlmanacUploadTimeIntervalResult::Documentation = "Result of GetAlmanacUploadTimeInterval.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAlmanacUploadTimeIntervalResult);


    GetAlmanacUploadTimeIntervalResult::GetAlmanacUploadTimeIntervalResult()
      : CommandResult(CmdName)
    {}

    GetAlmanacUploadTimeIntervalResult::GetAlmanacUploadTimeIntervalResult(CommandBasePtr relatedCommand, const std::string& system, int interval)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setInterval(interval);
    }


    GetAlmanacUploadTimeIntervalResultPtr GetAlmanacUploadTimeIntervalResult::create(CommandBasePtr relatedCommand, const std::string& system, int interval)
    {
      return std::make_shared<GetAlmanacUploadTimeIntervalResult>(relatedCommand, system, interval);
    }

    GetAlmanacUploadTimeIntervalResultPtr GetAlmanacUploadTimeIntervalResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAlmanacUploadTimeIntervalResult>(ptr);
    }

    bool GetAlmanacUploadTimeIntervalResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Interval"])
        ;

    }

    std::string GetAlmanacUploadTimeIntervalResult::documentation() const { return Documentation; }


    std::string GetAlmanacUploadTimeIntervalResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAlmanacUploadTimeIntervalResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAlmanacUploadTimeIntervalResult::interval() const
    {
      return parse_json<int>::parse(m_values["Interval"]);
    }

    void GetAlmanacUploadTimeIntervalResult::setInterval(int interval)
    {
      m_values.AddMember("Interval", parse_json<int>::format(interval, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMultipathForSV
///
#include "gen/SetMultipathForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMultipathForSV::CmdName = "SetMultipathForSV";
    const char* const SetMultipathForSV::Documentation = "Add or update signal echo (multipath). Offsets (power loss, pseudorange, Doppler and carrier phase) are all relative to line-of-sight signal.\nIf Id is not set, or unknown to Skydel, a new echo will be added. Otherwise, existing echo will be updated.";

    REGISTER_COMMAND_FACTORY(SetMultipathForSV);


    SetMultipathForSV::SetMultipathForSV()
      : CommandBase(CmdName)
    {}

    SetMultipathForSV::SetMultipathForSV(const std::string& signal, int svId, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
      setPowerLoss(powerLoss);
      setPseudorange(pseudorange);
      setDoppler(doppler);
      setCarrierPhase(carrierPhase);
      setEcho(echo);
      setId(id);
    }


    SetMultipathForSVPtr SetMultipathForSV::create(const std::string& signal, int svId, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo, const std::string& id)
    {
      return std::make_shared<SetMultipathForSV>(signal, svId, powerLoss, pseudorange, doppler, carrierPhase, echo, id);
    }

    SetMultipathForSVPtr SetMultipathForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMultipathForSV>(ptr);
    }

    bool SetMultipathForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["PowerLoss"])
          && parse_json<double>::is_valid(m_values["Pseudorange"])
          && parse_json<double>::is_valid(m_values["Doppler"])
          && parse_json<double>::is_valid(m_values["CarrierPhase"])
          && parse_json<int>::is_valid(m_values["Echo"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMultipathForSV::documentation() const { return Documentation; }


    int SetMultipathForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetMultipathForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetMultipathForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMultipathForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMultipathForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipathForSV::powerLoss() const
    {
      return parse_json<double>::parse(m_values["PowerLoss"]);
    }

    void SetMultipathForSV::setPowerLoss(double powerLoss)
    {
      m_values.AddMember("PowerLoss", parse_json<double>::format(powerLoss, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipathForSV::pseudorange() const
    {
      return parse_json<double>::parse(m_values["Pseudorange"]);
    }

    void SetMultipathForSV::setPseudorange(double pseudorange)
    {
      m_values.AddMember("Pseudorange", parse_json<double>::format(pseudorange, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipathForSV::doppler() const
    {
      return parse_json<double>::parse(m_values["Doppler"]);
    }

    void SetMultipathForSV::setDoppler(double doppler)
    {
      m_values.AddMember("Doppler", parse_json<double>::format(doppler, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipathForSV::carrierPhase() const
    {
      return parse_json<double>::parse(m_values["CarrierPhase"]);
    }

    void SetMultipathForSV::setCarrierPhase(double carrierPhase)
    {
      m_values.AddMember("CarrierPhase", parse_json<double>::format(carrierPhase, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMultipathForSV::echo() const
    {
      return parse_json<int>::parse(m_values["Echo"]);
    }

    void SetMultipathForSV::setEcho(int echo)
    {
      m_values.AddMember("Echo", parse_json<int>::format(echo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMultipathForSV::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMultipathForSV::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableMultipath
///
#include "gen/EnableMultipath.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableMultipath::CmdName = "EnableMultipath";
    const char* const EnableMultipath::Documentation = "Enable/Disable a multipath signal.";

    REGISTER_COMMAND_FACTORY(EnableMultipath);


    EnableMultipath::EnableMultipath()
      : CommandBase(CmdName)
    {}

    EnableMultipath::EnableMultipath(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    EnableMultipathPtr EnableMultipath::create(bool enabled, const std::string& id)
    {
      return std::make_shared<EnableMultipath>(enabled, id);
    }

    EnableMultipathPtr EnableMultipath::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableMultipath>(ptr);
    }

    bool EnableMultipath::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EnableMultipath::documentation() const { return Documentation; }


    int EnableMultipath::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool EnableMultipath::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableMultipath::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableMultipath::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EnableMultipath::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveMultipath
///
#include "gen/RemoveMultipath.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveMultipath::CmdName = "RemoveMultipath";
    const char* const RemoveMultipath::Documentation = "Removes a multipath signal.";

    REGISTER_COMMAND_FACTORY(RemoveMultipath);


    RemoveMultipath::RemoveMultipath()
      : CommandBase(CmdName)
    {}

    RemoveMultipath::RemoveMultipath(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveMultipathPtr RemoveMultipath::create(const std::string& id)
    {
      return std::make_shared<RemoveMultipath>(id);
    }

    RemoveMultipathPtr RemoveMultipath::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveMultipath>(ptr);
    }

    bool RemoveMultipath::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveMultipath::documentation() const { return Documentation; }


    int RemoveMultipath::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RemoveMultipath::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveMultipath::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllMultipathForSignal
///
#include "gen/RemoveAllMultipathForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllMultipathForSignal::CmdName = "RemoveAllMultipathForSignal";
    const char* const RemoveAllMultipathForSignal::Documentation = "Disable all multipath in all satellites but only for the specified signal.";

    REGISTER_COMMAND_FACTORY(RemoveAllMultipathForSignal);


    RemoveAllMultipathForSignal::RemoveAllMultipathForSignal()
      : CommandBase(CmdName)
    {}

    RemoveAllMultipathForSignal::RemoveAllMultipathForSignal(const std::string& signal, bool reset)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setReset(reset);
    }


    RemoveAllMultipathForSignalPtr RemoveAllMultipathForSignal::create(const std::string& signal, bool reset)
    {
      return std::make_shared<RemoveAllMultipathForSignal>(signal, reset);
    }

    RemoveAllMultipathForSignalPtr RemoveAllMultipathForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllMultipathForSignal>(ptr);
    }

    bool RemoveAllMultipathForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<bool>::is_valid(m_values["Reset"])
        ;

    }

    std::string RemoveAllMultipathForSignal::documentation() const { return Documentation; }


    int RemoveAllMultipathForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllMultipathForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void RemoveAllMultipathForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool RemoveAllMultipathForSignal::reset() const
    {
      return parse_json<bool>::parse(m_values["Reset"]);
    }

    void RemoveAllMultipathForSignal::setReset(bool reset)
    {
      m_values.AddMember("Reset", parse_json<bool>::format(reset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllMultipathForSV
///
#include "gen/RemoveAllMultipathForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllMultipathForSV::CmdName = "RemoveAllMultipathForSV";
    const char* const RemoveAllMultipathForSV::Documentation = "Disable all multipath for the specified satellite.";

    REGISTER_COMMAND_FACTORY(RemoveAllMultipathForSV);


    RemoveAllMultipathForSV::RemoveAllMultipathForSV()
      : CommandBase(CmdName)
    {}

    RemoveAllMultipathForSV::RemoveAllMultipathForSV(const std::string& system, int svId, bool reset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setReset(reset);
    }


    RemoveAllMultipathForSVPtr RemoveAllMultipathForSV::create(const std::string& system, int svId, bool reset)
    {
      return std::make_shared<RemoveAllMultipathForSV>(system, svId, reset);
    }

    RemoveAllMultipathForSVPtr RemoveAllMultipathForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllMultipathForSV>(ptr);
    }

    bool RemoveAllMultipathForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Reset"])
        ;

    }

    std::string RemoveAllMultipathForSV::documentation() const { return Documentation; }


    int RemoveAllMultipathForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllMultipathForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllMultipathForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int RemoveAllMultipathForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void RemoveAllMultipathForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool RemoveAllMultipathForSV::reset() const
    {
      return parse_json<bool>::parse(m_values["Reset"]);
    }

    void RemoveAllMultipathForSV::setReset(bool reset)
    {
      m_values.AddMember("Reset", parse_json<bool>::format(reset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllMultipathForSystem
///
#include "gen/RemoveAllMultipathForSystem.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllMultipathForSystem::CmdName = "RemoveAllMultipathForSystem";
    const char* const RemoveAllMultipathForSystem::Documentation = "Disable all multipath for the specified constellation.";

    REGISTER_COMMAND_FACTORY(RemoveAllMultipathForSystem);


    RemoveAllMultipathForSystem::RemoveAllMultipathForSystem()
      : CommandBase(CmdName)
    {}

    RemoveAllMultipathForSystem::RemoveAllMultipathForSystem(const std::string& system, bool reset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setReset(reset);
    }


    RemoveAllMultipathForSystemPtr RemoveAllMultipathForSystem::create(const std::string& system, bool reset)
    {
      return std::make_shared<RemoveAllMultipathForSystem>(system, reset);
    }

    RemoveAllMultipathForSystemPtr RemoveAllMultipathForSystem::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllMultipathForSystem>(ptr);
    }

    bool RemoveAllMultipathForSystem::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["Reset"])
        ;

    }

    std::string RemoveAllMultipathForSystem::documentation() const { return Documentation; }


    int RemoveAllMultipathForSystem::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllMultipathForSystem::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllMultipathForSystem::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool RemoveAllMultipathForSystem::reset() const
    {
      return parse_json<bool>::parse(m_values["Reset"]);
    }

    void RemoveAllMultipathForSystem::setReset(bool reset)
    {
      m_values.AddMember("Reset", parse_json<bool>::format(reset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMultipathForID
///
#include "gen/GetMultipathForID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMultipathForID::CmdName = "GetMultipathForID";
    const char* const GetMultipathForID::Documentation = "Get multipath infos for the specified multipath ID.";

    REGISTER_COMMAND_FACTORY(GetMultipathForID);


    GetMultipathForID::GetMultipathForID()
      : CommandBase(CmdName)
    {}

    GetMultipathForID::GetMultipathForID(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMultipathForIDPtr GetMultipathForID::create(const std::string& id)
    {
      return std::make_shared<GetMultipathForID>(id);
    }

    GetMultipathForIDPtr GetMultipathForID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMultipathForID>(ptr);
    }

    bool GetMultipathForID::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMultipathForID::documentation() const { return Documentation; }


    int GetMultipathForID::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMultipathForID::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMultipathForID::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMultipathForIDResult
///
#include "gen/GetMultipathForIDResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMultipathForIDResult::CmdName = "GetMultipathForIDResult";
    const char* const GetMultipathForIDResult::Documentation = "Result of GetMultipathForID.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMultipathForIDResult);


    GetMultipathForIDResult::GetMultipathForIDResult()
      : CommandResult(CmdName)
    {}

    GetMultipathForIDResult::GetMultipathForIDResult(CommandBasePtr relatedCommand, const std::string& id, const std::string& system, const std::string& signal, int svId, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo)
      : CommandResult(CmdName, relatedCommand)
    {

      setId(id);
      setSystem(system);
      setSignal(signal);
      setSvId(svId);
      setPowerLoss(powerLoss);
      setPseudorange(pseudorange);
      setDoppler(doppler);
      setCarrierPhase(carrierPhase);
      setEcho(echo);
    }


    GetMultipathForIDResultPtr GetMultipathForIDResult::create(CommandBasePtr relatedCommand, const std::string& id, const std::string& system, const std::string& signal, int svId, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo)
    {
      return std::make_shared<GetMultipathForIDResult>(relatedCommand, id, system, signal, svId, powerLoss, pseudorange, doppler, carrierPhase, echo);
    }

    GetMultipathForIDResultPtr GetMultipathForIDResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMultipathForIDResult>(ptr);
    }

    bool GetMultipathForIDResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["PowerLoss"])
          && parse_json<double>::is_valid(m_values["Pseudorange"])
          && parse_json<double>::is_valid(m_values["Doppler"])
          && parse_json<double>::is_valid(m_values["CarrierPhase"])
          && parse_json<int>::is_valid(m_values["Echo"])
        ;

    }

    std::string GetMultipathForIDResult::documentation() const { return Documentation; }


    std::string GetMultipathForIDResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMultipathForIDResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMultipathForIDResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetMultipathForIDResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMultipathForIDResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetMultipathForIDResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMultipathForIDResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMultipathForIDResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathForIDResult::powerLoss() const
    {
      return parse_json<double>::parse(m_values["PowerLoss"]);
    }

    void GetMultipathForIDResult::setPowerLoss(double powerLoss)
    {
      m_values.AddMember("PowerLoss", parse_json<double>::format(powerLoss, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathForIDResult::pseudorange() const
    {
      return parse_json<double>::parse(m_values["Pseudorange"]);
    }

    void GetMultipathForIDResult::setPseudorange(double pseudorange)
    {
      m_values.AddMember("Pseudorange", parse_json<double>::format(pseudorange, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathForIDResult::doppler() const
    {
      return parse_json<double>::parse(m_values["Doppler"]);
    }

    void GetMultipathForIDResult::setDoppler(double doppler)
    {
      m_values.AddMember("Doppler", parse_json<double>::format(doppler, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathForIDResult::carrierPhase() const
    {
      return parse_json<double>::parse(m_values["CarrierPhase"]);
    }

    void GetMultipathForIDResult::setCarrierPhase(double carrierPhase)
    {
      m_values.AddMember("CarrierPhase", parse_json<double>::format(carrierPhase, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMultipathForIDResult::echo() const
    {
      return parse_json<int>::parse(m_values["Echo"]);
    }

    void GetMultipathForIDResult::setEcho(int echo)
    {
      m_values.AddMember("Echo", parse_json<int>::format(echo, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMultipathForSystem
///
#include "gen/GetAllMultipathForSystem.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMultipathForSystem::CmdName = "GetAllMultipathForSystem";
    const char* const GetAllMultipathForSystem::Documentation = "Get all multipath ID for the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetAllMultipathForSystem);


    GetAllMultipathForSystem::GetAllMultipathForSystem()
      : CommandBase(CmdName)
    {}

    GetAllMultipathForSystem::GetAllMultipathForSystem(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetAllMultipathForSystemPtr GetAllMultipathForSystem::create(const std::string& system)
    {
      return std::make_shared<GetAllMultipathForSystem>(system);
    }

    GetAllMultipathForSystemPtr GetAllMultipathForSystem::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMultipathForSystem>(ptr);
    }

    bool GetAllMultipathForSystem::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetAllMultipathForSystem::documentation() const { return Documentation; }


    int GetAllMultipathForSystem::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMultipathForSystem::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllMultipathForSystem::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMultipathForSV
///
#include "gen/GetAllMultipathForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMultipathForSV::CmdName = "GetAllMultipathForSV";
    const char* const GetAllMultipathForSV::Documentation = "Get all multipath ID for the specified satellite of the constellation.";

    REGISTER_COMMAND_FACTORY(GetAllMultipathForSV);


    GetAllMultipathForSV::GetAllMultipathForSV()
      : CommandBase(CmdName)
    {}

    GetAllMultipathForSV::GetAllMultipathForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetAllMultipathForSVPtr GetAllMultipathForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<GetAllMultipathForSV>(system, svId);
    }

    GetAllMultipathForSVPtr GetAllMultipathForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMultipathForSV>(ptr);
    }

    bool GetAllMultipathForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetAllMultipathForSV::documentation() const { return Documentation; }


    int GetAllMultipathForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMultipathForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllMultipathForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllMultipathForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllMultipathForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMultipathForSignal
///
#include "gen/GetAllMultipathForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMultipathForSignal::CmdName = "GetAllMultipathForSignal";
    const char* const GetAllMultipathForSignal::Documentation = "Get all multipath ID for the specified signal.";

    REGISTER_COMMAND_FACTORY(GetAllMultipathForSignal);


    GetAllMultipathForSignal::GetAllMultipathForSignal()
      : CommandBase(CmdName)
    {}

    GetAllMultipathForSignal::GetAllMultipathForSignal(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetAllMultipathForSignalPtr GetAllMultipathForSignal::create(const std::string& signal)
    {
      return std::make_shared<GetAllMultipathForSignal>(signal);
    }

    GetAllMultipathForSignalPtr GetAllMultipathForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMultipathForSignal>(ptr);
    }

    bool GetAllMultipathForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetAllMultipathForSignal::documentation() const { return Documentation; }


    int GetAllMultipathForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMultipathForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetAllMultipathForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMultipathForResult
///
#include "gen/GetAllMultipathForResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMultipathForResult::CmdName = "GetAllMultipathForResult";
    const char* const GetAllMultipathForResult::Documentation = "Result of GetAllMultipathFor(Signal|SV|System) commands.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllMultipathForResult);


    GetAllMultipathForResult::GetAllMultipathForResult()
      : CommandResult(CmdName)
    {}

    GetAllMultipathForResult::GetAllMultipathForResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllMultipathForResultPtr GetAllMultipathForResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return std::make_shared<GetAllMultipathForResult>(relatedCommand, ids);
    }

    GetAllMultipathForResultPtr GetAllMultipathForResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMultipathForResult>(ptr);
    }

    bool GetAllMultipathForResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllMultipathForResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllMultipathForResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllMultipathForResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLosForSV
///
#include "gen/EnableLosForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLosForSV::CmdName = "EnableLosForSV";
    const char* const EnableLosForSV::Documentation = "Set Direct Line Of Sight signal from satellite enabled or disabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(EnableLosForSV);


    EnableLosForSV::EnableLosForSV()
      : CommandBase(CmdName)
    {}

    EnableLosForSV::EnableLosForSV(const std::string& system, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnableLosForSVPtr EnableLosForSV::create(const std::string& system, int svId, bool enabled)
    {
      return std::make_shared<EnableLosForSV>(system, svId, enabled);
    }

    EnableLosForSVPtr EnableLosForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLosForSV>(ptr);
    }

    bool EnableLosForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLosForSV::documentation() const { return Documentation; }


    int EnableLosForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableLosForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableLosForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnableLosForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnableLosForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableLosForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLosForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLosEnabledForSV
///
#include "gen/IsLosEnabledForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLosEnabledForSV::CmdName = "IsLosEnabledForSV";
    const char* const IsLosEnabledForSV::Documentation = "Get Direct Line Of Sight signal from satellite enabled or disabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(IsLosEnabledForSV);


    IsLosEnabledForSV::IsLosEnabledForSV()
      : CommandBase(CmdName)
    {}

    IsLosEnabledForSV::IsLosEnabledForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    IsLosEnabledForSVPtr IsLosEnabledForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<IsLosEnabledForSV>(system, svId);
    }

    IsLosEnabledForSVPtr IsLosEnabledForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLosEnabledForSV>(ptr);
    }

    bool IsLosEnabledForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsLosEnabledForSV::documentation() const { return Documentation; }


    int IsLosEnabledForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsLosEnabledForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLosEnabledForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsLosEnabledForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsLosEnabledForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLosEnabledForSVResult
///
#include "gen/IsLosEnabledForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLosEnabledForSVResult::CmdName = "IsLosEnabledForSVResult";
    const char* const IsLosEnabledForSVResult::Documentation = "Result of IsLosEnabledForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(IsLosEnabledForSVResult);


    IsLosEnabledForSVResult::IsLosEnabledForSVResult()
      : CommandResult(CmdName)
    {}

    IsLosEnabledForSVResult::IsLosEnabledForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsLosEnabledForSVResultPtr IsLosEnabledForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
    {
      return std::make_shared<IsLosEnabledForSVResult>(relatedCommand, system, svId, enabled);
    }

    IsLosEnabledForSVResultPtr IsLosEnabledForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLosEnabledForSVResult>(ptr);
    }

    bool IsLosEnabledForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLosEnabledForSVResult::documentation() const { return Documentation; }


    std::string IsLosEnabledForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLosEnabledForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsLosEnabledForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsLosEnabledForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsLosEnabledForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLosEnabledForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllLOSForSystem
///
#include "gen/ClearAllLOSForSystem.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllLOSForSystem::CmdName = "ClearAllLOSForSystem";
    const char* const ClearAllLOSForSystem::Documentation = "Enable Direct Line of Sight (LoS) of all satellites for the specified constellation.";

    REGISTER_COMMAND_FACTORY(ClearAllLOSForSystem);


    ClearAllLOSForSystem::ClearAllLOSForSystem()
      : CommandBase(CmdName)
    {}

    ClearAllLOSForSystem::ClearAllLOSForSystem(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    ClearAllLOSForSystemPtr ClearAllLOSForSystem::create(const std::string& system)
    {
      return std::make_shared<ClearAllLOSForSystem>(system);
    }

    ClearAllLOSForSystemPtr ClearAllLOSForSystem::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllLOSForSystem>(ptr);
    }

    bool ClearAllLOSForSystem::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string ClearAllLOSForSystem::documentation() const { return Documentation; }


    int ClearAllLOSForSystem::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string ClearAllLOSForSystem::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ClearAllLOSForSystem::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLosForEachSV
///
#include "gen/EnableLosForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLosForEachSV::CmdName = "EnableLosForEachSV";
    const char* const EnableLosForEachSV::Documentation = "Set Direct Line Of Sight signal from satellite disabled or enabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(EnableLosForEachSV);


    EnableLosForEachSV::EnableLosForEachSV()
      : CommandBase(CmdName)
    {}

    EnableLosForEachSV::EnableLosForEachSV(const std::string& system, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    EnableLosForEachSVPtr EnableLosForEachSV::create(const std::string& system, const std::vector<bool>& enabled)
    {
      return std::make_shared<EnableLosForEachSV>(system, enabled);
    }

    EnableLosForEachSVPtr EnableLosForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLosForEachSV>(ptr);
    }

    bool EnableLosForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLosForEachSV::documentation() const { return Documentation; }


    int EnableLosForEachSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableLosForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableLosForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableLosForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableLosForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLOSEnabledForEachSV
///
#include "gen/IsLOSEnabledForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLOSEnabledForEachSV::CmdName = "IsLOSEnabledForEachSV";
    const char* const IsLOSEnabledForEachSV::Documentation = "Get Direct Line Of Sight signal from satellite disabled or enabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(IsLOSEnabledForEachSV);


    IsLOSEnabledForEachSV::IsLOSEnabledForEachSV()
      : CommandBase(CmdName)
    {}

    IsLOSEnabledForEachSV::IsLOSEnabledForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsLOSEnabledForEachSVPtr IsLOSEnabledForEachSV::create(const std::string& system)
    {
      return std::make_shared<IsLOSEnabledForEachSV>(system);
    }

    IsLOSEnabledForEachSVPtr IsLOSEnabledForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLOSEnabledForEachSV>(ptr);
    }

    bool IsLOSEnabledForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsLOSEnabledForEachSV::documentation() const { return Documentation; }


    int IsLOSEnabledForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsLOSEnabledForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLOSEnabledForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLOSEnabledForEachSVResult
///
#include "gen/IsLOSEnabledForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLOSEnabledForEachSVResult::CmdName = "IsLOSEnabledForEachSVResult";
    const char* const IsLOSEnabledForEachSVResult::Documentation = "Result of IsLOSEnabledForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(IsLOSEnabledForEachSVResult);


    IsLOSEnabledForEachSVResult::IsLOSEnabledForEachSVResult()
      : CommandResult(CmdName)
    {}

    IsLOSEnabledForEachSVResult::IsLOSEnabledForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    IsLOSEnabledForEachSVResultPtr IsLOSEnabledForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
    {
      return std::make_shared<IsLOSEnabledForEachSVResult>(relatedCommand, system, enabled);
    }

    IsLOSEnabledForEachSVResultPtr IsLOSEnabledForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLOSEnabledForEachSVResult>(ptr);
    }

    bool IsLOSEnabledForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLOSEnabledForEachSVResult::documentation() const { return Documentation; }


    std::string IsLOSEnabledForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLOSEnabledForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsLOSEnabledForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsLOSEnabledForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddPlugInInstance
///
#include "gen/AddPlugInInstance.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddPlugInInstance::CmdName = "AddPlugInInstance";
    const char* const AddPlugInInstance::Documentation = "Add a plug-in instance of specified type.";

    REGISTER_COMMAND_FACTORY(AddPlugInInstance);


    AddPlugInInstance::AddPlugInInstance()
      : CommandBase(CmdName)
    {}

    AddPlugInInstance::AddPlugInInstance(const std::string& name, const std::string& type)
      : CommandBase(CmdName)
    {

      setName(name);
      setType(type);
    }


    AddPlugInInstancePtr AddPlugInInstance::create(const std::string& name, const std::string& type)
    {
      return std::make_shared<AddPlugInInstance>(name, type);
    }

    AddPlugInInstancePtr AddPlugInInstance::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddPlugInInstance>(ptr);
    }

    bool AddPlugInInstance::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string AddPlugInInstance::documentation() const { return Documentation; }


    int AddPlugInInstance::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddPlugInInstance::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void AddPlugInInstance::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddPlugInInstance::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void AddPlugInInstance::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemovePlugInInstance
///
#include "gen/RemovePlugInInstance.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemovePlugInInstance::CmdName = "RemovePlugInInstance";
    const char* const RemovePlugInInstance::Documentation = "Removes the plug-in instance.";

    REGISTER_COMMAND_FACTORY(RemovePlugInInstance);


    RemovePlugInInstance::RemovePlugInInstance()
      : CommandBase(CmdName)
    {}

    RemovePlugInInstance::RemovePlugInInstance(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    RemovePlugInInstancePtr RemovePlugInInstance::create(const std::string& name)
    {
      return std::make_shared<RemovePlugInInstance>(name);
    }

    RemovePlugInInstancePtr RemovePlugInInstance::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemovePlugInInstance>(ptr);
    }

    bool RemovePlugInInstance::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string RemovePlugInInstance::documentation() const { return Documentation; }


    int RemovePlugInInstance::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemovePlugInInstance::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void RemovePlugInInstance::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetDefaultIntTxPersistence
///
#include "gen/SetDefaultIntTxPersistence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetDefaultIntTxPersistence::CmdName = "SetDefaultIntTxPersistence";
    const char* const SetDefaultIntTxPersistence::Documentation = "Set wether by default transmitters should keep the modification done during simulation.";

    REGISTER_COMMAND_FACTORY(SetDefaultIntTxPersistence);


    SetDefaultIntTxPersistence::SetDefaultIntTxPersistence()
      : CommandBase(CmdName)
    {}

    SetDefaultIntTxPersistence::SetDefaultIntTxPersistence(bool defaultValue)
      : CommandBase(CmdName)
    {

      setDefaultValue(defaultValue);
    }


    SetDefaultIntTxPersistencePtr SetDefaultIntTxPersistence::create(bool defaultValue)
    {
      return std::make_shared<SetDefaultIntTxPersistence>(defaultValue);
    }

    SetDefaultIntTxPersistencePtr SetDefaultIntTxPersistence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetDefaultIntTxPersistence>(ptr);
    }

    bool SetDefaultIntTxPersistence::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["DefaultValue"])
        ;

    }

    std::string SetDefaultIntTxPersistence::documentation() const { return Documentation; }


    int SetDefaultIntTxPersistence::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool SetDefaultIntTxPersistence::defaultValue() const
    {
      return parse_json<bool>::parse(m_values["DefaultValue"]);
    }

    void SetDefaultIntTxPersistence::setDefaultValue(bool defaultValue)
    {
      m_values.AddMember("DefaultValue", parse_json<bool>::format(defaultValue, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetDefaultIntTxPersistence
///
#include "gen/GetDefaultIntTxPersistence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDefaultIntTxPersistence::CmdName = "GetDefaultIntTxPersistence";
    const char* const GetDefaultIntTxPersistence::Documentation = "Get wether by default transmitters should keep the modification done during simulation.";

    REGISTER_COMMAND_FACTORY(GetDefaultIntTxPersistence);


    GetDefaultIntTxPersistence::GetDefaultIntTxPersistence()
      : CommandBase(CmdName)
    {

    }


    GetDefaultIntTxPersistencePtr GetDefaultIntTxPersistence::create()
    {
      return std::make_shared<GetDefaultIntTxPersistence>();
    }

    GetDefaultIntTxPersistencePtr GetDefaultIntTxPersistence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDefaultIntTxPersistence>(ptr);
    }

    bool GetDefaultIntTxPersistence::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetDefaultIntTxPersistence::documentation() const { return Documentation; }


    int GetDefaultIntTxPersistence::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetDefaultIntTxPersistenceResult
///
#include "gen/GetDefaultIntTxPersistenceResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDefaultIntTxPersistenceResult::CmdName = "GetDefaultIntTxPersistenceResult";
    const char* const GetDefaultIntTxPersistenceResult::Documentation = "Result of GetDefaultIntTxPersistence.";

    REGISTER_COMMAND_RESULT_FACTORY(GetDefaultIntTxPersistenceResult);


    GetDefaultIntTxPersistenceResult::GetDefaultIntTxPersistenceResult()
      : CommandResult(CmdName)
    {}

    GetDefaultIntTxPersistenceResult::GetDefaultIntTxPersistenceResult(CommandBasePtr relatedCommand, bool defaultValue)
      : CommandResult(CmdName, relatedCommand)
    {

      setDefaultValue(defaultValue);
    }


    GetDefaultIntTxPersistenceResultPtr GetDefaultIntTxPersistenceResult::create(CommandBasePtr relatedCommand, bool defaultValue)
    {
      return std::make_shared<GetDefaultIntTxPersistenceResult>(relatedCommand, defaultValue);
    }

    GetDefaultIntTxPersistenceResultPtr GetDefaultIntTxPersistenceResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDefaultIntTxPersistenceResult>(ptr);
    }

    bool GetDefaultIntTxPersistenceResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["DefaultValue"])
        ;

    }

    std::string GetDefaultIntTxPersistenceResult::documentation() const { return Documentation; }


    bool GetDefaultIntTxPersistenceResult::defaultValue() const
    {
      return parse_json<bool>::parse(m_values["DefaultValue"]);
    }

    void GetDefaultIntTxPersistenceResult::setDefaultValue(bool defaultValue)
    {
      m_values.AddMember("DefaultValue", parse_json<bool>::format(defaultValue, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllIntTxID
///
#include "gen/GetAllIntTxID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllIntTxID::CmdName = "GetAllIntTxID";
    const char* const GetAllIntTxID::Documentation = "Get the ID of all interferences transmitters.";

    REGISTER_COMMAND_FACTORY(GetAllIntTxID);


    GetAllIntTxID::GetAllIntTxID()
      : CommandBase(CmdName)
    {

    }


    GetAllIntTxIDPtr GetAllIntTxID::create()
    {
      return std::make_shared<GetAllIntTxID>();
    }

    GetAllIntTxIDPtr GetAllIntTxID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllIntTxID>(ptr);
    }

    bool GetAllIntTxID::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAllIntTxID::documentation() const { return Documentation; }


    int GetAllIntTxID::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAllIntTxIDResult
///
#include "gen/GetAllIntTxIDResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllIntTxIDResult::CmdName = "GetAllIntTxIDResult";
    const char* const GetAllIntTxIDResult::Documentation = "Result of GetAllIntTxID.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllIntTxIDResult);


    GetAllIntTxIDResult::GetAllIntTxIDResult()
      : CommandResult(CmdName)
    {}

    GetAllIntTxIDResult::GetAllIntTxIDResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllIntTxIDResultPtr GetAllIntTxIDResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return std::make_shared<GetAllIntTxIDResult>(relatedCommand, ids);
    }

    GetAllIntTxIDResultPtr GetAllIntTxIDResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllIntTxIDResult>(ptr);
    }

    bool GetAllIntTxIDResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllIntTxIDResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllIntTxIDResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllIntTxIDResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddIntTx
///
#include "gen/AddIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddIntTx::CmdName = "AddIntTx";
    const char* const AddIntTx::Documentation = "Set an interference transmitter. If the transmitter ID parameter is not set (empty string),\nSkydel will assign a unique ID to the transmitter. If the ID is set and already used by Skydel, the\ncommand will fail.";

    REGISTER_COMMAND_FACTORY(AddIntTx);


    AddIntTx::AddIntTx()
      : CommandBase(CmdName)
    {}

    AddIntTx::AddIntTx(const std::string& usualName, bool enabled, int group, bool dynamic, double power, const std::string& id)
      : CommandBase(CmdName)
    {

      setUsualName(usualName);
      setEnabled(enabled);
      setGroup(group);
      setDynamic(dynamic);
      setPower(power);
      setId(id);
    }


    AddIntTxPtr AddIntTx::create(const std::string& usualName, bool enabled, int group, bool dynamic, double power, const std::string& id)
    {
      return std::make_shared<AddIntTx>(usualName, enabled, group, dynamic, power, id);
    }

    AddIntTxPtr AddIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddIntTx>(ptr);
    }

    bool AddIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<bool>::is_valid(m_values["Dynamic"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string AddIntTx::documentation() const { return Documentation; }


    int AddIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string AddIntTx::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void AddIntTx::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool AddIntTx::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void AddIntTx::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int AddIntTx::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void AddIntTx::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool AddIntTx::dynamic() const
    {
      return parse_json<bool>::parse(m_values["Dynamic"]);
    }

    void AddIntTx::setDynamic(bool dynamic)
    {
      m_values.AddMember("Dynamic", parse_json<bool>::format(dynamic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddIntTx::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void AddIntTx::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void AddIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTx
///
#include "gen/GetIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTx::CmdName = "GetIntTx";
    const char* const GetIntTx::Documentation = "Get an interference transmitter.";

    REGISTER_COMMAND_FACTORY(GetIntTx);


    GetIntTx::GetIntTx()
      : CommandBase(CmdName)
    {}

    GetIntTx::GetIntTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxPtr GetIntTx::create(const std::string& id)
    {
      return std::make_shared<GetIntTx>(id);
    }

    GetIntTxPtr GetIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTx>(ptr);
    }

    bool GetIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTx::documentation() const { return Documentation; }


    int GetIntTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxResult
///
#include "gen/GetIntTxResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxResult::CmdName = "GetIntTxResult";
    const char* const GetIntTxResult::Documentation = "Result of GetIntTx.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxResult);


    GetIntTxResult::GetIntTxResult()
      : CommandResult(CmdName)
    {}

    GetIntTxResult::GetIntTxResult(CommandBasePtr relatedCommand, const std::string& usualName, bool enabled, int group, bool dynamic, double power, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setUsualName(usualName);
      setEnabled(enabled);
      setGroup(group);
      setDynamic(dynamic);
      setPower(power);
      setId(id);
    }


    GetIntTxResultPtr GetIntTxResult::create(CommandBasePtr relatedCommand, const std::string& usualName, bool enabled, int group, bool dynamic, double power, const std::string& id)
    {
      return std::make_shared<GetIntTxResult>(relatedCommand, usualName, enabled, group, dynamic, power, id);
    }

    GetIntTxResultPtr GetIntTxResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxResult>(ptr);
    }

    bool GetIntTxResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<bool>::is_valid(m_values["Dynamic"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxResult::documentation() const { return Documentation; }


    std::string GetIntTxResult::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void GetIntTxResult::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIntTxResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxResult::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void GetIntTxResult::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIntTxResult::dynamic() const
    {
      return parse_json<bool>::parse(m_values["Dynamic"]);
    }

    void GetIntTxResult::setDynamic(bool dynamic)
    {
      m_values.AddMember("Dynamic", parse_json<bool>::format(dynamic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RenameIntTx
///
#include "gen/RenameIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RenameIntTx::CmdName = "RenameIntTx";
    const char* const RenameIntTx::Documentation = "Rename a transmitter.";

    REGISTER_COMMAND_FACTORY(RenameIntTx);


    RenameIntTx::RenameIntTx()
      : CommandBase(CmdName)
    {}

    RenameIntTx::RenameIntTx(const std::string& usualName, const std::string& id)
      : CommandBase(CmdName)
    {

      setUsualName(usualName);
      setId(id);
    }


    RenameIntTxPtr RenameIntTx::create(const std::string& usualName, const std::string& id)
    {
      return std::make_shared<RenameIntTx>(usualName, id);
    }

    RenameIntTxPtr RenameIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RenameIntTx>(ptr);
    }

    bool RenameIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RenameIntTx::documentation() const { return Documentation; }


    int RenameIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RenameIntTx::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void RenameIntTx::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RenameIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeIntTxColor
///
#include "gen/ChangeIntTxColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeIntTxColor::CmdName = "ChangeIntTxColor";
    const char* const ChangeIntTxColor::Documentation = "Set a transmitter color in spectrums";

    REGISTER_COMMAND_FACTORY(ChangeIntTxColor);


    ChangeIntTxColor::ChangeIntTxColor()
      : CommandBase(CmdName)
    {}

    ChangeIntTxColor::ChangeIntTxColor(const std::string& color, const std::string& id)
      : CommandBase(CmdName)
    {

      setColor(color);
      setId(id);
    }


    ChangeIntTxColorPtr ChangeIntTxColor::create(const std::string& color, const std::string& id)
    {
      return std::make_shared<ChangeIntTxColor>(color, id);
    }

    ChangeIntTxColorPtr ChangeIntTxColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeIntTxColor>(ptr);
    }

    bool ChangeIntTxColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ChangeIntTxColor::documentation() const { return Documentation; }


    int ChangeIntTxColor::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string ChangeIntTxColor::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void ChangeIntTxColor::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeIntTxColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeIntTxColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxColor
///
#include "gen/GetIntTxColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxColor::CmdName = "GetIntTxColor";
    const char* const GetIntTxColor::Documentation = "Get a transmitter color in spectrums";

    REGISTER_COMMAND_FACTORY(GetIntTxColor);


    GetIntTxColor::GetIntTxColor()
      : CommandBase(CmdName)
    {}

    GetIntTxColor::GetIntTxColor(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxColorPtr GetIntTxColor::create(const std::string& id)
    {
      return std::make_shared<GetIntTxColor>(id);
    }

    GetIntTxColorPtr GetIntTxColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxColor>(ptr);
    }

    bool GetIntTxColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxColor::documentation() const { return Documentation; }


    int GetIntTxColor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxColorResult
///
#include "gen/GetIntTxColorResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxColorResult::CmdName = "GetIntTxColorResult";
    const char* const GetIntTxColorResult::Documentation = "Result of GetIntTxColor.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxColorResult);


    GetIntTxColorResult::GetIntTxColorResult()
      : CommandResult(CmdName)
    {}

    GetIntTxColorResult::GetIntTxColorResult(CommandBasePtr relatedCommand, const std::string& color, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setColor(color);
      setId(id);
    }


    GetIntTxColorResultPtr GetIntTxColorResult::create(CommandBasePtr relatedCommand, const std::string& color, const std::string& id)
    {
      return std::make_shared<GetIntTxColorResult>(relatedCommand, color, id);
    }

    GetIntTxColorResultPtr GetIntTxColorResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxColorResult>(ptr);
    }

    bool GetIntTxColorResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxColorResult::documentation() const { return Documentation; }


    std::string GetIntTxColorResult::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void GetIntTxColorResult::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxColorResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxColorResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableIntTx
///
#include "gen/EnableIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableIntTx::CmdName = "EnableIntTx";
    const char* const EnableIntTx::Documentation = "Enable/Disable the interference transmitter.";

    REGISTER_COMMAND_FACTORY(EnableIntTx);


    EnableIntTx::EnableIntTx()
      : CommandBase(CmdName)
    {}

    EnableIntTx::EnableIntTx(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    EnableIntTxPtr EnableIntTx::create(bool enabled, const std::string& id)
    {
      return std::make_shared<EnableIntTx>(enabled, id);
    }

    EnableIntTxPtr EnableIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableIntTx>(ptr);
    }

    bool EnableIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EnableIntTx::documentation() const { return Documentation; }


    int EnableIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool EnableIntTx::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableIntTx::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EnableIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxGroup
///
#include "gen/SetIntTxGroup.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxGroup::CmdName = "SetIntTxGroup";
    const char* const SetIntTxGroup::Documentation = "Set the interference transmitter group (which links to a specific RF output target).";

    REGISTER_COMMAND_FACTORY(SetIntTxGroup);


    SetIntTxGroup::SetIntTxGroup()
      : CommandBase(CmdName)
    {}

    SetIntTxGroup::SetIntTxGroup(int group, const std::string& id)
      : CommandBase(CmdName)
    {

      setGroup(group);
      setId(id);
    }


    SetIntTxGroupPtr SetIntTxGroup::create(int group, const std::string& id)
    {
      return std::make_shared<SetIntTxGroup>(group, id);
    }

    SetIntTxGroupPtr SetIntTxGroup::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxGroup>(ptr);
    }

    bool SetIntTxGroup::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxGroup::documentation() const { return Documentation; }


    int SetIntTxGroup::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetIntTxGroup::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void SetIntTxGroup::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxGroup::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxGroup::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxRefPower
///
#include "gen/SetIntTxRefPower.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxRefPower::CmdName = "SetIntTxRefPower";
    const char* const SetIntTxRefPower::Documentation = "Set the interference transmitter reference power.";

    REGISTER_COMMAND_FACTORY(SetIntTxRefPower);


    SetIntTxRefPower::SetIntTxRefPower()
      : CommandBase(CmdName)
    {}

    SetIntTxRefPower::SetIntTxRefPower(double power, const std::string& id)
      : CommandBase(CmdName)
    {

      setPower(power);
      setId(id);
    }


    SetIntTxRefPowerPtr SetIntTxRefPower::create(double power, const std::string& id)
    {
      return std::make_shared<SetIntTxRefPower>(power, id);
    }

    SetIntTxRefPowerPtr SetIntTxRefPower::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxRefPower>(ptr);
    }

    bool SetIntTxRefPower::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxRefPower::documentation() const { return Documentation; }


    int SetIntTxRefPower::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxRefPower::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxRefPower::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxRefPower::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxRefPower::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxPersistence
///
#include "gen/SetIntTxPersistence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxPersistence::CmdName = "SetIntTxPersistence";
    const char* const SetIntTxPersistence::Documentation = "Set wether the transmitter should keep the modifications done during the simulation.";

    REGISTER_COMMAND_FACTORY(SetIntTxPersistence);


    SetIntTxPersistence::SetIntTxPersistence()
      : CommandBase(CmdName)
    {}

    SetIntTxPersistence::SetIntTxPersistence(bool persistence, const std::string& id)
      : CommandBase(CmdName)
    {

      setPersistence(persistence);
      setId(id);
    }


    SetIntTxPersistencePtr SetIntTxPersistence::create(bool persistence, const std::string& id)
    {
      return std::make_shared<SetIntTxPersistence>(persistence, id);
    }

    SetIntTxPersistencePtr SetIntTxPersistence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxPersistence>(ptr);
    }

    bool SetIntTxPersistence::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Persistence"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxPersistence::documentation() const { return Documentation; }


    int SetIntTxPersistence::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxPersistence::persistence() const
    {
      return parse_json<bool>::parse(m_values["Persistence"]);
    }

    void SetIntTxPersistence::setPersistence(bool persistence)
    {
      m_values.AddMember("Persistence", parse_json<bool>::format(persistence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxPersistence::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxPersistence::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxPersistence
///
#include "gen/GetIntTxPersistence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxPersistence::CmdName = "GetIntTxPersistence";
    const char* const GetIntTxPersistence::Documentation = "Get wether the transmitter should keep the modifications done during the simulation.";

    REGISTER_COMMAND_FACTORY(GetIntTxPersistence);


    GetIntTxPersistence::GetIntTxPersistence()
      : CommandBase(CmdName)
    {}

    GetIntTxPersistence::GetIntTxPersistence(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxPersistencePtr GetIntTxPersistence::create(const std::string& id)
    {
      return std::make_shared<GetIntTxPersistence>(id);
    }

    GetIntTxPersistencePtr GetIntTxPersistence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxPersistence>(ptr);
    }

    bool GetIntTxPersistence::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxPersistence::documentation() const { return Documentation; }


    int GetIntTxPersistence::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxPersistence::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxPersistence::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxPersistenceResult
///
#include "gen/GetIntTxPersistenceResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxPersistenceResult::CmdName = "GetIntTxPersistenceResult";
    const char* const GetIntTxPersistenceResult::Documentation = "Result of GetIntTxPersistence.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxPersistenceResult);


    GetIntTxPersistenceResult::GetIntTxPersistenceResult()
      : CommandResult(CmdName)
    {}

    GetIntTxPersistenceResult::GetIntTxPersistenceResult(CommandBasePtr relatedCommand, bool persistence, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPersistence(persistence);
      setId(id);
    }


    GetIntTxPersistenceResultPtr GetIntTxPersistenceResult::create(CommandBasePtr relatedCommand, bool persistence, const std::string& id)
    {
      return std::make_shared<GetIntTxPersistenceResult>(relatedCommand, persistence, id);
    }

    GetIntTxPersistenceResultPtr GetIntTxPersistenceResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxPersistenceResult>(ptr);
    }

    bool GetIntTxPersistenceResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Persistence"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxPersistenceResult::documentation() const { return Documentation; }


    bool GetIntTxPersistenceResult::persistence() const
    {
      return parse_json<bool>::parse(m_values["Persistence"]);
    }

    void GetIntTxPersistenceResult::setPersistence(bool persistence)
    {
      m_values.AddMember("Persistence", parse_json<bool>::format(persistence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxPersistenceResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxPersistenceResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxSignalManualPropagationLoss
///
#include "gen/SetIntTxSignalManualPropagationLoss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxSignalManualPropagationLoss::CmdName = "SetIntTxSignalManualPropagationLoss";
    const char* const SetIntTxSignalManualPropagationLoss::Documentation = "Set the manual propagation loss for the given interference signal. Value is used only if SetIntTxUseManualPropagationLoss has been set on the corresponding transmitter. This value is not preserved after simulation end.";

    REGISTER_COMMAND_FACTORY(SetIntTxSignalManualPropagationLoss);


    SetIntTxSignalManualPropagationLoss::SetIntTxSignalManualPropagationLoss()
      : CommandBase(CmdName)
    {}

    SetIntTxSignalManualPropagationLoss::SetIntTxSignalManualPropagationLoss(double propagationLoss, const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setPropagationLoss(propagationLoss);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    SetIntTxSignalManualPropagationLossPtr SetIntTxSignalManualPropagationLoss::create(double propagationLoss, const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<SetIntTxSignalManualPropagationLoss>(propagationLoss, transmitterId, signalId);
    }

    SetIntTxSignalManualPropagationLossPtr SetIntTxSignalManualPropagationLoss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxSignalManualPropagationLoss>(ptr);
    }

    bool SetIntTxSignalManualPropagationLoss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["PropagationLoss"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string SetIntTxSignalManualPropagationLoss::documentation() const { return Documentation; }


    int SetIntTxSignalManualPropagationLoss::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxSignalManualPropagationLoss::propagationLoss() const
    {
      return parse_json<double>::parse(m_values["PropagationLoss"]);
    }

    void SetIntTxSignalManualPropagationLoss::setPropagationLoss(double propagationLoss)
    {
      m_values.AddMember("PropagationLoss", parse_json<double>::format(propagationLoss, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxSignalManualPropagationLoss::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxSignalManualPropagationLoss::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxSignalManualPropagationLoss::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxSignalManualPropagationLoss::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxUseManualPropagationLoss
///
#include "gen/SetIntTxUseManualPropagationLoss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxUseManualPropagationLoss::CmdName = "SetIntTxUseManualPropagationLoss";
    const char* const SetIntTxUseManualPropagationLoss::Documentation = "Set whether a dynamic transmitter should only use user-provided propagation loss values. Propagation loss will not update automatically if set. This state is not preserved after simulation end.";

    REGISTER_COMMAND_FACTORY(SetIntTxUseManualPropagationLoss);


    SetIntTxUseManualPropagationLoss::SetIntTxUseManualPropagationLoss()
      : CommandBase(CmdName)
    {}

    SetIntTxUseManualPropagationLoss::SetIntTxUseManualPropagationLoss(bool manual, const std::string& id)
      : CommandBase(CmdName)
    {

      setManual(manual);
      setId(id);
    }


    SetIntTxUseManualPropagationLossPtr SetIntTxUseManualPropagationLoss::create(bool manual, const std::string& id)
    {
      return std::make_shared<SetIntTxUseManualPropagationLoss>(manual, id);
    }

    SetIntTxUseManualPropagationLossPtr SetIntTxUseManualPropagationLoss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxUseManualPropagationLoss>(ptr);
    }

    bool SetIntTxUseManualPropagationLoss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Manual"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxUseManualPropagationLoss::documentation() const { return Documentation; }


    int SetIntTxUseManualPropagationLoss::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxUseManualPropagationLoss::manual() const
    {
      return parse_json<bool>::parse(m_values["Manual"]);
    }

    void SetIntTxUseManualPropagationLoss::setManual(bool manual)
    {
      m_values.AddMember("Manual", parse_json<bool>::format(manual, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxUseManualPropagationLoss::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxUseManualPropagationLoss::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnorePropagationLoss
///
#include "gen/SetIntTxIgnorePropagationLoss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnorePropagationLoss::CmdName = "SetIntTxIgnorePropagationLoss";
    const char* const SetIntTxIgnorePropagationLoss::Documentation = "Set whether a dynamic transmitter should ignore propagation loss or not.";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnorePropagationLoss);


    SetIntTxIgnorePropagationLoss::SetIntTxIgnorePropagationLoss()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnorePropagationLoss::SetIntTxIgnorePropagationLoss(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnorePropagationLossPtr SetIntTxIgnorePropagationLoss::create(bool ignore, const std::string& id)
    {
      return std::make_shared<SetIntTxIgnorePropagationLoss>(ignore, id);
    }

    SetIntTxIgnorePropagationLossPtr SetIntTxIgnorePropagationLoss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnorePropagationLoss>(ptr);
    }

    bool SetIntTxIgnorePropagationLoss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnorePropagationLoss::documentation() const { return Documentation; }


    int SetIntTxIgnorePropagationLoss::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnorePropagationLoss::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnorePropagationLoss::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnorePropagationLoss::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnorePropagationLoss::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnoreRxAntennaPatterns
///
#include "gen/SetIntTxIgnoreRxAntennaPatterns.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnoreRxAntennaPatterns::CmdName = "SetIntTxIgnoreRxAntennaPatterns";
    const char* const SetIntTxIgnoreRxAntennaPatterns::Documentation = "Set whether a dynamic transmitter should ignore the vehicle's antenna patterns (gain and phase).";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnoreRxAntennaPatterns);


    SetIntTxIgnoreRxAntennaPatterns::SetIntTxIgnoreRxAntennaPatterns()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnoreRxAntennaPatterns::SetIntTxIgnoreRxAntennaPatterns(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnoreRxAntennaPatternsPtr SetIntTxIgnoreRxAntennaPatterns::create(bool ignore, const std::string& id)
    {
      return std::make_shared<SetIntTxIgnoreRxAntennaPatterns>(ignore, id);
    }

    SetIntTxIgnoreRxAntennaPatternsPtr SetIntTxIgnoreRxAntennaPatterns::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnoreRxAntennaPatterns>(ptr);
    }

    bool SetIntTxIgnoreRxAntennaPatterns::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnoreRxAntennaPatterns::documentation() const { return Documentation; }


    int SetIntTxIgnoreRxAntennaPatterns::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnoreRxAntennaPatterns::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnoreRxAntennaPatterns::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnoreRxAntennaPatterns::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnoreRxAntennaPatterns::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnoreVehicleAntennaPattern
///
#include "gen/SetIntTxIgnoreVehicleAntennaPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnoreVehicleAntennaPattern::CmdName = "SetIntTxIgnoreVehicleAntennaPattern";
    const char* const SetIntTxIgnoreVehicleAntennaPattern::Documentation = "Please note the command SetIntTxIgnoreVehicleAntennaPattern is deprecated since 20.2. You may use SetIntTxIgnoreRxAntennaPatterns.\n\nSet whether a dynamic transmitter should ignore the vehicle's antenna patterns (gain and phase).";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnoreVehicleAntennaPattern);


    SetIntTxIgnoreVehicleAntennaPattern::SetIntTxIgnoreVehicleAntennaPattern()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnoreVehicleAntennaPattern::SetIntTxIgnoreVehicleAntennaPattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnoreVehicleAntennaPatternPtr SetIntTxIgnoreVehicleAntennaPattern::create(bool ignore, const std::string& id)
    {
      return std::make_shared<SetIntTxIgnoreVehicleAntennaPattern>(ignore, id);
    }

    SetIntTxIgnoreVehicleAntennaPatternPtr SetIntTxIgnoreVehicleAntennaPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnoreVehicleAntennaPattern>(ptr);
    }

    bool SetIntTxIgnoreVehicleAntennaPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnoreVehicleAntennaPattern::documentation() const { return Documentation; }


    int SetIntTxIgnoreVehicleAntennaPattern::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnoreVehicleAntennaPattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnoreVehicleAntennaPattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnoreVehicleAntennaPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnoreVehicleAntennaPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxHiddenOnMap
///
#include "gen/SetIntTxHiddenOnMap.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxHiddenOnMap::CmdName = "SetIntTxHiddenOnMap";
    const char* const SetIntTxHiddenOnMap::Documentation = "Set whether a transmitter should be hidden on the map.";

    REGISTER_COMMAND_FACTORY(SetIntTxHiddenOnMap);


    SetIntTxHiddenOnMap::SetIntTxHiddenOnMap()
      : CommandBase(CmdName)
    {}

    SetIntTxHiddenOnMap::SetIntTxHiddenOnMap(bool hiddenOnMap, const std::string& id)
      : CommandBase(CmdName)
    {

      setHiddenOnMap(hiddenOnMap);
      setId(id);
    }


    SetIntTxHiddenOnMapPtr SetIntTxHiddenOnMap::create(bool hiddenOnMap, const std::string& id)
    {
      return std::make_shared<SetIntTxHiddenOnMap>(hiddenOnMap, id);
    }

    SetIntTxHiddenOnMapPtr SetIntTxHiddenOnMap::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxHiddenOnMap>(ptr);
    }

    bool SetIntTxHiddenOnMap::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["HiddenOnMap"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxHiddenOnMap::documentation() const { return Documentation; }


    int SetIntTxHiddenOnMap::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxHiddenOnMap::hiddenOnMap() const
    {
      return parse_json<bool>::parse(m_values["HiddenOnMap"]);
    }

    void SetIntTxHiddenOnMap::setHiddenOnMap(bool hiddenOnMap)
    {
      m_values.AddMember("HiddenOnMap", parse_json<bool>::format(hiddenOnMap, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxHiddenOnMap::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxHiddenOnMap::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxHiddenOnMap
///
#include "gen/GetIntTxHiddenOnMap.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxHiddenOnMap::CmdName = "GetIntTxHiddenOnMap";
    const char* const GetIntTxHiddenOnMap::Documentation = "Get whether a transmitter should be hidden on the map.";

    REGISTER_COMMAND_FACTORY(GetIntTxHiddenOnMap);


    GetIntTxHiddenOnMap::GetIntTxHiddenOnMap()
      : CommandBase(CmdName)
    {}

    GetIntTxHiddenOnMap::GetIntTxHiddenOnMap(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxHiddenOnMapPtr GetIntTxHiddenOnMap::create(const std::string& id)
    {
      return std::make_shared<GetIntTxHiddenOnMap>(id);
    }

    GetIntTxHiddenOnMapPtr GetIntTxHiddenOnMap::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxHiddenOnMap>(ptr);
    }

    bool GetIntTxHiddenOnMap::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxHiddenOnMap::documentation() const { return Documentation; }


    int GetIntTxHiddenOnMap::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxHiddenOnMap::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxHiddenOnMap::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxHiddenOnMapResult
///
#include "gen/GetIntTxHiddenOnMapResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxHiddenOnMapResult::CmdName = "GetIntTxHiddenOnMapResult";
    const char* const GetIntTxHiddenOnMapResult::Documentation = "Result of GetIntTxHiddenOnMap.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxHiddenOnMapResult);


    GetIntTxHiddenOnMapResult::GetIntTxHiddenOnMapResult()
      : CommandResult(CmdName)
    {}

    GetIntTxHiddenOnMapResult::GetIntTxHiddenOnMapResult(CommandBasePtr relatedCommand, bool hiddenOnMap, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setHiddenOnMap(hiddenOnMap);
      setId(id);
    }


    GetIntTxHiddenOnMapResultPtr GetIntTxHiddenOnMapResult::create(CommandBasePtr relatedCommand, bool hiddenOnMap, const std::string& id)
    {
      return std::make_shared<GetIntTxHiddenOnMapResult>(relatedCommand, hiddenOnMap, id);
    }

    GetIntTxHiddenOnMapResultPtr GetIntTxHiddenOnMapResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxHiddenOnMapResult>(ptr);
    }

    bool GetIntTxHiddenOnMapResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["HiddenOnMap"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxHiddenOnMapResult::documentation() const { return Documentation; }


    bool GetIntTxHiddenOnMapResult::hiddenOnMap() const
    {
      return parse_json<bool>::parse(m_values["HiddenOnMap"]);
    }

    void GetIntTxHiddenOnMapResult::setHiddenOnMap(bool hiddenOnMap)
    {
      m_values.AddMember("HiddenOnMap", parse_json<bool>::format(hiddenOnMap, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxHiddenOnMapResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxHiddenOnMapResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnoreRxAntennaGainPattern
///
#include "gen/SetIntTxIgnoreRxAntennaGainPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnoreRxAntennaGainPattern::CmdName = "SetIntTxIgnoreRxAntennaGainPattern";
    const char* const SetIntTxIgnoreRxAntennaGainPattern::Documentation = "Set whether a dynamic transmitter should ignore the receiver's antenna gain pattern.";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnoreRxAntennaGainPattern);


    SetIntTxIgnoreRxAntennaGainPattern::SetIntTxIgnoreRxAntennaGainPattern()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnoreRxAntennaGainPattern::SetIntTxIgnoreRxAntennaGainPattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnoreRxAntennaGainPatternPtr SetIntTxIgnoreRxAntennaGainPattern::create(bool ignore, const std::string& id)
    {
      return std::make_shared<SetIntTxIgnoreRxAntennaGainPattern>(ignore, id);
    }

    SetIntTxIgnoreRxAntennaGainPatternPtr SetIntTxIgnoreRxAntennaGainPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnoreRxAntennaGainPattern>(ptr);
    }

    bool SetIntTxIgnoreRxAntennaGainPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnoreRxAntennaGainPattern::documentation() const { return Documentation; }


    int SetIntTxIgnoreRxAntennaGainPattern::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnoreRxAntennaGainPattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnoreRxAntennaGainPattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnoreRxAntennaGainPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnoreRxAntennaGainPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxIgnoreRxAntennaGainPattern
///
#include "gen/IsIntTxIgnoreRxAntennaGainPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxIgnoreRxAntennaGainPattern::CmdName = "IsIntTxIgnoreRxAntennaGainPattern";
    const char* const IsIntTxIgnoreRxAntennaGainPattern::Documentation = "Get whether a dynamic transmitter ignore the receiver's antenna gain pattern.";

    REGISTER_COMMAND_FACTORY(IsIntTxIgnoreRxAntennaGainPattern);


    IsIntTxIgnoreRxAntennaGainPattern::IsIntTxIgnoreRxAntennaGainPattern()
      : CommandBase(CmdName)
    {}

    IsIntTxIgnoreRxAntennaGainPattern::IsIntTxIgnoreRxAntennaGainPattern(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsIntTxIgnoreRxAntennaGainPatternPtr IsIntTxIgnoreRxAntennaGainPattern::create(const std::string& id)
    {
      return std::make_shared<IsIntTxIgnoreRxAntennaGainPattern>(id);
    }

    IsIntTxIgnoreRxAntennaGainPatternPtr IsIntTxIgnoreRxAntennaGainPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxIgnoreRxAntennaGainPattern>(ptr);
    }

    bool IsIntTxIgnoreRxAntennaGainPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxIgnoreRxAntennaGainPattern::documentation() const { return Documentation; }


    int IsIntTxIgnoreRxAntennaGainPattern::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsIntTxIgnoreRxAntennaGainPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxIgnoreRxAntennaGainPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxIgnoreRxAntennaGainPatternResult
///
#include "gen/IsIntTxIgnoreRxAntennaGainPatternResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxIgnoreRxAntennaGainPatternResult::CmdName = "IsIntTxIgnoreRxAntennaGainPatternResult";
    const char* const IsIntTxIgnoreRxAntennaGainPatternResult::Documentation = "Result of IsIntTxIgnoreRxAntennaGainPattern.";

    REGISTER_COMMAND_RESULT_FACTORY(IsIntTxIgnoreRxAntennaGainPatternResult);


    IsIntTxIgnoreRxAntennaGainPatternResult::IsIntTxIgnoreRxAntennaGainPatternResult()
      : CommandResult(CmdName)
    {}

    IsIntTxIgnoreRxAntennaGainPatternResult::IsIntTxIgnoreRxAntennaGainPatternResult(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setIgnore(ignore);
      setId(id);
    }


    IsIntTxIgnoreRxAntennaGainPatternResultPtr IsIntTxIgnoreRxAntennaGainPatternResult::create(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
    {
      return std::make_shared<IsIntTxIgnoreRxAntennaGainPatternResult>(relatedCommand, ignore, id);
    }

    IsIntTxIgnoreRxAntennaGainPatternResultPtr IsIntTxIgnoreRxAntennaGainPatternResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxIgnoreRxAntennaGainPatternResult>(ptr);
    }

    bool IsIntTxIgnoreRxAntennaGainPatternResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxIgnoreRxAntennaGainPatternResult::documentation() const { return Documentation; }


    bool IsIntTxIgnoreRxAntennaGainPatternResult::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void IsIntTxIgnoreRxAntennaGainPatternResult::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsIntTxIgnoreRxAntennaGainPatternResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxIgnoreRxAntennaGainPatternResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnoreRxAntennaPhasePattern
///
#include "gen/SetIntTxIgnoreRxAntennaPhasePattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnoreRxAntennaPhasePattern::CmdName = "SetIntTxIgnoreRxAntennaPhasePattern";
    const char* const SetIntTxIgnoreRxAntennaPhasePattern::Documentation = "Set whether a dynamic transmitter should ignore the receiver's antenna phase pattern.";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnoreRxAntennaPhasePattern);


    SetIntTxIgnoreRxAntennaPhasePattern::SetIntTxIgnoreRxAntennaPhasePattern()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnoreRxAntennaPhasePattern::SetIntTxIgnoreRxAntennaPhasePattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnoreRxAntennaPhasePatternPtr SetIntTxIgnoreRxAntennaPhasePattern::create(bool ignore, const std::string& id)
    {
      return std::make_shared<SetIntTxIgnoreRxAntennaPhasePattern>(ignore, id);
    }

    SetIntTxIgnoreRxAntennaPhasePatternPtr SetIntTxIgnoreRxAntennaPhasePattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnoreRxAntennaPhasePattern>(ptr);
    }

    bool SetIntTxIgnoreRxAntennaPhasePattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnoreRxAntennaPhasePattern::documentation() const { return Documentation; }


    int SetIntTxIgnoreRxAntennaPhasePattern::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnoreRxAntennaPhasePattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnoreRxAntennaPhasePattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnoreRxAntennaPhasePattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnoreRxAntennaPhasePattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxIgnoreRxAntennaPhasePattern
///
#include "gen/IsIntTxIgnoreRxAntennaPhasePattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxIgnoreRxAntennaPhasePattern::CmdName = "IsIntTxIgnoreRxAntennaPhasePattern";
    const char* const IsIntTxIgnoreRxAntennaPhasePattern::Documentation = "Get whether a dynamic transmitter ignore the receiver's antenna phase pattern.";

    REGISTER_COMMAND_FACTORY(IsIntTxIgnoreRxAntennaPhasePattern);


    IsIntTxIgnoreRxAntennaPhasePattern::IsIntTxIgnoreRxAntennaPhasePattern()
      : CommandBase(CmdName)
    {}

    IsIntTxIgnoreRxAntennaPhasePattern::IsIntTxIgnoreRxAntennaPhasePattern(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsIntTxIgnoreRxAntennaPhasePatternPtr IsIntTxIgnoreRxAntennaPhasePattern::create(const std::string& id)
    {
      return std::make_shared<IsIntTxIgnoreRxAntennaPhasePattern>(id);
    }

    IsIntTxIgnoreRxAntennaPhasePatternPtr IsIntTxIgnoreRxAntennaPhasePattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxIgnoreRxAntennaPhasePattern>(ptr);
    }

    bool IsIntTxIgnoreRxAntennaPhasePattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxIgnoreRxAntennaPhasePattern::documentation() const { return Documentation; }


    int IsIntTxIgnoreRxAntennaPhasePattern::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsIntTxIgnoreRxAntennaPhasePattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxIgnoreRxAntennaPhasePattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxIgnoreRxAntennaPhasePatternResult
///
#include "gen/IsIntTxIgnoreRxAntennaPhasePatternResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxIgnoreRxAntennaPhasePatternResult::CmdName = "IsIntTxIgnoreRxAntennaPhasePatternResult";
    const char* const IsIntTxIgnoreRxAntennaPhasePatternResult::Documentation = "Result of IsIntTxIgnoreRxAntennaPhasePattern.";

    REGISTER_COMMAND_RESULT_FACTORY(IsIntTxIgnoreRxAntennaPhasePatternResult);


    IsIntTxIgnoreRxAntennaPhasePatternResult::IsIntTxIgnoreRxAntennaPhasePatternResult()
      : CommandResult(CmdName)
    {}

    IsIntTxIgnoreRxAntennaPhasePatternResult::IsIntTxIgnoreRxAntennaPhasePatternResult(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setIgnore(ignore);
      setId(id);
    }


    IsIntTxIgnoreRxAntennaPhasePatternResultPtr IsIntTxIgnoreRxAntennaPhasePatternResult::create(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
    {
      return std::make_shared<IsIntTxIgnoreRxAntennaPhasePatternResult>(relatedCommand, ignore, id);
    }

    IsIntTxIgnoreRxAntennaPhasePatternResultPtr IsIntTxIgnoreRxAntennaPhasePatternResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxIgnoreRxAntennaPhasePatternResult>(ptr);
    }

    bool IsIntTxIgnoreRxAntennaPhasePatternResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxIgnoreRxAntennaPhasePatternResult::documentation() const { return Documentation; }


    bool IsIntTxIgnoreRxAntennaPhasePatternResult::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void IsIntTxIgnoreRxAntennaPhasePatternResult::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsIntTxIgnoreRxAntennaPhasePatternResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxIgnoreRxAntennaPhasePatternResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxNone
///
#include "gen/SetIntTxNone.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxNone::CmdName = "SetIntTxNone";
    const char* const SetIntTxNone::Documentation = "Set an undefined trajectory to a transmitter, thus preventing it to be modulated (default value).";

    REGISTER_COMMAND_FACTORY(SetIntTxNone);


    SetIntTxNone::SetIntTxNone()
      : CommandBase(CmdName)
    {}

    SetIntTxNone::SetIntTxNone(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    SetIntTxNonePtr SetIntTxNone::create(const std::string& id)
    {
      return std::make_shared<SetIntTxNone>(id);
    }

    SetIntTxNonePtr SetIntTxNone::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxNone>(ptr);
    }

    bool SetIntTxNone::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxNone::documentation() const { return Documentation; }


    int SetIntTxNone::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetIntTxNone::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxNone::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxFix
///
#include "gen/SetIntTxFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxFix::CmdName = "SetIntTxFix";
    const char* const SetIntTxFix::Documentation = "Set interference transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(SetIntTxFix);


    SetIntTxFix::SetIntTxFix()
      : CommandBase(CmdName)
    {}

    SetIntTxFix::SetIntTxFix(double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetIntTxFixPtr SetIntTxFix::create(double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<SetIntTxFix>(lat, lon, alt, yaw, pitch, roll, id);
    }

    SetIntTxFixPtr SetIntTxFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxFix>(ptr);
    }

    bool SetIntTxFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxFix::documentation() const { return Documentation; }


    int SetIntTxFix::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxFix::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetIntTxFix::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetIntTxFix::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetIntTxFix::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetIntTxFix::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetIntTxFix::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetIntTxFix::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxFix::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxFix::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxFix
///
#include "gen/GetIntTxFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxFix::CmdName = "GetIntTxFix";
    const char* const GetIntTxFix::Documentation = "Get interference transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(GetIntTxFix);


    GetIntTxFix::GetIntTxFix()
      : CommandBase(CmdName)
    {}

    GetIntTxFix::GetIntTxFix(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxFixPtr GetIntTxFix::create(const std::string& id)
    {
      return std::make_shared<GetIntTxFix>(id);
    }

    GetIntTxFixPtr GetIntTxFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxFix>(ptr);
    }

    bool GetIntTxFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxFix::documentation() const { return Documentation; }


    int GetIntTxFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxFix::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxFix::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxFixResult
///
#include "gen/GetIntTxFixResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxFixResult::CmdName = "GetIntTxFixResult";
    const char* const GetIntTxFixResult::Documentation = "Result of GetIntTxFix.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxFixResult);


    GetIntTxFixResult::GetIntTxFixResult()
      : CommandResult(CmdName)
    {}

    GetIntTxFixResult::GetIntTxFixResult(CommandBasePtr relatedCommand, double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetIntTxFixResultPtr GetIntTxFixResult::create(CommandBasePtr relatedCommand, double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<GetIntTxFixResult>(relatedCommand, lat, lon, alt, yaw, pitch, roll, id);
    }

    GetIntTxFixResultPtr GetIntTxFixResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxFixResult>(ptr);
    }

    bool GetIntTxFixResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxFixResult::documentation() const { return Documentation; }


    double GetIntTxFixResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetIntTxFixResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetIntTxFixResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetIntTxFixResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetIntTxFixResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetIntTxFixResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetIntTxFixResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxFixResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxFixResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxFixEcef
///
#include "gen/SetIntTxFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxFixEcef::CmdName = "SetIntTxFixEcef";
    const char* const SetIntTxFixEcef::Documentation = "Set interference transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(SetIntTxFixEcef);


    SetIntTxFixEcef::SetIntTxFixEcef()
      : CommandBase(CmdName)
    {}

    SetIntTxFixEcef::SetIntTxFixEcef(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetIntTxFixEcefPtr SetIntTxFixEcef::create(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<SetIntTxFixEcef>(x, y, z, yaw, pitch, roll, id);
    }

    SetIntTxFixEcefPtr SetIntTxFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxFixEcef>(ptr);
    }

    bool SetIntTxFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxFixEcef::documentation() const { return Documentation; }


    int SetIntTxFixEcef::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxFixEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetIntTxFixEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetIntTxFixEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetIntTxFixEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetIntTxFixEcef::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetIntTxFixEcef::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetIntTxFixEcef::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxFixEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxFixEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxFixEcef
///
#include "gen/GetIntTxFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxFixEcef::CmdName = "GetIntTxFixEcef";
    const char* const GetIntTxFixEcef::Documentation = "Get interference transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(GetIntTxFixEcef);


    GetIntTxFixEcef::GetIntTxFixEcef()
      : CommandBase(CmdName)
    {}

    GetIntTxFixEcef::GetIntTxFixEcef(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxFixEcefPtr GetIntTxFixEcef::create(const std::string& id)
    {
      return std::make_shared<GetIntTxFixEcef>(id);
    }

    GetIntTxFixEcefPtr GetIntTxFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxFixEcef>(ptr);
    }

    bool GetIntTxFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxFixEcef::documentation() const { return Documentation; }


    int GetIntTxFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxFixEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxFixEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxFixEcefResult
///
#include "gen/GetIntTxFixEcefResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxFixEcefResult::CmdName = "GetIntTxFixEcefResult";
    const char* const GetIntTxFixEcefResult::Documentation = "Result of GetIntTxFixEcef.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxFixEcefResult);


    GetIntTxFixEcefResult::GetIntTxFixEcefResult()
      : CommandResult(CmdName)
    {}

    GetIntTxFixEcefResult::GetIntTxFixEcefResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetIntTxFixEcefResultPtr GetIntTxFixEcefResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<GetIntTxFixEcefResult>(relatedCommand, x, y, z, yaw, pitch, roll, id);
    }

    GetIntTxFixEcefResultPtr GetIntTxFixEcefResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxFixEcefResult>(ptr);
    }

    bool GetIntTxFixEcefResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxFixEcefResult::documentation() const { return Documentation; }


    double GetIntTxFixEcefResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetIntTxFixEcefResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetIntTxFixEcefResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetIntTxFixEcefResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetIntTxFixEcefResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetIntTxFixEcefResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetIntTxFixEcefResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxFixEcefResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxFixEcefResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxCircular
///
#include "gen/SetIntTxCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxCircular::CmdName = "SetIntTxCircular";
    const char* const SetIntTxCircular::Documentation = "Set interference transmitter circular trajectory";

    REGISTER_COMMAND_FACTORY(SetIntTxCircular);


    SetIntTxCircular::SetIntTxCircular()
      : CommandBase(CmdName)
    {}

    SetIntTxCircular::SetIntTxCircular(double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
      : CommandBase(CmdName)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setId(id);
      setOriginAngle(originAngle);
    }


    SetIntTxCircularPtr SetIntTxCircular::create(double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
    {
      return std::make_shared<SetIntTxCircular>(lat, lon, alt, radius, speed, clockwise, id, originAngle);
    }

    SetIntTxCircularPtr SetIntTxCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxCircular>(ptr);
    }

    bool SetIntTxCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string SetIntTxCircular::documentation() const { return Documentation; }


    int SetIntTxCircular::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxCircular::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetIntTxCircular::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCircular::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetIntTxCircular::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCircular::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetIntTxCircular::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCircular::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void SetIntTxCircular::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCircular::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void SetIntTxCircular::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetIntTxCircular::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void SetIntTxCircular::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxCircular::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxCircular::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> SetIntTxCircular::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void SetIntTxCircular::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxCircular
///
#include "gen/GetIntTxCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxCircular::CmdName = "GetIntTxCircular";
    const char* const GetIntTxCircular::Documentation = "Get interference transmitter circular trajectory";

    REGISTER_COMMAND_FACTORY(GetIntTxCircular);


    GetIntTxCircular::GetIntTxCircular()
      : CommandBase(CmdName)
    {}

    GetIntTxCircular::GetIntTxCircular(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxCircularPtr GetIntTxCircular::create(const std::string& id)
    {
      return std::make_shared<GetIntTxCircular>(id);
    }

    GetIntTxCircularPtr GetIntTxCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxCircular>(ptr);
    }

    bool GetIntTxCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxCircular::documentation() const { return Documentation; }


    int GetIntTxCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxCircular::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxCircular::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxCircularResult
///
#include "gen/GetIntTxCircularResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxCircularResult::CmdName = "GetIntTxCircularResult";
    const char* const GetIntTxCircularResult::Documentation = "Result of GetIntTxCircular.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxCircularResult);


    GetIntTxCircularResult::GetIntTxCircularResult()
      : CommandResult(CmdName)
    {}

    GetIntTxCircularResult::GetIntTxCircularResult(CommandBasePtr relatedCommand, double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
      : CommandResult(CmdName, relatedCommand)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setId(id);
      setOriginAngle(originAngle);
    }


    GetIntTxCircularResultPtr GetIntTxCircularResult::create(CommandBasePtr relatedCommand, double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
    {
      return std::make_shared<GetIntTxCircularResult>(relatedCommand, lat, lon, alt, radius, speed, clockwise, id, originAngle);
    }

    GetIntTxCircularResultPtr GetIntTxCircularResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxCircularResult>(ptr);
    }

    bool GetIntTxCircularResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string GetIntTxCircularResult::documentation() const { return Documentation; }


    double GetIntTxCircularResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetIntTxCircularResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCircularResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetIntTxCircularResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCircularResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetIntTxCircularResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCircularResult::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void GetIntTxCircularResult::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCircularResult::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void GetIntTxCircularResult::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIntTxCircularResult::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void GetIntTxCircularResult::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxCircularResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxCircularResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetIntTxCircularResult::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void GetIntTxCircularResult::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxHil
///
#include "gen/SetIntTxHil.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxHil::CmdName = "SetIntTxHil";
    const char* const SetIntTxHil::Documentation = "Set interference transmitter HIL trajectory";

    REGISTER_COMMAND_FACTORY(SetIntTxHil);


    SetIntTxHil::SetIntTxHil()
      : CommandBase(CmdName)
    {}

    SetIntTxHil::SetIntTxHil(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    SetIntTxHilPtr SetIntTxHil::create(const std::string& id)
    {
      return std::make_shared<SetIntTxHil>(id);
    }

    SetIntTxHilPtr SetIntTxHil::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxHil>(ptr);
    }

    bool SetIntTxHil::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxHil::documentation() const { return Documentation; }


    int SetIntTxHil::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetIntTxHil::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxHil::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BeginIntTxTrackDefinition
///
#include "gen/BeginIntTxTrackDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BeginIntTxTrackDefinition::CmdName = "BeginIntTxTrackDefinition";
    const char* const BeginIntTxTrackDefinition::Documentation = "Begins a new interference track definition. Actual track remains unchanged until\nEndIntTxTrackDefinition command is sent and successful. After this command, the\nclient must push time and position pairs to form a complete track. Once all the\npositions are sent, the client must send the command EndIntTxTrackDefinition.";

    REGISTER_COMMAND_FACTORY(BeginIntTxTrackDefinition);


    BeginIntTxTrackDefinition::BeginIntTxTrackDefinition()
      : CommandBase(CmdName)
    {}

    BeginIntTxTrackDefinition::BeginIntTxTrackDefinition(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    BeginIntTxTrackDefinitionPtr BeginIntTxTrackDefinition::create(const std::string& id)
    {
      return std::make_shared<BeginIntTxTrackDefinition>(id);
    }

    BeginIntTxTrackDefinitionPtr BeginIntTxTrackDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BeginIntTxTrackDefinition>(ptr);
    }

    bool BeginIntTxTrackDefinition::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string BeginIntTxTrackDefinition::documentation() const { return Documentation; }


    int BeginIntTxTrackDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string BeginIntTxTrackDefinition::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void BeginIntTxTrackDefinition::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of PushIntTxTrackEcef
///
#include "gen/PushIntTxTrackEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushIntTxTrackEcef::CmdName = "PushIntTxTrackEcef";
    const char* const PushIntTxTrackEcef::Documentation = "Push an interference track ecef node. Must be called after BeginIntTxTrackDefinition and before EndIntTxTrackDefinition.";

    REGISTER_COMMAND_FACTORY(PushIntTxTrackEcef);


    PushIntTxTrackEcef::PushIntTxTrackEcef()
      : CommandBase(CmdName)
    {}

    PushIntTxTrackEcef::PushIntTxTrackEcef(int time, double x, double y, double z, const std::string& id)
      : CommandBase(CmdName)
    {

      setTime(time);
      setX(x);
      setY(y);
      setZ(z);
      setId(id);
    }


    PushIntTxTrackEcefPtr PushIntTxTrackEcef::create(int time, double x, double y, double z, const std::string& id)
    {
      return std::make_shared<PushIntTxTrackEcef>(time, x, y, z, id);
    }

    PushIntTxTrackEcefPtr PushIntTxTrackEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushIntTxTrackEcef>(ptr);
    }

    bool PushIntTxTrackEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string PushIntTxTrackEcef::documentation() const { return Documentation; }


    int PushIntTxTrackEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int PushIntTxTrackEcef::time() const
    {
      return parse_json<int>::parse(m_values["Time"]);
    }

    void PushIntTxTrackEcef::setTime(int time)
    {
      m_values.AddMember("Time", parse_json<int>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushIntTxTrackEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushIntTxTrackEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushIntTxTrackEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string PushIntTxTrackEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void PushIntTxTrackEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of PushIntTxTrackEcefNed
///
#include "gen/PushIntTxTrackEcefNed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushIntTxTrackEcefNed::CmdName = "PushIntTxTrackEcefNed";
    const char* const PushIntTxTrackEcefNed::Documentation = "Push an interference track ecef and ned attitude node. Must be called after BeginIntTxTrackDefinition and before EndIntTxTrackDefinition.";

    REGISTER_COMMAND_FACTORY(PushIntTxTrackEcefNed);


    PushIntTxTrackEcefNed::PushIntTxTrackEcefNed()
      : CommandBase(CmdName)
    {}

    PushIntTxTrackEcefNed::PushIntTxTrackEcefNed(int time, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setTime(time);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    PushIntTxTrackEcefNedPtr PushIntTxTrackEcefNed::create(int time, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<PushIntTxTrackEcefNed>(time, x, y, z, yaw, pitch, roll, id);
    }

    PushIntTxTrackEcefNedPtr PushIntTxTrackEcefNed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushIntTxTrackEcefNed>(ptr);
    }

    bool PushIntTxTrackEcefNed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string PushIntTxTrackEcefNed::documentation() const { return Documentation; }


    int PushIntTxTrackEcefNed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int PushIntTxTrackEcefNed::time() const
    {
      return parse_json<int>::parse(m_values["Time"]);
    }

    void PushIntTxTrackEcefNed::setTime(int time)
    {
      m_values.AddMember("Time", parse_json<int>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushIntTxTrackEcefNed::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushIntTxTrackEcefNed::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushIntTxTrackEcefNed::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void PushIntTxTrackEcefNed::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void PushIntTxTrackEcefNed::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void PushIntTxTrackEcefNed::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string PushIntTxTrackEcefNed::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void PushIntTxTrackEcefNed::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EndIntTxTrackDefinition
///
#include "gen/EndIntTxTrackDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndIntTxTrackDefinition::CmdName = "EndIntTxTrackDefinition";
    const char* const EndIntTxTrackDefinition::Documentation = "This command completes the track started with BeginIntTxTrackDefinition command. If\nthe track is accepted, the current track in the configuration is replaced with\nthis new track. If the track is not accepted, the current track in the config\nremains unchanged.";

    REGISTER_COMMAND_FACTORY(EndIntTxTrackDefinition);


    EndIntTxTrackDefinition::EndIntTxTrackDefinition()
      : CommandBase(CmdName)
    {}

    EndIntTxTrackDefinition::EndIntTxTrackDefinition(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    EndIntTxTrackDefinitionPtr EndIntTxTrackDefinition::create(const std::string& id)
    {
      return std::make_shared<EndIntTxTrackDefinition>(id);
    }

    EndIntTxTrackDefinitionPtr EndIntTxTrackDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndIntTxTrackDefinition>(ptr);
    }

    bool EndIntTxTrackDefinition::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EndIntTxTrackDefinition::documentation() const { return Documentation; }


    int EndIntTxTrackDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EndIntTxTrackDefinition::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EndIntTxTrackDefinition::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EndIntTxTrackDefinitionResult
///
#include "gen/EndIntTxTrackDefinitionResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndIntTxTrackDefinitionResult::CmdName = "EndIntTxTrackDefinitionResult";
    const char* const EndIntTxTrackDefinitionResult::Documentation = "EndIntTxTrackDefinition Result with created track informations.";

    REGISTER_COMMAND_RESULT_FACTORY(EndIntTxTrackDefinitionResult);


    EndIntTxTrackDefinitionResult::EndIntTxTrackDefinitionResult()
      : CommandResult(CmdName)
    {}

    EndIntTxTrackDefinitionResult::EndIntTxTrackDefinitionResult(CommandBasePtr relatedCommand, int count, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setCount(count);
      setId(id);
    }


    EndIntTxTrackDefinitionResultPtr EndIntTxTrackDefinitionResult::create(CommandBasePtr relatedCommand, int count, const std::string& id)
    {
      return std::make_shared<EndIntTxTrackDefinitionResult>(relatedCommand, count, id);
    }

    EndIntTxTrackDefinitionResultPtr EndIntTxTrackDefinitionResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndIntTxTrackDefinitionResult>(ptr);
    }

    bool EndIntTxTrackDefinitionResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Count"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EndIntTxTrackDefinitionResult::documentation() const { return Documentation; }


    int EndIntTxTrackDefinitionResult::count() const
    {
      return parse_json<int>::parse(m_values["Count"]);
    }

    void EndIntTxTrackDefinitionResult::setCount(int count)
    {
      m_values.AddMember("Count", parse_json<int>::format(count, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EndIntTxTrackDefinitionResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EndIntTxTrackDefinitionResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportNmeaIntTxTrack
///
#include "gen/ImportNmeaIntTxTrack.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportNmeaIntTxTrack::CmdName = "ImportNmeaIntTxTrack";
    const char* const ImportNmeaIntTxTrack::Documentation = "Import NMEA interference track file";

    REGISTER_COMMAND_FACTORY(ImportNmeaIntTxTrack);


    ImportNmeaIntTxTrack::ImportNmeaIntTxTrack()
      : CommandBase(CmdName)
    {}

    ImportNmeaIntTxTrack::ImportNmeaIntTxTrack(const std::string& path, const std::string& id)
      : CommandBase(CmdName)
    {

      setPath(path);
      setId(id);
    }


    ImportNmeaIntTxTrackPtr ImportNmeaIntTxTrack::create(const std::string& path, const std::string& id)
    {
      return std::make_shared<ImportNmeaIntTxTrack>(path, id);
    }

    ImportNmeaIntTxTrackPtr ImportNmeaIntTxTrack::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportNmeaIntTxTrack>(ptr);
    }

    bool ImportNmeaIntTxTrack::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ImportNmeaIntTxTrack::documentation() const { return Documentation; }


    int ImportNmeaIntTxTrack::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportNmeaIntTxTrack::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportNmeaIntTxTrack::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportNmeaIntTxTrack::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ImportNmeaIntTxTrack::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableIntTxTrajectorySmoothing
///
#include "gen/EnableIntTxTrajectorySmoothing.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableIntTxTrajectorySmoothing::CmdName = "EnableIntTxTrajectorySmoothing";
    const char* const EnableIntTxTrajectorySmoothing::Documentation = "Set trajectory smoothing for interference Track enabled or disabled";

    REGISTER_COMMAND_FACTORY(EnableIntTxTrajectorySmoothing);


    EnableIntTxTrajectorySmoothing::EnableIntTxTrajectorySmoothing()
      : CommandBase(CmdName)
    {}

    EnableIntTxTrajectorySmoothing::EnableIntTxTrajectorySmoothing(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    EnableIntTxTrajectorySmoothingPtr EnableIntTxTrajectorySmoothing::create(bool enabled, const std::string& id)
    {
      return std::make_shared<EnableIntTxTrajectorySmoothing>(enabled, id);
    }

    EnableIntTxTrajectorySmoothingPtr EnableIntTxTrajectorySmoothing::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableIntTxTrajectorySmoothing>(ptr);
    }

    bool EnableIntTxTrajectorySmoothing::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EnableIntTxTrajectorySmoothing::documentation() const { return Documentation; }


    int EnableIntTxTrajectorySmoothing::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableIntTxTrajectorySmoothing::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableIntTxTrajectorySmoothing::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableIntTxTrajectorySmoothing::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EnableIntTxTrajectorySmoothing::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxTrajectorySmoothingEnabled
///
#include "gen/IsIntTxTrajectorySmoothingEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxTrajectorySmoothingEnabled::CmdName = "IsIntTxTrajectorySmoothingEnabled";
    const char* const IsIntTxTrajectorySmoothingEnabled::Documentation = "Get trajectory smoothing for interference Track enabled or disabled";

    REGISTER_COMMAND_FACTORY(IsIntTxTrajectorySmoothingEnabled);


    IsIntTxTrajectorySmoothingEnabled::IsIntTxTrajectorySmoothingEnabled()
      : CommandBase(CmdName)
    {}

    IsIntTxTrajectorySmoothingEnabled::IsIntTxTrajectorySmoothingEnabled(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsIntTxTrajectorySmoothingEnabledPtr IsIntTxTrajectorySmoothingEnabled::create(const std::string& id)
    {
      return std::make_shared<IsIntTxTrajectorySmoothingEnabled>(id);
    }

    IsIntTxTrajectorySmoothingEnabledPtr IsIntTxTrajectorySmoothingEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxTrajectorySmoothingEnabled>(ptr);
    }

    bool IsIntTxTrajectorySmoothingEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxTrajectorySmoothingEnabled::documentation() const { return Documentation; }


    int IsIntTxTrajectorySmoothingEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsIntTxTrajectorySmoothingEnabled::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxTrajectorySmoothingEnabled::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxTrajectorySmoothingEnabledResult
///
#include "gen/IsIntTxTrajectorySmoothingEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxTrajectorySmoothingEnabledResult::CmdName = "IsIntTxTrajectorySmoothingEnabledResult";
    const char* const IsIntTxTrajectorySmoothingEnabledResult::Documentation = "Result of IsIntTxTrajectorySmoothingEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsIntTxTrajectorySmoothingEnabledResult);


    IsIntTxTrajectorySmoothingEnabledResult::IsIntTxTrajectorySmoothingEnabledResult()
      : CommandResult(CmdName)
    {}

    IsIntTxTrajectorySmoothingEnabledResult::IsIntTxTrajectorySmoothingEnabledResult(CommandBasePtr relatedCommand, bool enabled, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setId(id);
    }


    IsIntTxTrajectorySmoothingEnabledResultPtr IsIntTxTrajectorySmoothingEnabledResult::create(CommandBasePtr relatedCommand, bool enabled, const std::string& id)
    {
      return std::make_shared<IsIntTxTrajectorySmoothingEnabledResult>(relatedCommand, enabled, id);
    }

    IsIntTxTrajectorySmoothingEnabledResultPtr IsIntTxTrajectorySmoothingEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxTrajectorySmoothingEnabledResult>(ptr);
    }

    bool IsIntTxTrajectorySmoothingEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxTrajectorySmoothingEnabledResult::documentation() const { return Documentation; }


    bool IsIntTxTrajectorySmoothingEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsIntTxTrajectorySmoothingEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsIntTxTrajectorySmoothingEnabledResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxTrajectorySmoothingEnabledResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ForceIntTxAttitudeToZero
///
#include "gen/ForceIntTxAttitudeToZero.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ForceIntTxAttitudeToZero::CmdName = "ForceIntTxAttitudeToZero";
    const char* const ForceIntTxAttitudeToZero::Documentation = "Set force interference vehicle yaw, pitch and roll to zero enabled or disabled";

    REGISTER_COMMAND_FACTORY(ForceIntTxAttitudeToZero);


    ForceIntTxAttitudeToZero::ForceIntTxAttitudeToZero()
      : CommandBase(CmdName)
    {}

    ForceIntTxAttitudeToZero::ForceIntTxAttitudeToZero(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    ForceIntTxAttitudeToZeroPtr ForceIntTxAttitudeToZero::create(bool enabled, const std::string& id)
    {
      return std::make_shared<ForceIntTxAttitudeToZero>(enabled, id);
    }

    ForceIntTxAttitudeToZeroPtr ForceIntTxAttitudeToZero::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ForceIntTxAttitudeToZero>(ptr);
    }

    bool ForceIntTxAttitudeToZero::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ForceIntTxAttitudeToZero::documentation() const { return Documentation; }


    int ForceIntTxAttitudeToZero::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ForceIntTxAttitudeToZero::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void ForceIntTxAttitudeToZero::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ForceIntTxAttitudeToZero::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ForceIntTxAttitudeToZero::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxAttitudeToZeroForced
///
#include "gen/IsIntTxAttitudeToZeroForced.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxAttitudeToZeroForced::CmdName = "IsIntTxAttitudeToZeroForced";
    const char* const IsIntTxAttitudeToZeroForced::Documentation = "Get force interference vehicle yaw, pitch and roll to zero enabled or disabled";

    REGISTER_COMMAND_FACTORY(IsIntTxAttitudeToZeroForced);


    IsIntTxAttitudeToZeroForced::IsIntTxAttitudeToZeroForced()
      : CommandBase(CmdName)
    {}

    IsIntTxAttitudeToZeroForced::IsIntTxAttitudeToZeroForced(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsIntTxAttitudeToZeroForcedPtr IsIntTxAttitudeToZeroForced::create(const std::string& id)
    {
      return std::make_shared<IsIntTxAttitudeToZeroForced>(id);
    }

    IsIntTxAttitudeToZeroForcedPtr IsIntTxAttitudeToZeroForced::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxAttitudeToZeroForced>(ptr);
    }

    bool IsIntTxAttitudeToZeroForced::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxAttitudeToZeroForced::documentation() const { return Documentation; }


    int IsIntTxAttitudeToZeroForced::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsIntTxAttitudeToZeroForced::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxAttitudeToZeroForced::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxAttitudeToZeroForcedResult
///
#include "gen/IsIntTxAttitudeToZeroForcedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxAttitudeToZeroForcedResult::CmdName = "IsIntTxAttitudeToZeroForcedResult";
    const char* const IsIntTxAttitudeToZeroForcedResult::Documentation = "Result of IsIntTxAttitudeToZeroForced.";

    REGISTER_COMMAND_RESULT_FACTORY(IsIntTxAttitudeToZeroForcedResult);


    IsIntTxAttitudeToZeroForcedResult::IsIntTxAttitudeToZeroForcedResult()
      : CommandResult(CmdName)
    {}

    IsIntTxAttitudeToZeroForcedResult::IsIntTxAttitudeToZeroForcedResult(CommandBasePtr relatedCommand, bool enabled, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setId(id);
    }


    IsIntTxAttitudeToZeroForcedResultPtr IsIntTxAttitudeToZeroForcedResult::create(CommandBasePtr relatedCommand, bool enabled, const std::string& id)
    {
      return std::make_shared<IsIntTxAttitudeToZeroForcedResult>(relatedCommand, enabled, id);
    }

    IsIntTxAttitudeToZeroForcedResultPtr IsIntTxAttitudeToZeroForcedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxAttitudeToZeroForcedResult>(ptr);
    }

    bool IsIntTxAttitudeToZeroForcedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxAttitudeToZeroForcedResult::documentation() const { return Documentation; }


    bool IsIntTxAttitudeToZeroForcedResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsIntTxAttitudeToZeroForcedResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsIntTxAttitudeToZeroForcedResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxAttitudeToZeroForcedResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxVehicleType
///
#include "gen/SetIntTxVehicleType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxVehicleType::CmdName = "SetIntTxVehicleType";
    const char* const SetIntTxVehicleType::Documentation = "Set Set interference vehicle type for Track Trajectory";

    REGISTER_COMMAND_FACTORY(SetIntTxVehicleType);


    SetIntTxVehicleType::SetIntTxVehicleType()
      : CommandBase(CmdName)
    {}

    SetIntTxVehicleType::SetIntTxVehicleType(const std::string& type, const std::string& id)
      : CommandBase(CmdName)
    {

      setType(type);
      setId(id);
    }


    SetIntTxVehicleTypePtr SetIntTxVehicleType::create(const std::string& type, const std::string& id)
    {
      return std::make_shared<SetIntTxVehicleType>(type, id);
    }

    SetIntTxVehicleTypePtr SetIntTxVehicleType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxVehicleType>(ptr);
    }

    bool SetIntTxVehicleType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxVehicleType::documentation() const { return Documentation; }


    int SetIntTxVehicleType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetIntTxVehicleType::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetIntTxVehicleType::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxVehicleType::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxVehicleType::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxVehicleType
///
#include "gen/GetIntTxVehicleType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxVehicleType::CmdName = "GetIntTxVehicleType";
    const char* const GetIntTxVehicleType::Documentation = "Get Set interference vehicle type for Track Trajectory";

    REGISTER_COMMAND_FACTORY(GetIntTxVehicleType);


    GetIntTxVehicleType::GetIntTxVehicleType()
      : CommandBase(CmdName)
    {}

    GetIntTxVehicleType::GetIntTxVehicleType(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxVehicleTypePtr GetIntTxVehicleType::create(const std::string& id)
    {
      return std::make_shared<GetIntTxVehicleType>(id);
    }

    GetIntTxVehicleTypePtr GetIntTxVehicleType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxVehicleType>(ptr);
    }

    bool GetIntTxVehicleType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxVehicleType::documentation() const { return Documentation; }


    int GetIntTxVehicleType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxVehicleType::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxVehicleType::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxVehicleTypeResult
///
#include "gen/GetIntTxVehicleTypeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxVehicleTypeResult::CmdName = "GetIntTxVehicleTypeResult";
    const char* const GetIntTxVehicleTypeResult::Documentation = "Result of GetIntTxVehicleType.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxVehicleTypeResult);


    GetIntTxVehicleTypeResult::GetIntTxVehicleTypeResult()
      : CommandResult(CmdName)
    {}

    GetIntTxVehicleTypeResult::GetIntTxVehicleTypeResult(CommandBasePtr relatedCommand, const std::string& type, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setId(id);
    }


    GetIntTxVehicleTypeResultPtr GetIntTxVehicleTypeResult::create(CommandBasePtr relatedCommand, const std::string& type, const std::string& id)
    {
      return std::make_shared<GetIntTxVehicleTypeResult>(relatedCommand, type, id);
    }

    GetIntTxVehicleTypeResultPtr GetIntTxVehicleTypeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxVehicleTypeResult>(ptr);
    }

    bool GetIntTxVehicleTypeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxVehicleTypeResult::documentation() const { return Documentation; }


    std::string GetIntTxVehicleTypeResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetIntTxVehicleTypeResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxVehicleTypeResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxVehicleTypeResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxTrajectory
///
#include "gen/GetIntTxTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxTrajectory::CmdName = "GetIntTxTrajectory";
    const char* const GetIntTxTrajectory::Documentation = "Get interference transmitter trajectory.";

    REGISTER_COMMAND_FACTORY(GetIntTxTrajectory);


    GetIntTxTrajectory::GetIntTxTrajectory()
      : CommandBase(CmdName)
    {}

    GetIntTxTrajectory::GetIntTxTrajectory(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxTrajectoryPtr GetIntTxTrajectory::create(const std::string& id)
    {
      return std::make_shared<GetIntTxTrajectory>(id);
    }

    GetIntTxTrajectoryPtr GetIntTxTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxTrajectory>(ptr);
    }

    bool GetIntTxTrajectory::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxTrajectory::documentation() const { return Documentation; }


    int GetIntTxTrajectory::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxTrajectory::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxTrajectory::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxTrajectoryResult
///
#include "gen/GetIntTxTrajectoryResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxTrajectoryResult::CmdName = "GetIntTxTrajectoryResult";
    const char* const GetIntTxTrajectoryResult::Documentation = "Result of GetIntTxTrajectory.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxTrajectoryResult);


    GetIntTxTrajectoryResult::GetIntTxTrajectoryResult()
      : CommandResult(CmdName)
    {}

    GetIntTxTrajectoryResult::GetIntTxTrajectoryResult(CommandBasePtr relatedCommand, const std::string& trajectoryType, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setTrajectoryType(trajectoryType);
      setId(id);
    }


    GetIntTxTrajectoryResultPtr GetIntTxTrajectoryResult::create(CommandBasePtr relatedCommand, const std::string& trajectoryType, const std::string& id)
    {
      return std::make_shared<GetIntTxTrajectoryResult>(relatedCommand, trajectoryType, id);
    }

    GetIntTxTrajectoryResultPtr GetIntTxTrajectoryResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxTrajectoryResult>(ptr);
    }

    bool GetIntTxTrajectoryResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TrajectoryType"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxTrajectoryResult::documentation() const { return Documentation; }


    std::string GetIntTxTrajectoryResult::trajectoryType() const
    {
      return parse_json<std::string>::parse(m_values["TrajectoryType"]);
    }

    void GetIntTxTrajectoryResult::setTrajectoryType(const std::string& trajectoryType)
    {
      m_values.AddMember("TrajectoryType", parse_json<std::string>::format(trajectoryType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxTrajectoryResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxTrajectoryResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxAntenna
///
#include "gen/SetIntTxAntenna.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxAntenna::CmdName = "SetIntTxAntenna";
    const char* const SetIntTxAntenna::Documentation = "Set transmitter antenna pattern.";

    REGISTER_COMMAND_FACTORY(SetIntTxAntenna);


    SetIntTxAntenna::SetIntTxAntenna()
      : CommandBase(CmdName)
    {}

    SetIntTxAntenna::SetIntTxAntenna(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
      : CommandBase(CmdName)
    {

      setGain(gain);
      setType(type);
      setId(id);
    }


    SetIntTxAntennaPtr SetIntTxAntenna::create(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
    {
      return std::make_shared<SetIntTxAntenna>(gain, type, id);
    }

    SetIntTxAntennaPtr SetIntTxAntenna::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxAntenna>(ptr);
    }

    bool SetIntTxAntenna::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxAntenna::documentation() const { return Documentation; }


    int SetIntTxAntenna::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetIntTxAntenna::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void SetIntTxAntenna::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetIntTxAntenna::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetIntTxAntenna::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxAntenna::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxAntenna::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAntenna
///
#include "gen/GetIntTxAntenna.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAntenna::CmdName = "GetIntTxAntenna";
    const char* const GetIntTxAntenna::Documentation = "Get transmitter antenna pattern.";

    REGISTER_COMMAND_FACTORY(GetIntTxAntenna);


    GetIntTxAntenna::GetIntTxAntenna()
      : CommandBase(CmdName)
    {}

    GetIntTxAntenna::GetIntTxAntenna(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxAntennaPtr GetIntTxAntenna::create(const std::string& id)
    {
      return std::make_shared<GetIntTxAntenna>(id);
    }

    GetIntTxAntennaPtr GetIntTxAntenna::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAntenna>(ptr);
    }

    bool GetIntTxAntenna::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxAntenna::documentation() const { return Documentation; }


    int GetIntTxAntenna::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxAntenna::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxAntenna::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAntennaResult
///
#include "gen/GetIntTxAntennaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAntennaResult::CmdName = "GetIntTxAntennaResult";
    const char* const GetIntTxAntennaResult::Documentation = "Result of GetIntTxAntenna.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxAntennaResult);


    GetIntTxAntennaResult::GetIntTxAntennaResult()
      : CommandResult(CmdName)
    {}

    GetIntTxAntennaResult::GetIntTxAntennaResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
      setType(type);
      setId(id);
    }


    GetIntTxAntennaResultPtr GetIntTxAntennaResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
    {
      return std::make_shared<GetIntTxAntennaResult>(relatedCommand, gain, type, id);
    }

    GetIntTxAntennaResultPtr GetIntTxAntennaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAntennaResult>(ptr);
    }

    bool GetIntTxAntennaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxAntennaResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetIntTxAntennaResult::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void GetIntTxAntennaResult::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetIntTxAntennaResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetIntTxAntennaResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAntennaResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxAntennaResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxAntennaOffset
///
#include "gen/SetIntTxAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxAntennaOffset::CmdName = "SetIntTxAntennaOffset";
    const char* const SetIntTxAntennaOffset::Documentation = "Set antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the transmitter trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(SetIntTxAntennaOffset);


    SetIntTxAntennaOffset::SetIntTxAntennaOffset()
      : CommandBase(CmdName)
    {}

    SetIntTxAntennaOffset::SetIntTxAntennaOffset(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetIntTxAntennaOffsetPtr SetIntTxAntennaOffset::create(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<SetIntTxAntennaOffset>(x, y, z, yaw, pitch, roll, id);
    }

    SetIntTxAntennaOffsetPtr SetIntTxAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxAntennaOffset>(ptr);
    }

    bool SetIntTxAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxAntennaOffset::documentation() const { return Documentation; }


    int SetIntTxAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxAntennaOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetIntTxAntennaOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetIntTxAntennaOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetIntTxAntennaOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetIntTxAntennaOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetIntTxAntennaOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetIntTxAntennaOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxAntennaOffset::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxAntennaOffset::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAntennaOffset
///
#include "gen/GetIntTxAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAntennaOffset::CmdName = "GetIntTxAntennaOffset";
    const char* const GetIntTxAntennaOffset::Documentation = "Get antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the transmitter trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(GetIntTxAntennaOffset);


    GetIntTxAntennaOffset::GetIntTxAntennaOffset()
      : CommandBase(CmdName)
    {}

    GetIntTxAntennaOffset::GetIntTxAntennaOffset(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxAntennaOffsetPtr GetIntTxAntennaOffset::create(const std::string& id)
    {
      return std::make_shared<GetIntTxAntennaOffset>(id);
    }

    GetIntTxAntennaOffsetPtr GetIntTxAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAntennaOffset>(ptr);
    }

    bool GetIntTxAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxAntennaOffset::documentation() const { return Documentation; }


    int GetIntTxAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxAntennaOffset::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxAntennaOffset::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAntennaOffsetResult
///
#include "gen/GetIntTxAntennaOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAntennaOffsetResult::CmdName = "GetIntTxAntennaOffsetResult";
    const char* const GetIntTxAntennaOffsetResult::Documentation = "Result of GetIntTxAntennaOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxAntennaOffsetResult);


    GetIntTxAntennaOffsetResult::GetIntTxAntennaOffsetResult()
      : CommandResult(CmdName)
    {}

    GetIntTxAntennaOffsetResult::GetIntTxAntennaOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetIntTxAntennaOffsetResultPtr GetIntTxAntennaOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<GetIntTxAntennaOffsetResult>(relatedCommand, x, y, z, yaw, pitch, roll, id);
    }

    GetIntTxAntennaOffsetResultPtr GetIntTxAntennaOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAntennaOffsetResult>(ptr);
    }

    bool GetIntTxAntennaOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxAntennaOffsetResult::documentation() const { return Documentation; }


    double GetIntTxAntennaOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetIntTxAntennaOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetIntTxAntennaOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetIntTxAntennaOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetIntTxAntennaOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetIntTxAntennaOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetIntTxAntennaOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAntennaOffsetResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxAntennaOffsetResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveIntTx
///
#include "gen/RemoveIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveIntTx::CmdName = "RemoveIntTx";
    const char* const RemoveIntTx::Documentation = "Removes the interference transmitter. See EnableIntTx if all you want is to\ndisable the interference temporarily.";

    REGISTER_COMMAND_FACTORY(RemoveIntTx);


    RemoveIntTx::RemoveIntTx()
      : CommandBase(CmdName)
    {}

    RemoveIntTx::RemoveIntTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveIntTxPtr RemoveIntTx::create(const std::string& id)
    {
      return std::make_shared<RemoveIntTx>(id);
    }

    RemoveIntTxPtr RemoveIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveIntTx>(ptr);
    }

    bool RemoveIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveIntTx::documentation() const { return Documentation; }


    int RemoveIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RemoveIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllIntTx
///
#include "gen/RemoveAllIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllIntTx::CmdName = "RemoveAllIntTx";
    const char* const RemoveAllIntTx::Documentation = "Remove all the interference transmitters.";

    REGISTER_COMMAND_FACTORY(RemoveAllIntTx);


    RemoveAllIntTx::RemoveAllIntTx()
      : CommandBase(CmdName)
    {

    }


    RemoveAllIntTxPtr RemoveAllIntTx::create()
    {
      return std::make_shared<RemoveAllIntTx>();
    }

    RemoveAllIntTxPtr RemoveAllIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllIntTx>(ptr);
    }

    bool RemoveAllIntTx::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllIntTx::documentation() const { return Documentation; }


    int RemoveAllIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAllSignalsFromIntTx
///
#include "gen/GetAllSignalsFromIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSignalsFromIntTx::CmdName = "GetAllSignalsFromIntTx";
    const char* const GetAllSignalsFromIntTx::Documentation = "Get all signal ID for this interference transmitters.";

    REGISTER_COMMAND_FACTORY(GetAllSignalsFromIntTx);


    GetAllSignalsFromIntTx::GetAllSignalsFromIntTx()
      : CommandBase(CmdName)
    {}

    GetAllSignalsFromIntTx::GetAllSignalsFromIntTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetAllSignalsFromIntTxPtr GetAllSignalsFromIntTx::create(const std::string& id)
    {
      return std::make_shared<GetAllSignalsFromIntTx>(id);
    }

    GetAllSignalsFromIntTxPtr GetAllSignalsFromIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSignalsFromIntTx>(ptr);
    }

    bool GetAllSignalsFromIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetAllSignalsFromIntTx::documentation() const { return Documentation; }


    int GetAllSignalsFromIntTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSignalsFromIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetAllSignalsFromIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSignalsFromIntTxResult
///
#include "gen/GetAllSignalsFromIntTxResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSignalsFromIntTxResult::CmdName = "GetAllSignalsFromIntTxResult";
    const char* const GetAllSignalsFromIntTxResult::Documentation = "Result of GetAllSignalsFromIntTx.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllSignalsFromIntTxResult);


    GetAllSignalsFromIntTxResult::GetAllSignalsFromIntTxResult()
      : CommandResult(CmdName)
    {}

    GetAllSignalsFromIntTxResult::GetAllSignalsFromIntTxResult(CommandBasePtr relatedCommand, const std::string& id, const std::vector<std::string>& idsSignal)
      : CommandResult(CmdName, relatedCommand)
    {

      setId(id);
      setIdsSignal(idsSignal);
    }


    GetAllSignalsFromIntTxResultPtr GetAllSignalsFromIntTxResult::create(CommandBasePtr relatedCommand, const std::string& id, const std::vector<std::string>& idsSignal)
    {
      return std::make_shared<GetAllSignalsFromIntTxResult>(relatedCommand, id, idsSignal);
    }

    GetAllSignalsFromIntTxResultPtr GetAllSignalsFromIntTxResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSignalsFromIntTxResult>(ptr);
    }

    bool GetAllSignalsFromIntTxResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["IdsSignal"])
        ;

    }

    std::string GetAllSignalsFromIntTxResult::documentation() const { return Documentation; }


    std::string GetAllSignalsFromIntTxResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetAllSignalsFromIntTxResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetAllSignalsFromIntTxResult::idsSignal() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["IdsSignal"]);
    }

    void GetAllSignalsFromIntTxResult::setIdsSignal(const std::vector<std::string>& idsSignal)
    {
      m_values.AddMember("IdsSignal", parse_json<std::vector<std::string>>::format(idsSignal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSignalFromIntTx
///
#include "gen/GetSignalFromIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSignalFromIntTx::CmdName = "GetSignalFromIntTx";
    const char* const GetSignalFromIntTx::Documentation = "Get all signal ID from this interference transmitters and this signal type. If the signal type is invalid, get the IDs of CW type.";

    REGISTER_COMMAND_FACTORY(GetSignalFromIntTx);


    GetSignalFromIntTx::GetSignalFromIntTx()
      : CommandBase(CmdName)
    {}

    GetSignalFromIntTx::GetSignalFromIntTx(const std::string& idTransmitter, const std::string& signalType)
      : CommandBase(CmdName)
    {

      setIdTransmitter(idTransmitter);
      setSignalType(signalType);
    }


    GetSignalFromIntTxPtr GetSignalFromIntTx::create(const std::string& idTransmitter, const std::string& signalType)
    {
      return std::make_shared<GetSignalFromIntTx>(idTransmitter, signalType);
    }

    GetSignalFromIntTxPtr GetSignalFromIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSignalFromIntTx>(ptr);
    }

    bool GetSignalFromIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["IdTransmitter"])
          && parse_json<std::string>::is_valid(m_values["SignalType"])
        ;

    }

    std::string GetSignalFromIntTx::documentation() const { return Documentation; }


    int GetSignalFromIntTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSignalFromIntTx::idTransmitter() const
    {
      return parse_json<std::string>::parse(m_values["IdTransmitter"]);
    }

    void GetSignalFromIntTx::setIdTransmitter(const std::string& idTransmitter)
    {
      m_values.AddMember("IdTransmitter", parse_json<std::string>::format(idTransmitter, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSignalFromIntTx::signalType() const
    {
      return parse_json<std::string>::parse(m_values["SignalType"]);
    }

    void GetSignalFromIntTx::setSignalType(const std::string& signalType)
    {
      m_values.AddMember("SignalType", parse_json<std::string>::format(signalType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSignalFromIntTxResult
///
#include "gen/GetSignalFromIntTxResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSignalFromIntTxResult::CmdName = "GetSignalFromIntTxResult";
    const char* const GetSignalFromIntTxResult::Documentation = "Result of GetSignalFromIntTx.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSignalFromIntTxResult);


    GetSignalFromIntTxResult::GetSignalFromIntTxResult()
      : CommandResult(CmdName)
    {}

    GetSignalFromIntTxResult::GetSignalFromIntTxResult(CommandBasePtr relatedCommand, const std::string& idTransmitter, const std::string& signalType, const std::vector<std::string>& idsSignal)
      : CommandResult(CmdName, relatedCommand)
    {

      setIdTransmitter(idTransmitter);
      setSignalType(signalType);
      setIdsSignal(idsSignal);
    }


    GetSignalFromIntTxResultPtr GetSignalFromIntTxResult::create(CommandBasePtr relatedCommand, const std::string& idTransmitter, const std::string& signalType, const std::vector<std::string>& idsSignal)
    {
      return std::make_shared<GetSignalFromIntTxResult>(relatedCommand, idTransmitter, signalType, idsSignal);
    }

    GetSignalFromIntTxResultPtr GetSignalFromIntTxResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSignalFromIntTxResult>(ptr);
    }

    bool GetSignalFromIntTxResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["IdTransmitter"])
          && parse_json<std::string>::is_valid(m_values["SignalType"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["IdsSignal"])
        ;

    }

    std::string GetSignalFromIntTxResult::documentation() const { return Documentation; }


    std::string GetSignalFromIntTxResult::idTransmitter() const
    {
      return parse_json<std::string>::parse(m_values["IdTransmitter"]);
    }

    void GetSignalFromIntTxResult::setIdTransmitter(const std::string& idTransmitter)
    {
      m_values.AddMember("IdTransmitter", parse_json<std::string>::format(idTransmitter, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSignalFromIntTxResult::signalType() const
    {
      return parse_json<std::string>::parse(m_values["SignalType"]);
    }

    void GetSignalFromIntTxResult::setSignalType(const std::string& signalType)
    {
      m_values.AddMember("SignalType", parse_json<std::string>::format(signalType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetSignalFromIntTxResult::idsSignal() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["IdsSignal"]);
    }

    void GetSignalFromIntTxResult::setIdsSignal(const std::vector<std::string>& idsSignal)
    {
      m_values.AddMember("IdsSignal", parse_json<std::vector<std::string>>::format(idsSignal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxCW
///
#include "gen/SetIntTxCW.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxCW::CmdName = "SetIntTxCW";
    const char* const SetIntTxCW::Documentation = "Set continuous wave (CW) signal to interference transmitter. A transmitter can combine\nmultiple signals of different types to create complex waveform. The CW id (SignalId) can be an empty\nstring. In such case, Skydel will assign a unique ID. If the signal id is already in use for the\nspecified transmitted, the existing signal is updated, ortherwise a new signal is added.";

    REGISTER_COMMAND_FACTORY(SetIntTxCW);


    SetIntTxCW::SetIntTxCW()
      : CommandBase(CmdName)
    {}

    SetIntTxCW::SetIntTxCW(bool enabled, double centralFreq, double power, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<double>& initialPhaseOffset, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setInitialPhaseOffset(initialPhaseOffset);
      setGroup(group);
    }


    SetIntTxCWPtr SetIntTxCW::create(bool enabled, double centralFreq, double power, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<double>& initialPhaseOffset, const Sdx::optional<int>& group)
    {
      return std::make_shared<SetIntTxCW>(enabled, centralFreq, power, transmitterId, signalId, initialPhaseOffset, group);
    }

    SetIntTxCWPtr SetIntTxCW::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxCW>(ptr);
    }

    bool SetIntTxCW::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["InitialPhaseOffset"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxCW::documentation() const { return Documentation; }


    int SetIntTxCW::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxCW::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxCW::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCW::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxCW::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCW::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxCW::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxCW::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxCW::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxCW::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxCW::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> SetIntTxCW::initialPhaseOffset() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["InitialPhaseOffset"]);
    }

    void SetIntTxCW::setInitialPhaseOffset(const Sdx::optional<double>& initialPhaseOffset)
    {
      m_values.AddMember("InitialPhaseOffset", parse_json<Sdx::optional<double>>::format(initialPhaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxCW::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxCW::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxCW
///
#include "gen/GetIntTxCW.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxCW::CmdName = "GetIntTxCW";
    const char* const GetIntTxCW::Documentation = "Get informations about the CW signal of the transmitter.";

    REGISTER_COMMAND_FACTORY(GetIntTxCW);


    GetIntTxCW::GetIntTxCW()
      : CommandBase(CmdName)
    {}

    GetIntTxCW::GetIntTxCW(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxCWPtr GetIntTxCW::create(const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<GetIntTxCW>(transmitterId, signalId);
    }

    GetIntTxCWPtr GetIntTxCW::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxCW>(ptr);
    }

    bool GetIntTxCW::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxCW::documentation() const { return Documentation; }


    int GetIntTxCW::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxCW::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxCW::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxCW::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxCW::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxCWResult
///
#include "gen/GetIntTxCWResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxCWResult::CmdName = "GetIntTxCWResult";
    const char* const GetIntTxCWResult::Documentation = "Result of GetIntTxCW.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxCWResult);


    GetIntTxCWResult::GetIntTxCWResult()
      : CommandResult(CmdName)
    {}

    GetIntTxCWResult::GetIntTxCWResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<double>& initialPhaseOffset, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setInitialPhaseOffset(initialPhaseOffset);
      setGroup(group);
    }


    GetIntTxCWResultPtr GetIntTxCWResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<double>& initialPhaseOffset, const Sdx::optional<int>& group)
    {
      return std::make_shared<GetIntTxCWResult>(relatedCommand, enabled, centralFreq, power, transmitterId, signalId, initialPhaseOffset, group);
    }

    GetIntTxCWResultPtr GetIntTxCWResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxCWResult>(ptr);
    }

    bool GetIntTxCWResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["InitialPhaseOffset"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxCWResult::documentation() const { return Documentation; }


    bool GetIntTxCWResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxCWResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCWResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxCWResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCWResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxCWResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxCWResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxCWResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxCWResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxCWResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetIntTxCWResult::initialPhaseOffset() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["InitialPhaseOffset"]);
    }

    void GetIntTxCWResult::setInitialPhaseOffset(const Sdx::optional<double>& initialPhaseOffset)
    {
      m_values.AddMember("InitialPhaseOffset", parse_json<Sdx::optional<double>>::format(initialPhaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxCWResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxCWResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxChirp
///
#include "gen/SetIntTxChirp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxChirp::CmdName = "SetIntTxChirp";
    const char* const SetIntTxChirp::Documentation = "Set Chirp signal to interference transmitter. A transmitter can combine\nmultiple signals of different types to create complex waveform. The signal id (SignalId) can be an empty\nstring. In such case, Skydel will assign a unique ID. If the signal id is already in use for the\nspecified transmitted, the existing signal is updated, ortherwise a new signal is added.";

    REGISTER_COMMAND_FACTORY(SetIntTxChirp);


    SetIntTxChirp::SetIntTxChirp()
      : CommandBase(CmdName)
    {}

    SetIntTxChirp::SetIntTxChirp(bool enabled, double centralFreq, double power, double bandwidth, double sweepTime, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setSweepTime(sweepTime);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    SetIntTxChirpPtr SetIntTxChirp::create(bool enabled, double centralFreq, double power, double bandwidth, double sweepTime, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return std::make_shared<SetIntTxChirp>(enabled, centralFreq, power, bandwidth, sweepTime, transmitterId, signalId, group);
    }

    SetIntTxChirpPtr SetIntTxChirp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxChirp>(ptr);
    }

    bool SetIntTxChirp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<double>::is_valid(m_values["SweepTime"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxChirp::documentation() const { return Documentation; }


    int SetIntTxChirp::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxChirp::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxChirp::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxChirp::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxChirp::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxChirp::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxChirp::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxChirp::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void SetIntTxChirp::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxChirp::sweepTime() const
    {
      return parse_json<double>::parse(m_values["SweepTime"]);
    }

    void SetIntTxChirp::setSweepTime(double sweepTime)
    {
      m_values.AddMember("SweepTime", parse_json<double>::format(sweepTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxChirp::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxChirp::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxChirp::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxChirp::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxChirp::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxChirp::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxChirp
///
#include "gen/GetIntTxChirp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxChirp::CmdName = "GetIntTxChirp";
    const char* const GetIntTxChirp::Documentation = "Get informations about the Chirp signal of the transmitter.";

    REGISTER_COMMAND_FACTORY(GetIntTxChirp);


    GetIntTxChirp::GetIntTxChirp()
      : CommandBase(CmdName)
    {}

    GetIntTxChirp::GetIntTxChirp(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxChirpPtr GetIntTxChirp::create(const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<GetIntTxChirp>(transmitterId, signalId);
    }

    GetIntTxChirpPtr GetIntTxChirp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxChirp>(ptr);
    }

    bool GetIntTxChirp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxChirp::documentation() const { return Documentation; }


    int GetIntTxChirp::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxChirp::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxChirp::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxChirp::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxChirp::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxChirpResult
///
#include "gen/GetIntTxChirpResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxChirpResult::CmdName = "GetIntTxChirpResult";
    const char* const GetIntTxChirpResult::Documentation = "Result of GetIntTxChirp.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxChirpResult);


    GetIntTxChirpResult::GetIntTxChirpResult()
      : CommandResult(CmdName)
    {}

    GetIntTxChirpResult::GetIntTxChirpResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double bandwidth, double sweepTime, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setSweepTime(sweepTime);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    GetIntTxChirpResultPtr GetIntTxChirpResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double bandwidth, double sweepTime, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return std::make_shared<GetIntTxChirpResult>(relatedCommand, enabled, centralFreq, power, bandwidth, sweepTime, transmitterId, signalId, group);
    }

    GetIntTxChirpResultPtr GetIntTxChirpResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxChirpResult>(ptr);
    }

    bool GetIntTxChirpResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<double>::is_valid(m_values["SweepTime"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxChirpResult::documentation() const { return Documentation; }


    bool GetIntTxChirpResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxChirpResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxChirpResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxChirpResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxChirpResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxChirpResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxChirpResult::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void GetIntTxChirpResult::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxChirpResult::sweepTime() const
    {
      return parse_json<double>::parse(m_values["SweepTime"]);
    }

    void GetIntTxChirpResult::setSweepTime(double sweepTime)
    {
      m_values.AddMember("SweepTime", parse_json<double>::format(sweepTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxChirpResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxChirpResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxChirpResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxChirpResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxChirpResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxChirpResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxPulse
///
#include "gen/SetIntTxPulse.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxPulse::CmdName = "SetIntTxPulse";
    const char* const SetIntTxPulse::Documentation = "Set pulse signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxPulse);


    SetIntTxPulse::SetIntTxPulse()
      : CommandBase(CmdName)
    {}

    SetIntTxPulse::SetIntTxPulse(bool enabled, double centralFreq, double power, double dutyCycle, int pulseRate, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setDutyCycle(dutyCycle);
      setPulseRate(pulseRate);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    SetIntTxPulsePtr SetIntTxPulse::create(bool enabled, double centralFreq, double power, double dutyCycle, int pulseRate, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return std::make_shared<SetIntTxPulse>(enabled, centralFreq, power, dutyCycle, pulseRate, transmitterId, signalId, group);
    }

    SetIntTxPulsePtr SetIntTxPulse::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxPulse>(ptr);
    }

    bool SetIntTxPulse::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["DutyCycle"])
          && parse_json<int>::is_valid(m_values["PulseRate"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxPulse::documentation() const { return Documentation; }


    int SetIntTxPulse::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxPulse::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxPulse::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxPulse::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxPulse::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxPulse::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxPulse::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxPulse::dutyCycle() const
    {
      return parse_json<double>::parse(m_values["DutyCycle"]);
    }

    void SetIntTxPulse::setDutyCycle(double dutyCycle)
    {
      m_values.AddMember("DutyCycle", parse_json<double>::format(dutyCycle, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxPulse::pulseRate() const
    {
      return parse_json<int>::parse(m_values["PulseRate"]);
    }

    void SetIntTxPulse::setPulseRate(int pulseRate)
    {
      m_values.AddMember("PulseRate", parse_json<int>::format(pulseRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxPulse::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxPulse::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxPulse::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxPulse::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxPulse::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxPulse::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxPulse
///
#include "gen/GetIntTxPulse.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxPulse::CmdName = "GetIntTxPulse";
    const char* const GetIntTxPulse::Documentation = "Get pulse signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxPulse);


    GetIntTxPulse::GetIntTxPulse()
      : CommandBase(CmdName)
    {}

    GetIntTxPulse::GetIntTxPulse(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxPulsePtr GetIntTxPulse::create(const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<GetIntTxPulse>(transmitterId, signalId);
    }

    GetIntTxPulsePtr GetIntTxPulse::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxPulse>(ptr);
    }

    bool GetIntTxPulse::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxPulse::documentation() const { return Documentation; }


    int GetIntTxPulse::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxPulse::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxPulse::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxPulse::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxPulse::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxPulseResult
///
#include "gen/GetIntTxPulseResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxPulseResult::CmdName = "GetIntTxPulseResult";
    const char* const GetIntTxPulseResult::Documentation = "Result of GetIntTxPulse.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxPulseResult);


    GetIntTxPulseResult::GetIntTxPulseResult()
      : CommandResult(CmdName)
    {}

    GetIntTxPulseResult::GetIntTxPulseResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double dutyCycle, int pulseRate, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setDutyCycle(dutyCycle);
      setPulseRate(pulseRate);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    GetIntTxPulseResultPtr GetIntTxPulseResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double dutyCycle, int pulseRate, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return std::make_shared<GetIntTxPulseResult>(relatedCommand, enabled, centralFreq, power, dutyCycle, pulseRate, transmitterId, signalId, group);
    }

    GetIntTxPulseResultPtr GetIntTxPulseResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxPulseResult>(ptr);
    }

    bool GetIntTxPulseResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["DutyCycle"])
          && parse_json<int>::is_valid(m_values["PulseRate"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxPulseResult::documentation() const { return Documentation; }


    bool GetIntTxPulseResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxPulseResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxPulseResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxPulseResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxPulseResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxPulseResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxPulseResult::dutyCycle() const
    {
      return parse_json<double>::parse(m_values["DutyCycle"]);
    }

    void GetIntTxPulseResult::setDutyCycle(double dutyCycle)
    {
      m_values.AddMember("DutyCycle", parse_json<double>::format(dutyCycle, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxPulseResult::pulseRate() const
    {
      return parse_json<int>::parse(m_values["PulseRate"]);
    }

    void GetIntTxPulseResult::setPulseRate(int pulseRate)
    {
      m_values.AddMember("PulseRate", parse_json<int>::format(pulseRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxPulseResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxPulseResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxPulseResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxPulseResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxPulseResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxPulseResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxBPSK
///
#include "gen/SetIntTxBPSK.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxBPSK::CmdName = "SetIntTxBPSK";
    const char* const SetIntTxBPSK::Documentation = "Set BPSK signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxBPSK);


    SetIntTxBPSK::SetIntTxBPSK()
      : CommandBase(CmdName)
    {}

    SetIntTxBPSK::SetIntTxBPSK(bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group, const Sdx::optional<int>& prn)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setCodeRate(codeRate);
      setCodeLengthMs(codeLengthMs);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
      setPrn(prn);
    }


    SetIntTxBPSKPtr SetIntTxBPSK::create(bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group, const Sdx::optional<int>& prn)
    {
      return std::make_shared<SetIntTxBPSK>(enabled, centralFreq, power, codeRate, codeLengthMs, transmitterId, signalId, group, prn);
    }

    SetIntTxBPSKPtr SetIntTxBPSK::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxBPSK>(ptr);
    }

    bool SetIntTxBPSK::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["CodeRate"])
          && parse_json<int>::is_valid(m_values["CodeLengthMs"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Prn"])
        ;

    }

    std::string SetIntTxBPSK::documentation() const { return Documentation; }


    int SetIntTxBPSK::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxBPSK::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxBPSK::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxBPSK::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxBPSK::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxBPSK::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxBPSK::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBPSK::codeRate() const
    {
      return parse_json<int>::parse(m_values["CodeRate"]);
    }

    void SetIntTxBPSK::setCodeRate(int codeRate)
    {
      m_values.AddMember("CodeRate", parse_json<int>::format(codeRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBPSK::codeLengthMs() const
    {
      return parse_json<int>::parse(m_values["CodeLengthMs"]);
    }

    void SetIntTxBPSK::setCodeLengthMs(int codeLengthMs)
    {
      m_values.AddMember("CodeLengthMs", parse_json<int>::format(codeLengthMs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxBPSK::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxBPSK::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxBPSK::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxBPSK::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxBPSK::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxBPSK::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxBPSK::prn() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Prn"]);
    }

    void SetIntTxBPSK::setPrn(const Sdx::optional<int>& prn)
    {
      m_values.AddMember("Prn", parse_json<Sdx::optional<int>>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxBPSK
///
#include "gen/GetIntTxBPSK.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxBPSK::CmdName = "GetIntTxBPSK";
    const char* const GetIntTxBPSK::Documentation = "Get BPSK signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxBPSK);


    GetIntTxBPSK::GetIntTxBPSK()
      : CommandBase(CmdName)
    {}

    GetIntTxBPSK::GetIntTxBPSK(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxBPSKPtr GetIntTxBPSK::create(const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<GetIntTxBPSK>(transmitterId, signalId);
    }

    GetIntTxBPSKPtr GetIntTxBPSK::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxBPSK>(ptr);
    }

    bool GetIntTxBPSK::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxBPSK::documentation() const { return Documentation; }


    int GetIntTxBPSK::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxBPSK::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxBPSK::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBPSK::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxBPSK::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxBPSKResult
///
#include "gen/GetIntTxBPSKResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxBPSKResult::CmdName = "GetIntTxBPSKResult";
    const char* const GetIntTxBPSKResult::Documentation = "Result of GetIntTxBPSK.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxBPSKResult);


    GetIntTxBPSKResult::GetIntTxBPSKResult()
      : CommandResult(CmdName)
    {}

    GetIntTxBPSKResult::GetIntTxBPSKResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group, const Sdx::optional<int>& prn)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setCodeRate(codeRate);
      setCodeLengthMs(codeLengthMs);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
      setPrn(prn);
    }


    GetIntTxBPSKResultPtr GetIntTxBPSKResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group, const Sdx::optional<int>& prn)
    {
      return std::make_shared<GetIntTxBPSKResult>(relatedCommand, enabled, centralFreq, power, codeRate, codeLengthMs, transmitterId, signalId, group, prn);
    }

    GetIntTxBPSKResultPtr GetIntTxBPSKResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxBPSKResult>(ptr);
    }

    bool GetIntTxBPSKResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["CodeRate"])
          && parse_json<int>::is_valid(m_values["CodeLengthMs"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetIntTxBPSKResult::documentation() const { return Documentation; }


    bool GetIntTxBPSKResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxBPSKResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxBPSKResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxBPSKResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxBPSKResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxBPSKResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBPSKResult::codeRate() const
    {
      return parse_json<int>::parse(m_values["CodeRate"]);
    }

    void GetIntTxBPSKResult::setCodeRate(int codeRate)
    {
      m_values.AddMember("CodeRate", parse_json<int>::format(codeRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBPSKResult::codeLengthMs() const
    {
      return parse_json<int>::parse(m_values["CodeLengthMs"]);
    }

    void GetIntTxBPSKResult::setCodeLengthMs(int codeLengthMs)
    {
      m_values.AddMember("CodeLengthMs", parse_json<int>::format(codeLengthMs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBPSKResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxBPSKResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBPSKResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxBPSKResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxBPSKResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxBPSKResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxBPSKResult::prn() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Prn"]);
    }

    void GetIntTxBPSKResult::setPrn(const Sdx::optional<int>& prn)
    {
      m_values.AddMember("Prn", parse_json<Sdx::optional<int>>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxBOC
///
#include "gen/SetIntTxBOC.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxBOC::CmdName = "SetIntTxBOC";
    const char* const SetIntTxBOC::Documentation = "Set BOC signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxBOC);


    SetIntTxBOC::SetIntTxBOC()
      : CommandBase(CmdName)
    {}

    SetIntTxBOC::SetIntTxBOC(bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, int subCarrierRate, bool cosinePhaseBoc, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setCodeRate(codeRate);
      setCodeLengthMs(codeLengthMs);
      setSubCarrierRate(subCarrierRate);
      setCosinePhaseBoc(cosinePhaseBoc);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    SetIntTxBOCPtr SetIntTxBOC::create(bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, int subCarrierRate, bool cosinePhaseBoc, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return std::make_shared<SetIntTxBOC>(enabled, centralFreq, power, codeRate, codeLengthMs, subCarrierRate, cosinePhaseBoc, transmitterId, signalId, group);
    }

    SetIntTxBOCPtr SetIntTxBOC::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxBOC>(ptr);
    }

    bool SetIntTxBOC::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["CodeRate"])
          && parse_json<int>::is_valid(m_values["CodeLengthMs"])
          && parse_json<int>::is_valid(m_values["SubCarrierRate"])
          && parse_json<bool>::is_valid(m_values["CosinePhaseBoc"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxBOC::documentation() const { return Documentation; }


    int SetIntTxBOC::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxBOC::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxBOC::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxBOC::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxBOC::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxBOC::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxBOC::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBOC::codeRate() const
    {
      return parse_json<int>::parse(m_values["CodeRate"]);
    }

    void SetIntTxBOC::setCodeRate(int codeRate)
    {
      m_values.AddMember("CodeRate", parse_json<int>::format(codeRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBOC::codeLengthMs() const
    {
      return parse_json<int>::parse(m_values["CodeLengthMs"]);
    }

    void SetIntTxBOC::setCodeLengthMs(int codeLengthMs)
    {
      m_values.AddMember("CodeLengthMs", parse_json<int>::format(codeLengthMs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBOC::subCarrierRate() const
    {
      return parse_json<int>::parse(m_values["SubCarrierRate"]);
    }

    void SetIntTxBOC::setSubCarrierRate(int subCarrierRate)
    {
      m_values.AddMember("SubCarrierRate", parse_json<int>::format(subCarrierRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetIntTxBOC::cosinePhaseBoc() const
    {
      return parse_json<bool>::parse(m_values["CosinePhaseBoc"]);
    }

    void SetIntTxBOC::setCosinePhaseBoc(bool cosinePhaseBoc)
    {
      m_values.AddMember("CosinePhaseBoc", parse_json<bool>::format(cosinePhaseBoc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxBOC::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxBOC::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxBOC::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxBOC::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxBOC::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxBOC::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxBOC
///
#include "gen/GetIntTxBOC.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxBOC::CmdName = "GetIntTxBOC";
    const char* const GetIntTxBOC::Documentation = "Get BOC signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxBOC);


    GetIntTxBOC::GetIntTxBOC()
      : CommandBase(CmdName)
    {}

    GetIntTxBOC::GetIntTxBOC(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxBOCPtr GetIntTxBOC::create(const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<GetIntTxBOC>(transmitterId, signalId);
    }

    GetIntTxBOCPtr GetIntTxBOC::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxBOC>(ptr);
    }

    bool GetIntTxBOC::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxBOC::documentation() const { return Documentation; }


    int GetIntTxBOC::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxBOC::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxBOC::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBOC::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxBOC::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxBOCResult
///
#include "gen/GetIntTxBOCResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxBOCResult::CmdName = "GetIntTxBOCResult";
    const char* const GetIntTxBOCResult::Documentation = "Result of GetIntTxBOC.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxBOCResult);


    GetIntTxBOCResult::GetIntTxBOCResult()
      : CommandResult(CmdName)
    {}

    GetIntTxBOCResult::GetIntTxBOCResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, int subCarrierRate, bool cosinePhaseBoc, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setCodeRate(codeRate);
      setCodeLengthMs(codeLengthMs);
      setSubCarrierRate(subCarrierRate);
      setCosinePhaseBoc(cosinePhaseBoc);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    GetIntTxBOCResultPtr GetIntTxBOCResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, int subCarrierRate, bool cosinePhaseBoc, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return std::make_shared<GetIntTxBOCResult>(relatedCommand, enabled, centralFreq, power, codeRate, codeLengthMs, subCarrierRate, cosinePhaseBoc, transmitterId, signalId, group);
    }

    GetIntTxBOCResultPtr GetIntTxBOCResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxBOCResult>(ptr);
    }

    bool GetIntTxBOCResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["CodeRate"])
          && parse_json<int>::is_valid(m_values["CodeLengthMs"])
          && parse_json<int>::is_valid(m_values["SubCarrierRate"])
          && parse_json<bool>::is_valid(m_values["CosinePhaseBoc"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxBOCResult::documentation() const { return Documentation; }


    bool GetIntTxBOCResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxBOCResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxBOCResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxBOCResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxBOCResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxBOCResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBOCResult::codeRate() const
    {
      return parse_json<int>::parse(m_values["CodeRate"]);
    }

    void GetIntTxBOCResult::setCodeRate(int codeRate)
    {
      m_values.AddMember("CodeRate", parse_json<int>::format(codeRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBOCResult::codeLengthMs() const
    {
      return parse_json<int>::parse(m_values["CodeLengthMs"]);
    }

    void GetIntTxBOCResult::setCodeLengthMs(int codeLengthMs)
    {
      m_values.AddMember("CodeLengthMs", parse_json<int>::format(codeLengthMs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBOCResult::subCarrierRate() const
    {
      return parse_json<int>::parse(m_values["SubCarrierRate"]);
    }

    void GetIntTxBOCResult::setSubCarrierRate(int subCarrierRate)
    {
      m_values.AddMember("SubCarrierRate", parse_json<int>::format(subCarrierRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIntTxBOCResult::cosinePhaseBoc() const
    {
      return parse_json<bool>::parse(m_values["CosinePhaseBoc"]);
    }

    void GetIntTxBOCResult::setCosinePhaseBoc(bool cosinePhaseBoc)
    {
      m_values.AddMember("CosinePhaseBoc", parse_json<bool>::format(cosinePhaseBoc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBOCResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxBOCResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBOCResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxBOCResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxBOCResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxBOCResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxAWGN
///
#include "gen/SetIntTxAWGN.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxAWGN::CmdName = "SetIntTxAWGN";
    const char* const SetIntTxAWGN::Documentation = "Set AWGN signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxAWGN);


    SetIntTxAWGN::SetIntTxAWGN()
      : CommandBase(CmdName)
    {}

    SetIntTxAWGN::SetIntTxAWGN(bool enabled, double centralFreq, double power, double bandwidth, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& seed, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setSeed(seed);
      setGroup(group);
    }


    SetIntTxAWGNPtr SetIntTxAWGN::create(bool enabled, double centralFreq, double power, double bandwidth, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& seed, const Sdx::optional<int>& group)
    {
      return std::make_shared<SetIntTxAWGN>(enabled, centralFreq, power, bandwidth, transmitterId, signalId, seed, group);
    }

    SetIntTxAWGNPtr SetIntTxAWGN::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxAWGN>(ptr);
    }

    bool SetIntTxAWGN::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Seed"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxAWGN::documentation() const { return Documentation; }


    int SetIntTxAWGN::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxAWGN::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxAWGN::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAWGN::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxAWGN::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAWGN::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxAWGN::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAWGN::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void SetIntTxAWGN::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxAWGN::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxAWGN::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxAWGN::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxAWGN::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxAWGN::seed() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Seed"]);
    }

    void SetIntTxAWGN::setSeed(const Sdx::optional<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<Sdx::optional<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxAWGN::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxAWGN::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAWGN
///
#include "gen/GetIntTxAWGN.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAWGN::CmdName = "GetIntTxAWGN";
    const char* const GetIntTxAWGN::Documentation = "Get AWGN signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxAWGN);


    GetIntTxAWGN::GetIntTxAWGN()
      : CommandBase(CmdName)
    {}

    GetIntTxAWGN::GetIntTxAWGN(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxAWGNPtr GetIntTxAWGN::create(const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<GetIntTxAWGN>(transmitterId, signalId);
    }

    GetIntTxAWGNPtr GetIntTxAWGN::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAWGN>(ptr);
    }

    bool GetIntTxAWGN::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxAWGN::documentation() const { return Documentation; }


    int GetIntTxAWGN::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxAWGN::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxAWGN::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAWGN::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxAWGN::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAWGNResult
///
#include "gen/GetIntTxAWGNResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAWGNResult::CmdName = "GetIntTxAWGNResult";
    const char* const GetIntTxAWGNResult::Documentation = "Result of GetIntTxAWGN.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxAWGNResult);


    GetIntTxAWGNResult::GetIntTxAWGNResult()
      : CommandResult(CmdName)
    {}

    GetIntTxAWGNResult::GetIntTxAWGNResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double bandwidth, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& seed, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setSeed(seed);
      setGroup(group);
    }


    GetIntTxAWGNResultPtr GetIntTxAWGNResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double bandwidth, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& seed, const Sdx::optional<int>& group)
    {
      return std::make_shared<GetIntTxAWGNResult>(relatedCommand, enabled, centralFreq, power, bandwidth, transmitterId, signalId, seed, group);
    }

    GetIntTxAWGNResultPtr GetIntTxAWGNResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAWGNResult>(ptr);
    }

    bool GetIntTxAWGNResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Seed"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxAWGNResult::documentation() const { return Documentation; }


    bool GetIntTxAWGNResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxAWGNResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAWGNResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxAWGNResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAWGNResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxAWGNResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAWGNResult::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void GetIntTxAWGNResult::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAWGNResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxAWGNResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAWGNResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxAWGNResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxAWGNResult::seed() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Seed"]);
    }

    void GetIntTxAWGNResult::setSeed(const Sdx::optional<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<Sdx::optional<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxAWGNResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxAWGNResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIqFile
///
#include "gen/SetIntTxIqFile.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIqFile::CmdName = "SetIntTxIqFile";
    const char* const SetIntTxIqFile::Documentation = "Set IQ file signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxIqFile);


    SetIntTxIqFile::SetIntTxIqFile()
      : CommandBase(CmdName)
    {}

    SetIntTxIqFile::SetIntTxIqFile(bool enabled, double centralFreq, double power, const std::string& path, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setPath(path);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    SetIntTxIqFilePtr SetIntTxIqFile::create(bool enabled, double centralFreq, double power, const std::string& path, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return std::make_shared<SetIntTxIqFile>(enabled, centralFreq, power, path, transmitterId, signalId, group);
    }

    SetIntTxIqFilePtr SetIntTxIqFile::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIqFile>(ptr);
    }

    bool SetIntTxIqFile::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxIqFile::documentation() const { return Documentation; }


    int SetIntTxIqFile::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIqFile::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxIqFile::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxIqFile::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxIqFile::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxIqFile::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxIqFile::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIqFile::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void SetIntTxIqFile::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIqFile::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxIqFile::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIqFile::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxIqFile::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxIqFile::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxIqFile::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxIqFile
///
#include "gen/GetIntTxIqFile.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxIqFile::CmdName = "GetIntTxIqFile";
    const char* const GetIntTxIqFile::Documentation = "Get IQ file signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxIqFile);


    GetIntTxIqFile::GetIntTxIqFile()
      : CommandBase(CmdName)
    {}

    GetIntTxIqFile::GetIntTxIqFile(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxIqFilePtr GetIntTxIqFile::create(const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<GetIntTxIqFile>(transmitterId, signalId);
    }

    GetIntTxIqFilePtr GetIntTxIqFile::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxIqFile>(ptr);
    }

    bool GetIntTxIqFile::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxIqFile::documentation() const { return Documentation; }


    int GetIntTxIqFile::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxIqFile::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxIqFile::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxIqFile::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxIqFile::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxIqFileResult
///
#include "gen/GetIntTxIqFileResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxIqFileResult::CmdName = "GetIntTxIqFileResult";
    const char* const GetIntTxIqFileResult::Documentation = "Result of GetIntTxIqFile.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxIqFileResult);


    GetIntTxIqFileResult::GetIntTxIqFileResult()
      : CommandResult(CmdName)
    {}

    GetIntTxIqFileResult::GetIntTxIqFileResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, const std::string& path, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setPath(path);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    GetIntTxIqFileResultPtr GetIntTxIqFileResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, const std::string& path, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return std::make_shared<GetIntTxIqFileResult>(relatedCommand, enabled, centralFreq, power, path, transmitterId, signalId, group);
    }

    GetIntTxIqFileResultPtr GetIntTxIqFileResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxIqFileResult>(ptr);
    }

    bool GetIntTxIqFileResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxIqFileResult::documentation() const { return Documentation; }


    bool GetIntTxIqFileResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxIqFileResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxIqFileResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxIqFileResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxIqFileResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxIqFileResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxIqFileResult::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void GetIntTxIqFileResult::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxIqFileResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxIqFileResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxIqFileResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxIqFileResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxIqFileResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxIqFileResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableIntTxSignal
///
#include "gen/EnableIntTxSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableIntTxSignal::CmdName = "EnableIntTxSignal";
    const char* const EnableIntTxSignal::Documentation = "Change whether a signal is enabled or disabled";

    REGISTER_COMMAND_FACTORY(EnableIntTxSignal);


    EnableIntTxSignal::EnableIntTxSignal()
      : CommandBase(CmdName)
    {}

    EnableIntTxSignal::EnableIntTxSignal(bool enabled, const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    EnableIntTxSignalPtr EnableIntTxSignal::create(bool enabled, const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<EnableIntTxSignal>(enabled, transmitterId, signalId);
    }

    EnableIntTxSignalPtr EnableIntTxSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableIntTxSignal>(ptr);
    }

    bool EnableIntTxSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string EnableIntTxSignal::documentation() const { return Documentation; }


    int EnableIntTxSignal::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool EnableIntTxSignal::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableIntTxSignal::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableIntTxSignal::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void EnableIntTxSignal::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableIntTxSignal::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void EnableIntTxSignal::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveSignalFromIntTx
///
#include "gen/RemoveSignalFromIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveSignalFromIntTx::CmdName = "RemoveSignalFromIntTx";
    const char* const RemoveSignalFromIntTx::Documentation = "Removes the specified signal from the interference transmitter.";

    REGISTER_COMMAND_FACTORY(RemoveSignalFromIntTx);


    RemoveSignalFromIntTx::RemoveSignalFromIntTx()
      : CommandBase(CmdName)
    {}

    RemoveSignalFromIntTx::RemoveSignalFromIntTx(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    RemoveSignalFromIntTxPtr RemoveSignalFromIntTx::create(const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<RemoveSignalFromIntTx>(transmitterId, signalId);
    }

    RemoveSignalFromIntTxPtr RemoveSignalFromIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveSignalFromIntTx>(ptr);
    }

    bool RemoveSignalFromIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string RemoveSignalFromIntTx::documentation() const { return Documentation; }


    int RemoveSignalFromIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RemoveSignalFromIntTx::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void RemoveSignalFromIntTx::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveSignalFromIntTx::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void RemoveSignalFromIntTx::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllSignalsFromIntTx
///
#include "gen/RemoveAllSignalsFromIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllSignalsFromIntTx::CmdName = "RemoveAllSignalsFromIntTx";
    const char* const RemoveAllSignalsFromIntTx::Documentation = "Removes all signals from the interference transmitter.";

    REGISTER_COMMAND_FACTORY(RemoveAllSignalsFromIntTx);


    RemoveAllSignalsFromIntTx::RemoveAllSignalsFromIntTx()
      : CommandBase(CmdName)
    {}

    RemoveAllSignalsFromIntTx::RemoveAllSignalsFromIntTx(const std::string& transmitterId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
    }


    RemoveAllSignalsFromIntTxPtr RemoveAllSignalsFromIntTx::create(const std::string& transmitterId)
    {
      return std::make_shared<RemoveAllSignalsFromIntTx>(transmitterId);
    }

    RemoveAllSignalsFromIntTxPtr RemoveAllSignalsFromIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllSignalsFromIntTx>(ptr);
    }

    bool RemoveAllSignalsFromIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
        ;

    }

    std::string RemoveAllSignalsFromIntTx::documentation() const { return Documentation; }


    int RemoveAllSignalsFromIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RemoveAllSignalsFromIntTx::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void RemoveAllSignalsFromIntTx::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetStreamingBuffer
///
#include "gen/SetStreamingBuffer.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetStreamingBuffer::CmdName = "SetStreamingBuffer";
    const char* const SetStreamingBuffer::Documentation = "Set streaming buffer size.";

    REGISTER_COMMAND_FACTORY(SetStreamingBuffer);


    SetStreamingBuffer::SetStreamingBuffer()
      : CommandBase(CmdName)
    {}

    SetStreamingBuffer::SetStreamingBuffer(int size)
      : CommandBase(CmdName)
    {

      setSize(size);
    }


    SetStreamingBufferPtr SetStreamingBuffer::create(int size)
    {
      return std::make_shared<SetStreamingBuffer>(size);
    }

    SetStreamingBufferPtr SetStreamingBuffer::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetStreamingBuffer>(ptr);
    }

    bool SetStreamingBuffer::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Size"])
        ;

    }

    std::string SetStreamingBuffer::documentation() const { return Documentation; }


    int SetStreamingBuffer::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    int SetStreamingBuffer::size() const
    {
      return parse_json<int>::parse(m_values["Size"]);
    }

    void SetStreamingBuffer::setSize(int size)
    {
      m_values.AddMember("Size", parse_json<int>::format(size, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetStreamingBuffer
///
#include "gen/GetStreamingBuffer.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStreamingBuffer::CmdName = "GetStreamingBuffer";
    const char* const GetStreamingBuffer::Documentation = "Get streaming buffer size.";

    REGISTER_COMMAND_FACTORY(GetStreamingBuffer);


    GetStreamingBuffer::GetStreamingBuffer()
      : CommandBase(CmdName)
    {

    }


    GetStreamingBufferPtr GetStreamingBuffer::create()
    {
      return std::make_shared<GetStreamingBuffer>();
    }

    GetStreamingBufferPtr GetStreamingBuffer::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStreamingBuffer>(ptr);
    }

    bool GetStreamingBuffer::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetStreamingBuffer::documentation() const { return Documentation; }


    int GetStreamingBuffer::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetStreamingBufferResult
///
#include "gen/GetStreamingBufferResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStreamingBufferResult::CmdName = "GetStreamingBufferResult";
    const char* const GetStreamingBufferResult::Documentation = "Result of GetStreamingBuffer.";

    REGISTER_COMMAND_RESULT_FACTORY(GetStreamingBufferResult);


    GetStreamingBufferResult::GetStreamingBufferResult()
      : CommandResult(CmdName)
    {}

    GetStreamingBufferResult::GetStreamingBufferResult(CommandBasePtr relatedCommand, int size)
      : CommandResult(CmdName, relatedCommand)
    {

      setSize(size);
    }


    GetStreamingBufferResultPtr GetStreamingBufferResult::create(CommandBasePtr relatedCommand, int size)
    {
      return std::make_shared<GetStreamingBufferResult>(relatedCommand, size);
    }

    GetStreamingBufferResultPtr GetStreamingBufferResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStreamingBufferResult>(ptr);
    }

    bool GetStreamingBufferResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Size"])
        ;

    }

    std::string GetStreamingBufferResult::documentation() const { return Documentation; }


    int GetStreamingBufferResult::size() const
    {
      return parse_json<int>::parse(m_values["Size"]);
    }

    void GetStreamingBufferResult::setSize(int size)
    {
      m_values.AddMember("Size", parse_json<int>::format(size, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetEngineLatency
///
#include "gen/SetEngineLatency.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetEngineLatency::CmdName = "SetEngineLatency";
    const char* const SetEngineLatency::Documentation = "Set engine latency.";

    REGISTER_COMMAND_FACTORY(SetEngineLatency);


    SetEngineLatency::SetEngineLatency()
      : CommandBase(CmdName)
    {}

    SetEngineLatency::SetEngineLatency(int latency)
      : CommandBase(CmdName)
    {

      setLatency(latency);
    }


    SetEngineLatencyPtr SetEngineLatency::create(int latency)
    {
      return std::make_shared<SetEngineLatency>(latency);
    }

    SetEngineLatencyPtr SetEngineLatency::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetEngineLatency>(ptr);
    }

    bool SetEngineLatency::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Latency"])
        ;

    }

    std::string SetEngineLatency::documentation() const { return Documentation; }


    int SetEngineLatency::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    int SetEngineLatency::latency() const
    {
      return parse_json<int>::parse(m_values["Latency"]);
    }

    void SetEngineLatency::setLatency(int latency)
    {
      m_values.AddMember("Latency", parse_json<int>::format(latency, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEngineLatency
///
#include "gen/GetEngineLatency.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEngineLatency::CmdName = "GetEngineLatency";
    const char* const GetEngineLatency::Documentation = "Get engine latency.";

    REGISTER_COMMAND_FACTORY(GetEngineLatency);


    GetEngineLatency::GetEngineLatency()
      : CommandBase(CmdName)
    {

    }


    GetEngineLatencyPtr GetEngineLatency::create()
    {
      return std::make_shared<GetEngineLatency>();
    }

    GetEngineLatencyPtr GetEngineLatency::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEngineLatency>(ptr);
    }

    bool GetEngineLatency::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetEngineLatency::documentation() const { return Documentation; }


    int GetEngineLatency::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetEngineLatencyResult
///
#include "gen/GetEngineLatencyResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEngineLatencyResult::CmdName = "GetEngineLatencyResult";
    const char* const GetEngineLatencyResult::Documentation = "Result of GetEngineLatency.";

    REGISTER_COMMAND_RESULT_FACTORY(GetEngineLatencyResult);


    GetEngineLatencyResult::GetEngineLatencyResult()
      : CommandResult(CmdName)
    {}

    GetEngineLatencyResult::GetEngineLatencyResult(CommandBasePtr relatedCommand, int latency)
      : CommandResult(CmdName, relatedCommand)
    {

      setLatency(latency);
    }


    GetEngineLatencyResultPtr GetEngineLatencyResult::create(CommandBasePtr relatedCommand, int latency)
    {
      return std::make_shared<GetEngineLatencyResult>(relatedCommand, latency);
    }

    GetEngineLatencyResultPtr GetEngineLatencyResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEngineLatencyResult>(ptr);
    }

    bool GetEngineLatencyResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Latency"])
        ;

    }

    std::string GetEngineLatencyResult::documentation() const { return Documentation; }


    int GetEngineLatencyResult::latency() const
    {
      return parse_json<int>::parse(m_values["Latency"]);
    }

    void GetEngineLatencyResult::setLatency(int latency)
    {
      m_values.AddMember("Latency", parse_json<int>::format(latency, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetHilTjoin
///
#include "gen/SetHilTjoin.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetHilTjoin::CmdName = "SetHilTjoin";
    const char* const SetHilTjoin::Documentation = "HIL Tjoin. Value is in milliseconds.";

    REGISTER_COMMAND_FACTORY(SetHilTjoin);


    SetHilTjoin::SetHilTjoin()
      : CommandBase(CmdName)
    {}

    SetHilTjoin::SetHilTjoin(int hilTjoin)
      : CommandBase(CmdName)
    {

      setHilTjoin(hilTjoin);
    }


    SetHilTjoinPtr SetHilTjoin::create(int hilTjoin)
    {
      return std::make_shared<SetHilTjoin>(hilTjoin);
    }

    SetHilTjoinPtr SetHilTjoin::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetHilTjoin>(ptr);
    }

    bool SetHilTjoin::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["HilTjoin"])
        ;

    }

    std::string SetHilTjoin::documentation() const { return Documentation; }


    int SetHilTjoin::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetHilTjoin::hilTjoin() const
    {
      return parse_json<int>::parse(m_values["HilTjoin"]);
    }

    void SetHilTjoin::setHilTjoin(int hilTjoin)
    {
      m_values.AddMember("HilTjoin", parse_json<int>::format(hilTjoin, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSyncServer
///
#include "gen/SetSyncServer.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSyncServer::CmdName = "SetSyncServer";
    const char* const SetSyncServer::Documentation = "Set listening port for sync time server.";

    REGISTER_COMMAND_FACTORY(SetSyncServer);


    SetSyncServer::SetSyncServer()
      : CommandBase(CmdName)
    {}

    SetSyncServer::SetSyncServer(int port)
      : CommandBase(CmdName)
    {

      setPort(port);
    }


    SetSyncServerPtr SetSyncServer::create(int port)
    {
      return std::make_shared<SetSyncServer>(port);
    }

    SetSyncServerPtr SetSyncServer::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSyncServer>(ptr);
    }

    bool SetSyncServer::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Port"])
        ;

    }

    std::string SetSyncServer::documentation() const { return Documentation; }


    int SetSyncServer::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    int SetSyncServer::port() const
    {
      return parse_json<int>::parse(m_values["Port"]);
    }

    void SetSyncServer::setPort(int port)
    {
      m_values.AddMember("Port", parse_json<int>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSyncClient
///
#include "gen/SetSyncClient.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSyncClient::CmdName = "SetSyncClient";
    const char* const SetSyncClient::Documentation = "Set host and port to connect to sync time server.";

    REGISTER_COMMAND_FACTORY(SetSyncClient);


    SetSyncClient::SetSyncClient()
      : CommandBase(CmdName)
    {}

    SetSyncClient::SetSyncClient(const std::string& host, int port)
      : CommandBase(CmdName)
    {

      setHost(host);
      setPort(port);
    }


    SetSyncClientPtr SetSyncClient::create(const std::string& host, int port)
    {
      return std::make_shared<SetSyncClient>(host, port);
    }

    SetSyncClientPtr SetSyncClient::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSyncClient>(ptr);
    }

    bool SetSyncClient::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Host"])
          && parse_json<int>::is_valid(m_values["Port"])
        ;

    }

    std::string SetSyncClient::documentation() const { return Documentation; }


    int SetSyncClient::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    std::string SetSyncClient::host() const
    {
      return parse_json<std::string>::parse(m_values["Host"]);
    }

    void SetSyncClient::setHost(const std::string& host)
    {
      m_values.AddMember("Host", parse_json<std::string>::format(host, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSyncClient::port() const
    {
      return parse_json<int>::parse(m_values["Port"]);
    }

    void SetSyncClient::setPort(int port)
    {
      m_values.AddMember("Port", parse_json<int>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSyncTime
///
#include "gen/SetSyncTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSyncTime::CmdName = "SetSyncTime";
    const char* const SetSyncTime::Documentation = "Set time delay to start streaming, in order to allign PPS out Signal with RF.\n2000 ms is a calibrated value.";

    REGISTER_COMMAND_FACTORY(SetSyncTime);


    SetSyncTime::SetSyncTime()
      : CommandBase(CmdName)
    {}

    SetSyncTime::SetSyncTime(double time)
      : CommandBase(CmdName)
    {

      setTime(time);
    }


    SetSyncTimePtr SetSyncTime::create(double time)
    {
      return std::make_shared<SetSyncTime>(time);
    }

    SetSyncTimePtr SetSyncTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSyncTime>(ptr);
    }

    bool SetSyncTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Time"])
        ;

    }

    std::string SetSyncTime::documentation() const { return Documentation; }


    int SetSyncTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSyncTime::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void SetSyncTime::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSyncTime
///
#include "gen/GetSyncTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSyncTime::CmdName = "GetSyncTime";
    const char* const GetSyncTime::Documentation = "Get time delay to start streaming, in order to allign PPS out Signal with RF.\n2000 ms is a calibrated value.";

    REGISTER_COMMAND_FACTORY(GetSyncTime);


    GetSyncTime::GetSyncTime()
      : CommandBase(CmdName)
    {

    }


    GetSyncTimePtr GetSyncTime::create()
    {
      return std::make_shared<GetSyncTime>();
    }

    GetSyncTimePtr GetSyncTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSyncTime>(ptr);
    }

    bool GetSyncTime::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSyncTime::documentation() const { return Documentation; }


    int GetSyncTime::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetSyncTimeResult
///
#include "gen/GetSyncTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSyncTimeResult::CmdName = "GetSyncTimeResult";
    const char* const GetSyncTimeResult::Documentation = "Result of GetSyncTime.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSyncTimeResult);


    GetSyncTimeResult::GetSyncTimeResult()
      : CommandResult(CmdName)
    {}

    GetSyncTimeResult::GetSyncTimeResult(CommandBasePtr relatedCommand, double time)
      : CommandResult(CmdName, relatedCommand)
    {

      setTime(time);
    }


    GetSyncTimeResultPtr GetSyncTimeResult::create(CommandBasePtr relatedCommand, double time)
    {
      return std::make_shared<GetSyncTimeResult>(relatedCommand, time);
    }

    GetSyncTimeResultPtr GetSyncTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSyncTimeResult>(ptr);
    }

    bool GetSyncTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Time"])
        ;

    }

    std::string GetSyncTimeResult::documentation() const { return Documentation; }


    double GetSyncTimeResult::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void GetSyncTimeResult::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSyncTimeMaster
///
#include "gen/SetSyncTimeMaster.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSyncTimeMaster::CmdName = "SetSyncTimeMaster";
    const char* const SetSyncTimeMaster::Documentation = "Set time delay to start streaming after PPS synchronization. A value of 1500\nmeans the simulation will start streaming 1.5 sec after the PPS used for\nsynchornization.";

    REGISTER_COMMAND_FACTORY(SetSyncTimeMaster);


    SetSyncTimeMaster::SetSyncTimeMaster()
      : CommandBase(CmdName)
    {}

    SetSyncTimeMaster::SetSyncTimeMaster(double time)
      : CommandBase(CmdName)
    {

      setTime(time);
    }


    SetSyncTimeMasterPtr SetSyncTimeMaster::create(double time)
    {
      return std::make_shared<SetSyncTimeMaster>(time);
    }

    SetSyncTimeMasterPtr SetSyncTimeMaster::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSyncTimeMaster>(ptr);
    }

    bool SetSyncTimeMaster::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Time"])
        ;

    }

    std::string SetSyncTimeMaster::documentation() const { return Documentation; }


    int SetSyncTimeMaster::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSyncTimeMaster::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void SetSyncTimeMaster::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSyncTimeMaster
///
#include "gen/GetSyncTimeMaster.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSyncTimeMaster::CmdName = "GetSyncTimeMaster";
    const char* const GetSyncTimeMaster::Documentation = "Get time delay to start streaming after PPS synchronization. A value of 1500\nmeans the simulation will start streaming 1.5 sec after the PPS used for\nsynchornization.";

    REGISTER_COMMAND_FACTORY(GetSyncTimeMaster);


    GetSyncTimeMaster::GetSyncTimeMaster()
      : CommandBase(CmdName)
    {

    }


    GetSyncTimeMasterPtr GetSyncTimeMaster::create()
    {
      return std::make_shared<GetSyncTimeMaster>();
    }

    GetSyncTimeMasterPtr GetSyncTimeMaster::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSyncTimeMaster>(ptr);
    }

    bool GetSyncTimeMaster::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSyncTimeMaster::documentation() const { return Documentation; }


    int GetSyncTimeMaster::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetSyncTimeMasterResult
///
#include "gen/GetSyncTimeMasterResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSyncTimeMasterResult::CmdName = "GetSyncTimeMasterResult";
    const char* const GetSyncTimeMasterResult::Documentation = "Result of GetSyncTimeMaster.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSyncTimeMasterResult);


    GetSyncTimeMasterResult::GetSyncTimeMasterResult()
      : CommandResult(CmdName)
    {}

    GetSyncTimeMasterResult::GetSyncTimeMasterResult(CommandBasePtr relatedCommand, double time)
      : CommandResult(CmdName, relatedCommand)
    {

      setTime(time);
    }


    GetSyncTimeMasterResultPtr GetSyncTimeMasterResult::create(CommandBasePtr relatedCommand, double time)
    {
      return std::make_shared<GetSyncTimeMasterResult>(relatedCommand, time);
    }

    GetSyncTimeMasterResultPtr GetSyncTimeMasterResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSyncTimeMasterResult>(ptr);
    }

    bool GetSyncTimeMasterResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Time"])
        ;

    }

    std::string GetSyncTimeMasterResult::documentation() const { return Documentation; }


    double GetSyncTimeMasterResult::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void GetSyncTimeMasterResult::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of StopWhenCommandFail
///
#include "gen/StopWhenCommandFail.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const StopWhenCommandFail::CmdName = "StopWhenCommandFail";
    const char* const StopWhenCommandFail::Documentation = "If enabled, simulation stops when a command result fail.";

    REGISTER_COMMAND_FACTORY(StopWhenCommandFail);


    StopWhenCommandFail::StopWhenCommandFail()
      : CommandBase(CmdName)
    {}

    StopWhenCommandFail::StopWhenCommandFail(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    StopWhenCommandFailPtr StopWhenCommandFail::create(bool enabled)
    {
      return std::make_shared<StopWhenCommandFail>(enabled);
    }

    StopWhenCommandFailPtr StopWhenCommandFail::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<StopWhenCommandFail>(ptr);
    }

    bool StopWhenCommandFail::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string StopWhenCommandFail::documentation() const { return Documentation; }


    int StopWhenCommandFail::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool StopWhenCommandFail::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void StopWhenCommandFail::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSimStopWhenCommandFailEnabled
///
#include "gen/IsSimStopWhenCommandFailEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSimStopWhenCommandFailEnabled::CmdName = "IsSimStopWhenCommandFailEnabled";
    const char* const IsSimStopWhenCommandFailEnabled::Documentation = "If enabled, simulation stops when a command result fail.";

    REGISTER_COMMAND_FACTORY(IsSimStopWhenCommandFailEnabled);


    IsSimStopWhenCommandFailEnabled::IsSimStopWhenCommandFailEnabled()
      : CommandBase(CmdName)
    {

    }


    IsSimStopWhenCommandFailEnabledPtr IsSimStopWhenCommandFailEnabled::create()
    {
      return std::make_shared<IsSimStopWhenCommandFailEnabled>();
    }

    IsSimStopWhenCommandFailEnabledPtr IsSimStopWhenCommandFailEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSimStopWhenCommandFailEnabled>(ptr);
    }

    bool IsSimStopWhenCommandFailEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsSimStopWhenCommandFailEnabled::documentation() const { return Documentation; }


    int IsSimStopWhenCommandFailEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of IsSimStopWhenCommandFailEnabledResult
///
#include "gen/IsSimStopWhenCommandFailEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSimStopWhenCommandFailEnabledResult::CmdName = "IsSimStopWhenCommandFailEnabledResult";
    const char* const IsSimStopWhenCommandFailEnabledResult::Documentation = "Result of IsSimStopWhenCommandFailEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSimStopWhenCommandFailEnabledResult);


    IsSimStopWhenCommandFailEnabledResult::IsSimStopWhenCommandFailEnabledResult()
      : CommandResult(CmdName)
    {}

    IsSimStopWhenCommandFailEnabledResult::IsSimStopWhenCommandFailEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsSimStopWhenCommandFailEnabledResultPtr IsSimStopWhenCommandFailEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsSimStopWhenCommandFailEnabledResult>(relatedCommand, enabled);
    }

    IsSimStopWhenCommandFailEnabledResultPtr IsSimStopWhenCommandFailEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSimStopWhenCommandFailEnabledResult>(ptr);
    }

    bool IsSimStopWhenCommandFailEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSimStopWhenCommandFailEnabledResult::documentation() const { return Documentation; }


    bool IsSimStopWhenCommandFailEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSimStopWhenCommandFailEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of StopMasterWhenSlaveStop
///
#include "gen/StopMasterWhenSlaveStop.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const StopMasterWhenSlaveStop::CmdName = "StopMasterWhenSlaveStop";
    const char* const StopMasterWhenSlaveStop::Documentation = "If enabled, master and all the slaves will stop if a slave stop.";

    REGISTER_COMMAND_FACTORY(StopMasterWhenSlaveStop);


    StopMasterWhenSlaveStop::StopMasterWhenSlaveStop()
      : CommandBase(CmdName)
    {}

    StopMasterWhenSlaveStop::StopMasterWhenSlaveStop(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    StopMasterWhenSlaveStopPtr StopMasterWhenSlaveStop::create(bool enabled)
    {
      return std::make_shared<StopMasterWhenSlaveStop>(enabled);
    }

    StopMasterWhenSlaveStopPtr StopMasterWhenSlaveStop::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<StopMasterWhenSlaveStop>(ptr);
    }

    bool StopMasterWhenSlaveStop::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string StopMasterWhenSlaveStop::documentation() const { return Documentation; }


    int StopMasterWhenSlaveStop::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool StopMasterWhenSlaveStop::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void StopMasterWhenSlaveStop::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsStopMasterWhenSlaveStop
///
#include "gen/IsStopMasterWhenSlaveStop.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsStopMasterWhenSlaveStop::CmdName = "IsStopMasterWhenSlaveStop";
    const char* const IsStopMasterWhenSlaveStop::Documentation = "If enabled, master and all the slaves will stop if a slave stop.";

    REGISTER_COMMAND_FACTORY(IsStopMasterWhenSlaveStop);


    IsStopMasterWhenSlaveStop::IsStopMasterWhenSlaveStop()
      : CommandBase(CmdName)
    {

    }


    IsStopMasterWhenSlaveStopPtr IsStopMasterWhenSlaveStop::create()
    {
      return std::make_shared<IsStopMasterWhenSlaveStop>();
    }

    IsStopMasterWhenSlaveStopPtr IsStopMasterWhenSlaveStop::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsStopMasterWhenSlaveStop>(ptr);
    }

    bool IsStopMasterWhenSlaveStop::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsStopMasterWhenSlaveStop::documentation() const { return Documentation; }


    int IsStopMasterWhenSlaveStop::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of IsStopMasterWhenSlaveStopResult
///
#include "gen/IsStopMasterWhenSlaveStopResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsStopMasterWhenSlaveStopResult::CmdName = "IsStopMasterWhenSlaveStopResult";
    const char* const IsStopMasterWhenSlaveStopResult::Documentation = "Result of IsStopMasterWhenSlaveStop.";

    REGISTER_COMMAND_RESULT_FACTORY(IsStopMasterWhenSlaveStopResult);


    IsStopMasterWhenSlaveStopResult::IsStopMasterWhenSlaveStopResult()
      : CommandResult(CmdName)
    {}

    IsStopMasterWhenSlaveStopResult::IsStopMasterWhenSlaveStopResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsStopMasterWhenSlaveStopResultPtr IsStopMasterWhenSlaveStopResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return std::make_shared<IsStopMasterWhenSlaveStopResult>(relatedCommand, enabled);
    }

    IsStopMasterWhenSlaveStopResultPtr IsStopMasterWhenSlaveStopResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsStopMasterWhenSlaveStopResult>(ptr);
    }

    bool IsStopMasterWhenSlaveStopResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsStopMasterWhenSlaveStopResult::documentation() const { return Documentation; }


    bool IsStopMasterWhenSlaveStopResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsStopMasterWhenSlaveStopResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ShowMapAnalysis
///
#include "gen/ShowMapAnalysis.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ShowMapAnalysis::CmdName = "ShowMapAnalysis";
    const char* const ShowMapAnalysis::Documentation = "Set if map is show/hide in Analysis tab.";

    REGISTER_COMMAND_FACTORY(ShowMapAnalysis);


    ShowMapAnalysis::ShowMapAnalysis()
      : CommandBase(CmdName)
    {}

    ShowMapAnalysis::ShowMapAnalysis(bool show)
      : CommandBase(CmdName)
    {

      setShow(show);
    }


    ShowMapAnalysisPtr ShowMapAnalysis::create(bool show)
    {
      return std::make_shared<ShowMapAnalysis>(show);
    }

    ShowMapAnalysisPtr ShowMapAnalysis::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ShowMapAnalysis>(ptr);
    }

    bool ShowMapAnalysis::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Show"])
        ;

    }

    std::string ShowMapAnalysis::documentation() const { return Documentation; }


    int ShowMapAnalysis::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    bool ShowMapAnalysis::show() const
    {
      return parse_json<bool>::parse(m_values["Show"]);
    }

    void ShowMapAnalysis::setShow(bool show)
    {
      m_values.AddMember("Show", parse_json<bool>::format(show, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsMapAnalysisEnabled
///
#include "gen/IsMapAnalysisEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsMapAnalysisEnabled::CmdName = "IsMapAnalysisEnabled";
    const char* const IsMapAnalysisEnabled::Documentation = "Get if map is show/hide in Analysis tab.";

    REGISTER_COMMAND_FACTORY(IsMapAnalysisEnabled);


    IsMapAnalysisEnabled::IsMapAnalysisEnabled()
      : CommandBase(CmdName)
    {

    }


    IsMapAnalysisEnabledPtr IsMapAnalysisEnabled::create()
    {
      return std::make_shared<IsMapAnalysisEnabled>();
    }

    IsMapAnalysisEnabledPtr IsMapAnalysisEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsMapAnalysisEnabled>(ptr);
    }

    bool IsMapAnalysisEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsMapAnalysisEnabled::documentation() const { return Documentation; }


    int IsMapAnalysisEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsMapAnalysisEnabledResult
///
#include "gen/IsMapAnalysisEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsMapAnalysisEnabledResult::CmdName = "IsMapAnalysisEnabledResult";
    const char* const IsMapAnalysisEnabledResult::Documentation = "Result of IsMapAnalysisEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsMapAnalysisEnabledResult);


    IsMapAnalysisEnabledResult::IsMapAnalysisEnabledResult()
      : CommandResult(CmdName)
    {}

    IsMapAnalysisEnabledResult::IsMapAnalysisEnabledResult(CommandBasePtr relatedCommand, bool show)
      : CommandResult(CmdName, relatedCommand)
    {

      setShow(show);
    }


    IsMapAnalysisEnabledResultPtr IsMapAnalysisEnabledResult::create(CommandBasePtr relatedCommand, bool show)
    {
      return std::make_shared<IsMapAnalysisEnabledResult>(relatedCommand, show);
    }

    IsMapAnalysisEnabledResultPtr IsMapAnalysisEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsMapAnalysisEnabledResult>(ptr);
    }

    bool IsMapAnalysisEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Show"])
        ;

    }

    std::string IsMapAnalysisEnabledResult::documentation() const { return Documentation; }


    bool IsMapAnalysisEnabledResult::show() const
    {
      return parse_json<bool>::parse(m_values["Show"]);
    }

    void IsMapAnalysisEnabledResult::setShow(bool show)
    {
      m_values.AddMember("Show", parse_json<bool>::format(show, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpectrumVisible
///
#include "gen/SetSpectrumVisible.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpectrumVisible::CmdName = "SetSpectrumVisible";
    const char* const SetSpectrumVisible::Documentation = "Set if spectrums are show/hide.";

    REGISTER_COMMAND_FACTORY(SetSpectrumVisible);


    SetSpectrumVisible::SetSpectrumVisible()
      : CommandBase(CmdName)
    {}

    SetSpectrumVisible::SetSpectrumVisible(bool visible)
      : CommandBase(CmdName)
    {

      setVisible(visible);
    }


    SetSpectrumVisiblePtr SetSpectrumVisible::create(bool visible)
    {
      return std::make_shared<SetSpectrumVisible>(visible);
    }

    SetSpectrumVisiblePtr SetSpectrumVisible::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpectrumVisible>(ptr);
    }

    bool SetSpectrumVisible::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Visible"])
        ;

    }

    std::string SetSpectrumVisible::documentation() const { return Documentation; }


    int SetSpectrumVisible::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    bool SetSpectrumVisible::visible() const
    {
      return parse_json<bool>::parse(m_values["Visible"]);
    }

    void SetSpectrumVisible::setVisible(bool visible)
    {
      m_values.AddMember("Visible", parse_json<bool>::format(visible, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpectrumVisible
///
#include "gen/IsSpectrumVisible.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpectrumVisible::CmdName = "IsSpectrumVisible";
    const char* const IsSpectrumVisible::Documentation = "Get if spectrums are show/hide.";

    REGISTER_COMMAND_FACTORY(IsSpectrumVisible);


    IsSpectrumVisible::IsSpectrumVisible()
      : CommandBase(CmdName)
    {

    }


    IsSpectrumVisiblePtr IsSpectrumVisible::create()
    {
      return std::make_shared<IsSpectrumVisible>();
    }

    IsSpectrumVisiblePtr IsSpectrumVisible::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpectrumVisible>(ptr);
    }

    bool IsSpectrumVisible::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsSpectrumVisible::documentation() const { return Documentation; }


    int IsSpectrumVisible::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsSpectrumVisibleResult
///
#include "gen/IsSpectrumVisibleResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpectrumVisibleResult::CmdName = "IsSpectrumVisibleResult";
    const char* const IsSpectrumVisibleResult::Documentation = "Result of IsSpectrumVisible.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSpectrumVisibleResult);


    IsSpectrumVisibleResult::IsSpectrumVisibleResult()
      : CommandResult(CmdName)
    {}

    IsSpectrumVisibleResult::IsSpectrumVisibleResult(CommandBasePtr relatedCommand, bool visible)
      : CommandResult(CmdName, relatedCommand)
    {

      setVisible(visible);
    }


    IsSpectrumVisibleResultPtr IsSpectrumVisibleResult::create(CommandBasePtr relatedCommand, bool visible)
    {
      return std::make_shared<IsSpectrumVisibleResult>(relatedCommand, visible);
    }

    IsSpectrumVisibleResultPtr IsSpectrumVisibleResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpectrumVisibleResult>(ptr);
    }

    bool IsSpectrumVisibleResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Visible"])
        ;

    }

    std::string IsSpectrumVisibleResult::documentation() const { return Documentation; }


    bool IsSpectrumVisibleResult::visible() const
    {
      return parse_json<bool>::parse(m_values["Visible"]);
    }

    void IsSpectrumVisibleResult::setVisible(bool visible)
    {
      m_values.AddMember("Visible", parse_json<bool>::format(visible, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSimulatorState
///
#include "gen/GetSimulatorState.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSimulatorState::CmdName = "GetSimulatorState";
    const char* const GetSimulatorState::Documentation = "Ask current simulator state. Will return a SimulatorStateResult.";

    REGISTER_COMMAND_FACTORY(GetSimulatorState);


    GetSimulatorState::GetSimulatorState()
      : CommandBase(CmdName)
    {

    }


    GetSimulatorStatePtr GetSimulatorState::create()
    {
      return std::make_shared<GetSimulatorState>();
    }

    GetSimulatorStatePtr GetSimulatorState::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSimulatorState>(ptr);
    }

    bool GetSimulatorState::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSimulatorState::documentation() const { return Documentation; }


    int GetSimulatorState::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of WaitSimulatorState
///
#include "gen/WaitSimulatorState.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const WaitSimulatorState::CmdName = "WaitSimulatorState";
    const char* const WaitSimulatorState::Documentation = "Wait until simulator has reached the specified substate unless simulator goes to error state or specified failure substate. Will return a SimulatorStateResult.\nPossible substates are :\n-None\n-Incomplete\n-Ready\n-Initializing\n-Armed\n-Streaming RF\n-Sync Slave\n-WF Init (Slave)\n-WF Init (Master)\n-HIL Sync\n-Sync Init\n-Sync PPS Reset\n-Sync Start Time\n-Sync Start\n-Error";

    REGISTER_COMMAND_FACTORY(WaitSimulatorState);


    WaitSimulatorState::WaitSimulatorState()
      : CommandBase(CmdName)
    {}

    WaitSimulatorState::WaitSimulatorState(const std::string& state, const std::string& failureState)
      : CommandBase(CmdName)
    {

      setState(state);
      setFailureState(failureState);
    }


    WaitSimulatorStatePtr WaitSimulatorState::create(const std::string& state, const std::string& failureState)
    {
      return std::make_shared<WaitSimulatorState>(state, failureState);
    }

    WaitSimulatorStatePtr WaitSimulatorState::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<WaitSimulatorState>(ptr);
    }

    bool WaitSimulatorState::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["State"])
          && parse_json<std::string>::is_valid(m_values["FailureState"])
        ;

    }

    std::string WaitSimulatorState::documentation() const { return Documentation; }


    int WaitSimulatorState::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string WaitSimulatorState::state() const
    {
      return parse_json<std::string>::parse(m_values["State"]);
    }

    void WaitSimulatorState::setState(const std::string& state)
    {
      m_values.AddMember("State", parse_json<std::string>::format(state, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string WaitSimulatorState::failureState() const
    {
      return parse_json<std::string>::parse(m_values["FailureState"]);
    }

    void WaitSimulatorState::setFailureState(const std::string& failureState)
    {
      m_values.AddMember("FailureState", parse_json<std::string>::format(failureState, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AbortWaitSimulatorState
///
#include "gen/AbortWaitSimulatorState.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AbortWaitSimulatorState::CmdName = "AbortWaitSimulatorState";
    const char* const AbortWaitSimulatorState::Documentation = "Abort the current WaitSimulatorState if any.";

    REGISTER_COMMAND_FACTORY(AbortWaitSimulatorState);


    AbortWaitSimulatorState::AbortWaitSimulatorState()
      : CommandBase(CmdName)
    {

    }


    AbortWaitSimulatorStatePtr AbortWaitSimulatorState::create()
    {
      return std::make_shared<AbortWaitSimulatorState>();
    }

    AbortWaitSimulatorStatePtr AbortWaitSimulatorState::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AbortWaitSimulatorState>(ptr);
    }

    bool AbortWaitSimulatorState::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string AbortWaitSimulatorState::documentation() const { return Documentation; }


    int AbortWaitSimulatorState::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of SimulatorStateResult
///
#include "gen/SimulatorStateResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SimulatorStateResult::CmdName = "SimulatorStateResult";
    const char* const SimulatorStateResult::Documentation = "Simulator State Result.\nPossible substates are :\n-None\n-Incomplete\n-Ready\n-Initializing\n-Armed\n-Streaming RF\n-Sync Slave\n-WF Init (Slave)\n-WF Init (Master)\n-HIL Sync\n-Sync Init\n-Sync PPS Reset\n-Sync Start Time\n-Sync Start\n-Error";

    REGISTER_COMMAND_RESULT_FACTORY(SimulatorStateResult);


    SimulatorStateResult::SimulatorStateResult()
      : CommandResult(CmdName)
    {}

    SimulatorStateResult::SimulatorStateResult(CommandBasePtr relatedCommand, const std::string& state, const std::string& error, const Sdx::SimulatorState& stateId, const Sdx::SimulatorSubState& subStateId)
      : CommandResult(CmdName, relatedCommand)
    {

      setState(state);
      setError(error);
      setStateId(stateId);
      setSubStateId(subStateId);
    }


    SimulatorStateResultPtr SimulatorStateResult::create(CommandBasePtr relatedCommand, const std::string& state, const std::string& error, const Sdx::SimulatorState& stateId, const Sdx::SimulatorSubState& subStateId)
    {
      return std::make_shared<SimulatorStateResult>(relatedCommand, state, error, stateId, subStateId);
    }

    SimulatorStateResultPtr SimulatorStateResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SimulatorStateResult>(ptr);
    }

    bool SimulatorStateResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["State"])
          && parse_json<std::string>::is_valid(m_values["Error"])
          && parse_json<Sdx::SimulatorState>::is_valid(m_values["StateId"])
          && parse_json<Sdx::SimulatorSubState>::is_valid(m_values["SubStateId"])
        ;

    }

    std::string SimulatorStateResult::documentation() const { return Documentation; }


    std::string SimulatorStateResult::state() const
    {
      return parse_json<std::string>::parse(m_values["State"]);
    }

    void SimulatorStateResult::setState(const std::string& state)
    {
      m_values.AddMember("State", parse_json<std::string>::format(state, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SimulatorStateResult::error() const
    {
      return parse_json<std::string>::parse(m_values["Error"]);
    }

    void SimulatorStateResult::setError(const std::string& error)
    {
      m_values.AddMember("Error", parse_json<std::string>::format(error, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::SimulatorState SimulatorStateResult::stateId() const
    {
      return parse_json<Sdx::SimulatorState>::parse(m_values["StateId"]);
    }

    void SimulatorStateResult::setStateId(const Sdx::SimulatorState& stateId)
    {
      m_values.AddMember("StateId", parse_json<Sdx::SimulatorState>::format(stateId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::SimulatorSubState SimulatorStateResult::subStateId() const
    {
      return parse_json<Sdx::SimulatorSubState>::parse(m_values["SubStateId"]);
    }

    void SimulatorStateResult::setSubStateId(const Sdx::SimulatorSubState& subStateId)
    {
      m_values.AddMember("SubStateId", parse_json<Sdx::SimulatorSubState>::format(subStateId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BeginVehicleInfo
///
#include "gen/BeginVehicleInfo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BeginVehicleInfo::CmdName = "BeginVehicleInfo";
    const char* const BeginVehicleInfo::Documentation = "Begin receiving simulated vehicle informations. \nDuring simulation, you must call RemoteSimulator.lastVehicleInfo to get current simulation statistics or RemoteSimulator.nextVehicleInfo to get pending simulation statistics";

    REGISTER_COMMAND_FACTORY(BeginVehicleInfo);


    BeginVehicleInfo::BeginVehicleInfo()
      : CommandBase(CmdName)
    {

    }


    BeginVehicleInfoPtr BeginVehicleInfo::create()
    {
      return std::make_shared<BeginVehicleInfo>();
    }

    BeginVehicleInfoPtr BeginVehicleInfo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BeginVehicleInfo>(ptr);
    }

    bool BeginVehicleInfo::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string BeginVehicleInfo::documentation() const { return Documentation; }


    int BeginVehicleInfo::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of EndVehicleInfo
///
#include "gen/EndVehicleInfo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndVehicleInfo::CmdName = "EndVehicleInfo";
    const char* const EndVehicleInfo::Documentation = "End receiving simulated vehicle informations.";

    REGISTER_COMMAND_FACTORY(EndVehicleInfo);


    EndVehicleInfo::EndVehicleInfo()
      : CommandBase(CmdName)
    {

    }


    EndVehicleInfoPtr EndVehicleInfo::create()
    {
      return std::make_shared<EndVehicleInfo>();
    }

    EndVehicleInfoPtr EndVehicleInfo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndVehicleInfo>(ptr);
    }

    bool EndVehicleInfo::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string EndVehicleInfo::documentation() const { return Documentation; }


    int EndVehicleInfo::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of MessageSequenceInsert
///
#include "gen/MessageSequenceInsert.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const MessageSequenceInsert::CmdName = "MessageSequenceInsert";
    const char* const MessageSequenceInsert::Documentation = "Insert message to sequence.";

    REGISTER_COMMAND_FACTORY(MessageSequenceInsert);


    MessageSequenceInsert::MessageSequenceInsert()
      : CommandBase(CmdName)
    {}

    MessageSequenceInsert::MessageSequenceInsert(const std::string& signal, int index, int type)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setIndex(index);
      setType(type);
    }


    MessageSequenceInsertPtr MessageSequenceInsert::create(const std::string& signal, int index, int type)
    {
      return std::make_shared<MessageSequenceInsert>(signal, index, type);
    }

    MessageSequenceInsertPtr MessageSequenceInsert::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<MessageSequenceInsert>(ptr);
    }

    bool MessageSequenceInsert::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<int>::is_valid(m_values["Type"])
        ;

    }

    std::string MessageSequenceInsert::documentation() const { return Documentation; }


    int MessageSequenceInsert::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string MessageSequenceInsert::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void MessageSequenceInsert::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceInsert::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void MessageSequenceInsert::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceInsert::type() const
    {
      return parse_json<int>::parse(m_values["Type"]);
    }

    void MessageSequenceInsert::setType(int type)
    {
      m_values.AddMember("Type", parse_json<int>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of MessageSequenceRemove
///
#include "gen/MessageSequenceRemove.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const MessageSequenceRemove::CmdName = "MessageSequenceRemove";
    const char* const MessageSequenceRemove::Documentation = "Remove message from sequence.";

    REGISTER_COMMAND_FACTORY(MessageSequenceRemove);


    MessageSequenceRemove::MessageSequenceRemove()
      : CommandBase(CmdName)
    {}

    MessageSequenceRemove::MessageSequenceRemove(const std::string& signal, int index)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setIndex(index);
    }


    MessageSequenceRemovePtr MessageSequenceRemove::create(const std::string& signal, int index)
    {
      return std::make_shared<MessageSequenceRemove>(signal, index);
    }

    MessageSequenceRemovePtr MessageSequenceRemove::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<MessageSequenceRemove>(ptr);
    }

    bool MessageSequenceRemove::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Index"])
        ;

    }

    std::string MessageSequenceRemove::documentation() const { return Documentation; }


    int MessageSequenceRemove::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string MessageSequenceRemove::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void MessageSequenceRemove::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceRemove::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void MessageSequenceRemove::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of MessageSequenceSwap
///
#include "gen/MessageSequenceSwap.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const MessageSequenceSwap::CmdName = "MessageSequenceSwap";
    const char* const MessageSequenceSwap::Documentation = "Swap 2 messages in sequence.";

    REGISTER_COMMAND_FACTORY(MessageSequenceSwap);


    MessageSequenceSwap::MessageSequenceSwap()
      : CommandBase(CmdName)
    {}

    MessageSequenceSwap::MessageSequenceSwap(const std::string& signal, int indexI, int indexJ)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setIndexI(indexI);
      setIndexJ(indexJ);
    }


    MessageSequenceSwapPtr MessageSequenceSwap::create(const std::string& signal, int indexI, int indexJ)
    {
      return std::make_shared<MessageSequenceSwap>(signal, indexI, indexJ);
    }

    MessageSequenceSwapPtr MessageSequenceSwap::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<MessageSequenceSwap>(ptr);
    }

    bool MessageSequenceSwap::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["IndexI"])
          && parse_json<int>::is_valid(m_values["IndexJ"])
        ;

    }

    std::string MessageSequenceSwap::documentation() const { return Documentation; }


    int MessageSequenceSwap::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string MessageSequenceSwap::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void MessageSequenceSwap::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceSwap::indexI() const
    {
      return parse_json<int>::parse(m_values["IndexI"]);
    }

    void MessageSequenceSwap::setIndexI(int indexI)
    {
      m_values.AddMember("IndexI", parse_json<int>::format(indexI, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceSwap::indexJ() const
    {
      return parse_json<int>::parse(m_values["IndexJ"]);
    }

    void MessageSequenceSwap::setIndexJ(int indexJ)
    {
      m_values.AddMember("IndexJ", parse_json<int>::format(indexJ, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of MessageSequenceImport
///
#include "gen/MessageSequenceImport.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const MessageSequenceImport::CmdName = "MessageSequenceImport";
    const char* const MessageSequenceImport::Documentation = "Import a sequence file.\nA sequence file is a CSV with one message type per line.";

    REGISTER_COMMAND_FACTORY(MessageSequenceImport);


    MessageSequenceImport::MessageSequenceImport()
      : CommandBase(CmdName)
    {}

    MessageSequenceImport::MessageSequenceImport(const std::string& signal, const std::string& filename)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setFilename(filename);
    }


    MessageSequenceImportPtr MessageSequenceImport::create(const std::string& signal, const std::string& filename)
    {
      return std::make_shared<MessageSequenceImport>(signal, filename);
    }

    MessageSequenceImportPtr MessageSequenceImport::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<MessageSequenceImport>(ptr);
    }

    bool MessageSequenceImport::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::string>::is_valid(m_values["Filename"])
        ;

    }

    std::string MessageSequenceImport::documentation() const { return Documentation; }


    int MessageSequenceImport::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string MessageSequenceImport::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void MessageSequenceImport::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string MessageSequenceImport::filename() const
    {
      return parse_json<std::string>::parse(m_values["Filename"]);
    }

    void MessageSequenceImport::setFilename(const std::string& filename)
    {
      m_values.AddMember("Filename", parse_json<std::string>::format(filename, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageSequence
///
#include "gen/GetMessageSequence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageSequence::CmdName = "GetMessageSequence";
    const char* const GetMessageSequence::Documentation = "Get the messages sequence for the signal";

    REGISTER_COMMAND_FACTORY(GetMessageSequence);


    GetMessageSequence::GetMessageSequence()
      : CommandBase(CmdName)
    {}

    GetMessageSequence::GetMessageSequence(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetMessageSequencePtr GetMessageSequence::create(const std::string& signal)
    {
      return std::make_shared<GetMessageSequence>(signal);
    }

    GetMessageSequencePtr GetMessageSequence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageSequence>(ptr);
    }

    bool GetMessageSequence::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetMessageSequence::documentation() const { return Documentation; }


    int GetMessageSequence::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageSequence::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetMessageSequence::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageSequenceResult
///
#include "gen/GetMessageSequenceResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageSequenceResult::CmdName = "GetMessageSequenceResult";
    const char* const GetMessageSequenceResult::Documentation = "Result of GetMessageSequence.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageSequenceResult);


    GetMessageSequenceResult::GetMessageSequenceResult()
      : CommandResult(CmdName)
    {}

    GetMessageSequenceResult::GetMessageSequenceResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<int>& sequence)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setSequence(sequence);
    }


    GetMessageSequenceResultPtr GetMessageSequenceResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<int>& sequence)
    {
      return std::make_shared<GetMessageSequenceResult>(relatedCommand, signal, sequence);
    }

    GetMessageSequenceResultPtr GetMessageSequenceResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageSequenceResult>(ptr);
    }

    bool GetMessageSequenceResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<int>>::is_valid(m_values["Sequence"])
        ;

    }

    std::string GetMessageSequenceResult::documentation() const { return Documentation; }


    std::string GetMessageSequenceResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetMessageSequenceResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetMessageSequenceResult::sequence() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Sequence"]);
    }

    void GetMessageSequenceResult::setSequence(const std::vector<int>& sequence)
    {
      m_values.AddMember("Sequence", parse_json<std::vector<int>>::format(sequence, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoFnavSatelliteK
///
#include "gen/SetGalileoFnavSatelliteK.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoFnavSatelliteK::CmdName = "SetGalileoFnavSatelliteK";
    const char* const SetGalileoFnavSatelliteK::Documentation = "Set the almanac satellite id for subframe 1 (Parameter K described in ICD 4.2.3 Frame Layout).";

    REGISTER_COMMAND_FACTORY(SetGalileoFnavSatelliteK);


    SetGalileoFnavSatelliteK::SetGalileoFnavSatelliteK()
      : CommandBase(CmdName)
    {}

    SetGalileoFnavSatelliteK::SetGalileoFnavSatelliteK(int prn, int k)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setK(k);
    }


    SetGalileoFnavSatelliteKPtr SetGalileoFnavSatelliteK::create(int prn, int k)
    {
      return std::make_shared<SetGalileoFnavSatelliteK>(prn, k);
    }

    SetGalileoFnavSatelliteKPtr SetGalileoFnavSatelliteK::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoFnavSatelliteK>(ptr);
    }

    bool SetGalileoFnavSatelliteK::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["K"])
        ;

    }

    std::string SetGalileoFnavSatelliteK::documentation() const { return Documentation; }


    int SetGalileoFnavSatelliteK::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGalileoFnavSatelliteK::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoFnavSatelliteK::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoFnavSatelliteK::k() const
    {
      return parse_json<int>::parse(m_values["K"]);
    }

    void SetGalileoFnavSatelliteK::setK(int k)
    {
      m_values.AddMember("K", parse_json<int>::format(k, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoFnavSatelliteK
///
#include "gen/GetGalileoFnavSatelliteK.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoFnavSatelliteK::CmdName = "GetGalileoFnavSatelliteK";
    const char* const GetGalileoFnavSatelliteK::Documentation = "Get the almanac satellite id for subframe 1 (Parameter K described in ICD 4.2.3 Frame Layout).";

    REGISTER_COMMAND_FACTORY(GetGalileoFnavSatelliteK);


    GetGalileoFnavSatelliteK::GetGalileoFnavSatelliteK()
      : CommandBase(CmdName)
    {}

    GetGalileoFnavSatelliteK::GetGalileoFnavSatelliteK(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGalileoFnavSatelliteKPtr GetGalileoFnavSatelliteK::create(int prn)
    {
      return std::make_shared<GetGalileoFnavSatelliteK>(prn);
    }

    GetGalileoFnavSatelliteKPtr GetGalileoFnavSatelliteK::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoFnavSatelliteK>(ptr);
    }

    bool GetGalileoFnavSatelliteK::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGalileoFnavSatelliteK::documentation() const { return Documentation; }


    int GetGalileoFnavSatelliteK::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoFnavSatelliteK::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoFnavSatelliteK::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoFnavSatelliteKResult
///
#include "gen/GetGalileoFnavSatelliteKResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoFnavSatelliteKResult::CmdName = "GetGalileoFnavSatelliteKResult";
    const char* const GetGalileoFnavSatelliteKResult::Documentation = "Result of GetGalileoFnavSatelliteK.";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoFnavSatelliteKResult);


    GetGalileoFnavSatelliteKResult::GetGalileoFnavSatelliteKResult()
      : CommandResult(CmdName)
    {}

    GetGalileoFnavSatelliteKResult::GetGalileoFnavSatelliteKResult(CommandBasePtr relatedCommand, int prn, int k)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setK(k);
    }


    GetGalileoFnavSatelliteKResultPtr GetGalileoFnavSatelliteKResult::create(CommandBasePtr relatedCommand, int prn, int k)
    {
      return std::make_shared<GetGalileoFnavSatelliteKResult>(relatedCommand, prn, k);
    }

    GetGalileoFnavSatelliteKResultPtr GetGalileoFnavSatelliteKResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoFnavSatelliteKResult>(ptr);
    }

    bool GetGalileoFnavSatelliteKResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["K"])
        ;

    }

    std::string GetGalileoFnavSatelliteKResult::documentation() const { return Documentation; }


    int GetGalileoFnavSatelliteKResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoFnavSatelliteKResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoFnavSatelliteKResult::k() const
    {
      return parse_json<int>::parse(m_values["K"]);
    }

    void GetGalileoFnavSatelliteKResult::setK(int k)
    {
      m_values.AddMember("K", parse_json<int>::format(k, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CalibFunction
///
#include "gen/CalibFunction.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CalibFunction::CmdName = "CalibFunction";
    const char* const CalibFunction::Documentation = "Skydel special calibration function, internal use only";

    REGISTER_COMMAND_FACTORY(CalibFunction);


    CalibFunction::CalibFunction()
      : CommandBase(CmdName)
    {}

    CalibFunction::CalibFunction(int svId, const std::string& signal, bool enableSV, bool enableDoppler, double phaseOffet)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSignal(signal);
      setEnableSV(enableSV);
      setEnableDoppler(enableDoppler);
      setPhaseOffet(phaseOffet);
    }


    CalibFunctionPtr CalibFunction::create(int svId, const std::string& signal, bool enableSV, bool enableDoppler, double phaseOffet)
    {
      return std::make_shared<CalibFunction>(svId, signal, enableSV, enableDoppler, phaseOffet);
    }

    CalibFunctionPtr CalibFunction::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CalibFunction>(ptr);
    }

    bool CalibFunction::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<bool>::is_valid(m_values["EnableSV"])
          && parse_json<bool>::is_valid(m_values["EnableDoppler"])
          && parse_json<double>::is_valid(m_values["PhaseOffet"])
        ;

    }

    std::string CalibFunction::documentation() const { return Documentation; }


    int CalibFunction::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    int CalibFunction::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void CalibFunction::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string CalibFunction::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void CalibFunction::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool CalibFunction::enableSV() const
    {
      return parse_json<bool>::parse(m_values["EnableSV"]);
    }

    void CalibFunction::setEnableSV(bool enableSV)
    {
      m_values.AddMember("EnableSV", parse_json<bool>::format(enableSV, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool CalibFunction::enableDoppler() const
    {
      return parse_json<bool>::parse(m_values["EnableDoppler"]);
    }

    void CalibFunction::setEnableDoppler(bool enableDoppler)
    {
      m_values.AddMember("EnableDoppler", parse_json<bool>::format(enableDoppler, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double CalibFunction::phaseOffet() const
    {
      return parse_json<double>::parse(m_values["PhaseOffet"]);
    }

    void CalibFunction::setPhaseOffet(double phaseOffet)
    {
      m_values.AddMember("PhaseOffet", parse_json<double>::format(phaseOffet, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearStatusLog
///
#include "gen/ClearStatusLog.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearStatusLog::CmdName = "ClearStatusLog";
    const char* const ClearStatusLog::Documentation = "Clears the status log";

    REGISTER_COMMAND_FACTORY(ClearStatusLog);


    ClearStatusLog::ClearStatusLog()
      : CommandBase(CmdName)
    {

    }


    ClearStatusLogPtr ClearStatusLog::create()
    {
      return std::make_shared<ClearStatusLog>();
    }

    ClearStatusLogPtr ClearStatusLog::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearStatusLog>(ptr);
    }

    bool ClearStatusLog::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearStatusLog::documentation() const { return Documentation; }


    int ClearStatusLog::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetStatusLog
///
#include "gen/GetStatusLog.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStatusLog::CmdName = "GetStatusLog";
    const char* const GetStatusLog::Documentation = "Returns the status log in a GetStatusLogResult and clears it";

    REGISTER_COMMAND_FACTORY(GetStatusLog);


    GetStatusLog::GetStatusLog()
      : CommandBase(CmdName)
    {

    }


    GetStatusLogPtr GetStatusLog::create()
    {
      return std::make_shared<GetStatusLog>();
    }

    GetStatusLogPtr GetStatusLog::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStatusLog>(ptr);
    }

    bool GetStatusLog::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetStatusLog::documentation() const { return Documentation; }


    int GetStatusLog::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetStatusLogResult
///
#include "gen/GetStatusLogResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStatusLogResult::CmdName = "GetStatusLogResult";
    const char* const GetStatusLogResult::Documentation = "Result of GetStatusLog.";

    REGISTER_COMMAND_RESULT_FACTORY(GetStatusLogResult);


    GetStatusLogResult::GetStatusLogResult()
      : CommandResult(CmdName)
    {}

    GetStatusLogResult::GetStatusLogResult(CommandBasePtr relatedCommand, const std::vector<Sdx::LogRecord>& records)
      : CommandResult(CmdName, relatedCommand)
    {

      setRecords(records);
    }


    GetStatusLogResultPtr GetStatusLogResult::create(CommandBasePtr relatedCommand, const std::vector<Sdx::LogRecord>& records)
    {
      return std::make_shared<GetStatusLogResult>(relatedCommand, records);
    }

    GetStatusLogResultPtr GetStatusLogResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStatusLogResult>(ptr);
    }

    bool GetStatusLogResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<Sdx::LogRecord>>::is_valid(m_values["Records"])
        ;

    }

    std::string GetStatusLogResult::documentation() const { return Documentation; }


    std::vector<Sdx::LogRecord> GetStatusLogResult::records() const
    {
      return parse_json<std::vector<Sdx::LogRecord>>::parse(m_values["Records"]);
    }

    void GetStatusLogResult::setRecords(const std::vector<Sdx::LogRecord>& records)
    {
      m_values.AddMember("Records", parse_json<std::vector<Sdx::LogRecord>>::format(records, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CommandGroup
///
#include "gen/CommandGroup.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CommandGroup::CmdName = "CommandGroup";
    const char* const CommandGroup::Documentation = "Group multiple commands as one";

    REGISTER_COMMAND_FACTORY(CommandGroup);


    CommandGroup::CommandGroup()
      : CommandBase(CmdName)
    {}

    CommandGroup::CommandGroup(const std::vector<Sdx::CommandBasePtr>& commands)
      : CommandBase(CmdName)
    {

      setCommands(commands);
    }


    CommandGroupPtr CommandGroup::create(const std::vector<Sdx::CommandBasePtr>& commands)
    {
      return std::make_shared<CommandGroup>(commands);
    }

    CommandGroupPtr CommandGroup::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CommandGroup>(ptr);
    }

    bool CommandGroup::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<Sdx::CommandBasePtr>>::is_valid(m_values["Commands"])
        ;

    }

    std::string CommandGroup::documentation() const { return Documentation; }


    int CommandGroup::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::vector<Sdx::CommandBasePtr> CommandGroup::commands() const
    {
      return parse_json<std::vector<Sdx::CommandBasePtr>>::parse(m_values["Commands"]);
    }

    void CommandGroup::setCommands(const std::vector<Sdx::CommandBasePtr>& commands)
    {
      m_values.AddMember("Commands", parse_json<std::vector<Sdx::CommandBasePtr>>::format(commands, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVisibleSV
///
#include "gen/GetVisibleSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVisibleSV::CmdName = "GetVisibleSV";
    const char* const GetVisibleSV::Documentation = "Get a list of visible satellites' SV IDs within a system, returns a GetVisibleSVResult";

    REGISTER_COMMAND_FACTORY(GetVisibleSV);


    GetVisibleSV::GetVisibleSV()
      : CommandBase(CmdName)
    {}

    GetVisibleSV::GetVisibleSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetVisibleSVPtr GetVisibleSV::create(const std::string& system)
    {
      return std::make_shared<GetVisibleSV>(system);
    }

    GetVisibleSVPtr GetVisibleSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVisibleSV>(ptr);
    }

    bool GetVisibleSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetVisibleSV::documentation() const { return Documentation; }


    int GetVisibleSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string GetVisibleSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetVisibleSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVisibleSVResult
///
#include "gen/GetVisibleSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVisibleSVResult::CmdName = "GetVisibleSVResult";
    const char* const GetVisibleSVResult::Documentation = "Result of GetVisibleSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetVisibleSVResult);


    GetVisibleSVResult::GetVisibleSVResult()
      : CommandResult(CmdName)
    {}

    GetVisibleSVResult::GetVisibleSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<int>& svId)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetVisibleSVResultPtr GetVisibleSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<int>& svId)
    {
      return std::make_shared<GetVisibleSVResult>(relatedCommand, system, svId);
    }

    GetVisibleSVResultPtr GetVisibleSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVisibleSVResult>(ptr);
    }

    bool GetVisibleSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<int>>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetVisibleSVResult::documentation() const { return Documentation; }


    std::string GetVisibleSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetVisibleSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetVisibleSVResult::svId() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvId"]);
    }

    void GetVisibleSVResult::setSvId(const std::vector<int>& svId)
    {
      m_values.AddMember("SvId", parse_json<std::vector<int>>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ArmPPS
///
#include "gen/ArmPPS.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ArmPPS::CmdName = "ArmPPS";
    const char* const ArmPPS::Documentation = "Arm the system for further PPS synchronization instructions.";

    REGISTER_COMMAND_FACTORY(ArmPPS);


    ArmPPS::ArmPPS()
      : CommandBase(CmdName)
    {

    }


    ArmPPSPtr ArmPPS::create()
    {
      return std::make_shared<ArmPPS>();
    }

    ArmPPSPtr ArmPPS::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ArmPPS>(ptr);
    }

    bool ArmPPS::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ArmPPS::documentation() const { return Documentation; }


    int ArmPPS::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of WaitAndResetPPS
///
#include "gen/WaitAndResetPPS.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const WaitAndResetPPS::CmdName = "WaitAndResetPPS";
    const char* const WaitAndResetPPS::Documentation = "Ask Skydel to reset its PPS counter.";

    REGISTER_COMMAND_FACTORY(WaitAndResetPPS);


    WaitAndResetPPS::WaitAndResetPPS()
      : CommandBase(CmdName)
    {

    }


    WaitAndResetPPSPtr WaitAndResetPPS::create()
    {
      return std::make_shared<WaitAndResetPPS>();
    }

    WaitAndResetPPSPtr WaitAndResetPPS::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<WaitAndResetPPS>(ptr);
    }

    bool WaitAndResetPPS::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string WaitAndResetPPS::documentation() const { return Documentation; }


    int WaitAndResetPPS::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of StartPPS
///
#include "gen/StartPPS.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const StartPPS::CmdName = "StartPPS";
    const char* const StartPPS::Documentation = "Start the simulation at the given PPS count.";

    REGISTER_COMMAND_FACTORY(StartPPS);


    StartPPS::StartPPS()
      : CommandBase(CmdName)
    {}

    StartPPS::StartPPS(int msec)
      : CommandBase(CmdName)
    {

      setMsec(msec);
    }


    StartPPSPtr StartPPS::create(int msec)
    {
      return std::make_shared<StartPPS>(msec);
    }

    StartPPSPtr StartPPS::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<StartPPS>(ptr);
    }

    bool StartPPS::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Msec"])
        ;

    }

    std::string StartPPS::documentation() const { return Documentation; }


    int StartPPS::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    int StartPPS::msec() const
    {
      return parse_json<int>::parse(m_values["Msec"]);
    }

    void StartPPS::setMsec(int msec)
    {
      m_values.AddMember("Msec", parse_json<int>::format(msec, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSV
///
#include "gen/EnableSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSV::CmdName = "EnableSV";
    const char* const EnableSV::Documentation = "Enable or disable a satellite for this constellation.";

    REGISTER_COMMAND_FACTORY(EnableSV);


    EnableSV::EnableSV()
      : CommandBase(CmdName)
    {}

    EnableSV::EnableSV(const std::string& system, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnableSVPtr EnableSV::create(const std::string& system, int svId, bool enabled)
    {
      return std::make_shared<EnableSV>(system, svId, enabled);
    }

    EnableSVPtr EnableSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSV>(ptr);
    }

    bool EnableSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSV::documentation() const { return Documentation; }


    int EnableSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EnableSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnableSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnableSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSVEnabled
///
#include "gen/IsSVEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSVEnabled::CmdName = "IsSVEnabled";
    const char* const IsSVEnabled::Documentation = "Get whether a satellite is enabled or disabled for this constellation.";

    REGISTER_COMMAND_FACTORY(IsSVEnabled);


    IsSVEnabled::IsSVEnabled()
      : CommandBase(CmdName)
    {}

    IsSVEnabled::IsSVEnabled(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    IsSVEnabledPtr IsSVEnabled::create(const std::string& system, int svId)
    {
      return std::make_shared<IsSVEnabled>(system, svId);
    }

    IsSVEnabledPtr IsSVEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSVEnabled>(ptr);
    }

    bool IsSVEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsSVEnabled::documentation() const { return Documentation; }


    int IsSVEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSVEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSVEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSVEnabled::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSVEnabled::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSVEnabledResult
///
#include "gen/IsSVEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSVEnabledResult::CmdName = "IsSVEnabledResult";
    const char* const IsSVEnabledResult::Documentation = "Result of IsSVEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSVEnabledResult);


    IsSVEnabledResult::IsSVEnabledResult()
      : CommandResult(CmdName)
    {}

    IsSVEnabledResult::IsSVEnabledResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsSVEnabledResultPtr IsSVEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
    {
      return std::make_shared<IsSVEnabledResult>(relatedCommand, system, svId, enabled);
    }

    IsSVEnabledResultPtr IsSVEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSVEnabledResult>(ptr);
    }

    bool IsSVEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSVEnabledResult::documentation() const { return Documentation; }


    std::string IsSVEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSVEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSVEnabledResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSVEnabledResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSVEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSVEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableEachSV
///
#include "gen/EnableEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableEachSV::CmdName = "EnableEachSV";
    const char* const EnableEachSV::Documentation = "Enable or disable each satellite for this constellation.";

    REGISTER_COMMAND_FACTORY(EnableEachSV);


    EnableEachSV::EnableEachSV()
      : CommandBase(CmdName)
    {}

    EnableEachSV::EnableEachSV(const std::string& system, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    EnableEachSVPtr EnableEachSV::create(const std::string& system, const std::vector<bool>& enabled)
    {
      return std::make_shared<EnableEachSV>(system, enabled);
    }

    EnableEachSVPtr EnableEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableEachSV>(ptr);
    }

    bool EnableEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableEachSV::documentation() const { return Documentation; }


    int EnableEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EnableEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsEachSVEnabled
///
#include "gen/IsEachSVEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsEachSVEnabled::CmdName = "IsEachSVEnabled";
    const char* const IsEachSVEnabled::Documentation = "Get whether each satellite is enabled or disabled for this constellation.";

    REGISTER_COMMAND_FACTORY(IsEachSVEnabled);


    IsEachSVEnabled::IsEachSVEnabled()
      : CommandBase(CmdName)
    {}

    IsEachSVEnabled::IsEachSVEnabled(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsEachSVEnabledPtr IsEachSVEnabled::create(const std::string& system)
    {
      return std::make_shared<IsEachSVEnabled>(system);
    }

    IsEachSVEnabledPtr IsEachSVEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsEachSVEnabled>(ptr);
    }

    bool IsEachSVEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsEachSVEnabled::documentation() const { return Documentation; }


    int IsEachSVEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsEachSVEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsEachSVEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsEachSVEnabledResult
///
#include "gen/IsEachSVEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsEachSVEnabledResult::CmdName = "IsEachSVEnabledResult";
    const char* const IsEachSVEnabledResult::Documentation = "Result of IsEachSVEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsEachSVEnabledResult);


    IsEachSVEnabledResult::IsEachSVEnabledResult()
      : CommandResult(CmdName)
    {}

    IsEachSVEnabledResult::IsEachSVEnabledResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    IsEachSVEnabledResultPtr IsEachSVEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
    {
      return std::make_shared<IsEachSVEnabledResult>(relatedCommand, system, enabled);
    }

    IsEachSVEnabledResultPtr IsEachSVEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsEachSVEnabledResult>(ptr);
    }

    bool IsEachSVEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsEachSVEnabledResult::documentation() const { return Documentation; }


    std::string IsEachSVEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsEachSVEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsEachSVEnabledResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsEachSVEnabledResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableCnav2Pages
///
#include "gen/EnableCnav2Pages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableCnav2Pages::CmdName = "EnableCnav2Pages";
    const char* const EnableCnav2Pages::Documentation = "Set the enabled L1C CNAV2 pages";

    REGISTER_COMMAND_FACTORY(EnableCnav2Pages);


    EnableCnav2Pages::EnableCnav2Pages()
      : CommandBase(CmdName)
    {}

    EnableCnav2Pages::EnableCnav2Pages(const std::vector<int>& messages)
      : CommandBase(CmdName)
    {

      setMessages(messages);
    }


    EnableCnav2PagesPtr EnableCnav2Pages::create(const std::vector<int>& messages)
    {
      return std::make_shared<EnableCnav2Pages>(messages);
    }

    EnableCnav2PagesPtr EnableCnav2Pages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableCnav2Pages>(ptr);
    }

    bool EnableCnav2Pages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["Messages"])
        ;

    }

    std::string EnableCnav2Pages::documentation() const { return Documentation; }


    int EnableCnav2Pages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<int> EnableCnav2Pages::messages() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Messages"]);
    }

    void EnableCnav2Pages::setMessages(const std::vector<int>& messages)
    {
      m_values.AddMember("Messages", parse_json<std::vector<int>>::format(messages, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetCnav2PagesEnabled
///
#include "gen/GetCnav2PagesEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetCnav2PagesEnabled::CmdName = "GetCnav2PagesEnabled";
    const char* const GetCnav2PagesEnabled::Documentation = "Get the enabled L1C CNAV2 pages";

    REGISTER_COMMAND_FACTORY(GetCnav2PagesEnabled);


    GetCnav2PagesEnabled::GetCnav2PagesEnabled()
      : CommandBase(CmdName)
    {

    }


    GetCnav2PagesEnabledPtr GetCnav2PagesEnabled::create()
    {
      return std::make_shared<GetCnav2PagesEnabled>();
    }

    GetCnav2PagesEnabledPtr GetCnav2PagesEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetCnav2PagesEnabled>(ptr);
    }

    bool GetCnav2PagesEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetCnav2PagesEnabled::documentation() const { return Documentation; }


    int GetCnav2PagesEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetCnav2PagesEnabledResult
///
#include "gen/GetCnav2PagesEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetCnav2PagesEnabledResult::CmdName = "GetCnav2PagesEnabledResult";
    const char* const GetCnav2PagesEnabledResult::Documentation = "Result of GetCnav2PagesEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(GetCnav2PagesEnabledResult);


    GetCnav2PagesEnabledResult::GetCnav2PagesEnabledResult()
      : CommandResult(CmdName)
    {}

    GetCnav2PagesEnabledResult::GetCnav2PagesEnabledResult(CommandBasePtr relatedCommand, const std::vector<int>& messages)
      : CommandResult(CmdName, relatedCommand)
    {

      setMessages(messages);
    }


    GetCnav2PagesEnabledResultPtr GetCnav2PagesEnabledResult::create(CommandBasePtr relatedCommand, const std::vector<int>& messages)
    {
      return std::make_shared<GetCnav2PagesEnabledResult>(relatedCommand, messages);
    }

    GetCnav2PagesEnabledResultPtr GetCnav2PagesEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetCnav2PagesEnabledResult>(ptr);
    }

    bool GetCnav2PagesEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["Messages"])
        ;

    }

    std::string GetCnav2PagesEnabledResult::documentation() const { return Documentation; }


    std::vector<int> GetCnav2PagesEnabledResult::messages() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Messages"]);
    }

    void GetCnav2PagesEnabledResult::setMessages(const std::vector<int>& messages)
    {
      m_values.AddMember("Messages", parse_json<std::vector<int>>::format(messages, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSbasMessages
///
#include "gen/EnableSbasMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSbasMessages::CmdName = "EnableSbasMessages";
    const char* const EnableSbasMessages::Documentation = "Set the enabled SBAS messages. Message 63 is always enabled";

    REGISTER_COMMAND_FACTORY(EnableSbasMessages);


    EnableSbasMessages::EnableSbasMessages()
      : CommandBase(CmdName)
    {}

    EnableSbasMessages::EnableSbasMessages(const std::vector<int>& messages)
      : CommandBase(CmdName)
    {

      setMessages(messages);
    }


    EnableSbasMessagesPtr EnableSbasMessages::create(const std::vector<int>& messages)
    {
      return std::make_shared<EnableSbasMessages>(messages);
    }

    EnableSbasMessagesPtr EnableSbasMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSbasMessages>(ptr);
    }

    bool EnableSbasMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["Messages"])
        ;

    }

    std::string EnableSbasMessages::documentation() const { return Documentation; }


    int EnableSbasMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::vector<int> EnableSbasMessages::messages() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Messages"]);
    }

    void EnableSbasMessages::setMessages(const std::vector<int>& messages)
    {
      m_values.AddMember("Messages", parse_json<std::vector<int>>::format(messages, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasMessagesEnabled
///
#include "gen/GetSbasMessagesEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMessagesEnabled::CmdName = "GetSbasMessagesEnabled";
    const char* const GetSbasMessagesEnabled::Documentation = "Get the enabled SBAS messages. Message 63 is always enabled";

    REGISTER_COMMAND_FACTORY(GetSbasMessagesEnabled);


    GetSbasMessagesEnabled::GetSbasMessagesEnabled()
      : CommandBase(CmdName)
    {

    }


    GetSbasMessagesEnabledPtr GetSbasMessagesEnabled::create()
    {
      return std::make_shared<GetSbasMessagesEnabled>();
    }

    GetSbasMessagesEnabledPtr GetSbasMessagesEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMessagesEnabled>(ptr);
    }

    bool GetSbasMessagesEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSbasMessagesEnabled::documentation() const { return Documentation; }


    int GetSbasMessagesEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetSbasMessagesEnabledResult
///
#include "gen/GetSbasMessagesEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMessagesEnabledResult::CmdName = "GetSbasMessagesEnabledResult";
    const char* const GetSbasMessagesEnabledResult::Documentation = "Result of GetSbasMessagesEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasMessagesEnabledResult);


    GetSbasMessagesEnabledResult::GetSbasMessagesEnabledResult()
      : CommandResult(CmdName)
    {}

    GetSbasMessagesEnabledResult::GetSbasMessagesEnabledResult(CommandBasePtr relatedCommand, const std::vector<int>& messages)
      : CommandResult(CmdName, relatedCommand)
    {

      setMessages(messages);
    }


    GetSbasMessagesEnabledResultPtr GetSbasMessagesEnabledResult::create(CommandBasePtr relatedCommand, const std::vector<int>& messages)
    {
      return std::make_shared<GetSbasMessagesEnabledResult>(relatedCommand, messages);
    }

    GetSbasMessagesEnabledResultPtr GetSbasMessagesEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMessagesEnabledResult>(ptr);
    }

    bool GetSbasMessagesEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["Messages"])
        ;

    }

    std::string GetSbasMessagesEnabledResult::documentation() const { return Documentation; }


    std::vector<int> GetSbasMessagesEnabledResult::messages() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Messages"]);
    }

    void GetSbasMessagesEnabledResult::setMessages(const std::vector<int>& messages)
    {
      m_values.AddMember("Messages", parse_json<std::vector<int>>::format(messages, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasMessageUpdateInterval
///
#include "gen/SetSbasMessageUpdateInterval.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasMessageUpdateInterval::CmdName = "SetSbasMessageUpdateInterval";
    const char* const SetSbasMessageUpdateInterval::Documentation = "Set the SBAS message update interval.";

    REGISTER_COMMAND_FACTORY(SetSbasMessageUpdateInterval);


    SetSbasMessageUpdateInterval::SetSbasMessageUpdateInterval()
      : CommandBase(CmdName)
    {}

    SetSbasMessageUpdateInterval::SetSbasMessageUpdateInterval(int message, int updateInterval)
      : CommandBase(CmdName)
    {

      setMessage(message);
      setUpdateInterval(updateInterval);
    }


    SetSbasMessageUpdateIntervalPtr SetSbasMessageUpdateInterval::create(int message, int updateInterval)
    {
      return std::make_shared<SetSbasMessageUpdateInterval>(message, updateInterval);
    }

    SetSbasMessageUpdateIntervalPtr SetSbasMessageUpdateInterval::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasMessageUpdateInterval>(ptr);
    }

    bool SetSbasMessageUpdateInterval::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Message"])
          && parse_json<int>::is_valid(m_values["UpdateInterval"])
        ;

    }

    std::string SetSbasMessageUpdateInterval::documentation() const { return Documentation; }


    int SetSbasMessageUpdateInterval::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetSbasMessageUpdateInterval::message() const
    {
      return parse_json<int>::parse(m_values["Message"]);
    }

    void SetSbasMessageUpdateInterval::setMessage(int message)
    {
      m_values.AddMember("Message", parse_json<int>::format(message, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSbasMessageUpdateInterval::updateInterval() const
    {
      return parse_json<int>::parse(m_values["UpdateInterval"]);
    }

    void SetSbasMessageUpdateInterval::setUpdateInterval(int updateInterval)
    {
      m_values.AddMember("UpdateInterval", parse_json<int>::format(updateInterval, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasMessageUpdateInterval
///
#include "gen/GetSbasMessageUpdateInterval.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMessageUpdateInterval::CmdName = "GetSbasMessageUpdateInterval";
    const char* const GetSbasMessageUpdateInterval::Documentation = "Get the SBAS message update interval.";

    REGISTER_COMMAND_FACTORY(GetSbasMessageUpdateInterval);


    GetSbasMessageUpdateInterval::GetSbasMessageUpdateInterval()
      : CommandBase(CmdName)
    {}

    GetSbasMessageUpdateInterval::GetSbasMessageUpdateInterval(int message)
      : CommandBase(CmdName)
    {

      setMessage(message);
    }


    GetSbasMessageUpdateIntervalPtr GetSbasMessageUpdateInterval::create(int message)
    {
      return std::make_shared<GetSbasMessageUpdateInterval>(message);
    }

    GetSbasMessageUpdateIntervalPtr GetSbasMessageUpdateInterval::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMessageUpdateInterval>(ptr);
    }

    bool GetSbasMessageUpdateInterval::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Message"])
        ;

    }

    std::string GetSbasMessageUpdateInterval::documentation() const { return Documentation; }


    int GetSbasMessageUpdateInterval::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int GetSbasMessageUpdateInterval::message() const
    {
      return parse_json<int>::parse(m_values["Message"]);
    }

    void GetSbasMessageUpdateInterval::setMessage(int message)
    {
      m_values.AddMember("Message", parse_json<int>::format(message, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasMessageUpdateIntervalResult
///
#include "gen/GetSbasMessageUpdateIntervalResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMessageUpdateIntervalResult::CmdName = "GetSbasMessageUpdateIntervalResult";
    const char* const GetSbasMessageUpdateIntervalResult::Documentation = "Result of GetSbasMessageUpdateInterval.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasMessageUpdateIntervalResult);


    GetSbasMessageUpdateIntervalResult::GetSbasMessageUpdateIntervalResult()
      : CommandResult(CmdName)
    {}

    GetSbasMessageUpdateIntervalResult::GetSbasMessageUpdateIntervalResult(CommandBasePtr relatedCommand, int message, int updateInterval)
      : CommandResult(CmdName, relatedCommand)
    {

      setMessage(message);
      setUpdateInterval(updateInterval);
    }


    GetSbasMessageUpdateIntervalResultPtr GetSbasMessageUpdateIntervalResult::create(CommandBasePtr relatedCommand, int message, int updateInterval)
    {
      return std::make_shared<GetSbasMessageUpdateIntervalResult>(relatedCommand, message, updateInterval);
    }

    GetSbasMessageUpdateIntervalResultPtr GetSbasMessageUpdateIntervalResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMessageUpdateIntervalResult>(ptr);
    }

    bool GetSbasMessageUpdateIntervalResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Message"])
          && parse_json<int>::is_valid(m_values["UpdateInterval"])
        ;

    }

    std::string GetSbasMessageUpdateIntervalResult::documentation() const { return Documentation; }


    int GetSbasMessageUpdateIntervalResult::message() const
    {
      return parse_json<int>::parse(m_values["Message"]);
    }

    void GetSbasMessageUpdateIntervalResult::setMessage(int message)
    {
      m_values.AddMember("Message", parse_json<int>::format(message, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSbasMessageUpdateIntervalResult::updateInterval() const
    {
      return parse_json<int>::parse(m_values["UpdateInterval"]);
    }

    void GetSbasMessageUpdateIntervalResult::setUpdateInterval(int updateInterval)
    {
      m_values.AddMember("UpdateInterval", parse_json<int>::format(updateInterval, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportSbasMessageSequence
///
#include "gen/ExportSbasMessageSequence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportSbasMessageSequence::CmdName = "ExportSbasMessageSequence";
    const char* const ExportSbasMessageSequence::Documentation = "Export the SBAS message sequence into a csv file.";

    REGISTER_COMMAND_FACTORY(ExportSbasMessageSequence);


    ExportSbasMessageSequence::ExportSbasMessageSequence()
      : CommandBase(CmdName)
    {}

    ExportSbasMessageSequence::ExportSbasMessageSequence(const std::string& path, bool overwriting)
      : CommandBase(CmdName)
    {

      setPath(path);
      setOverwriting(overwriting);
    }


    ExportSbasMessageSequencePtr ExportSbasMessageSequence::create(const std::string& path, bool overwriting)
    {
      return std::make_shared<ExportSbasMessageSequence>(path, overwriting);
    }

    ExportSbasMessageSequencePtr ExportSbasMessageSequence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportSbasMessageSequence>(ptr);
    }

    bool ExportSbasMessageSequence::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
        ;

    }

    std::string ExportSbasMessageSequence::documentation() const { return Documentation; }


    int ExportSbasMessageSequence::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string ExportSbasMessageSequence::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ExportSbasMessageSequence::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ExportSbasMessageSequence::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportSbasMessageSequence::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasMonitoredSystems
///
#include "gen/SetSbasMonitoredSystems.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasMonitoredSystems::CmdName = "SetSbasMonitoredSystems";
    const char* const SetSbasMonitoredSystems::Documentation = "Set the systems monitored by SBAS.";

    REGISTER_COMMAND_FACTORY(SetSbasMonitoredSystems);


    SetSbasMonitoredSystems::SetSbasMonitoredSystems()
      : CommandBase(CmdName)
    {}

    SetSbasMonitoredSystems::SetSbasMonitoredSystems(const std::vector<std::string>& systems)
      : CommandBase(CmdName)
    {

      setSystems(systems);
    }


    SetSbasMonitoredSystemsPtr SetSbasMonitoredSystems::create(const std::vector<std::string>& systems)
    {
      return std::make_shared<SetSbasMonitoredSystems>(systems);
    }

    SetSbasMonitoredSystemsPtr SetSbasMonitoredSystems::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasMonitoredSystems>(ptr);
    }

    bool SetSbasMonitoredSystems::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Systems"])
        ;

    }

    std::string SetSbasMonitoredSystems::documentation() const { return Documentation; }


    int SetSbasMonitoredSystems::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetSbasMonitoredSystems::systems() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Systems"]);
    }

    void SetSbasMonitoredSystems::setSystems(const std::vector<std::string>& systems)
    {
      m_values.AddMember("Systems", parse_json<std::vector<std::string>>::format(systems, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasMonitoredSystems
///
#include "gen/GetSbasMonitoredSystems.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMonitoredSystems::CmdName = "GetSbasMonitoredSystems";
    const char* const GetSbasMonitoredSystems::Documentation = "Get the systems monitored by SBAS.";

    REGISTER_COMMAND_FACTORY(GetSbasMonitoredSystems);


    GetSbasMonitoredSystems::GetSbasMonitoredSystems()
      : CommandBase(CmdName)
    {

    }


    GetSbasMonitoredSystemsPtr GetSbasMonitoredSystems::create()
    {
      return std::make_shared<GetSbasMonitoredSystems>();
    }

    GetSbasMonitoredSystemsPtr GetSbasMonitoredSystems::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMonitoredSystems>(ptr);
    }

    bool GetSbasMonitoredSystems::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSbasMonitoredSystems::documentation() const { return Documentation; }


    int GetSbasMonitoredSystems::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetSbasMonitoredSystemsResult
///
#include "gen/GetSbasMonitoredSystemsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMonitoredSystemsResult::CmdName = "GetSbasMonitoredSystemsResult";
    const char* const GetSbasMonitoredSystemsResult::Documentation = "Result of GetSbasMonitoredSystems.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasMonitoredSystemsResult);


    GetSbasMonitoredSystemsResult::GetSbasMonitoredSystemsResult()
      : CommandResult(CmdName)
    {}

    GetSbasMonitoredSystemsResult::GetSbasMonitoredSystemsResult(CommandBasePtr relatedCommand, const std::vector<std::string>& systems)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystems(systems);
    }


    GetSbasMonitoredSystemsResultPtr GetSbasMonitoredSystemsResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& systems)
    {
      return std::make_shared<GetSbasMonitoredSystemsResult>(relatedCommand, systems);
    }

    GetSbasMonitoredSystemsResultPtr GetSbasMonitoredSystemsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMonitoredSystemsResult>(ptr);
    }

    bool GetSbasMonitoredSystemsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Systems"])
        ;

    }

    std::string GetSbasMonitoredSystemsResult::documentation() const { return Documentation; }


    std::vector<std::string> GetSbasMonitoredSystemsResult::systems() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Systems"]);
    }

    void GetSbasMonitoredSystemsResult::setSystems(const std::vector<std::string>& systems)
    {
      m_values.AddMember("Systems", parse_json<std::vector<std::string>>::format(systems, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetUdreiForSV
///
#include "gen/SetUdreiForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetUdreiForSV::CmdName = "SetUdreiForSV";
    const char* const SetUdreiForSV::Documentation = "Set the UDREI value transmitted by SBAS for the satellite of the specified constellation.";

    REGISTER_COMMAND_FACTORY(SetUdreiForSV);


    SetUdreiForSV::SetUdreiForSV()
      : CommandBase(CmdName)
    {}

    SetUdreiForSV::SetUdreiForSV(const std::string& system, int svId, int udrei)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setUdrei(udrei);
    }


    SetUdreiForSVPtr SetUdreiForSV::create(const std::string& system, int svId, int udrei)
    {
      return std::make_shared<SetUdreiForSV>(system, svId, udrei);
    }

    SetUdreiForSVPtr SetUdreiForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetUdreiForSV>(ptr);
    }

    bool SetUdreiForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Udrei"])
        ;

    }

    std::string SetUdreiForSV::documentation() const { return Documentation; }


    int SetUdreiForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string SetUdreiForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetUdreiForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetUdreiForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetUdreiForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetUdreiForSV::udrei() const
    {
      return parse_json<int>::parse(m_values["Udrei"]);
    }

    void SetUdreiForSV::setUdrei(int udrei)
    {
      m_values.AddMember("Udrei", parse_json<int>::format(udrei, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetUdreiForSV
///
#include "gen/GetUdreiForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetUdreiForSV::CmdName = "GetUdreiForSV";
    const char* const GetUdreiForSV::Documentation = "Get the UDREI value transmitted by SBAS for the satellite of the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetUdreiForSV);


    GetUdreiForSV::GetUdreiForSV()
      : CommandBase(CmdName)
    {}

    GetUdreiForSV::GetUdreiForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetUdreiForSVPtr GetUdreiForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<GetUdreiForSV>(system, svId);
    }

    GetUdreiForSVPtr GetUdreiForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetUdreiForSV>(ptr);
    }

    bool GetUdreiForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetUdreiForSV::documentation() const { return Documentation; }


    int GetUdreiForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetUdreiForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetUdreiForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetUdreiForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetUdreiForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetUdreiForSVResult
///
#include "gen/GetUdreiForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetUdreiForSVResult::CmdName = "GetUdreiForSVResult";
    const char* const GetUdreiForSVResult::Documentation = "Result of GetUdreiForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetUdreiForSVResult);


    GetUdreiForSVResult::GetUdreiForSVResult()
      : CommandResult(CmdName)
    {}

    GetUdreiForSVResult::GetUdreiForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, int udrei)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setUdrei(udrei);
    }


    GetUdreiForSVResultPtr GetUdreiForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, int udrei)
    {
      return std::make_shared<GetUdreiForSVResult>(relatedCommand, system, svId, udrei);
    }

    GetUdreiForSVResultPtr GetUdreiForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetUdreiForSVResult>(ptr);
    }

    bool GetUdreiForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Udrei"])
        ;

    }

    std::string GetUdreiForSVResult::documentation() const { return Documentation; }


    std::string GetUdreiForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetUdreiForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetUdreiForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetUdreiForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetUdreiForSVResult::udrei() const
    {
      return parse_json<int>::parse(m_values["Udrei"]);
    }

    void GetUdreiForSVResult::setUdrei(int udrei)
    {
      m_values.AddMember("Udrei", parse_json<int>::format(udrei, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetUdreiForEachSV
///
#include "gen/SetUdreiForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetUdreiForEachSV::CmdName = "SetUdreiForEachSV";
    const char* const SetUdreiForEachSV::Documentation = "Set the UDREI value transmitted by SBAS for all satellites of the specified constellation.";

    REGISTER_COMMAND_FACTORY(SetUdreiForEachSV);


    SetUdreiForEachSV::SetUdreiForEachSV()
      : CommandBase(CmdName)
    {}

    SetUdreiForEachSV::SetUdreiForEachSV(const std::string& system, const std::vector<int>& udreis)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setUdreis(udreis);
    }


    SetUdreiForEachSVPtr SetUdreiForEachSV::create(const std::string& system, const std::vector<int>& udreis)
    {
      return std::make_shared<SetUdreiForEachSV>(system, udreis);
    }

    SetUdreiForEachSVPtr SetUdreiForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetUdreiForEachSV>(ptr);
    }

    bool SetUdreiForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<int>>::is_valid(m_values["Udreis"])
        ;

    }

    std::string SetUdreiForEachSV::documentation() const { return Documentation; }


    int SetUdreiForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string SetUdreiForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetUdreiForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetUdreiForEachSV::udreis() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Udreis"]);
    }

    void SetUdreiForEachSV::setUdreis(const std::vector<int>& udreis)
    {
      m_values.AddMember("Udreis", parse_json<std::vector<int>>::format(udreis, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetUdreiForEachSV
///
#include "gen/GetUdreiForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetUdreiForEachSV::CmdName = "GetUdreiForEachSV";
    const char* const GetUdreiForEachSV::Documentation = "Get the UDREI value transmitted by SBAS for all satellites of the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetUdreiForEachSV);


    GetUdreiForEachSV::GetUdreiForEachSV()
      : CommandBase(CmdName)
    {}

    GetUdreiForEachSV::GetUdreiForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetUdreiForEachSVPtr GetUdreiForEachSV::create(const std::string& system)
    {
      return std::make_shared<GetUdreiForEachSV>(system);
    }

    GetUdreiForEachSVPtr GetUdreiForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetUdreiForEachSV>(ptr);
    }

    bool GetUdreiForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetUdreiForEachSV::documentation() const { return Documentation; }


    int GetUdreiForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetUdreiForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetUdreiForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetUdreiForEachSVResult
///
#include "gen/GetUdreiForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetUdreiForEachSVResult::CmdName = "GetUdreiForEachSVResult";
    const char* const GetUdreiForEachSVResult::Documentation = "Result of GetUdreiForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetUdreiForEachSVResult);


    GetUdreiForEachSVResult::GetUdreiForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetUdreiForEachSVResult::GetUdreiForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<int>& udreis)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setUdreis(udreis);
    }


    GetUdreiForEachSVResultPtr GetUdreiForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<int>& udreis)
    {
      return std::make_shared<GetUdreiForEachSVResult>(relatedCommand, system, udreis);
    }

    GetUdreiForEachSVResultPtr GetUdreiForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetUdreiForEachSVResult>(ptr);
    }

    bool GetUdreiForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<int>>::is_valid(m_values["Udreis"])
        ;

    }

    std::string GetUdreiForEachSVResult::documentation() const { return Documentation; }


    std::string GetUdreiForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetUdreiForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetUdreiForEachSVResult::udreis() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Udreis"]);
    }

    void GetUdreiForEachSVResult::setUdreis(const std::vector<int>& udreis)
    {
      m_values.AddMember("Udreis", parse_json<std::vector<int>>::format(udreis, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BroadcastConfig
///
#include "gen/BroadcastConfig.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BroadcastConfig::CmdName = "BroadcastConfig";
    const char* const BroadcastConfig::Documentation = "Ask the master to broadcast its configuration to all slaves.";

    REGISTER_COMMAND_FACTORY(BroadcastConfig);


    BroadcastConfig::BroadcastConfig()
      : CommandBase(CmdName)
    {

    }


    BroadcastConfigPtr BroadcastConfig::create()
    {
      return std::make_shared<BroadcastConfig>();
    }

    BroadcastConfigPtr BroadcastConfig::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BroadcastConfig>(ptr);
    }

    bool BroadcastConfig::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string BroadcastConfig::documentation() const { return Documentation; }


    int BroadcastConfig::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of CancelBroadcastConfig
///
#include "gen/CancelBroadcastConfig.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CancelBroadcastConfig::CmdName = "CancelBroadcastConfig";
    const char* const CancelBroadcastConfig::Documentation = "Cancel the current configuration broadcast if any.";

    REGISTER_COMMAND_FACTORY(CancelBroadcastConfig);


    CancelBroadcastConfig::CancelBroadcastConfig()
      : CommandBase(CmdName)
    {

    }


    CancelBroadcastConfigPtr CancelBroadcastConfig::create()
    {
      return std::make_shared<CancelBroadcastConfig>();
    }

    CancelBroadcastConfigPtr CancelBroadcastConfig::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CancelBroadcastConfig>(ptr);
    }

    bool CancelBroadcastConfig::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string CancelBroadcastConfig::documentation() const { return Documentation; }


    int CancelBroadcastConfig::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of SetConfigBroadcastOnStart
///
#include "gen/SetConfigBroadcastOnStart.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetConfigBroadcastOnStart::CmdName = "SetConfigBroadcastOnStart";
    const char* const SetConfigBroadcastOnStart::Documentation = "Set wether the master should send its configuration to every slave when simulation start.";

    REGISTER_COMMAND_FACTORY(SetConfigBroadcastOnStart);


    SetConfigBroadcastOnStart::SetConfigBroadcastOnStart()
      : CommandBase(CmdName)
    {}

    SetConfigBroadcastOnStart::SetConfigBroadcastOnStart(bool broadcastOnStart)
      : CommandBase(CmdName)
    {

      setBroadcastOnStart(broadcastOnStart);
    }


    SetConfigBroadcastOnStartPtr SetConfigBroadcastOnStart::create(bool broadcastOnStart)
    {
      return std::make_shared<SetConfigBroadcastOnStart>(broadcastOnStart);
    }

    SetConfigBroadcastOnStartPtr SetConfigBroadcastOnStart::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetConfigBroadcastOnStart>(ptr);
    }

    bool SetConfigBroadcastOnStart::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["BroadcastOnStart"])
        ;

    }

    std::string SetConfigBroadcastOnStart::documentation() const { return Documentation; }


    int SetConfigBroadcastOnStart::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool SetConfigBroadcastOnStart::broadcastOnStart() const
    {
      return parse_json<bool>::parse(m_values["BroadcastOnStart"]);
    }

    void SetConfigBroadcastOnStart::setBroadcastOnStart(bool broadcastOnStart)
    {
      m_values.AddMember("BroadcastOnStart", parse_json<bool>::format(broadcastOnStart, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetConfigBroadcastOnStart
///
#include "gen/GetConfigBroadcastOnStart.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigBroadcastOnStart::CmdName = "GetConfigBroadcastOnStart";
    const char* const GetConfigBroadcastOnStart::Documentation = "Get wether the master should send its configuration to every slave when simulation start.";

    REGISTER_COMMAND_FACTORY(GetConfigBroadcastOnStart);


    GetConfigBroadcastOnStart::GetConfigBroadcastOnStart()
      : CommandBase(CmdName)
    {

    }


    GetConfigBroadcastOnStartPtr GetConfigBroadcastOnStart::create()
    {
      return std::make_shared<GetConfigBroadcastOnStart>();
    }

    GetConfigBroadcastOnStartPtr GetConfigBroadcastOnStart::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigBroadcastOnStart>(ptr);
    }

    bool GetConfigBroadcastOnStart::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetConfigBroadcastOnStart::documentation() const { return Documentation; }


    int GetConfigBroadcastOnStart::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetConfigBroadcastOnStartResult
///
#include "gen/GetConfigBroadcastOnStartResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigBroadcastOnStartResult::CmdName = "GetConfigBroadcastOnStartResult";
    const char* const GetConfigBroadcastOnStartResult::Documentation = "Result of GetConfigBroadcastOnStart.";

    REGISTER_COMMAND_RESULT_FACTORY(GetConfigBroadcastOnStartResult);


    GetConfigBroadcastOnStartResult::GetConfigBroadcastOnStartResult()
      : CommandResult(CmdName)
    {}

    GetConfigBroadcastOnStartResult::GetConfigBroadcastOnStartResult(CommandBasePtr relatedCommand, bool broadcastOnStart)
      : CommandResult(CmdName, relatedCommand)
    {

      setBroadcastOnStart(broadcastOnStart);
    }


    GetConfigBroadcastOnStartResultPtr GetConfigBroadcastOnStartResult::create(CommandBasePtr relatedCommand, bool broadcastOnStart)
    {
      return std::make_shared<GetConfigBroadcastOnStartResult>(relatedCommand, broadcastOnStart);
    }

    GetConfigBroadcastOnStartResultPtr GetConfigBroadcastOnStartResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigBroadcastOnStartResult>(ptr);
    }

    bool GetConfigBroadcastOnStartResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["BroadcastOnStart"])
        ;

    }

    std::string GetConfigBroadcastOnStartResult::documentation() const { return Documentation; }


    bool GetConfigBroadcastOnStartResult::broadcastOnStart() const
    {
      return parse_json<bool>::parse(m_values["BroadcastOnStart"]);
    }

    void GetConfigBroadcastOnStartResult::setBroadcastOnStart(bool broadcastOnStart)
    {
      m_values.AddMember("BroadcastOnStart", parse_json<bool>::format(broadcastOnStart, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetConfigBroadcastFilter
///
#include "gen/SetConfigBroadcastFilter.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetConfigBroadcastFilter::CmdName = "SetConfigBroadcastFilter";
    const char* const SetConfigBroadcastFilter::Documentation = "Set the filter for configuration broadcast.";

    REGISTER_COMMAND_FACTORY(SetConfigBroadcastFilter);


    SetConfigBroadcastFilter::SetConfigBroadcastFilter()
      : CommandBase(CmdName)
    {}

    SetConfigBroadcastFilter::SetConfigBroadcastFilter(const std::vector<Sdx::ConfigFilter>& filter)
      : CommandBase(CmdName)
    {

      setFilter(filter);
    }


    SetConfigBroadcastFilterPtr SetConfigBroadcastFilter::create(const std::vector<Sdx::ConfigFilter>& filter)
    {
      return std::make_shared<SetConfigBroadcastFilter>(filter);
    }

    SetConfigBroadcastFilterPtr SetConfigBroadcastFilter::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetConfigBroadcastFilter>(ptr);
    }

    bool SetConfigBroadcastFilter::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<Sdx::ConfigFilter>>::is_valid(m_values["Filter"])
        ;

    }

    std::string SetConfigBroadcastFilter::documentation() const { return Documentation; }


    int SetConfigBroadcastFilter::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<Sdx::ConfigFilter> SetConfigBroadcastFilter::filter() const
    {
      return parse_json<std::vector<Sdx::ConfigFilter>>::parse(m_values["Filter"]);
    }

    void SetConfigBroadcastFilter::setFilter(const std::vector<Sdx::ConfigFilter>& filter)
    {
      m_values.AddMember("Filter", parse_json<std::vector<Sdx::ConfigFilter>>::format(filter, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetConfigBroadcastFilter
///
#include "gen/GetConfigBroadcastFilter.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigBroadcastFilter::CmdName = "GetConfigBroadcastFilter";
    const char* const GetConfigBroadcastFilter::Documentation = "Get the filter for configuration broadcast.";

    REGISTER_COMMAND_FACTORY(GetConfigBroadcastFilter);


    GetConfigBroadcastFilter::GetConfigBroadcastFilter()
      : CommandBase(CmdName)
    {

    }


    GetConfigBroadcastFilterPtr GetConfigBroadcastFilter::create()
    {
      return std::make_shared<GetConfigBroadcastFilter>();
    }

    GetConfigBroadcastFilterPtr GetConfigBroadcastFilter::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigBroadcastFilter>(ptr);
    }

    bool GetConfigBroadcastFilter::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetConfigBroadcastFilter::documentation() const { return Documentation; }


    int GetConfigBroadcastFilter::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetConfigBroadcastFilterResult
///
#include "gen/GetConfigBroadcastFilterResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigBroadcastFilterResult::CmdName = "GetConfigBroadcastFilterResult";
    const char* const GetConfigBroadcastFilterResult::Documentation = "Result of GetConfigBroadcastFilter.";

    REGISTER_COMMAND_RESULT_FACTORY(GetConfigBroadcastFilterResult);


    GetConfigBroadcastFilterResult::GetConfigBroadcastFilterResult()
      : CommandResult(CmdName)
    {}

    GetConfigBroadcastFilterResult::GetConfigBroadcastFilterResult(CommandBasePtr relatedCommand, const std::vector<Sdx::ConfigFilter>& filter)
      : CommandResult(CmdName, relatedCommand)
    {

      setFilter(filter);
    }


    GetConfigBroadcastFilterResultPtr GetConfigBroadcastFilterResult::create(CommandBasePtr relatedCommand, const std::vector<Sdx::ConfigFilter>& filter)
    {
      return std::make_shared<GetConfigBroadcastFilterResult>(relatedCommand, filter);
    }

    GetConfigBroadcastFilterResultPtr GetConfigBroadcastFilterResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigBroadcastFilterResult>(ptr);
    }

    bool GetConfigBroadcastFilterResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<Sdx::ConfigFilter>>::is_valid(m_values["Filter"])
        ;

    }

    std::string GetConfigBroadcastFilterResult::documentation() const { return Documentation; }


    std::vector<Sdx::ConfigFilter> GetConfigBroadcastFilterResult::filter() const
    {
      return parse_json<std::vector<Sdx::ConfigFilter>>::parse(m_values["Filter"]);
    }

    void GetConfigBroadcastFilterResult::setFilter(const std::vector<Sdx::ConfigFilter>& filter)
    {
      m_values.AddMember("Filter", parse_json<std::vector<Sdx::ConfigFilter>>::format(filter, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseOffsetForSV
///
#include "gen/SetPseudorangeNoiseOffsetForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseOffsetForSV::CmdName = "SetPseudorangeNoiseOffsetForSV";
    const char* const SetPseudorangeNoiseOffsetForSV::Documentation = "Set the satellite pseudorange noise constant offset.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseOffsetForSV);


    SetPseudorangeNoiseOffsetForSV::SetPseudorangeNoiseOffsetForSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseOffsetForSV::SetPseudorangeNoiseOffsetForSV(const std::string& system, int svId, bool enabled, double offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
      setOffset(offset);
    }


    SetPseudorangeNoiseOffsetForSVPtr SetPseudorangeNoiseOffsetForSV::create(const std::string& system, int svId, bool enabled, double offset)
    {
      return std::make_shared<SetPseudorangeNoiseOffsetForSV>(system, svId, enabled, offset);
    }

    SetPseudorangeNoiseOffsetForSVPtr SetPseudorangeNoiseOffsetForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseOffsetForSV>(ptr);
    }

    bool SetPseudorangeNoiseOffsetForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPseudorangeNoiseOffsetForSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseOffsetForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseOffsetForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseOffsetForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseOffsetForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPseudorangeNoiseOffsetForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPseudorangeNoiseOffsetForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseOffsetForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseOffsetForSV::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPseudorangeNoiseOffsetForSV::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseOffsetForSV
///
#include "gen/GetPseudorangeNoiseOffsetForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseOffsetForSV::CmdName = "GetPseudorangeNoiseOffsetForSV";
    const char* const GetPseudorangeNoiseOffsetForSV::Documentation = "Get the satellite pseudorange noise constant offset.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseOffsetForSV);


    GetPseudorangeNoiseOffsetForSV::GetPseudorangeNoiseOffsetForSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseOffsetForSV::GetPseudorangeNoiseOffsetForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetPseudorangeNoiseOffsetForSVPtr GetPseudorangeNoiseOffsetForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<GetPseudorangeNoiseOffsetForSV>(system, svId);
    }

    GetPseudorangeNoiseOffsetForSVPtr GetPseudorangeNoiseOffsetForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseOffsetForSV>(ptr);
    }

    bool GetPseudorangeNoiseOffsetForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetPseudorangeNoiseOffsetForSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseOffsetForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseOffsetForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseOffsetForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseOffsetForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseOffsetForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseOffsetForSVResult
///
#include "gen/GetPseudorangeNoiseOffsetForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseOffsetForSVResult::CmdName = "GetPseudorangeNoiseOffsetForSVResult";
    const char* const GetPseudorangeNoiseOffsetForSVResult::Documentation = "Result of GetPseudorangeNoiseOffsetForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseOffsetForSVResult);


    GetPseudorangeNoiseOffsetForSVResult::GetPseudorangeNoiseOffsetForSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseOffsetForSVResult::GetPseudorangeNoiseOffsetForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
      setOffset(offset);
    }


    GetPseudorangeNoiseOffsetForSVResultPtr GetPseudorangeNoiseOffsetForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled, double offset)
    {
      return std::make_shared<GetPseudorangeNoiseOffsetForSVResult>(relatedCommand, system, svId, enabled, offset);
    }

    GetPseudorangeNoiseOffsetForSVResultPtr GetPseudorangeNoiseOffsetForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseOffsetForSVResult>(ptr);
    }

    bool GetPseudorangeNoiseOffsetForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPseudorangeNoiseOffsetForSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseOffsetForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseOffsetForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseOffsetForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseOffsetForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetPseudorangeNoiseOffsetForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseOffsetForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseOffsetForSVResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPseudorangeNoiseOffsetForSVResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseOffsetForEachSV
///
#include "gen/SetPseudorangeNoiseOffsetForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseOffsetForEachSV::CmdName = "SetPseudorangeNoiseOffsetForEachSV";
    const char* const SetPseudorangeNoiseOffsetForEachSV::Documentation = "Set the satellite pseudorange noise constant offset for all satellites.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseOffsetForEachSV);


    SetPseudorangeNoiseOffsetForEachSV::SetPseudorangeNoiseOffsetForEachSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseOffsetForEachSV::SetPseudorangeNoiseOffsetForEachSV(const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
      setOffset(offset);
    }


    SetPseudorangeNoiseOffsetForEachSVPtr SetPseudorangeNoiseOffsetForEachSV::create(const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
    {
      return std::make_shared<SetPseudorangeNoiseOffsetForEachSV>(system, enabled, offset);
    }

    SetPseudorangeNoiseOffsetForEachSVPtr SetPseudorangeNoiseOffsetForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseOffsetForEachSV>(ptr);
    }

    bool SetPseudorangeNoiseOffsetForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPseudorangeNoiseOffsetForEachSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseOffsetForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseOffsetForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseOffsetForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetPseudorangeNoiseOffsetForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseOffsetForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseOffsetForEachSV::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void SetPseudorangeNoiseOffsetForEachSV::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAllSatellitesPseudorangeNoiseOffset
///
#include "gen/SetAllSatellitesPseudorangeNoiseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAllSatellitesPseudorangeNoiseOffset::CmdName = "SetAllSatellitesPseudorangeNoiseOffset";
    const char* const SetAllSatellitesPseudorangeNoiseOffset::Documentation = "Please note the command SetAllSatellitesPseudorangeNoiseOffset is deprecated since 21.3. You may use SetPseudorangeNoiseOffsetForEachSV.\n\nSet the satellite pseudorange noise constant offset for all satellites.";

    REGISTER_COMMAND_FACTORY(SetAllSatellitesPseudorangeNoiseOffset);


    SetAllSatellitesPseudorangeNoiseOffset::SetAllSatellitesPseudorangeNoiseOffset()
      : CommandBase(CmdName)
    {}

    SetAllSatellitesPseudorangeNoiseOffset::SetAllSatellitesPseudorangeNoiseOffset(const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
      setOffset(offset);
    }


    SetAllSatellitesPseudorangeNoiseOffsetPtr SetAllSatellitesPseudorangeNoiseOffset::create(const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
    {
      return std::make_shared<SetAllSatellitesPseudorangeNoiseOffset>(system, enabled, offset);
    }

    SetAllSatellitesPseudorangeNoiseOffsetPtr SetAllSatellitesPseudorangeNoiseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAllSatellitesPseudorangeNoiseOffset>(ptr);
    }

    bool SetAllSatellitesPseudorangeNoiseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetAllSatellitesPseudorangeNoiseOffset::documentation() const { return Documentation; }


    int SetAllSatellitesPseudorangeNoiseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAllSatellitesPseudorangeNoiseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAllSatellitesPseudorangeNoiseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetAllSatellitesPseudorangeNoiseOffset::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetAllSatellitesPseudorangeNoiseOffset::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseOffset::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void SetAllSatellitesPseudorangeNoiseOffset::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseOffsetForEachSV
///
#include "gen/GetPseudorangeNoiseOffsetForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseOffsetForEachSV::CmdName = "GetPseudorangeNoiseOffsetForEachSV";
    const char* const GetPseudorangeNoiseOffsetForEachSV::Documentation = "Get the satellite pseudorange noise constant offset for all satellites.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseOffsetForEachSV);


    GetPseudorangeNoiseOffsetForEachSV::GetPseudorangeNoiseOffsetForEachSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseOffsetForEachSV::GetPseudorangeNoiseOffsetForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetPseudorangeNoiseOffsetForEachSVPtr GetPseudorangeNoiseOffsetForEachSV::create(const std::string& system)
    {
      return std::make_shared<GetPseudorangeNoiseOffsetForEachSV>(system);
    }

    GetPseudorangeNoiseOffsetForEachSVPtr GetPseudorangeNoiseOffsetForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseOffsetForEachSV>(ptr);
    }

    bool GetPseudorangeNoiseOffsetForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetPseudorangeNoiseOffsetForEachSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseOffsetForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseOffsetForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseOffsetForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSatellitesPseudorangeNoiseOffset
///
#include "gen/GetAllSatellitesPseudorangeNoiseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSatellitesPseudorangeNoiseOffset::CmdName = "GetAllSatellitesPseudorangeNoiseOffset";
    const char* const GetAllSatellitesPseudorangeNoiseOffset::Documentation = "Please note the command GetAllSatellitesPseudorangeNoiseOffset is deprecated since 21.3. You may use GetPseudorangeNoiseOffsetForEachSV.\n\nGet the satellite pseudorange noise constant offset for all satellites.";

    REGISTER_COMMAND_FACTORY(GetAllSatellitesPseudorangeNoiseOffset);


    GetAllSatellitesPseudorangeNoiseOffset::GetAllSatellitesPseudorangeNoiseOffset()
      : CommandBase(CmdName)
    {}

    GetAllSatellitesPseudorangeNoiseOffset::GetAllSatellitesPseudorangeNoiseOffset(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetAllSatellitesPseudorangeNoiseOffsetPtr GetAllSatellitesPseudorangeNoiseOffset::create(const std::string& system)
    {
      return std::make_shared<GetAllSatellitesPseudorangeNoiseOffset>(system);
    }

    GetAllSatellitesPseudorangeNoiseOffsetPtr GetAllSatellitesPseudorangeNoiseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSatellitesPseudorangeNoiseOffset>(ptr);
    }

    bool GetAllSatellitesPseudorangeNoiseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetAllSatellitesPseudorangeNoiseOffset::documentation() const { return Documentation; }


    int GetAllSatellitesPseudorangeNoiseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSatellitesPseudorangeNoiseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSatellitesPseudorangeNoiseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseOffsetForEachSVResult
///
#include "gen/GetPseudorangeNoiseOffsetForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseOffsetForEachSVResult::CmdName = "GetPseudorangeNoiseOffsetForEachSVResult";
    const char* const GetPseudorangeNoiseOffsetForEachSVResult::Documentation = "Result of GetPseudorangeNoiseOffsetForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseOffsetForEachSVResult);


    GetPseudorangeNoiseOffsetForEachSVResult::GetPseudorangeNoiseOffsetForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseOffsetForEachSVResult::GetPseudorangeNoiseOffsetForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
      setOffset(offset);
    }


    GetPseudorangeNoiseOffsetForEachSVResultPtr GetPseudorangeNoiseOffsetForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
    {
      return std::make_shared<GetPseudorangeNoiseOffsetForEachSVResult>(relatedCommand, system, enabled, offset);
    }

    GetPseudorangeNoiseOffsetForEachSVResultPtr GetPseudorangeNoiseOffsetForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseOffsetForEachSVResult>(ptr);
    }

    bool GetPseudorangeNoiseOffsetForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPseudorangeNoiseOffsetForEachSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseOffsetForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseOffsetForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetPseudorangeNoiseOffsetForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseOffsetForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseOffsetForEachSVResult::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void GetPseudorangeNoiseOffsetForEachSVResult::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseSineWaveForSV
///
#include "gen/SetPseudorangeNoiseSineWaveForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseSineWaveForSV::CmdName = "SetPseudorangeNoiseSineWaveForSV";
    const char* const SetPseudorangeNoiseSineWaveForSV::Documentation = "Set the satellite pseudorange noise sine wave attributes.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseSineWaveForSV);


    SetPseudorangeNoiseSineWaveForSV::SetPseudorangeNoiseSineWaveForSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseSineWaveForSV::SetPseudorangeNoiseSineWaveForSV(const std::string& system, int svId, int sineWave, bool enabled, double amplitude, int period, double offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    SetPseudorangeNoiseSineWaveForSVPtr SetPseudorangeNoiseSineWaveForSV::create(const std::string& system, int svId, int sineWave, bool enabled, double amplitude, int period, double offset)
    {
      return std::make_shared<SetPseudorangeNoiseSineWaveForSV>(system, svId, sineWave, enabled, amplitude, period, offset);
    }

    SetPseudorangeNoiseSineWaveForSVPtr SetPseudorangeNoiseSineWaveForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseSineWaveForSV>(ptr);
    }

    bool SetPseudorangeNoiseSineWaveForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Amplitude"])
          && parse_json<int>::is_valid(m_values["Period"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPseudorangeNoiseSineWaveForSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseSineWaveForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseSineWaveForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseSineWaveForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseSineWaveForSV::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPseudorangeNoiseSineWaveForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseSineWaveForSV::amplitude() const
    {
      return parse_json<double>::parse(m_values["Amplitude"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setAmplitude(double amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<double>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseSineWaveForSV::period() const
    {
      return parse_json<int>::parse(m_values["Period"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setPeriod(int period)
    {
      m_values.AddMember("Period", parse_json<int>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseSineWaveForSV::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseSineWaveForSV
///
#include "gen/GetPseudorangeNoiseSineWaveForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseSineWaveForSV::CmdName = "GetPseudorangeNoiseSineWaveForSV";
    const char* const GetPseudorangeNoiseSineWaveForSV::Documentation = "Get the satellite pseudorange noise sine wave attributes.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseSineWaveForSV);


    GetPseudorangeNoiseSineWaveForSV::GetPseudorangeNoiseSineWaveForSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseSineWaveForSV::GetPseudorangeNoiseSineWaveForSV(const std::string& system, int svId, int sineWave)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setSineWave(sineWave);
    }


    GetPseudorangeNoiseSineWaveForSVPtr GetPseudorangeNoiseSineWaveForSV::create(const std::string& system, int svId, int sineWave)
    {
      return std::make_shared<GetPseudorangeNoiseSineWaveForSV>(system, svId, sineWave);
    }

    GetPseudorangeNoiseSineWaveForSVPtr GetPseudorangeNoiseSineWaveForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseSineWaveForSV>(ptr);
    }

    bool GetPseudorangeNoiseSineWaveForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SineWave"])
        ;

    }

    std::string GetPseudorangeNoiseSineWaveForSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseSineWaveForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseSineWaveForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseSineWaveForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseSineWaveForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSV::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetPseudorangeNoiseSineWaveForSV::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseSineWaveForSVResult
///
#include "gen/GetPseudorangeNoiseSineWaveForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseSineWaveForSVResult::CmdName = "GetPseudorangeNoiseSineWaveForSVResult";
    const char* const GetPseudorangeNoiseSineWaveForSVResult::Documentation = "Result of GetPseudorangeNoiseSineWaveForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseSineWaveForSVResult);


    GetPseudorangeNoiseSineWaveForSVResult::GetPseudorangeNoiseSineWaveForSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseSineWaveForSVResult::GetPseudorangeNoiseSineWaveForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, int sineWave, bool enabled, double amplitude, int period, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    GetPseudorangeNoiseSineWaveForSVResultPtr GetPseudorangeNoiseSineWaveForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, int sineWave, bool enabled, double amplitude, int period, double offset)
    {
      return std::make_shared<GetPseudorangeNoiseSineWaveForSVResult>(relatedCommand, system, svId, sineWave, enabled, amplitude, period, offset);
    }

    GetPseudorangeNoiseSineWaveForSVResultPtr GetPseudorangeNoiseSineWaveForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseSineWaveForSVResult>(ptr);
    }

    bool GetPseudorangeNoiseSineWaveForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Amplitude"])
          && parse_json<int>::is_valid(m_values["Period"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPseudorangeNoiseSineWaveForSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseSineWaveForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSVResult::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetPseudorangeNoiseSineWaveForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseSineWaveForSVResult::amplitude() const
    {
      return parse_json<double>::parse(m_values["Amplitude"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setAmplitude(double amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<double>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSVResult::period() const
    {
      return parse_json<int>::parse(m_values["Period"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setPeriod(int period)
    {
      m_values.AddMember("Period", parse_json<int>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseSineWaveForSVResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseSineWaveForEachSV
///
#include "gen/SetPseudorangeNoiseSineWaveForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseSineWaveForEachSV::CmdName = "SetPseudorangeNoiseSineWaveForEachSV";
    const char* const SetPseudorangeNoiseSineWaveForEachSV::Documentation = "Set the satellite pseudorange noise sine wave attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseSineWaveForEachSV);


    SetPseudorangeNoiseSineWaveForEachSV::SetPseudorangeNoiseSineWaveForEachSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseSineWaveForEachSV::SetPseudorangeNoiseSineWaveForEachSV(const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    SetPseudorangeNoiseSineWaveForEachSVPtr SetPseudorangeNoiseSineWaveForEachSV::create(const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
    {
      return std::make_shared<SetPseudorangeNoiseSineWaveForEachSV>(system, sineWave, enabled, amplitude, period, offset);
    }

    SetPseudorangeNoiseSineWaveForEachSVPtr SetPseudorangeNoiseSineWaveForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseSineWaveForEachSV>(ptr);
    }

    bool SetPseudorangeNoiseSineWaveForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Amplitude"])
          && parse_json<std::vector<int>>::is_valid(m_values["Period"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPseudorangeNoiseSineWaveForEachSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseSineWaveForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseSineWaveForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseSineWaveForEachSV::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetPseudorangeNoiseSineWaveForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseSineWaveForEachSV::amplitude() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Amplitude"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setAmplitude(const std::vector<double>& amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<std::vector<double>>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetPseudorangeNoiseSineWaveForEachSV::period() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Period"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setPeriod(const std::vector<int>& period)
    {
      m_values.AddMember("Period", parse_json<std::vector<int>>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseSineWaveForEachSV::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAllSatellitesPseudorangeNoiseSineWave
///
#include "gen/SetAllSatellitesPseudorangeNoiseSineWave.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAllSatellitesPseudorangeNoiseSineWave::CmdName = "SetAllSatellitesPseudorangeNoiseSineWave";
    const char* const SetAllSatellitesPseudorangeNoiseSineWave::Documentation = "Please note the command SetAllSatellitesPseudorangeNoiseSineWave is deprecated since 21.3. You may use SetPseudorangeNoiseSineWaveForEachSV.\n\nSet the satellite pseudorange noise sine wave attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(SetAllSatellitesPseudorangeNoiseSineWave);


    SetAllSatellitesPseudorangeNoiseSineWave::SetAllSatellitesPseudorangeNoiseSineWave()
      : CommandBase(CmdName)
    {}

    SetAllSatellitesPseudorangeNoiseSineWave::SetAllSatellitesPseudorangeNoiseSineWave(const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    SetAllSatellitesPseudorangeNoiseSineWavePtr SetAllSatellitesPseudorangeNoiseSineWave::create(const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
    {
      return std::make_shared<SetAllSatellitesPseudorangeNoiseSineWave>(system, sineWave, enabled, amplitude, period, offset);
    }

    SetAllSatellitesPseudorangeNoiseSineWavePtr SetAllSatellitesPseudorangeNoiseSineWave::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAllSatellitesPseudorangeNoiseSineWave>(ptr);
    }

    bool SetAllSatellitesPseudorangeNoiseSineWave::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Amplitude"])
          && parse_json<std::vector<int>>::is_valid(m_values["Period"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetAllSatellitesPseudorangeNoiseSineWave::documentation() const { return Documentation; }


    int SetAllSatellitesPseudorangeNoiseSineWave::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAllSatellitesPseudorangeNoiseSineWave::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAllSatellitesPseudorangeNoiseSineWave::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetAllSatellitesPseudorangeNoiseSineWave::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseSineWave::amplitude() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Amplitude"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setAmplitude(const std::vector<double>& amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<std::vector<double>>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetAllSatellitesPseudorangeNoiseSineWave::period() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Period"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setPeriod(const std::vector<int>& period)
    {
      m_values.AddMember("Period", parse_json<std::vector<int>>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseSineWave::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseSineWaveForEachSV
///
#include "gen/GetPseudorangeNoiseSineWaveForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseSineWaveForEachSV::CmdName = "GetPseudorangeNoiseSineWaveForEachSV";
    const char* const GetPseudorangeNoiseSineWaveForEachSV::Documentation = "Get the satellite pseudorange noise sine wave attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseSineWaveForEachSV);


    GetPseudorangeNoiseSineWaveForEachSV::GetPseudorangeNoiseSineWaveForEachSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseSineWaveForEachSV::GetPseudorangeNoiseSineWaveForEachSV(const std::string& system, int sineWave)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSineWave(sineWave);
    }


    GetPseudorangeNoiseSineWaveForEachSVPtr GetPseudorangeNoiseSineWaveForEachSV::create(const std::string& system, int sineWave)
    {
      return std::make_shared<GetPseudorangeNoiseSineWaveForEachSV>(system, sineWave);
    }

    GetPseudorangeNoiseSineWaveForEachSVPtr GetPseudorangeNoiseSineWaveForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseSineWaveForEachSV>(ptr);
    }

    bool GetPseudorangeNoiseSineWaveForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
        ;

    }

    std::string GetPseudorangeNoiseSineWaveForEachSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseSineWaveForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseSineWaveForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForEachSV::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSV::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSatellitesPseudorangeNoiseSineWave
///
#include "gen/GetAllSatellitesPseudorangeNoiseSineWave.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSatellitesPseudorangeNoiseSineWave::CmdName = "GetAllSatellitesPseudorangeNoiseSineWave";
    const char* const GetAllSatellitesPseudorangeNoiseSineWave::Documentation = "Please note the command GetAllSatellitesPseudorangeNoiseSineWave is deprecated since 21.3. You may use GetPseudorangeNoiseSineWaveForEachSV.\n\nGet the satellite pseudorange noise sine wave attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(GetAllSatellitesPseudorangeNoiseSineWave);


    GetAllSatellitesPseudorangeNoiseSineWave::GetAllSatellitesPseudorangeNoiseSineWave()
      : CommandBase(CmdName)
    {}

    GetAllSatellitesPseudorangeNoiseSineWave::GetAllSatellitesPseudorangeNoiseSineWave(const std::string& system, int sineWave)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSineWave(sineWave);
    }


    GetAllSatellitesPseudorangeNoiseSineWavePtr GetAllSatellitesPseudorangeNoiseSineWave::create(const std::string& system, int sineWave)
    {
      return std::make_shared<GetAllSatellitesPseudorangeNoiseSineWave>(system, sineWave);
    }

    GetAllSatellitesPseudorangeNoiseSineWavePtr GetAllSatellitesPseudorangeNoiseSineWave::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSatellitesPseudorangeNoiseSineWave>(ptr);
    }

    bool GetAllSatellitesPseudorangeNoiseSineWave::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
        ;

    }

    std::string GetAllSatellitesPseudorangeNoiseSineWave::documentation() const { return Documentation; }


    int GetAllSatellitesPseudorangeNoiseSineWave::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSatellitesPseudorangeNoiseSineWave::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSatellitesPseudorangeNoiseSineWave::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllSatellitesPseudorangeNoiseSineWave::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetAllSatellitesPseudorangeNoiseSineWave::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseSineWaveForEachSVResult
///
#include "gen/GetPseudorangeNoiseSineWaveForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseSineWaveForEachSVResult::CmdName = "GetPseudorangeNoiseSineWaveForEachSVResult";
    const char* const GetPseudorangeNoiseSineWaveForEachSVResult::Documentation = "Result of GetPseudorangeNoiseSineWaveForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseSineWaveForEachSVResult);


    GetPseudorangeNoiseSineWaveForEachSVResult::GetPseudorangeNoiseSineWaveForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseSineWaveForEachSVResult::GetPseudorangeNoiseSineWaveForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    GetPseudorangeNoiseSineWaveForEachSVResultPtr GetPseudorangeNoiseSineWaveForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
    {
      return std::make_shared<GetPseudorangeNoiseSineWaveForEachSVResult>(relatedCommand, system, sineWave, enabled, amplitude, period, offset);
    }

    GetPseudorangeNoiseSineWaveForEachSVResultPtr GetPseudorangeNoiseSineWaveForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseSineWaveForEachSVResult>(ptr);
    }

    bool GetPseudorangeNoiseSineWaveForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Amplitude"])
          && parse_json<std::vector<int>>::is_valid(m_values["Period"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPseudorangeNoiseSineWaveForEachSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseSineWaveForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForEachSVResult::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetPseudorangeNoiseSineWaveForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseSineWaveForEachSVResult::amplitude() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Amplitude"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setAmplitude(const std::vector<double>& amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<std::vector<double>>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetPseudorangeNoiseSineWaveForEachSVResult::period() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Period"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setPeriod(const std::vector<int>& period)
    {
      m_values.AddMember("Period", parse_json<std::vector<int>>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseSineWaveForEachSVResult::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseGaussMarkovForSV
///
#include "gen/SetPseudorangeNoiseGaussMarkovForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseGaussMarkovForSV::CmdName = "SetPseudorangeNoiseGaussMarkovForSV";
    const char* const SetPseudorangeNoiseGaussMarkovForSV::Documentation = "Set the satellite pseudorange noise Gauss-Markov process attributes.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseGaussMarkovForSV);


    SetPseudorangeNoiseGaussMarkovForSV::SetPseudorangeNoiseGaussMarkovForSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseGaussMarkovForSV::SetPseudorangeNoiseGaussMarkovForSV(const std::string& system, int svId, int process, bool enabled, double sigma, double time, int seed)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    SetPseudorangeNoiseGaussMarkovForSVPtr SetPseudorangeNoiseGaussMarkovForSV::create(const std::string& system, int svId, int process, bool enabled, double sigma, double time, int seed)
    {
      return std::make_shared<SetPseudorangeNoiseGaussMarkovForSV>(system, svId, process, enabled, sigma, time, seed);
    }

    SetPseudorangeNoiseGaussMarkovForSVPtr SetPseudorangeNoiseGaussMarkovForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseGaussMarkovForSV>(ptr);
    }

    bool SetPseudorangeNoiseGaussMarkovForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Sigma"])
          && parse_json<double>::is_valid(m_values["Time"])
          && parse_json<int>::is_valid(m_values["Seed"])
        ;

    }

    std::string SetPseudorangeNoiseGaussMarkovForSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseGaussMarkovForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseGaussMarkovForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseGaussMarkovForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseGaussMarkovForSV::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPseudorangeNoiseGaussMarkovForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseGaussMarkovForSV::sigma() const
    {
      return parse_json<double>::parse(m_values["Sigma"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setSigma(double sigma)
    {
      m_values.AddMember("Sigma", parse_json<double>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseGaussMarkovForSV::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseGaussMarkovForSV::seed() const
    {
      return parse_json<int>::parse(m_values["Seed"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setSeed(int seed)
    {
      m_values.AddMember("Seed", parse_json<int>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseGaussMarkovForSV
///
#include "gen/GetPseudorangeNoiseGaussMarkovForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseGaussMarkovForSV::CmdName = "GetPseudorangeNoiseGaussMarkovForSV";
    const char* const GetPseudorangeNoiseGaussMarkovForSV::Documentation = "Get the satellite pseudorange noise Gauss-Markov process attributes.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseGaussMarkovForSV);


    GetPseudorangeNoiseGaussMarkovForSV::GetPseudorangeNoiseGaussMarkovForSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseGaussMarkovForSV::GetPseudorangeNoiseGaussMarkovForSV(const std::string& system, int svId, int process)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setProcess(process);
    }


    GetPseudorangeNoiseGaussMarkovForSVPtr GetPseudorangeNoiseGaussMarkovForSV::create(const std::string& system, int svId, int process)
    {
      return std::make_shared<GetPseudorangeNoiseGaussMarkovForSV>(system, svId, process);
    }

    GetPseudorangeNoiseGaussMarkovForSVPtr GetPseudorangeNoiseGaussMarkovForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseGaussMarkovForSV>(ptr);
    }

    bool GetPseudorangeNoiseGaussMarkovForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Process"])
        ;

    }

    std::string GetPseudorangeNoiseGaussMarkovForSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseGaussMarkovForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseGaussMarkovForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSV::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSV::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseGaussMarkovForSVResult
///
#include "gen/GetPseudorangeNoiseGaussMarkovForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseGaussMarkovForSVResult::CmdName = "GetPseudorangeNoiseGaussMarkovForSVResult";
    const char* const GetPseudorangeNoiseGaussMarkovForSVResult::Documentation = "Result of GetPseudorangeNoiseGaussMarkovForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseGaussMarkovForSVResult);


    GetPseudorangeNoiseGaussMarkovForSVResult::GetPseudorangeNoiseGaussMarkovForSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseGaussMarkovForSVResult::GetPseudorangeNoiseGaussMarkovForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, int process, bool enabled, double sigma, double time, int seed)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    GetPseudorangeNoiseGaussMarkovForSVResultPtr GetPseudorangeNoiseGaussMarkovForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, int process, bool enabled, double sigma, double time, int seed)
    {
      return std::make_shared<GetPseudorangeNoiseGaussMarkovForSVResult>(relatedCommand, system, svId, process, enabled, sigma, time, seed);
    }

    GetPseudorangeNoiseGaussMarkovForSVResultPtr GetPseudorangeNoiseGaussMarkovForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseGaussMarkovForSVResult>(ptr);
    }

    bool GetPseudorangeNoiseGaussMarkovForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Sigma"])
          && parse_json<double>::is_valid(m_values["Time"])
          && parse_json<int>::is_valid(m_values["Seed"])
        ;

    }

    std::string GetPseudorangeNoiseGaussMarkovForSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseGaussMarkovForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSVResult::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetPseudorangeNoiseGaussMarkovForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseGaussMarkovForSVResult::sigma() const
    {
      return parse_json<double>::parse(m_values["Sigma"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setSigma(double sigma)
    {
      m_values.AddMember("Sigma", parse_json<double>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseGaussMarkovForSVResult::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSVResult::seed() const
    {
      return parse_json<int>::parse(m_values["Seed"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setSeed(int seed)
    {
      m_values.AddMember("Seed", parse_json<int>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseGaussMarkovForEachSV
///
#include "gen/SetPseudorangeNoiseGaussMarkovForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseGaussMarkovForEachSV::CmdName = "SetPseudorangeNoiseGaussMarkovForEachSV";
    const char* const SetPseudorangeNoiseGaussMarkovForEachSV::Documentation = "Set the satellite pseudorange noise Gauss-Markov process attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseGaussMarkovForEachSV);


    SetPseudorangeNoiseGaussMarkovForEachSV::SetPseudorangeNoiseGaussMarkovForEachSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseGaussMarkovForEachSV::SetPseudorangeNoiseGaussMarkovForEachSV(const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    SetPseudorangeNoiseGaussMarkovForEachSVPtr SetPseudorangeNoiseGaussMarkovForEachSV::create(const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
    {
      return std::make_shared<SetPseudorangeNoiseGaussMarkovForEachSV>(system, process, enabled, sigma, time, seed);
    }

    SetPseudorangeNoiseGaussMarkovForEachSVPtr SetPseudorangeNoiseGaussMarkovForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseGaussMarkovForEachSV>(ptr);
    }

    bool SetPseudorangeNoiseGaussMarkovForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Sigma"])
          && parse_json<std::vector<double>>::is_valid(m_values["Time"])
          && parse_json<std::vector<int>>::is_valid(m_values["Seed"])
        ;

    }

    std::string SetPseudorangeNoiseGaussMarkovForEachSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseGaussMarkovForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseGaussMarkovForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseGaussMarkovForEachSV::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetPseudorangeNoiseGaussMarkovForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseGaussMarkovForEachSV::sigma() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Sigma"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setSigma(const std::vector<double>& sigma)
    {
      m_values.AddMember("Sigma", parse_json<std::vector<double>>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseGaussMarkovForEachSV::time() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Time"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setTime(const std::vector<double>& time)
    {
      m_values.AddMember("Time", parse_json<std::vector<double>>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetPseudorangeNoiseGaussMarkovForEachSV::seed() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Seed"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setSeed(const std::vector<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<std::vector<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAllSatellitesPseudorangeNoiseGaussMarkov
///
#include "gen/SetAllSatellitesPseudorangeNoiseGaussMarkov.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAllSatellitesPseudorangeNoiseGaussMarkov::CmdName = "SetAllSatellitesPseudorangeNoiseGaussMarkov";
    const char* const SetAllSatellitesPseudorangeNoiseGaussMarkov::Documentation = "Please note the command SetAllSatellitesPseudorangeNoiseGaussMarkov is deprecated since 21.3. You may use SetPseudorangeNoiseGaussMarkovForEachSV.\n\nSet the satellite pseudorange noise Gauss-Markov process attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(SetAllSatellitesPseudorangeNoiseGaussMarkov);


    SetAllSatellitesPseudorangeNoiseGaussMarkov::SetAllSatellitesPseudorangeNoiseGaussMarkov()
      : CommandBase(CmdName)
    {}

    SetAllSatellitesPseudorangeNoiseGaussMarkov::SetAllSatellitesPseudorangeNoiseGaussMarkov(const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    SetAllSatellitesPseudorangeNoiseGaussMarkovPtr SetAllSatellitesPseudorangeNoiseGaussMarkov::create(const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
    {
      return std::make_shared<SetAllSatellitesPseudorangeNoiseGaussMarkov>(system, process, enabled, sigma, time, seed);
    }

    SetAllSatellitesPseudorangeNoiseGaussMarkovPtr SetAllSatellitesPseudorangeNoiseGaussMarkov::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAllSatellitesPseudorangeNoiseGaussMarkov>(ptr);
    }

    bool SetAllSatellitesPseudorangeNoiseGaussMarkov::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Sigma"])
          && parse_json<std::vector<double>>::is_valid(m_values["Time"])
          && parse_json<std::vector<int>>::is_valid(m_values["Seed"])
        ;

    }

    std::string SetAllSatellitesPseudorangeNoiseGaussMarkov::documentation() const { return Documentation; }


    int SetAllSatellitesPseudorangeNoiseGaussMarkov::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAllSatellitesPseudorangeNoiseGaussMarkov::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAllSatellitesPseudorangeNoiseGaussMarkov::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetAllSatellitesPseudorangeNoiseGaussMarkov::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseGaussMarkov::sigma() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Sigma"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setSigma(const std::vector<double>& sigma)
    {
      m_values.AddMember("Sigma", parse_json<std::vector<double>>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseGaussMarkov::time() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Time"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setTime(const std::vector<double>& time)
    {
      m_values.AddMember("Time", parse_json<std::vector<double>>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetAllSatellitesPseudorangeNoiseGaussMarkov::seed() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Seed"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setSeed(const std::vector<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<std::vector<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseGaussMarkovForEachSV
///
#include "gen/GetPseudorangeNoiseGaussMarkovForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseGaussMarkovForEachSV::CmdName = "GetPseudorangeNoiseGaussMarkovForEachSV";
    const char* const GetPseudorangeNoiseGaussMarkovForEachSV::Documentation = "Get the satellite pseudorange noise Gauss-Markov process attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseGaussMarkovForEachSV);


    GetPseudorangeNoiseGaussMarkovForEachSV::GetPseudorangeNoiseGaussMarkovForEachSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseGaussMarkovForEachSV::GetPseudorangeNoiseGaussMarkovForEachSV(const std::string& system, int process)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setProcess(process);
    }


    GetPseudorangeNoiseGaussMarkovForEachSVPtr GetPseudorangeNoiseGaussMarkovForEachSV::create(const std::string& system, int process)
    {
      return std::make_shared<GetPseudorangeNoiseGaussMarkovForEachSV>(system, process);
    }

    GetPseudorangeNoiseGaussMarkovForEachSVPtr GetPseudorangeNoiseGaussMarkovForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseGaussMarkovForEachSV>(ptr);
    }

    bool GetPseudorangeNoiseGaussMarkovForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
        ;

    }

    std::string GetPseudorangeNoiseGaussMarkovForEachSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseGaussMarkovForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseGaussMarkovForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForEachSV::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSV::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSatellitesPseudorangeNoiseGaussMarkov
///
#include "gen/GetAllSatellitesPseudorangeNoiseGaussMarkov.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSatellitesPseudorangeNoiseGaussMarkov::CmdName = "GetAllSatellitesPseudorangeNoiseGaussMarkov";
    const char* const GetAllSatellitesPseudorangeNoiseGaussMarkov::Documentation = "Please note the command GetAllSatellitesPseudorangeNoiseGaussMarkov is deprecated since 21.3. You may use GetPseudorangeNoiseGaussMarkovForEachSV.\n\nGet the satellite pseudorange noise Gauss-Markov process attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(GetAllSatellitesPseudorangeNoiseGaussMarkov);


    GetAllSatellitesPseudorangeNoiseGaussMarkov::GetAllSatellitesPseudorangeNoiseGaussMarkov()
      : CommandBase(CmdName)
    {}

    GetAllSatellitesPseudorangeNoiseGaussMarkov::GetAllSatellitesPseudorangeNoiseGaussMarkov(const std::string& system, int process)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setProcess(process);
    }


    GetAllSatellitesPseudorangeNoiseGaussMarkovPtr GetAllSatellitesPseudorangeNoiseGaussMarkov::create(const std::string& system, int process)
    {
      return std::make_shared<GetAllSatellitesPseudorangeNoiseGaussMarkov>(system, process);
    }

    GetAllSatellitesPseudorangeNoiseGaussMarkovPtr GetAllSatellitesPseudorangeNoiseGaussMarkov::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSatellitesPseudorangeNoiseGaussMarkov>(ptr);
    }

    bool GetAllSatellitesPseudorangeNoiseGaussMarkov::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
        ;

    }

    std::string GetAllSatellitesPseudorangeNoiseGaussMarkov::documentation() const { return Documentation; }


    int GetAllSatellitesPseudorangeNoiseGaussMarkov::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSatellitesPseudorangeNoiseGaussMarkov::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSatellitesPseudorangeNoiseGaussMarkov::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllSatellitesPseudorangeNoiseGaussMarkov::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetAllSatellitesPseudorangeNoiseGaussMarkov::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseGaussMarkovForEachSVResult
///
#include "gen/GetPseudorangeNoiseGaussMarkovForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseGaussMarkovForEachSVResult::CmdName = "GetPseudorangeNoiseGaussMarkovForEachSVResult";
    const char* const GetPseudorangeNoiseGaussMarkovForEachSVResult::Documentation = "Result of GetPseudorangeNoiseGaussMarkovForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseGaussMarkovForEachSVResult);


    GetPseudorangeNoiseGaussMarkovForEachSVResult::GetPseudorangeNoiseGaussMarkovForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseGaussMarkovForEachSVResult::GetPseudorangeNoiseGaussMarkovForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    GetPseudorangeNoiseGaussMarkovForEachSVResultPtr GetPseudorangeNoiseGaussMarkovForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
    {
      return std::make_shared<GetPseudorangeNoiseGaussMarkovForEachSVResult>(relatedCommand, system, process, enabled, sigma, time, seed);
    }

    GetPseudorangeNoiseGaussMarkovForEachSVResultPtr GetPseudorangeNoiseGaussMarkovForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseGaussMarkovForEachSVResult>(ptr);
    }

    bool GetPseudorangeNoiseGaussMarkovForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Sigma"])
          && parse_json<std::vector<double>>::is_valid(m_values["Time"])
          && parse_json<std::vector<int>>::is_valid(m_values["Seed"])
        ;

    }

    std::string GetPseudorangeNoiseGaussMarkovForEachSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseGaussMarkovForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForEachSVResult::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetPseudorangeNoiseGaussMarkovForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseGaussMarkovForEachSVResult::sigma() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Sigma"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setSigma(const std::vector<double>& sigma)
    {
      m_values.AddMember("Sigma", parse_json<std::vector<double>>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseGaussMarkovForEachSVResult::time() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Time"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setTime(const std::vector<double>& time)
    {
      m_values.AddMember("Time", parse_json<std::vector<double>>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetPseudorangeNoiseGaussMarkovForEachSVResult::seed() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Seed"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setSeed(const std::vector<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<std::vector<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV
///
#include "gen/RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::CmdName = "RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV";
    const char* const RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::Documentation = "Generate new seeds for pseudorange noise Gauss-Markov process error on all satellites.";

    REGISTER_COMMAND_FACTORY(RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV);


    RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV()
      : CommandBase(CmdName)
    {}

    RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    RandomizePseudorangeNoiseGaussMarkovSeedsForAllSVPtr RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::create(const std::string& system)
    {
      return std::make_shared<RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV>(system);
    }

    RandomizePseudorangeNoiseGaussMarkovSeedsForAllSVPtr RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV>(ptr);
    }

    bool RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::documentation() const { return Documentation; }


    int RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov
///
#include "gen/RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::CmdName = "RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov";
    const char* const RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::Documentation = "Please note the command RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov is deprecated since 21.3. You may use RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV.\n\nGenerate new seeds for pseudorange noise Gauss-Markov process error on all satellites.";

    REGISTER_COMMAND_FACTORY(RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov);


    RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov()
      : CommandBase(CmdName)
    {}

    RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkovPtr RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::create(const std::string& system)
    {
      return std::make_shared<RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov>(system);
    }

    RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkovPtr RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov>(ptr);
    }

    bool RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::documentation() const { return Documentation; }


    int RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetEphemerisErrorForSV
///
#include "gen/SetEphemerisErrorForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetEphemerisErrorForSV::CmdName = "SetEphemerisErrorForSV";
    const char* const SetEphemerisErrorForSV::Documentation = "Set the satellite ephemeris error.";

    REGISTER_COMMAND_FACTORY(SetEphemerisErrorForSV);


    SetEphemerisErrorForSV::SetEphemerisErrorForSV()
      : CommandBase(CmdName)
    {}

    SetEphemerisErrorForSV::SetEphemerisErrorForSV(const std::string& system, int svId, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setOrbit(orbit);
      setDeltaAf0(deltaAf0);
      setDeltaAf1(deltaAf1);
    }


    SetEphemerisErrorForSVPtr SetEphemerisErrorForSV::create(const std::string& system, int svId, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
    {
      return std::make_shared<SetEphemerisErrorForSV>(system, svId, orbit, deltaAf0, deltaAf1);
    }

    SetEphemerisErrorForSVPtr SetEphemerisErrorForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetEphemerisErrorForSV>(ptr);
    }

    bool SetEphemerisErrorForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::RIC>::is_valid(m_values["Orbit"])
          && parse_json<double>::is_valid(m_values["DeltaAf0"])
          && parse_json<double>::is_valid(m_values["DeltaAf1"])
        ;

    }

    std::string SetEphemerisErrorForSV::documentation() const { return Documentation; }


    int SetEphemerisErrorForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetEphemerisErrorForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetEphemerisErrorForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetEphemerisErrorForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetEphemerisErrorForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::RIC SetEphemerisErrorForSV::orbit() const
    {
      return parse_json<Sdx::RIC>::parse(m_values["Orbit"]);
    }

    void SetEphemerisErrorForSV::setOrbit(const Sdx::RIC& orbit)
    {
      m_values.AddMember("Orbit", parse_json<Sdx::RIC>::format(orbit, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetEphemerisErrorForSV::deltaAf0() const
    {
      return parse_json<double>::parse(m_values["DeltaAf0"]);
    }

    void SetEphemerisErrorForSV::setDeltaAf0(double deltaAf0)
    {
      m_values.AddMember("DeltaAf0", parse_json<double>::format(deltaAf0, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetEphemerisErrorForSV::deltaAf1() const
    {
      return parse_json<double>::parse(m_values["DeltaAf1"]);
    }

    void SetEphemerisErrorForSV::setDeltaAf1(double deltaAf1)
    {
      m_values.AddMember("DeltaAf1", parse_json<double>::format(deltaAf1, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisErrorForSV
///
#include "gen/GetEphemerisErrorForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisErrorForSV::CmdName = "GetEphemerisErrorForSV";
    const char* const GetEphemerisErrorForSV::Documentation = "Get the satellite ephemeris error.";

    REGISTER_COMMAND_FACTORY(GetEphemerisErrorForSV);


    GetEphemerisErrorForSV::GetEphemerisErrorForSV()
      : CommandBase(CmdName)
    {}

    GetEphemerisErrorForSV::GetEphemerisErrorForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetEphemerisErrorForSVPtr GetEphemerisErrorForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<GetEphemerisErrorForSV>(system, svId);
    }

    GetEphemerisErrorForSVPtr GetEphemerisErrorForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisErrorForSV>(ptr);
    }

    bool GetEphemerisErrorForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetEphemerisErrorForSV::documentation() const { return Documentation; }


    int GetEphemerisErrorForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetEphemerisErrorForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisErrorForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisErrorForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisErrorForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisErrorForSVResult
///
#include "gen/GetEphemerisErrorForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisErrorForSVResult::CmdName = "GetEphemerisErrorForSVResult";
    const char* const GetEphemerisErrorForSVResult::Documentation = "Result of GetEphemerisErrorForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetEphemerisErrorForSVResult);


    GetEphemerisErrorForSVResult::GetEphemerisErrorForSVResult()
      : CommandResult(CmdName)
    {}

    GetEphemerisErrorForSVResult::GetEphemerisErrorForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setOrbit(orbit);
      setDeltaAf0(deltaAf0);
      setDeltaAf1(deltaAf1);
    }


    GetEphemerisErrorForSVResultPtr GetEphemerisErrorForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
    {
      return std::make_shared<GetEphemerisErrorForSVResult>(relatedCommand, system, svId, orbit, deltaAf0, deltaAf1);
    }

    GetEphemerisErrorForSVResultPtr GetEphemerisErrorForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisErrorForSVResult>(ptr);
    }

    bool GetEphemerisErrorForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::RIC>::is_valid(m_values["Orbit"])
          && parse_json<double>::is_valid(m_values["DeltaAf0"])
          && parse_json<double>::is_valid(m_values["DeltaAf1"])
        ;

    }

    std::string GetEphemerisErrorForSVResult::documentation() const { return Documentation; }


    std::string GetEphemerisErrorForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisErrorForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisErrorForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisErrorForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::RIC GetEphemerisErrorForSVResult::orbit() const
    {
      return parse_json<Sdx::RIC>::parse(m_values["Orbit"]);
    }

    void GetEphemerisErrorForSVResult::setOrbit(const Sdx::RIC& orbit)
    {
      m_values.AddMember("Orbit", parse_json<Sdx::RIC>::format(orbit, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetEphemerisErrorForSVResult::deltaAf0() const
    {
      return parse_json<double>::parse(m_values["DeltaAf0"]);
    }

    void GetEphemerisErrorForSVResult::setDeltaAf0(double deltaAf0)
    {
      m_values.AddMember("DeltaAf0", parse_json<double>::format(deltaAf0, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetEphemerisErrorForSVResult::deltaAf1() const
    {
      return parse_json<double>::parse(m_values["DeltaAf1"]);
    }

    void GetEphemerisErrorForSVResult::setDeltaAf1(double deltaAf1)
    {
      m_values.AddMember("DeltaAf1", parse_json<double>::format(deltaAf1, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetUsingVelocityInSbasMessage25
///
#include "gen/SetUsingVelocityInSbasMessage25.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetUsingVelocityInSbasMessage25::CmdName = "SetUsingVelocityInSbasMessage25";
    const char* const SetUsingVelocityInSbasMessage25::Documentation = "Set whether SBAS message 25 should send velocity corrections";

    REGISTER_COMMAND_FACTORY(SetUsingVelocityInSbasMessage25);


    SetUsingVelocityInSbasMessage25::SetUsingVelocityInSbasMessage25()
      : CommandBase(CmdName)
    {}

    SetUsingVelocityInSbasMessage25::SetUsingVelocityInSbasMessage25(bool useVelocity)
      : CommandBase(CmdName)
    {

      setUseVelocity(useVelocity);
    }


    SetUsingVelocityInSbasMessage25Ptr SetUsingVelocityInSbasMessage25::create(bool useVelocity)
    {
      return std::make_shared<SetUsingVelocityInSbasMessage25>(useVelocity);
    }

    SetUsingVelocityInSbasMessage25Ptr SetUsingVelocityInSbasMessage25::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetUsingVelocityInSbasMessage25>(ptr);
    }

    bool SetUsingVelocityInSbasMessage25::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["UseVelocity"])
        ;

    }

    std::string SetUsingVelocityInSbasMessage25::documentation() const { return Documentation; }


    int SetUsingVelocityInSbasMessage25::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool SetUsingVelocityInSbasMessage25::useVelocity() const
    {
      return parse_json<bool>::parse(m_values["UseVelocity"]);
    }

    void SetUsingVelocityInSbasMessage25::setUseVelocity(bool useVelocity)
    {
      m_values.AddMember("UseVelocity", parse_json<bool>::format(useVelocity, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsUsingVelocityInSbasMessage25
///
#include "gen/IsUsingVelocityInSbasMessage25.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsUsingVelocityInSbasMessage25::CmdName = "IsUsingVelocityInSbasMessage25";
    const char* const IsUsingVelocityInSbasMessage25::Documentation = "Get whether SBAS message 25 should send velocity corrections";

    REGISTER_COMMAND_FACTORY(IsUsingVelocityInSbasMessage25);


    IsUsingVelocityInSbasMessage25::IsUsingVelocityInSbasMessage25()
      : CommandBase(CmdName)
    {

    }


    IsUsingVelocityInSbasMessage25Ptr IsUsingVelocityInSbasMessage25::create()
    {
      return std::make_shared<IsUsingVelocityInSbasMessage25>();
    }

    IsUsingVelocityInSbasMessage25Ptr IsUsingVelocityInSbasMessage25::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsUsingVelocityInSbasMessage25>(ptr);
    }

    bool IsUsingVelocityInSbasMessage25::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsUsingVelocityInSbasMessage25::documentation() const { return Documentation; }


    int IsUsingVelocityInSbasMessage25::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsUsingVelocityInSbasMessage25Result
///
#include "gen/IsUsingVelocityInSbasMessage25Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsUsingVelocityInSbasMessage25Result::CmdName = "IsUsingVelocityInSbasMessage25Result";
    const char* const IsUsingVelocityInSbasMessage25Result::Documentation = "Result of IsUsingVelocityInSbasMessage25.";

    REGISTER_COMMAND_RESULT_FACTORY(IsUsingVelocityInSbasMessage25Result);


    IsUsingVelocityInSbasMessage25Result::IsUsingVelocityInSbasMessage25Result()
      : CommandResult(CmdName)
    {}

    IsUsingVelocityInSbasMessage25Result::IsUsingVelocityInSbasMessage25Result(CommandBasePtr relatedCommand, bool useVelocity)
      : CommandResult(CmdName, relatedCommand)
    {

      setUseVelocity(useVelocity);
    }


    IsUsingVelocityInSbasMessage25ResultPtr IsUsingVelocityInSbasMessage25Result::create(CommandBasePtr relatedCommand, bool useVelocity)
    {
      return std::make_shared<IsUsingVelocityInSbasMessage25Result>(relatedCommand, useVelocity);
    }

    IsUsingVelocityInSbasMessage25ResultPtr IsUsingVelocityInSbasMessage25Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsUsingVelocityInSbasMessage25Result>(ptr);
    }

    bool IsUsingVelocityInSbasMessage25Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["UseVelocity"])
        ;

    }

    std::string IsUsingVelocityInSbasMessage25Result::documentation() const { return Documentation; }


    bool IsUsingVelocityInSbasMessage25Result::useVelocity() const
    {
      return parse_json<bool>::parse(m_values["UseVelocity"]);
    }

    void IsUsingVelocityInSbasMessage25Result::setUseVelocity(bool useVelocity)
    {
      m_values.AddMember("UseVelocity", parse_json<bool>::format(useVelocity, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetTransmitMessage2InSbasMessage0
///
#include "gen/SetTransmitMessage2InSbasMessage0.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetTransmitMessage2InSbasMessage0::CmdName = "SetTransmitMessage2InSbasMessage0";
    const char* const SetTransmitMessage2InSbasMessage0::Documentation = "Set whether SBAS should transmit message 2 instead of message 0.";

    REGISTER_COMMAND_FACTORY(SetTransmitMessage2InSbasMessage0);


    SetTransmitMessage2InSbasMessage0::SetTransmitMessage2InSbasMessage0()
      : CommandBase(CmdName)
    {}

    SetTransmitMessage2InSbasMessage0::SetTransmitMessage2InSbasMessage0(bool transmitMessage2)
      : CommandBase(CmdName)
    {

      setTransmitMessage2(transmitMessage2);
    }


    SetTransmitMessage2InSbasMessage0Ptr SetTransmitMessage2InSbasMessage0::create(bool transmitMessage2)
    {
      return std::make_shared<SetTransmitMessage2InSbasMessage0>(transmitMessage2);
    }

    SetTransmitMessage2InSbasMessage0Ptr SetTransmitMessage2InSbasMessage0::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetTransmitMessage2InSbasMessage0>(ptr);
    }

    bool SetTransmitMessage2InSbasMessage0::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["TransmitMessage2"])
        ;

    }

    std::string SetTransmitMessage2InSbasMessage0::documentation() const { return Documentation; }


    int SetTransmitMessage2InSbasMessage0::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool SetTransmitMessage2InSbasMessage0::transmitMessage2() const
    {
      return parse_json<bool>::parse(m_values["TransmitMessage2"]);
    }

    void SetTransmitMessage2InSbasMessage0::setTransmitMessage2(bool transmitMessage2)
    {
      m_values.AddMember("TransmitMessage2", parse_json<bool>::format(transmitMessage2, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsTransmitMessage2InSbasMessage0
///
#include "gen/IsTransmitMessage2InSbasMessage0.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTransmitMessage2InSbasMessage0::CmdName = "IsTransmitMessage2InSbasMessage0";
    const char* const IsTransmitMessage2InSbasMessage0::Documentation = "Get whether SBAS should transmit message 2 instead of message 0.";

    REGISTER_COMMAND_FACTORY(IsTransmitMessage2InSbasMessage0);


    IsTransmitMessage2InSbasMessage0::IsTransmitMessage2InSbasMessage0()
      : CommandBase(CmdName)
    {

    }


    IsTransmitMessage2InSbasMessage0Ptr IsTransmitMessage2InSbasMessage0::create()
    {
      return std::make_shared<IsTransmitMessage2InSbasMessage0>();
    }

    IsTransmitMessage2InSbasMessage0Ptr IsTransmitMessage2InSbasMessage0::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTransmitMessage2InSbasMessage0>(ptr);
    }

    bool IsTransmitMessage2InSbasMessage0::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsTransmitMessage2InSbasMessage0::documentation() const { return Documentation; }


    int IsTransmitMessage2InSbasMessage0::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsTransmitMessage2InSbasMessage0Result
///
#include "gen/IsTransmitMessage2InSbasMessage0Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTransmitMessage2InSbasMessage0Result::CmdName = "IsTransmitMessage2InSbasMessage0Result";
    const char* const IsTransmitMessage2InSbasMessage0Result::Documentation = "Result of IsTransmitMessage2InSbasMessage0.";

    REGISTER_COMMAND_RESULT_FACTORY(IsTransmitMessage2InSbasMessage0Result);


    IsTransmitMessage2InSbasMessage0Result::IsTransmitMessage2InSbasMessage0Result()
      : CommandResult(CmdName)
    {}

    IsTransmitMessage2InSbasMessage0Result::IsTransmitMessage2InSbasMessage0Result(CommandBasePtr relatedCommand, bool transmitMessage2)
      : CommandResult(CmdName, relatedCommand)
    {

      setTransmitMessage2(transmitMessage2);
    }


    IsTransmitMessage2InSbasMessage0ResultPtr IsTransmitMessage2InSbasMessage0Result::create(CommandBasePtr relatedCommand, bool transmitMessage2)
    {
      return std::make_shared<IsTransmitMessage2InSbasMessage0Result>(relatedCommand, transmitMessage2);
    }

    IsTransmitMessage2InSbasMessage0ResultPtr IsTransmitMessage2InSbasMessage0Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTransmitMessage2InSbasMessage0Result>(ptr);
    }

    bool IsTransmitMessage2InSbasMessage0Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["TransmitMessage2"])
        ;

    }

    std::string IsTransmitMessage2InSbasMessage0Result::documentation() const { return Documentation; }


    bool IsTransmitMessage2InSbasMessage0Result::transmitMessage2() const
    {
      return parse_json<bool>::parse(m_values["TransmitMessage2"]);
    }

    void IsTransmitMessage2InSbasMessage0Result::setTransmitMessage2(bool transmitMessage2)
    {
      m_values.AddMember("TransmitMessage2", parse_json<bool>::format(transmitMessage2, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ForceSVGeo
///
#include "gen/ForceSVGeo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ForceSVGeo::CmdName = "ForceSVGeo";
    const char* const ForceSVGeo::Documentation = "Set whether a satellite is geostationary";

    REGISTER_COMMAND_FACTORY(ForceSVGeo);


    ForceSVGeo::ForceSVGeo()
      : CommandBase(CmdName)
    {}

    ForceSVGeo::ForceSVGeo(const std::string& system, int svId, bool isGeo, double longitude, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setIsGeo(isGeo);
      setLongitude(longitude);
      setDataSetName(dataSetName);
    }


    ForceSVGeoPtr ForceSVGeo::create(const std::string& system, int svId, bool isGeo, double longitude, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<ForceSVGeo>(system, svId, isGeo, longitude, dataSetName);
    }

    ForceSVGeoPtr ForceSVGeo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ForceSVGeo>(ptr);
    }

    bool ForceSVGeo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsGeo"])
          && parse_json<double>::is_valid(m_values["Longitude"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string ForceSVGeo::documentation() const { return Documentation; }


    int ForceSVGeo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ForceSVGeo::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ForceSVGeo::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ForceSVGeo::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void ForceSVGeo::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ForceSVGeo::isGeo() const
    {
      return parse_json<bool>::parse(m_values["IsGeo"]);
    }

    void ForceSVGeo::setIsGeo(bool isGeo)
    {
      m_values.AddMember("IsGeo", parse_json<bool>::format(isGeo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double ForceSVGeo::longitude() const
    {
      return parse_json<double>::parse(m_values["Longitude"]);
    }

    void ForceSVGeo::setLongitude(double longitude)
    {
      m_values.AddMember("Longitude", parse_json<double>::format(longitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ForceSVGeo::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void ForceSVGeo::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSVForcedGeo
///
#include "gen/IsSVForcedGeo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSVForcedGeo::CmdName = "IsSVForcedGeo";
    const char* const IsSVForcedGeo::Documentation = "Get whether a satellite is geostationary";

    REGISTER_COMMAND_FACTORY(IsSVForcedGeo);


    IsSVForcedGeo::IsSVForcedGeo()
      : CommandBase(CmdName)
    {}

    IsSVForcedGeo::IsSVForcedGeo(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setDataSetName(dataSetName);
    }


    IsSVForcedGeoPtr IsSVForcedGeo::create(const std::string& system, int svId, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<IsSVForcedGeo>(system, svId, dataSetName);
    }

    IsSVForcedGeoPtr IsSVForcedGeo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSVForcedGeo>(ptr);
    }

    bool IsSVForcedGeo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string IsSVForcedGeo::documentation() const { return Documentation; }


    int IsSVForcedGeo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSVForcedGeo::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSVForcedGeo::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSVForcedGeo::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSVForcedGeo::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> IsSVForcedGeo::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void IsSVForcedGeo::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSVForcedGeoResult
///
#include "gen/IsSVForcedGeoResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSVForcedGeoResult::CmdName = "IsSVForcedGeoResult";
    const char* const IsSVForcedGeoResult::Documentation = "Result of IsSVForcedGeo.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSVForcedGeoResult);


    IsSVForcedGeoResult::IsSVForcedGeoResult()
      : CommandResult(CmdName)
    {}

    IsSVForcedGeoResult::IsSVForcedGeoResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool isGeo, double longitude, const Sdx::optional<std::string>& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setIsGeo(isGeo);
      setLongitude(longitude);
      setDataSetName(dataSetName);
    }


    IsSVForcedGeoResultPtr IsSVForcedGeoResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool isGeo, double longitude, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<IsSVForcedGeoResult>(relatedCommand, system, svId, isGeo, longitude, dataSetName);
    }

    IsSVForcedGeoResultPtr IsSVForcedGeoResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSVForcedGeoResult>(ptr);
    }

    bool IsSVForcedGeoResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsGeo"])
          && parse_json<double>::is_valid(m_values["Longitude"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string IsSVForcedGeoResult::documentation() const { return Documentation; }


    std::string IsSVForcedGeoResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSVForcedGeoResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSVForcedGeoResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSVForcedGeoResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSVForcedGeoResult::isGeo() const
    {
      return parse_json<bool>::parse(m_values["IsGeo"]);
    }

    void IsSVForcedGeoResult::setIsGeo(bool isGeo)
    {
      m_values.AddMember("IsGeo", parse_json<bool>::format(isGeo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double IsSVForcedGeoResult::longitude() const
    {
      return parse_json<double>::parse(m_values["Longitude"]);
    }

    void IsSVForcedGeoResult::setLongitude(double longitude)
    {
      m_values.AddMember("Longitude", parse_json<double>::format(longitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> IsSVForcedGeoResult::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void IsSVForcedGeoResult::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSbasFastCorrectionsFor
///
#include "gen/EnableSbasFastCorrectionsFor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSbasFastCorrectionsFor::CmdName = "EnableSbasFastCorrectionsFor";
    const char* const EnableSbasFastCorrectionsFor::Documentation = "Set whether specific errors type for this constellation should be compensated in SBAS fast corrections";

    REGISTER_COMMAND_FACTORY(EnableSbasFastCorrectionsFor);


    EnableSbasFastCorrectionsFor::EnableSbasFastCorrectionsFor()
      : CommandBase(CmdName)
    {}

    EnableSbasFastCorrectionsFor::EnableSbasFastCorrectionsFor(const std::string& system, bool isEnabled, const Sdx::optional<std::string>& errorType)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setIsEnabled(isEnabled);
      setErrorType(errorType);
    }


    EnableSbasFastCorrectionsForPtr EnableSbasFastCorrectionsFor::create(const std::string& system, bool isEnabled, const Sdx::optional<std::string>& errorType)
    {
      return std::make_shared<EnableSbasFastCorrectionsFor>(system, isEnabled, errorType);
    }

    EnableSbasFastCorrectionsForPtr EnableSbasFastCorrectionsFor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSbasFastCorrectionsFor>(ptr);
    }

    bool EnableSbasFastCorrectionsFor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ErrorType"])
        ;

    }

    std::string EnableSbasFastCorrectionsFor::documentation() const { return Documentation; }


    int EnableSbasFastCorrectionsFor::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string EnableSbasFastCorrectionsFor::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableSbasFastCorrectionsFor::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableSbasFastCorrectionsFor::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void EnableSbasFastCorrectionsFor::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> EnableSbasFastCorrectionsFor::errorType() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ErrorType"]);
    }

    void EnableSbasFastCorrectionsFor::setErrorType(const Sdx::optional<std::string>& errorType)
    {
      m_values.AddMember("ErrorType", parse_json<Sdx::optional<std::string>>::format(errorType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSbasFastCorrectionsEnabledFor
///
#include "gen/IsSbasFastCorrectionsEnabledFor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSbasFastCorrectionsEnabledFor::CmdName = "IsSbasFastCorrectionsEnabledFor";
    const char* const IsSbasFastCorrectionsEnabledFor::Documentation = "Get whether specific errors type for this constellation should be compensated in SBAS fast corrections";

    REGISTER_COMMAND_FACTORY(IsSbasFastCorrectionsEnabledFor);


    IsSbasFastCorrectionsEnabledFor::IsSbasFastCorrectionsEnabledFor()
      : CommandBase(CmdName)
    {}

    IsSbasFastCorrectionsEnabledFor::IsSbasFastCorrectionsEnabledFor(const std::string& system, const Sdx::optional<std::string>& errorType)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setErrorType(errorType);
    }


    IsSbasFastCorrectionsEnabledForPtr IsSbasFastCorrectionsEnabledFor::create(const std::string& system, const Sdx::optional<std::string>& errorType)
    {
      return std::make_shared<IsSbasFastCorrectionsEnabledFor>(system, errorType);
    }

    IsSbasFastCorrectionsEnabledForPtr IsSbasFastCorrectionsEnabledFor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSbasFastCorrectionsEnabledFor>(ptr);
    }

    bool IsSbasFastCorrectionsEnabledFor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ErrorType"])
        ;

    }

    std::string IsSbasFastCorrectionsEnabledFor::documentation() const { return Documentation; }


    int IsSbasFastCorrectionsEnabledFor::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string IsSbasFastCorrectionsEnabledFor::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSbasFastCorrectionsEnabledFor::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> IsSbasFastCorrectionsEnabledFor::errorType() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ErrorType"]);
    }

    void IsSbasFastCorrectionsEnabledFor::setErrorType(const Sdx::optional<std::string>& errorType)
    {
      m_values.AddMember("ErrorType", parse_json<Sdx::optional<std::string>>::format(errorType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSbasFastCorrectionsEnabledForResult
///
#include "gen/IsSbasFastCorrectionsEnabledForResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSbasFastCorrectionsEnabledForResult::CmdName = "IsSbasFastCorrectionsEnabledForResult";
    const char* const IsSbasFastCorrectionsEnabledForResult::Documentation = "Result of IsSbasFastCorrectionsEnabledFor.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSbasFastCorrectionsEnabledForResult);


    IsSbasFastCorrectionsEnabledForResult::IsSbasFastCorrectionsEnabledForResult()
      : CommandResult(CmdName)
    {}

    IsSbasFastCorrectionsEnabledForResult::IsSbasFastCorrectionsEnabledForResult(CommandBasePtr relatedCommand, const std::string& system, bool isEnabled, const Sdx::optional<std::string>& errorType)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setIsEnabled(isEnabled);
      setErrorType(errorType);
    }


    IsSbasFastCorrectionsEnabledForResultPtr IsSbasFastCorrectionsEnabledForResult::create(CommandBasePtr relatedCommand, const std::string& system, bool isEnabled, const Sdx::optional<std::string>& errorType)
    {
      return std::make_shared<IsSbasFastCorrectionsEnabledForResult>(relatedCommand, system, isEnabled, errorType);
    }

    IsSbasFastCorrectionsEnabledForResultPtr IsSbasFastCorrectionsEnabledForResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSbasFastCorrectionsEnabledForResult>(ptr);
    }

    bool IsSbasFastCorrectionsEnabledForResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ErrorType"])
        ;

    }

    std::string IsSbasFastCorrectionsEnabledForResult::documentation() const { return Documentation; }


    std::string IsSbasFastCorrectionsEnabledForResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSbasFastCorrectionsEnabledForResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSbasFastCorrectionsEnabledForResult::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void IsSbasFastCorrectionsEnabledForResult::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> IsSbasFastCorrectionsEnabledForResult::errorType() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ErrorType"]);
    }

    void IsSbasFastCorrectionsEnabledForResult::setErrorType(const Sdx::optional<std::string>& errorType)
    {
      m_values.AddMember("ErrorType", parse_json<Sdx::optional<std::string>>::format(errorType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ApplyDelayInSbas
///
#include "gen/ApplyDelayInSbas.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ApplyDelayInSbas::CmdName = "ApplyDelayInSbas";
    const char* const ApplyDelayInSbas::Documentation = "Set whether the ionospheric offsets grid should be used for SBAS corrections in message 26";

    REGISTER_COMMAND_FACTORY(ApplyDelayInSbas);


    ApplyDelayInSbas::ApplyDelayInSbas()
      : CommandBase(CmdName)
    {}

    ApplyDelayInSbas::ApplyDelayInSbas(bool isEnabled)
      : CommandBase(CmdName)
    {

      setIsEnabled(isEnabled);
    }


    ApplyDelayInSbasPtr ApplyDelayInSbas::create(bool isEnabled)
    {
      return std::make_shared<ApplyDelayInSbas>(isEnabled);
    }

    ApplyDelayInSbasPtr ApplyDelayInSbas::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ApplyDelayInSbas>(ptr);
    }

    bool ApplyDelayInSbas::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string ApplyDelayInSbas::documentation() const { return Documentation; }


    int ApplyDelayInSbas::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool ApplyDelayInSbas::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void ApplyDelayInSbas::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsDelayAppliedInSbas
///
#include "gen/IsDelayAppliedInSbas.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsDelayAppliedInSbas::CmdName = "IsDelayAppliedInSbas";
    const char* const IsDelayAppliedInSbas::Documentation = "Get whether the ionospheric offsets grid should be used for SBAS corrections in message 26";

    REGISTER_COMMAND_FACTORY(IsDelayAppliedInSbas);


    IsDelayAppliedInSbas::IsDelayAppliedInSbas()
      : CommandBase(CmdName)
    {

    }


    IsDelayAppliedInSbasPtr IsDelayAppliedInSbas::create()
    {
      return std::make_shared<IsDelayAppliedInSbas>();
    }

    IsDelayAppliedInSbasPtr IsDelayAppliedInSbas::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsDelayAppliedInSbas>(ptr);
    }

    bool IsDelayAppliedInSbas::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsDelayAppliedInSbas::documentation() const { return Documentation; }


    int IsDelayAppliedInSbas::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of IsDelayAppliedInSbasResult
///
#include "gen/IsDelayAppliedInSbasResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsDelayAppliedInSbasResult::CmdName = "IsDelayAppliedInSbasResult";
    const char* const IsDelayAppliedInSbasResult::Documentation = "Result of IsDelayAppliedInSbas.";

    REGISTER_COMMAND_RESULT_FACTORY(IsDelayAppliedInSbasResult);


    IsDelayAppliedInSbasResult::IsDelayAppliedInSbasResult()
      : CommandResult(CmdName)
    {}

    IsDelayAppliedInSbasResult::IsDelayAppliedInSbasResult(CommandBasePtr relatedCommand, bool isEnabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsEnabled(isEnabled);
    }


    IsDelayAppliedInSbasResultPtr IsDelayAppliedInSbasResult::create(CommandBasePtr relatedCommand, bool isEnabled)
    {
      return std::make_shared<IsDelayAppliedInSbasResult>(relatedCommand, isEnabled);
    }

    IsDelayAppliedInSbasResultPtr IsDelayAppliedInSbasResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsDelayAppliedInSbasResult>(ptr);
    }

    bool IsDelayAppliedInSbasResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string IsDelayAppliedInSbasResult::documentation() const { return Documentation; }


    bool IsDelayAppliedInSbasResult::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void IsDelayAppliedInSbasResult::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableIonoOffset
///
#include "gen/EnableIonoOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableIonoOffset::CmdName = "EnableIonoOffset";
    const char* const EnableIonoOffset::Documentation = "Set whether the ionospheric offsets grid should be applied to the ionosphere";

    REGISTER_COMMAND_FACTORY(EnableIonoOffset);


    EnableIonoOffset::EnableIonoOffset()
      : CommandBase(CmdName)
    {}

    EnableIonoOffset::EnableIonoOffset(bool isEnabled)
      : CommandBase(CmdName)
    {

      setIsEnabled(isEnabled);
    }


    EnableIonoOffsetPtr EnableIonoOffset::create(bool isEnabled)
    {
      return std::make_shared<EnableIonoOffset>(isEnabled);
    }

    EnableIonoOffsetPtr EnableIonoOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableIonoOffset>(ptr);
    }

    bool EnableIonoOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string EnableIonoOffset::documentation() const { return Documentation; }


    int EnableIonoOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableIonoOffset::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void EnableIonoOffset::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIonoOffsetEnabled
///
#include "gen/IsIonoOffsetEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIonoOffsetEnabled::CmdName = "IsIonoOffsetEnabled";
    const char* const IsIonoOffsetEnabled::Documentation = "Get whether the ionospheric offsets grid should be applied to the ionosphere";

    REGISTER_COMMAND_FACTORY(IsIonoOffsetEnabled);


    IsIonoOffsetEnabled::IsIonoOffsetEnabled()
      : CommandBase(CmdName)
    {

    }


    IsIonoOffsetEnabledPtr IsIonoOffsetEnabled::create()
    {
      return std::make_shared<IsIonoOffsetEnabled>();
    }

    IsIonoOffsetEnabledPtr IsIonoOffsetEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIonoOffsetEnabled>(ptr);
    }

    bool IsIonoOffsetEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsIonoOffsetEnabled::documentation() const { return Documentation; }


    int IsIonoOffsetEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsIonoOffsetEnabledResult
///
#include "gen/IsIonoOffsetEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIonoOffsetEnabledResult::CmdName = "IsIonoOffsetEnabledResult";
    const char* const IsIonoOffsetEnabledResult::Documentation = "Result of IsIonoOffsetEnabled.";

    REGISTER_COMMAND_RESULT_FACTORY(IsIonoOffsetEnabledResult);


    IsIonoOffsetEnabledResult::IsIonoOffsetEnabledResult()
      : CommandResult(CmdName)
    {}

    IsIonoOffsetEnabledResult::IsIonoOffsetEnabledResult(CommandBasePtr relatedCommand, bool isEnabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsEnabled(isEnabled);
    }


    IsIonoOffsetEnabledResultPtr IsIonoOffsetEnabledResult::create(CommandBasePtr relatedCommand, bool isEnabled)
    {
      return std::make_shared<IsIonoOffsetEnabledResult>(relatedCommand, isEnabled);
    }

    IsIonoOffsetEnabledResultPtr IsIonoOffsetEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIonoOffsetEnabledResult>(ptr);
    }

    bool IsIonoOffsetEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string IsIonoOffsetEnabledResult::documentation() const { return Documentation; }


    bool IsIonoOffsetEnabledResult::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void IsIonoOffsetEnabledResult::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSbasLongTermCorrectionsFor
///
#include "gen/EnableSbasLongTermCorrectionsFor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSbasLongTermCorrectionsFor::CmdName = "EnableSbasLongTermCorrectionsFor";
    const char* const EnableSbasLongTermCorrectionsFor::Documentation = "Set whether ephemeris errors for this constellation should be compensated in SBAS long term corrections.";

    REGISTER_COMMAND_FACTORY(EnableSbasLongTermCorrectionsFor);


    EnableSbasLongTermCorrectionsFor::EnableSbasLongTermCorrectionsFor()
      : CommandBase(CmdName)
    {}

    EnableSbasLongTermCorrectionsFor::EnableSbasLongTermCorrectionsFor(const std::string& system, bool isEnabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setIsEnabled(isEnabled);
    }


    EnableSbasLongTermCorrectionsForPtr EnableSbasLongTermCorrectionsFor::create(const std::string& system, bool isEnabled)
    {
      return std::make_shared<EnableSbasLongTermCorrectionsFor>(system, isEnabled);
    }

    EnableSbasLongTermCorrectionsForPtr EnableSbasLongTermCorrectionsFor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSbasLongTermCorrectionsFor>(ptr);
    }

    bool EnableSbasLongTermCorrectionsFor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string EnableSbasLongTermCorrectionsFor::documentation() const { return Documentation; }


    int EnableSbasLongTermCorrectionsFor::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string EnableSbasLongTermCorrectionsFor::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableSbasLongTermCorrectionsFor::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableSbasLongTermCorrectionsFor::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void EnableSbasLongTermCorrectionsFor::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSbasLongTermCorrectionsEnabledFor
///
#include "gen/IsSbasLongTermCorrectionsEnabledFor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSbasLongTermCorrectionsEnabledFor::CmdName = "IsSbasLongTermCorrectionsEnabledFor";
    const char* const IsSbasLongTermCorrectionsEnabledFor::Documentation = "Get whether ephemeris errors for this constellation should be compensated in SBAS long term corrections.";

    REGISTER_COMMAND_FACTORY(IsSbasLongTermCorrectionsEnabledFor);


    IsSbasLongTermCorrectionsEnabledFor::IsSbasLongTermCorrectionsEnabledFor()
      : CommandBase(CmdName)
    {}

    IsSbasLongTermCorrectionsEnabledFor::IsSbasLongTermCorrectionsEnabledFor(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsSbasLongTermCorrectionsEnabledForPtr IsSbasLongTermCorrectionsEnabledFor::create(const std::string& system)
    {
      return std::make_shared<IsSbasLongTermCorrectionsEnabledFor>(system);
    }

    IsSbasLongTermCorrectionsEnabledForPtr IsSbasLongTermCorrectionsEnabledFor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSbasLongTermCorrectionsEnabledFor>(ptr);
    }

    bool IsSbasLongTermCorrectionsEnabledFor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsSbasLongTermCorrectionsEnabledFor::documentation() const { return Documentation; }


    int IsSbasLongTermCorrectionsEnabledFor::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string IsSbasLongTermCorrectionsEnabledFor::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSbasLongTermCorrectionsEnabledFor::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSbasLongTermCorrectionsEnabledForResult
///
#include "gen/IsSbasLongTermCorrectionsEnabledForResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSbasLongTermCorrectionsEnabledForResult::CmdName = "IsSbasLongTermCorrectionsEnabledForResult";
    const char* const IsSbasLongTermCorrectionsEnabledForResult::Documentation = "Result of IsSbasLongTermCorrectionsEnabledFor.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSbasLongTermCorrectionsEnabledForResult);


    IsSbasLongTermCorrectionsEnabledForResult::IsSbasLongTermCorrectionsEnabledForResult()
      : CommandResult(CmdName)
    {}

    IsSbasLongTermCorrectionsEnabledForResult::IsSbasLongTermCorrectionsEnabledForResult(CommandBasePtr relatedCommand, const std::string& system, bool isEnabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setIsEnabled(isEnabled);
    }


    IsSbasLongTermCorrectionsEnabledForResultPtr IsSbasLongTermCorrectionsEnabledForResult::create(CommandBasePtr relatedCommand, const std::string& system, bool isEnabled)
    {
      return std::make_shared<IsSbasLongTermCorrectionsEnabledForResult>(relatedCommand, system, isEnabled);
    }

    IsSbasLongTermCorrectionsEnabledForResultPtr IsSbasLongTermCorrectionsEnabledForResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSbasLongTermCorrectionsEnabledForResult>(ptr);
    }

    bool IsSbasLongTermCorrectionsEnabledForResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string IsSbasLongTermCorrectionsEnabledForResult::documentation() const { return Documentation; }


    std::string IsSbasLongTermCorrectionsEnabledForResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSbasLongTermCorrectionsEnabledForResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSbasLongTermCorrectionsEnabledForResult::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void IsSbasLongTermCorrectionsEnabledForResult::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsUraIndexForSV
///
#include "gen/SetGpsUraIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsUraIndexForSV::CmdName = "SetGpsUraIndexForSV";
    const char* const SetGpsUraIndexForSV::Documentation = "Set the ura index of a GPS satellite";

    REGISTER_COMMAND_FACTORY(SetGpsUraIndexForSV);


    SetGpsUraIndexForSV::SetGpsUraIndexForSV()
      : CommandBase(CmdName)
    {}

    SetGpsUraIndexForSV::SetGpsUraIndexForSV(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
      setDataSetName(dataSetName);
    }


    SetGpsUraIndexForSVPtr SetGpsUraIndexForSV::create(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGpsUraIndexForSV>(svId, urai, dataSetName);
    }

    SetGpsUraIndexForSVPtr SetGpsUraIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsUraIndexForSV>(ptr);
    }

    bool SetGpsUraIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGpsUraIndexForSV::documentation() const { return Documentation; }


    int SetGpsUraIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGpsUraIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsUraIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsUraIndexForSV::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetGpsUraIndexForSV::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGpsUraIndexForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGpsUraIndexForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouUraIndexForSV
///
#include "gen/SetBeiDouUraIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouUraIndexForSV::CmdName = "SetBeiDouUraIndexForSV";
    const char* const SetBeiDouUraIndexForSV::Documentation = "Set the ura index of a BeiDou satellite";

    REGISTER_COMMAND_FACTORY(SetBeiDouUraIndexForSV);


    SetBeiDouUraIndexForSV::SetBeiDouUraIndexForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouUraIndexForSV::SetBeiDouUraIndexForSV(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
      setDataSetName(dataSetName);
    }


    SetBeiDouUraIndexForSVPtr SetBeiDouUraIndexForSV::create(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetBeiDouUraIndexForSV>(svId, urai, dataSetName);
    }

    SetBeiDouUraIndexForSVPtr SetBeiDouUraIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouUraIndexForSV>(ptr);
    }

    bool SetBeiDouUraIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetBeiDouUraIndexForSV::documentation() const { return Documentation; }


    int SetBeiDouUraIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetBeiDouUraIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouUraIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouUraIndexForSV::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetBeiDouUraIndexForSV::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetBeiDouUraIndexForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetBeiDouUraIndexForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssUraIndexForSV
///
#include "gen/SetQzssUraIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssUraIndexForSV::CmdName = "SetQzssUraIndexForSV";
    const char* const SetQzssUraIndexForSV::Documentation = "Set the URA index of a QZSS satellite";

    REGISTER_COMMAND_FACTORY(SetQzssUraIndexForSV);


    SetQzssUraIndexForSV::SetQzssUraIndexForSV()
      : CommandBase(CmdName)
    {}

    SetQzssUraIndexForSV::SetQzssUraIndexForSV(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
      setDataSetName(dataSetName);
    }


    SetQzssUraIndexForSVPtr SetQzssUraIndexForSV::create(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssUraIndexForSV>(svId, urai, dataSetName);
    }

    SetQzssUraIndexForSVPtr SetQzssUraIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssUraIndexForSV>(ptr);
    }

    bool SetQzssUraIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssUraIndexForSV::documentation() const { return Documentation; }


    int SetQzssUraIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetQzssUraIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssUraIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssUraIndexForSV::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetQzssUraIndexForSV::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssUraIndexForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssUraIndexForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssUraIndex
///
#include "gen/SetQzssUraIndex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssUraIndex::CmdName = "SetQzssUraIndex";
    const char* const SetQzssUraIndex::Documentation = "Please note the command SetQzssUraIndex is deprecated since 21.3. You may use SetQzssUraIndexForSV.\n\nSet the URA index of a QZSS satellite";

    REGISTER_COMMAND_FACTORY(SetQzssUraIndex);


    SetQzssUraIndex::SetQzssUraIndex()
      : CommandBase(CmdName)
    {}

    SetQzssUraIndex::SetQzssUraIndex(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
      setDataSetName(dataSetName);
    }


    SetQzssUraIndexPtr SetQzssUraIndex::create(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetQzssUraIndex>(svId, urai, dataSetName);
    }

    SetQzssUraIndexPtr SetQzssUraIndex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssUraIndex>(ptr);
    }

    bool SetQzssUraIndex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetQzssUraIndex::documentation() const { return Documentation; }


    int SetQzssUraIndex::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetQzssUraIndex::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssUraIndex::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssUraIndex::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetQzssUraIndex::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetQzssUraIndex::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetQzssUraIndex::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICUraIndexForSV
///
#include "gen/SetNavICUraIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICUraIndexForSV::CmdName = "SetNavICUraIndexForSV";
    const char* const SetNavICUraIndexForSV::Documentation = "Set the URA index of a NavIC satellite";

    REGISTER_COMMAND_FACTORY(SetNavICUraIndexForSV);


    SetNavICUraIndexForSV::SetNavICUraIndexForSV()
      : CommandBase(CmdName)
    {}

    SetNavICUraIndexForSV::SetNavICUraIndexForSV(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
      setDataSetName(dataSetName);
    }


    SetNavICUraIndexForSVPtr SetNavICUraIndexForSV::create(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICUraIndexForSV>(svId, urai, dataSetName);
    }

    SetNavICUraIndexForSVPtr SetNavICUraIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICUraIndexForSV>(ptr);
    }

    bool SetNavICUraIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICUraIndexForSV::documentation() const { return Documentation; }


    int SetNavICUraIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetNavICUraIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICUraIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetNavICUraIndexForSV::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetNavICUraIndexForSV::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICUraIndexForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICUraIndexForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICUraIndex
///
#include "gen/SetNavICUraIndex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICUraIndex::CmdName = "SetNavICUraIndex";
    const char* const SetNavICUraIndex::Documentation = "Please note the command SetNavICUraIndex is deprecated since 21.3. You may use SetNavICUraIndexForSV.\n\nSet the URA index of a NavIC satellite";

    REGISTER_COMMAND_FACTORY(SetNavICUraIndex);


    SetNavICUraIndex::SetNavICUraIndex()
      : CommandBase(CmdName)
    {}

    SetNavICUraIndex::SetNavICUraIndex(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
      setDataSetName(dataSetName);
    }


    SetNavICUraIndexPtr SetNavICUraIndex::create(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetNavICUraIndex>(svId, urai, dataSetName);
    }

    SetNavICUraIndexPtr SetNavICUraIndex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICUraIndex>(ptr);
    }

    bool SetNavICUraIndex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetNavICUraIndex::documentation() const { return Documentation; }


    int SetNavICUraIndex::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetNavICUraIndex::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICUraIndex::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetNavICUraIndex::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetNavICUraIndex::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetNavICUraIndex::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetNavICUraIndex::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasUraIndexForSV
///
#include "gen/SetSbasUraIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasUraIndexForSV::CmdName = "SetSbasUraIndexForSV";
    const char* const SetSbasUraIndexForSV::Documentation = "Set the URA index of a Sbas satellite";

    REGISTER_COMMAND_FACTORY(SetSbasUraIndexForSV);


    SetSbasUraIndexForSV::SetSbasUraIndexForSV()
      : CommandBase(CmdName)
    {}

    SetSbasUraIndexForSV::SetSbasUraIndexForSV(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
      setDataSetName(dataSetName);
    }


    SetSbasUraIndexForSVPtr SetSbasUraIndexForSV::create(int svId, int urai, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetSbasUraIndexForSV>(svId, urai, dataSetName);
    }

    SetSbasUraIndexForSVPtr SetSbasUraIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasUraIndexForSV>(ptr);
    }

    bool SetSbasUraIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetSbasUraIndexForSV::documentation() const { return Documentation; }


    int SetSbasUraIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetSbasUraIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasUraIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSbasUraIndexForSV::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetSbasUraIndexForSV::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetSbasUraIndexForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetSbasUraIndexForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSisaE1E5aIndexForSV
///
#include "gen/SetGalileoSisaE1E5aIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSisaE1E5aIndexForSV::CmdName = "SetGalileoSisaE1E5aIndexForSV";
    const char* const SetGalileoSisaE1E5aIndexForSV::Documentation = "Set the SISA(E1,E5a) index of a Galileo satellite";

    REGISTER_COMMAND_FACTORY(SetGalileoSisaE1E5aIndexForSV);


    SetGalileoSisaE1E5aIndexForSV::SetGalileoSisaE1E5aIndexForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoSisaE1E5aIndexForSV::SetGalileoSisaE1E5aIndexForSV(int svId, int sisai, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSisai(sisai);
      setDataSetName(dataSetName);
    }


    SetGalileoSisaE1E5aIndexForSVPtr SetGalileoSisaE1E5aIndexForSV::create(int svId, int sisai, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGalileoSisaE1E5aIndexForSV>(svId, sisai, dataSetName);
    }

    SetGalileoSisaE1E5aIndexForSVPtr SetGalileoSisaE1E5aIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSisaE1E5aIndexForSV>(ptr);
    }

    bool SetGalileoSisaE1E5aIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Sisai"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGalileoSisaE1E5aIndexForSV::documentation() const { return Documentation; }


    int SetGalileoSisaE1E5aIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGalileoSisaE1E5aIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoSisaE1E5aIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoSisaE1E5aIndexForSV::sisai() const
    {
      return parse_json<int>::parse(m_values["Sisai"]);
    }

    void SetGalileoSisaE1E5aIndexForSV::setSisai(int sisai)
    {
      m_values.AddMember("Sisai", parse_json<int>::format(sisai, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGalileoSisaE1E5aIndexForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGalileoSisaE1E5aIndexForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSisaE1E5bIndexForSV
///
#include "gen/SetGalileoSisaE1E5bIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSisaE1E5bIndexForSV::CmdName = "SetGalileoSisaE1E5bIndexForSV";
    const char* const SetGalileoSisaE1E5bIndexForSV::Documentation = "Set the SISA(E1,E5b) index of a Galileo satellite";

    REGISTER_COMMAND_FACTORY(SetGalileoSisaE1E5bIndexForSV);


    SetGalileoSisaE1E5bIndexForSV::SetGalileoSisaE1E5bIndexForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoSisaE1E5bIndexForSV::SetGalileoSisaE1E5bIndexForSV(int svId, int sisai, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSisai(sisai);
      setDataSetName(dataSetName);
    }


    SetGalileoSisaE1E5bIndexForSVPtr SetGalileoSisaE1E5bIndexForSV::create(int svId, int sisai, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<SetGalileoSisaE1E5bIndexForSV>(svId, sisai, dataSetName);
    }

    SetGalileoSisaE1E5bIndexForSVPtr SetGalileoSisaE1E5bIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSisaE1E5bIndexForSV>(ptr);
    }

    bool SetGalileoSisaE1E5bIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Sisai"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetGalileoSisaE1E5bIndexForSV::documentation() const { return Documentation; }


    int SetGalileoSisaE1E5bIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGalileoSisaE1E5bIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoSisaE1E5bIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoSisaE1E5bIndexForSV::sisai() const
    {
      return parse_json<int>::parse(m_values["Sisai"]);
    }

    void SetGalileoSisaE1E5bIndexForSV::setSisai(int sisai)
    {
      m_values.AddMember("Sisai", parse_json<int>::format(sisai, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetGalileoSisaE1E5bIndexForSV::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void SetGalileoSisaE1E5bIndexForSV::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPilotCW
///
#include "gen/SetPilotCW.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPilotCW::CmdName = "SetPilotCW";
    const char* const SetPilotCW::Documentation = "Set CW pilot added to signal";

    REGISTER_COMMAND_FACTORY(SetPilotCW);


    SetPilotCW::SetPilotCW()
      : CommandBase(CmdName)
    {}

    SetPilotCW::SetPilotCW(bool enabled, int outputIdx, double centralFreqOffset, double power, const std::string& pilotId)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setOutputIdx(outputIdx);
      setCentralFreqOffset(centralFreqOffset);
      setPower(power);
      setPilotId(pilotId);
    }


    SetPilotCWPtr SetPilotCW::create(bool enabled, int outputIdx, double centralFreqOffset, double power, const std::string& pilotId)
    {
      return std::make_shared<SetPilotCW>(enabled, outputIdx, centralFreqOffset, power, pilotId);
    }

    SetPilotCWPtr SetPilotCW::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPilotCW>(ptr);
    }

    bool SetPilotCW::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["OutputIdx"])
          && parse_json<double>::is_valid(m_values["CentralFreqOffset"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["PilotId"])
        ;

    }

    std::string SetPilotCW::documentation() const { return Documentation; }


    int SetPilotCW::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    bool SetPilotCW::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPilotCW::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPilotCW::outputIdx() const
    {
      return parse_json<int>::parse(m_values["OutputIdx"]);
    }

    void SetPilotCW::setOutputIdx(int outputIdx)
    {
      m_values.AddMember("OutputIdx", parse_json<int>::format(outputIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPilotCW::centralFreqOffset() const
    {
      return parse_json<double>::parse(m_values["CentralFreqOffset"]);
    }

    void SetPilotCW::setCentralFreqOffset(double centralFreqOffset)
    {
      m_values.AddMember("CentralFreqOffset", parse_json<double>::format(centralFreqOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPilotCW::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetPilotCW::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetPilotCW::pilotId() const
    {
      return parse_json<std::string>::parse(m_values["PilotId"]);
    }

    void SetPilotCW::setPilotId(const std::string& pilotId)
    {
      m_values.AddMember("PilotId", parse_json<std::string>::format(pilotId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPilotPRN
///
#include "gen/SetPilotPRN.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPilotPRN::CmdName = "SetPilotPRN";
    const char* const SetPilotPRN::Documentation = "Set PRN pilot added to signal";

    REGISTER_COMMAND_FACTORY(SetPilotPRN);


    SetPilotPRN::SetPilotPRN()
      : CommandBase(CmdName)
    {}

    SetPilotPRN::SetPilotPRN(bool enabled, int outputIdx, double centralFreqOffset, double power, int prn, const std::string& type, const std::string& pilotId)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setOutputIdx(outputIdx);
      setCentralFreqOffset(centralFreqOffset);
      setPower(power);
      setPrn(prn);
      setType(type);
      setPilotId(pilotId);
    }


    SetPilotPRNPtr SetPilotPRN::create(bool enabled, int outputIdx, double centralFreqOffset, double power, int prn, const std::string& type, const std::string& pilotId)
    {
      return std::make_shared<SetPilotPRN>(enabled, outputIdx, centralFreqOffset, power, prn, type, pilotId);
    }

    SetPilotPRNPtr SetPilotPRN::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPilotPRN>(ptr);
    }

    bool SetPilotPRN::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["OutputIdx"])
          && parse_json<double>::is_valid(m_values["CentralFreqOffset"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["PilotId"])
        ;

    }

    std::string SetPilotPRN::documentation() const { return Documentation; }


    int SetPilotPRN::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    bool SetPilotPRN::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPilotPRN::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPilotPRN::outputIdx() const
    {
      return parse_json<int>::parse(m_values["OutputIdx"]);
    }

    void SetPilotPRN::setOutputIdx(int outputIdx)
    {
      m_values.AddMember("OutputIdx", parse_json<int>::format(outputIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPilotPRN::centralFreqOffset() const
    {
      return parse_json<double>::parse(m_values["CentralFreqOffset"]);
    }

    void SetPilotPRN::setCentralFreqOffset(double centralFreqOffset)
    {
      m_values.AddMember("CentralFreqOffset", parse_json<double>::format(centralFreqOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPilotPRN::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetPilotPRN::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPilotPRN::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetPilotPRN::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetPilotPRN::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetPilotPRN::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetPilotPRN::pilotId() const
    {
      return parse_json<std::string>::parse(m_values["PilotId"]);
    }

    void SetPilotPRN::setPilotId(const std::string& pilotId)
    {
      m_values.AddMember("PilotId", parse_json<std::string>::format(pilotId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CalibratePilotOutput
///
#include "gen/CalibratePilotOutput.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CalibratePilotOutput::CmdName = "CalibratePilotOutput";
    const char* const CalibratePilotOutput::Documentation = "Calibrate a pilot output";

    REGISTER_COMMAND_FACTORY(CalibratePilotOutput);


    CalibratePilotOutput::CalibratePilotOutput()
      : CommandBase(CmdName)
    {}

    CalibratePilotOutput::CalibratePilotOutput(int outputIdx, double power, double time, double carrierPhase)
      : CommandBase(CmdName)
    {

      setOutputIdx(outputIdx);
      setPower(power);
      setTime(time);
      setCarrierPhase(carrierPhase);
    }


    CalibratePilotOutputPtr CalibratePilotOutput::create(int outputIdx, double power, double time, double carrierPhase)
    {
      return std::make_shared<CalibratePilotOutput>(outputIdx, power, time, carrierPhase);
    }

    CalibratePilotOutputPtr CalibratePilotOutput::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CalibratePilotOutput>(ptr);
    }

    bool CalibratePilotOutput::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["OutputIdx"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["CarrierPhase"])
        ;

    }

    std::string CalibratePilotOutput::documentation() const { return Documentation; }


    int CalibratePilotOutput::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    int CalibratePilotOutput::outputIdx() const
    {
      return parse_json<int>::parse(m_values["OutputIdx"]);
    }

    void CalibratePilotOutput::setOutputIdx(int outputIdx)
    {
      m_values.AddMember("OutputIdx", parse_json<int>::format(outputIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double CalibratePilotOutput::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void CalibratePilotOutput::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double CalibratePilotOutput::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void CalibratePilotOutput::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double CalibratePilotOutput::carrierPhase() const
    {
      return parse_json<double>::parse(m_values["CarrierPhase"]);
    }

    void CalibratePilotOutput::setCarrierPhase(double carrierPhase)
    {
      m_values.AddMember("CarrierPhase", parse_json<double>::format(carrierPhase, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllPilots
///
#include "gen/RemoveAllPilots.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllPilots::CmdName = "RemoveAllPilots";
    const char* const RemoveAllPilots::Documentation = "Remove all pilots on all outputs";

    REGISTER_COMMAND_FACTORY(RemoveAllPilots);


    RemoveAllPilots::RemoveAllPilots()
      : CommandBase(CmdName)
    {

    }


    RemoveAllPilotsPtr RemoveAllPilots::create()
    {
      return std::make_shared<RemoveAllPilots>();
    }

    RemoveAllPilotsPtr RemoveAllPilots::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllPilots>(ptr);
    }

    bool RemoveAllPilots::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllPilots::documentation() const { return Documentation; }


    int RemoveAllPilots::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of SetRFOutputOffsets
///
#include "gen/SetRFOutputOffsets.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetRFOutputOffsets::CmdName = "SetRFOutputOffsets";
    const char* const SetRFOutputOffsets::Documentation = "Change modulation offsets of one RF output";

    REGISTER_COMMAND_FACTORY(SetRFOutputOffsets);


    SetRFOutputOffsets::SetRFOutputOffsets()
      : CommandBase(CmdName)
    {}

    SetRFOutputOffsets::SetRFOutputOffsets(int outputIdx, double powerOffset, double timeOffset, double phaseOffset)
      : CommandBase(CmdName)
    {

      setOutputIdx(outputIdx);
      setPowerOffset(powerOffset);
      setTimeOffset(timeOffset);
      setPhaseOffset(phaseOffset);
    }


    SetRFOutputOffsetsPtr SetRFOutputOffsets::create(int outputIdx, double powerOffset, double timeOffset, double phaseOffset)
    {
      return std::make_shared<SetRFOutputOffsets>(outputIdx, powerOffset, timeOffset, phaseOffset);
    }

    SetRFOutputOffsetsPtr SetRFOutputOffsets::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetRFOutputOffsets>(ptr);
    }

    bool SetRFOutputOffsets::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["OutputIdx"])
          && parse_json<double>::is_valid(m_values["PowerOffset"])
          && parse_json<double>::is_valid(m_values["TimeOffset"])
          && parse_json<double>::is_valid(m_values["PhaseOffset"])
        ;

    }

    std::string SetRFOutputOffsets::documentation() const { return Documentation; }


    int SetRFOutputOffsets::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    int SetRFOutputOffsets::outputIdx() const
    {
      return parse_json<int>::parse(m_values["OutputIdx"]);
    }

    void SetRFOutputOffsets::setOutputIdx(int outputIdx)
    {
      m_values.AddMember("OutputIdx", parse_json<int>::format(outputIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetRFOutputOffsets::powerOffset() const
    {
      return parse_json<double>::parse(m_values["PowerOffset"]);
    }

    void SetRFOutputOffsets::setPowerOffset(double powerOffset)
    {
      m_values.AddMember("PowerOffset", parse_json<double>::format(powerOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetRFOutputOffsets::timeOffset() const
    {
      return parse_json<double>::parse(m_values["TimeOffset"]);
    }

    void SetRFOutputOffsets::setTimeOffset(double timeOffset)
    {
      m_values.AddMember("TimeOffset", parse_json<double>::format(timeOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetRFOutputOffsets::phaseOffset() const
    {
      return parse_json<double>::parse(m_values["PhaseOffset"]);
    }

    void SetRFOutputOffsets::setPhaseOffset(double phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<double>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsTrajectoryCompleted
///
#include "gen/IsTrajectoryCompleted.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTrajectoryCompleted::CmdName = "IsTrajectoryCompleted";
    const char* const IsTrajectoryCompleted::Documentation = "Returns whether the vehicle trajectory was completed.\nFor fixed, circular and earth-orbiting spacecraft, this will always return false.\nFor track playback and vehicle simulation, this will return true once the vehicle will reach the last position in the track/route.\nThe value is unreliable for HIL trajectories.";

    REGISTER_COMMAND_FACTORY(IsTrajectoryCompleted);


    IsTrajectoryCompleted::IsTrajectoryCompleted()
      : CommandBase(CmdName)
    {

    }


    IsTrajectoryCompletedPtr IsTrajectoryCompleted::create()
    {
      return std::make_shared<IsTrajectoryCompleted>();
    }

    IsTrajectoryCompletedPtr IsTrajectoryCompleted::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTrajectoryCompleted>(ptr);
    }

    bool IsTrajectoryCompleted::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsTrajectoryCompleted::documentation() const { return Documentation; }


    int IsTrajectoryCompleted::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of IsTrajectoryCompletedResult
///
#include "gen/IsTrajectoryCompletedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTrajectoryCompletedResult::CmdName = "IsTrajectoryCompletedResult";
    const char* const IsTrajectoryCompletedResult::Documentation = "Result of IsTrajectoryCompleted.";

    REGISTER_COMMAND_RESULT_FACTORY(IsTrajectoryCompletedResult);


    IsTrajectoryCompletedResult::IsTrajectoryCompletedResult()
      : CommandResult(CmdName)
    {}

    IsTrajectoryCompletedResult::IsTrajectoryCompletedResult(CommandBasePtr relatedCommand, bool isCompleted)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsCompleted(isCompleted);
    }


    IsTrajectoryCompletedResultPtr IsTrajectoryCompletedResult::create(CommandBasePtr relatedCommand, bool isCompleted)
    {
      return std::make_shared<IsTrajectoryCompletedResult>(relatedCommand, isCompleted);
    }

    IsTrajectoryCompletedResultPtr IsTrajectoryCompletedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTrajectoryCompletedResult>(ptr);
    }

    bool IsTrajectoryCompletedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsCompleted"])
        ;

    }

    std::string IsTrajectoryCompletedResult::documentation() const { return Documentation; }


    bool IsTrajectoryCompletedResult::isCompleted() const
    {
      return parse_json<bool>::parse(m_values["IsCompleted"]);
    }

    void IsTrajectoryCompletedResult::setIsCompleted(bool isCompleted)
    {
      m_values.AddMember("IsCompleted", parse_json<bool>::format(isCompleted, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridError
///
#include "gen/SetIonoGridError.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridError::CmdName = "SetIonoGridError";
    const char* const SetIonoGridError::Documentation = "Set the error offset for a ionospheric grid point";

    REGISTER_COMMAND_FACTORY(SetIonoGridError);


    SetIonoGridError::SetIonoGridError()
      : CommandBase(CmdName)
    {}

    SetIonoGridError::SetIonoGridError(int band, int point, double error)
      : CommandBase(CmdName)
    {

      setBand(band);
      setPoint(point);
      setError(error);
    }


    SetIonoGridErrorPtr SetIonoGridError::create(int band, int point, double error)
    {
      return std::make_shared<SetIonoGridError>(band, point, error);
    }

    SetIonoGridErrorPtr SetIonoGridError::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridError>(ptr);
    }

    bool SetIonoGridError::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<double>::is_valid(m_values["Error"])
        ;

    }

    std::string SetIonoGridError::documentation() const { return Documentation; }


    int SetIonoGridError::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoGridError::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void SetIonoGridError::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridError::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void SetIonoGridError::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIonoGridError::error() const
    {
      return parse_json<double>::parse(m_values["Error"]);
    }

    void SetIonoGridError::setError(double error)
    {
      m_values.AddMember("Error", parse_json<double>::format(error, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridError
///
#include "gen/GetIonoGridError.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridError::CmdName = "GetIonoGridError";
    const char* const GetIonoGridError::Documentation = "Get the error offset for a ionospheric grid point";

    REGISTER_COMMAND_FACTORY(GetIonoGridError);


    GetIonoGridError::GetIonoGridError()
      : CommandBase(CmdName)
    {}

    GetIonoGridError::GetIonoGridError(int band, int point)
      : CommandBase(CmdName)
    {

      setBand(band);
      setPoint(point);
    }


    GetIonoGridErrorPtr GetIonoGridError::create(int band, int point)
    {
      return std::make_shared<GetIonoGridError>(band, point);
    }

    GetIonoGridErrorPtr GetIonoGridError::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridError>(ptr);
    }

    bool GetIonoGridError::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
        ;

    }

    std::string GetIonoGridError::documentation() const { return Documentation; }


    int GetIonoGridError::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoGridError::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridError::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridError::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridError::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridErrorResult
///
#include "gen/GetIonoGridErrorResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridErrorResult::CmdName = "GetIonoGridErrorResult";
    const char* const GetIonoGridErrorResult::Documentation = "Result of GetIonoGridError.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridErrorResult);


    GetIonoGridErrorResult::GetIonoGridErrorResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridErrorResult::GetIonoGridErrorResult(CommandBasePtr relatedCommand, int band, int point, double error)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setPoint(point);
      setError(error);
    }


    GetIonoGridErrorResultPtr GetIonoGridErrorResult::create(CommandBasePtr relatedCommand, int band, int point, double error)
    {
      return std::make_shared<GetIonoGridErrorResult>(relatedCommand, band, point, error);
    }

    GetIonoGridErrorResultPtr GetIonoGridErrorResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridErrorResult>(ptr);
    }

    bool GetIonoGridErrorResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<double>::is_valid(m_values["Error"])
        ;

    }

    std::string GetIonoGridErrorResult::documentation() const { return Documentation; }


    int GetIonoGridErrorResult::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridErrorResult::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridErrorResult::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridErrorResult::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIonoGridErrorResult::error() const
    {
      return parse_json<double>::parse(m_values["Error"]);
    }

    void GetIonoGridErrorResult::setError(double error)
    {
      m_values.AddMember("Error", parse_json<double>::format(error, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridGIVEI
///
#include "gen/SetIonoGridGIVEI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridGIVEI::CmdName = "SetIonoGridGIVEI";
    const char* const SetIonoGridGIVEI::Documentation = "Set the GIVEI for a ionospheric grid point";

    REGISTER_COMMAND_FACTORY(SetIonoGridGIVEI);


    SetIonoGridGIVEI::SetIonoGridGIVEI()
      : CommandBase(CmdName)
    {}

    SetIonoGridGIVEI::SetIonoGridGIVEI(int band, int point, int giveI, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setBand(band);
      setPoint(point);
      setGiveI(giveI);
      setServiceProvider(serviceProvider);
    }


    SetIonoGridGIVEIPtr SetIonoGridGIVEI::create(int band, int point, int giveI, const Sdx::optional<std::string>& serviceProvider)
    {
      return std::make_shared<SetIonoGridGIVEI>(band, point, giveI, serviceProvider);
    }

    SetIonoGridGIVEIPtr SetIonoGridGIVEI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridGIVEI>(ptr);
    }

    bool SetIonoGridGIVEI::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<int>::is_valid(m_values["GiveI"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string SetIonoGridGIVEI::documentation() const { return Documentation; }


    int SetIonoGridGIVEI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoGridGIVEI::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void SetIonoGridGIVEI::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridGIVEI::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void SetIonoGridGIVEI::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridGIVEI::giveI() const
    {
      return parse_json<int>::parse(m_values["GiveI"]);
    }

    void SetIonoGridGIVEI::setGiveI(int giveI)
    {
      m_values.AddMember("GiveI", parse_json<int>::format(giveI, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetIonoGridGIVEI::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void SetIonoGridGIVEI::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridGIVEI
///
#include "gen/GetIonoGridGIVEI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridGIVEI::CmdName = "GetIonoGridGIVEI";
    const char* const GetIonoGridGIVEI::Documentation = "Get the GIVEI for a ionospheric grid point";

    REGISTER_COMMAND_FACTORY(GetIonoGridGIVEI);


    GetIonoGridGIVEI::GetIonoGridGIVEI()
      : CommandBase(CmdName)
    {}

    GetIonoGridGIVEI::GetIonoGridGIVEI(int band, int point, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setBand(band);
      setPoint(point);
      setServiceProvider(serviceProvider);
    }


    GetIonoGridGIVEIPtr GetIonoGridGIVEI::create(int band, int point, const Sdx::optional<std::string>& serviceProvider)
    {
      return std::make_shared<GetIonoGridGIVEI>(band, point, serviceProvider);
    }

    GetIonoGridGIVEIPtr GetIonoGridGIVEI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridGIVEI>(ptr);
    }

    bool GetIonoGridGIVEI::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridGIVEI::documentation() const { return Documentation; }


    int GetIonoGridGIVEI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoGridGIVEI::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridGIVEI::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridGIVEI::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridGIVEI::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetIonoGridGIVEI::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridGIVEI::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridGIVEIResult
///
#include "gen/GetIonoGridGIVEIResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridGIVEIResult::CmdName = "GetIonoGridGIVEIResult";
    const char* const GetIonoGridGIVEIResult::Documentation = "Result of GetIonoGridGIVEI.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridGIVEIResult);


    GetIonoGridGIVEIResult::GetIonoGridGIVEIResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridGIVEIResult::GetIonoGridGIVEIResult(CommandBasePtr relatedCommand, int band, int point, int giveI, const Sdx::optional<std::string>& serviceProvider)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setPoint(point);
      setGiveI(giveI);
      setServiceProvider(serviceProvider);
    }


    GetIonoGridGIVEIResultPtr GetIonoGridGIVEIResult::create(CommandBasePtr relatedCommand, int band, int point, int giveI, const Sdx::optional<std::string>& serviceProvider)
    {
      return std::make_shared<GetIonoGridGIVEIResult>(relatedCommand, band, point, giveI, serviceProvider);
    }

    GetIonoGridGIVEIResultPtr GetIonoGridGIVEIResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridGIVEIResult>(ptr);
    }

    bool GetIonoGridGIVEIResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<int>::is_valid(m_values["GiveI"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridGIVEIResult::documentation() const { return Documentation; }


    int GetIonoGridGIVEIResult::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridGIVEIResult::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridGIVEIResult::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridGIVEIResult::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridGIVEIResult::giveI() const
    {
      return parse_json<int>::parse(m_values["GiveI"]);
    }

    void GetIonoGridGIVEIResult::setGiveI(int giveI)
    {
      m_values.AddMember("GiveI", parse_json<int>::format(giveI, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetIonoGridGIVEIResult::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridGIVEIResult::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridErrorAll
///
#include "gen/SetIonoGridErrorAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridErrorAll::CmdName = "SetIonoGridErrorAll";
    const char* const SetIonoGridErrorAll::Documentation = "Set Error offsets in the ionospheric grid.  The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(SetIonoGridErrorAll);


    SetIonoGridErrorAll::SetIonoGridErrorAll()
      : CommandBase(CmdName)
    {}

    SetIonoGridErrorAll::SetIonoGridErrorAll(const std::vector<std::vector<double>>& grid)
      : CommandBase(CmdName)
    {

      setGrid(grid);
    }


    SetIonoGridErrorAllPtr SetIonoGridErrorAll::create(const std::vector<std::vector<double>>& grid)
    {
      return std::make_shared<SetIonoGridErrorAll>(grid);
    }

    SetIonoGridErrorAllPtr SetIonoGridErrorAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridErrorAll>(ptr);
    }

    bool SetIonoGridErrorAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Grid"])
        ;

    }

    std::string SetIonoGridErrorAll::documentation() const { return Documentation; }


    int SetIonoGridErrorAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetIonoGridErrorAll::grid() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Grid"]);
    }

    void SetIonoGridErrorAll::setGrid(const std::vector<std::vector<double>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<double>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridErrorAll
///
#include "gen/GetIonoGridErrorAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridErrorAll::CmdName = "GetIonoGridErrorAll";
    const char* const GetIonoGridErrorAll::Documentation = "Get Error offsets in the ionospheric grid.  The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(GetIonoGridErrorAll);


    GetIonoGridErrorAll::GetIonoGridErrorAll()
      : CommandBase(CmdName)
    {

    }


    GetIonoGridErrorAllPtr GetIonoGridErrorAll::create()
    {
      return std::make_shared<GetIonoGridErrorAll>();
    }

    GetIonoGridErrorAllPtr GetIonoGridErrorAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridErrorAll>(ptr);
    }

    bool GetIonoGridErrorAll::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIonoGridErrorAll::documentation() const { return Documentation; }


    int GetIonoGridErrorAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIonoGridErrorAllResult
///
#include "gen/GetIonoGridErrorAllResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridErrorAllResult::CmdName = "GetIonoGridErrorAllResult";
    const char* const GetIonoGridErrorAllResult::Documentation = "Result of GetIonoGridErrorAll.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridErrorAllResult);


    GetIonoGridErrorAllResult::GetIonoGridErrorAllResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridErrorAllResult::GetIonoGridErrorAllResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& grid)
      : CommandResult(CmdName, relatedCommand)
    {

      setGrid(grid);
    }


    GetIonoGridErrorAllResultPtr GetIonoGridErrorAllResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& grid)
    {
      return std::make_shared<GetIonoGridErrorAllResult>(relatedCommand, grid);
    }

    GetIonoGridErrorAllResultPtr GetIonoGridErrorAllResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridErrorAllResult>(ptr);
    }

    bool GetIonoGridErrorAllResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Grid"])
        ;

    }

    std::string GetIonoGridErrorAllResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetIonoGridErrorAllResult::grid() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Grid"]);
    }

    void GetIonoGridErrorAllResult::setGrid(const std::vector<std::vector<double>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<double>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridGIVEIAll
///
#include "gen/SetIonoGridGIVEIAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridGIVEIAll::CmdName = "SetIonoGridGIVEIAll";
    const char* const SetIonoGridGIVEIAll::Documentation = "Set GIVEI in the ionospheric grid.  The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(SetIonoGridGIVEIAll);


    SetIonoGridGIVEIAll::SetIonoGridGIVEIAll()
      : CommandBase(CmdName)
    {}

    SetIonoGridGIVEIAll::SetIonoGridGIVEIAll(const std::vector<std::vector<int>>& grid, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setGrid(grid);
      setServiceProvider(serviceProvider);
    }


    SetIonoGridGIVEIAllPtr SetIonoGridGIVEIAll::create(const std::vector<std::vector<int>>& grid, const Sdx::optional<std::string>& serviceProvider)
    {
      return std::make_shared<SetIonoGridGIVEIAll>(grid, serviceProvider);
    }

    SetIonoGridGIVEIAllPtr SetIonoGridGIVEIAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridGIVEIAll>(ptr);
    }

    bool SetIonoGridGIVEIAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<int>>>::is_valid(m_values["Grid"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string SetIonoGridGIVEIAll::documentation() const { return Documentation; }


    int SetIonoGridGIVEIAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<int>> SetIonoGridGIVEIAll::grid() const
    {
      return parse_json<std::vector<std::vector<int>>>::parse(m_values["Grid"]);
    }

    void SetIonoGridGIVEIAll::setGrid(const std::vector<std::vector<int>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<int>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetIonoGridGIVEIAll::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void SetIonoGridGIVEIAll::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridGIVEIAll
///
#include "gen/GetIonoGridGIVEIAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridGIVEIAll::CmdName = "GetIonoGridGIVEIAll";
    const char* const GetIonoGridGIVEIAll::Documentation = "Get GIVEI in the ionospheric grid.  The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(GetIonoGridGIVEIAll);


    GetIonoGridGIVEIAll::GetIonoGridGIVEIAll(const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
    }


    GetIonoGridGIVEIAllPtr GetIonoGridGIVEIAll::create(const Sdx::optional<std::string>& serviceProvider)
    {
      return std::make_shared<GetIonoGridGIVEIAll>(serviceProvider);
    }

    GetIonoGridGIVEIAllPtr GetIonoGridGIVEIAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridGIVEIAll>(ptr);
    }

    bool GetIonoGridGIVEIAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridGIVEIAll::documentation() const { return Documentation; }


    int GetIonoGridGIVEIAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::optional<std::string> GetIonoGridGIVEIAll::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridGIVEIAll::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridGIVEIAllResult
///
#include "gen/GetIonoGridGIVEIAllResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridGIVEIAllResult::CmdName = "GetIonoGridGIVEIAllResult";
    const char* const GetIonoGridGIVEIAllResult::Documentation = "Result of GetIonoGridGIVEIAll.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridGIVEIAllResult);


    GetIonoGridGIVEIAllResult::GetIonoGridGIVEIAllResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridGIVEIAllResult::GetIonoGridGIVEIAllResult(CommandBasePtr relatedCommand, const std::vector<std::vector<int>>& grid, const Sdx::optional<std::string>& serviceProvider)
      : CommandResult(CmdName, relatedCommand)
    {

      setGrid(grid);
      setServiceProvider(serviceProvider);
    }


    GetIonoGridGIVEIAllResultPtr GetIonoGridGIVEIAllResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<int>>& grid, const Sdx::optional<std::string>& serviceProvider)
    {
      return std::make_shared<GetIonoGridGIVEIAllResult>(relatedCommand, grid, serviceProvider);
    }

    GetIonoGridGIVEIAllResultPtr GetIonoGridGIVEIAllResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridGIVEIAllResult>(ptr);
    }

    bool GetIonoGridGIVEIAllResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<int>>>::is_valid(m_values["Grid"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridGIVEIAllResult::documentation() const { return Documentation; }


    std::vector<std::vector<int>> GetIonoGridGIVEIAllResult::grid() const
    {
      return parse_json<std::vector<std::vector<int>>>::parse(m_values["Grid"]);
    }

    void GetIonoGridGIVEIAllResult::setGrid(const std::vector<std::vector<int>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<int>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetIonoGridGIVEIAllResult::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridGIVEIAllResult::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridMask
///
#include "gen/SetIonoGridMask.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridMask::CmdName = "SetIonoGridMask";
    const char* const SetIonoGridMask::Documentation = "Set the flag for a ionospheric grid point in the SBAS message 18 mask";

    REGISTER_COMMAND_FACTORY(SetIonoGridMask);


    SetIonoGridMask::SetIonoGridMask()
      : CommandBase(CmdName)
    {}

    SetIonoGridMask::SetIonoGridMask(const std::string& serviceProvider, int band, int point, bool flag)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setBand(band);
      setPoint(point);
      setFlag(flag);
    }


    SetIonoGridMaskPtr SetIonoGridMask::create(const std::string& serviceProvider, int band, int point, bool flag)
    {
      return std::make_shared<SetIonoGridMask>(serviceProvider, band, point, flag);
    }

    SetIonoGridMaskPtr SetIonoGridMask::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridMask>(ptr);
    }

    bool SetIonoGridMask::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<bool>::is_valid(m_values["Flag"])
        ;

    }

    std::string SetIonoGridMask::documentation() const { return Documentation; }


    int SetIonoGridMask::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetIonoGridMask::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void SetIonoGridMask::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridMask::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void SetIonoGridMask::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridMask::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void SetIonoGridMask::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetIonoGridMask::flag() const
    {
      return parse_json<bool>::parse(m_values["Flag"]);
    }

    void SetIonoGridMask::setFlag(bool flag)
    {
      m_values.AddMember("Flag", parse_json<bool>::format(flag, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridMask
///
#include "gen/GetIonoGridMask.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridMask::CmdName = "GetIonoGridMask";
    const char* const GetIonoGridMask::Documentation = "Get the flag for a ionospheric grid point in the SBAS message 18 mask";

    REGISTER_COMMAND_FACTORY(GetIonoGridMask);


    GetIonoGridMask::GetIonoGridMask()
      : CommandBase(CmdName)
    {}

    GetIonoGridMask::GetIonoGridMask(const std::string& serviceProvider, int band, int point)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setBand(band);
      setPoint(point);
    }


    GetIonoGridMaskPtr GetIonoGridMask::create(const std::string& serviceProvider, int band, int point)
    {
      return std::make_shared<GetIonoGridMask>(serviceProvider, band, point);
    }

    GetIonoGridMaskPtr GetIonoGridMask::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridMask>(ptr);
    }

    bool GetIonoGridMask::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
        ;

    }

    std::string GetIonoGridMask::documentation() const { return Documentation; }


    int GetIonoGridMask::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIonoGridMask::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridMask::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridMask::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridMask::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridMask::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridMask::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridMaskResult
///
#include "gen/GetIonoGridMaskResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridMaskResult::CmdName = "GetIonoGridMaskResult";
    const char* const GetIonoGridMaskResult::Documentation = "Result of GetIonoGridMask.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridMaskResult);


    GetIonoGridMaskResult::GetIonoGridMaskResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridMaskResult::GetIonoGridMaskResult(CommandBasePtr relatedCommand, const std::string& serviceProvider, int band, int point, bool flag)
      : CommandResult(CmdName, relatedCommand)
    {

      setServiceProvider(serviceProvider);
      setBand(band);
      setPoint(point);
      setFlag(flag);
    }


    GetIonoGridMaskResultPtr GetIonoGridMaskResult::create(CommandBasePtr relatedCommand, const std::string& serviceProvider, int band, int point, bool flag)
    {
      return std::make_shared<GetIonoGridMaskResult>(relatedCommand, serviceProvider, band, point, flag);
    }

    GetIonoGridMaskResultPtr GetIonoGridMaskResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridMaskResult>(ptr);
    }

    bool GetIonoGridMaskResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<bool>::is_valid(m_values["Flag"])
        ;

    }

    std::string GetIonoGridMaskResult::documentation() const { return Documentation; }


    std::string GetIonoGridMaskResult::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridMaskResult::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridMaskResult::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridMaskResult::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridMaskResult::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridMaskResult::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIonoGridMaskResult::flag() const
    {
      return parse_json<bool>::parse(m_values["Flag"]);
    }

    void GetIonoGridMaskResult::setFlag(bool flag)
    {
      m_values.AddMember("Flag", parse_json<bool>::format(flag, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridMaskAll
///
#include "gen/SetIonoGridMaskAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridMaskAll::CmdName = "SetIonoGridMaskAll";
    const char* const SetIonoGridMaskAll::Documentation = "Set Mask flags in the ionospheric grid for a given service provider. The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(SetIonoGridMaskAll);


    SetIonoGridMaskAll::SetIonoGridMaskAll()
      : CommandBase(CmdName)
    {}

    SetIonoGridMaskAll::SetIonoGridMaskAll(const std::string& serviceProvider, const std::vector<std::vector<bool>>& grid)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setGrid(grid);
    }


    SetIonoGridMaskAllPtr SetIonoGridMaskAll::create(const std::string& serviceProvider, const std::vector<std::vector<bool>>& grid)
    {
      return std::make_shared<SetIonoGridMaskAll>(serviceProvider, grid);
    }

    SetIonoGridMaskAllPtr SetIonoGridMaskAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridMaskAll>(ptr);
    }

    bool SetIonoGridMaskAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<std::vector<std::vector<bool>>>::is_valid(m_values["Grid"])
        ;

    }

    std::string SetIonoGridMaskAll::documentation() const { return Documentation; }


    int SetIonoGridMaskAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetIonoGridMaskAll::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void SetIonoGridMaskAll::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<bool>> SetIonoGridMaskAll::grid() const
    {
      return parse_json<std::vector<std::vector<bool>>>::parse(m_values["Grid"]);
    }

    void SetIonoGridMaskAll::setGrid(const std::vector<std::vector<bool>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<bool>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridMaskAll
///
#include "gen/GetIonoGridMaskAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridMaskAll::CmdName = "GetIonoGridMaskAll";
    const char* const GetIonoGridMaskAll::Documentation = "Get Mask flags in the ionospheric grid for a given service provider. The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(GetIonoGridMaskAll);


    GetIonoGridMaskAll::GetIonoGridMaskAll()
      : CommandBase(CmdName)
    {}

    GetIonoGridMaskAll::GetIonoGridMaskAll(const std::string& serviceProvider)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
    }


    GetIonoGridMaskAllPtr GetIonoGridMaskAll::create(const std::string& serviceProvider)
    {
      return std::make_shared<GetIonoGridMaskAll>(serviceProvider);
    }

    GetIonoGridMaskAllPtr GetIonoGridMaskAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridMaskAll>(ptr);
    }

    bool GetIonoGridMaskAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridMaskAll::documentation() const { return Documentation; }


    int GetIonoGridMaskAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIonoGridMaskAll::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridMaskAll::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridMaskAllResult
///
#include "gen/GetIonoGridMaskAllResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridMaskAllResult::CmdName = "GetIonoGridMaskAllResult";
    const char* const GetIonoGridMaskAllResult::Documentation = "Result of GetIonoGridMaskAll.";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridMaskAllResult);


    GetIonoGridMaskAllResult::GetIonoGridMaskAllResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridMaskAllResult::GetIonoGridMaskAllResult(CommandBasePtr relatedCommand, const std::string& serviceProvider, const std::vector<std::vector<bool>>& grid)
      : CommandResult(CmdName, relatedCommand)
    {

      setServiceProvider(serviceProvider);
      setGrid(grid);
    }


    GetIonoGridMaskAllResultPtr GetIonoGridMaskAllResult::create(CommandBasePtr relatedCommand, const std::string& serviceProvider, const std::vector<std::vector<bool>>& grid)
    {
      return std::make_shared<GetIonoGridMaskAllResult>(relatedCommand, serviceProvider, grid);
    }

    GetIonoGridMaskAllResultPtr GetIonoGridMaskAllResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridMaskAllResult>(ptr);
    }

    bool GetIonoGridMaskAllResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<std::vector<std::vector<bool>>>::is_valid(m_values["Grid"])
        ;

    }

    std::string GetIonoGridMaskAllResult::documentation() const { return Documentation; }


    std::string GetIonoGridMaskAllResult::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridMaskAllResult::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<bool>> GetIonoGridMaskAllResult::grid() const
    {
      return parse_json<std::vector<std::vector<bool>>>::parse(m_values["Grid"]);
    }

    void GetIonoGridMaskAllResult::setGrid(const std::vector<std::vector<bool>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<bool>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportIonoGridErrors
///
#include "gen/ImportIonoGridErrors.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportIonoGridErrors::CmdName = "ImportIonoGridErrors";
    const char* const ImportIonoGridErrors::Documentation = "Import ionospheric grid errors.";

    REGISTER_COMMAND_FACTORY(ImportIonoGridErrors);


    ImportIonoGridErrors::ImportIonoGridErrors()
      : CommandBase(CmdName)
    {}

    ImportIonoGridErrors::ImportIonoGridErrors(bool overwriting, const std::string& path)
      : CommandBase(CmdName)
    {

      setOverwriting(overwriting);
      setPath(path);
    }


    ImportIonoGridErrorsPtr ImportIonoGridErrors::create(bool overwriting, const std::string& path)
    {
      return std::make_shared<ImportIonoGridErrors>(overwriting, path);
    }

    ImportIonoGridErrorsPtr ImportIonoGridErrors::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportIonoGridErrors>(ptr);
    }

    bool ImportIonoGridErrors::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportIonoGridErrors::documentation() const { return Documentation; }


    int ImportIonoGridErrors::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ImportIonoGridErrors::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ImportIonoGridErrors::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportIonoGridErrors::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportIonoGridErrors::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportIonoGridGIVEI
///
#include "gen/ImportIonoGridGIVEI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportIonoGridGIVEI::CmdName = "ImportIonoGridGIVEI";
    const char* const ImportIonoGridGIVEI::Documentation = "Import ionospheric grid GIVEI.";

    REGISTER_COMMAND_FACTORY(ImportIonoGridGIVEI);


    ImportIonoGridGIVEI::ImportIonoGridGIVEI()
      : CommandBase(CmdName)
    {}

    ImportIonoGridGIVEI::ImportIonoGridGIVEI(bool overwriting, const std::string& path, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setOverwriting(overwriting);
      setPath(path);
      setServiceProvider(serviceProvider);
    }


    ImportIonoGridGIVEIPtr ImportIonoGridGIVEI::create(bool overwriting, const std::string& path, const Sdx::optional<std::string>& serviceProvider)
    {
      return std::make_shared<ImportIonoGridGIVEI>(overwriting, path, serviceProvider);
    }

    ImportIonoGridGIVEIPtr ImportIonoGridGIVEI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportIonoGridGIVEI>(ptr);
    }

    bool ImportIonoGridGIVEI::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string ImportIonoGridGIVEI::documentation() const { return Documentation; }


    int ImportIonoGridGIVEI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ImportIonoGridGIVEI::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ImportIonoGridGIVEI::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportIonoGridGIVEI::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportIonoGridGIVEI::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ImportIonoGridGIVEI::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void ImportIonoGridGIVEI::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportIonoGridMask
///
#include "gen/ImportIonoGridMask.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportIonoGridMask::CmdName = "ImportIonoGridMask";
    const char* const ImportIonoGridMask::Documentation = "Import ionospheric grid mask for a giver service provider.";

    REGISTER_COMMAND_FACTORY(ImportIonoGridMask);


    ImportIonoGridMask::ImportIonoGridMask()
      : CommandBase(CmdName)
    {}

    ImportIonoGridMask::ImportIonoGridMask(const std::string& serviceProvider, bool overwriting, const std::string& path)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setOverwriting(overwriting);
      setPath(path);
    }


    ImportIonoGridMaskPtr ImportIonoGridMask::create(const std::string& serviceProvider, bool overwriting, const std::string& path)
    {
      return std::make_shared<ImportIonoGridMask>(serviceProvider, overwriting, path);
    }

    ImportIonoGridMaskPtr ImportIonoGridMask::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportIonoGridMask>(ptr);
    }

    bool ImportIonoGridMask::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportIonoGridMask::documentation() const { return Documentation; }


    int ImportIonoGridMask::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportIonoGridMask::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void ImportIonoGridMask::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ImportIonoGridMask::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ImportIonoGridMask::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportIonoGridMask::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportIonoGridMask::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportIonoGridErrors
///
#include "gen/ExportIonoGridErrors.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportIonoGridErrors::CmdName = "ExportIonoGridErrors";
    const char* const ExportIonoGridErrors::Documentation = "Export ionospheric grid errors.";

    REGISTER_COMMAND_FACTORY(ExportIonoGridErrors);


    ExportIonoGridErrors::ExportIonoGridErrors()
      : CommandBase(CmdName)
    {}

    ExportIonoGridErrors::ExportIonoGridErrors(bool overwriting, const std::string& path)
      : CommandBase(CmdName)
    {

      setOverwriting(overwriting);
      setPath(path);
    }


    ExportIonoGridErrorsPtr ExportIonoGridErrors::create(bool overwriting, const std::string& path)
    {
      return std::make_shared<ExportIonoGridErrors>(overwriting, path);
    }

    ExportIonoGridErrorsPtr ExportIonoGridErrors::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportIonoGridErrors>(ptr);
    }

    bool ExportIonoGridErrors::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ExportIonoGridErrors::documentation() const { return Documentation; }


    int ExportIonoGridErrors::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ExportIonoGridErrors::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportIonoGridErrors::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportIonoGridErrors::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ExportIonoGridErrors::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportIonoGridGIVEI
///
#include "gen/ExportIonoGridGIVEI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportIonoGridGIVEI::CmdName = "ExportIonoGridGIVEI";
    const char* const ExportIonoGridGIVEI::Documentation = "Export ionospheric grid GIVEI.";

    REGISTER_COMMAND_FACTORY(ExportIonoGridGIVEI);


    ExportIonoGridGIVEI::ExportIonoGridGIVEI()
      : CommandBase(CmdName)
    {}

    ExportIonoGridGIVEI::ExportIonoGridGIVEI(bool overwriting, const std::string& path, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setOverwriting(overwriting);
      setPath(path);
      setServiceProvider(serviceProvider);
    }


    ExportIonoGridGIVEIPtr ExportIonoGridGIVEI::create(bool overwriting, const std::string& path, const Sdx::optional<std::string>& serviceProvider)
    {
      return std::make_shared<ExportIonoGridGIVEI>(overwriting, path, serviceProvider);
    }

    ExportIonoGridGIVEIPtr ExportIonoGridGIVEI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportIonoGridGIVEI>(ptr);
    }

    bool ExportIonoGridGIVEI::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string ExportIonoGridGIVEI::documentation() const { return Documentation; }


    int ExportIonoGridGIVEI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ExportIonoGridGIVEI::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportIonoGridGIVEI::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportIonoGridGIVEI::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ExportIonoGridGIVEI::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ExportIonoGridGIVEI::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void ExportIonoGridGIVEI::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportIonoGridMask
///
#include "gen/ExportIonoGridMask.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportIonoGridMask::CmdName = "ExportIonoGridMask";
    const char* const ExportIonoGridMask::Documentation = "Export ionospheric grid mask for a given service provider.";

    REGISTER_COMMAND_FACTORY(ExportIonoGridMask);


    ExportIonoGridMask::ExportIonoGridMask()
      : CommandBase(CmdName)
    {}

    ExportIonoGridMask::ExportIonoGridMask(const std::string& serviceProvider, bool overwriting, const std::string& path)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setOverwriting(overwriting);
      setPath(path);
    }


    ExportIonoGridMaskPtr ExportIonoGridMask::create(const std::string& serviceProvider, bool overwriting, const std::string& path)
    {
      return std::make_shared<ExportIonoGridMask>(serviceProvider, overwriting, path);
    }

    ExportIonoGridMaskPtr ExportIonoGridMask::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportIonoGridMask>(ptr);
    }

    bool ExportIonoGridMask::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ExportIonoGridMask::documentation() const { return Documentation; }


    int ExportIonoGridMask::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ExportIonoGridMask::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void ExportIonoGridMask::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ExportIonoGridMask::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportIonoGridMask::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportIonoGridMask::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ExportIonoGridMask::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetConfigPaths
///
#include "gen/GetConfigPaths.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigPaths::CmdName = "GetConfigPaths";
    const char* const GetConfigPaths::Documentation = "Get a list of paths for all the files in the Configurations folder.";

    REGISTER_COMMAND_FACTORY(GetConfigPaths);


    GetConfigPaths::GetConfigPaths()
      : CommandBase(CmdName)
    {

    }


    GetConfigPathsPtr GetConfigPaths::create()
    {
      return std::make_shared<GetConfigPaths>();
    }

    GetConfigPathsPtr GetConfigPaths::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigPaths>(ptr);
    }

    bool GetConfigPaths::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetConfigPaths::documentation() const { return Documentation; }


    int GetConfigPaths::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetConfigPathsResult
///
#include "gen/GetConfigPathsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigPathsResult::CmdName = "GetConfigPathsResult";
    const char* const GetConfigPathsResult::Documentation = "Result of GetConfigPaths.";

    REGISTER_COMMAND_RESULT_FACTORY(GetConfigPathsResult);


    GetConfigPathsResult::GetConfigPathsResult()
      : CommandResult(CmdName)
    {}

    GetConfigPathsResult::GetConfigPathsResult(CommandBasePtr relatedCommand, const std::vector<std::string>& paths)
      : CommandResult(CmdName, relatedCommand)
    {

      setPaths(paths);
    }


    GetConfigPathsResultPtr GetConfigPathsResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& paths)
    {
      return std::make_shared<GetConfigPathsResult>(relatedCommand, paths);
    }

    GetConfigPathsResultPtr GetConfigPathsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigPathsResult>(ptr);
    }

    bool GetConfigPathsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Paths"])
        ;

    }

    std::string GetConfigPathsResult::documentation() const { return Documentation; }


    std::vector<std::string> GetConfigPathsResult::paths() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Paths"]);
    }

    void GetConfigPathsResult::setPaths(const std::vector<std::string>& paths)
    {
      m_values.AddMember("Paths", parse_json<std::vector<std::string>>::format(paths, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPps0GpsTime
///
#include "gen/SetPps0GpsTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPps0GpsTime::CmdName = "SetPps0GpsTime";
    const char* const SetPps0GpsTime::Documentation = "Set the 0th PPS' date time";

    REGISTER_COMMAND_FACTORY(SetPps0GpsTime);


    SetPps0GpsTime::SetPps0GpsTime()
      : CommandBase(CmdName)
    {}

    SetPps0GpsTime::SetPps0GpsTime(const Sdx::DateTime& gpsTime)
      : CommandBase(CmdName)
    {

      setGpsTime(gpsTime);
    }


    SetPps0GpsTimePtr SetPps0GpsTime::create(const Sdx::DateTime& gpsTime)
    {
      return std::make_shared<SetPps0GpsTime>(gpsTime);
    }

    SetPps0GpsTimePtr SetPps0GpsTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPps0GpsTime>(ptr);
    }

    bool SetPps0GpsTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::DateTime>::is_valid(m_values["GpsTime"])
        ;

    }

    std::string SetPps0GpsTime::documentation() const { return Documentation; }


    int SetPps0GpsTime::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    Sdx::DateTime SetPps0GpsTime::gpsTime() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["GpsTime"]);
    }

    void SetPps0GpsTime::setGpsTime(const Sdx::DateTime& gpsTime)
    {
      m_values.AddMember("GpsTime", parse_json<Sdx::DateTime>::format(gpsTime, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetOfficialLeapSecond
///
#include "gen/GetOfficialLeapSecond.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetOfficialLeapSecond::CmdName = "GetOfficialLeapSecond";
    const char* const GetOfficialLeapSecond::Documentation = "Returns the official leap second for a given date";

    REGISTER_COMMAND_FACTORY(GetOfficialLeapSecond);


    GetOfficialLeapSecond::GetOfficialLeapSecond()
      : CommandBase(CmdName)
    {}

    GetOfficialLeapSecond::GetOfficialLeapSecond(const Sdx::DateTime& date)
      : CommandBase(CmdName)
    {

      setDate(date);
    }


    GetOfficialLeapSecondPtr GetOfficialLeapSecond::create(const Sdx::DateTime& date)
    {
      return std::make_shared<GetOfficialLeapSecond>(date);
    }

    GetOfficialLeapSecondPtr GetOfficialLeapSecond::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetOfficialLeapSecond>(ptr);
    }

    bool GetOfficialLeapSecond::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::DateTime>::is_valid(m_values["Date"])
        ;

    }

    std::string GetOfficialLeapSecond::documentation() const { return Documentation; }


    int GetOfficialLeapSecond::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    Sdx::DateTime GetOfficialLeapSecond::date() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Date"]);
    }

    void GetOfficialLeapSecond::setDate(const Sdx::DateTime& date)
    {
      m_values.AddMember("Date", parse_json<Sdx::DateTime>::format(date, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetOfficialLeapSecondResult
///
#include "gen/GetOfficialLeapSecondResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetOfficialLeapSecondResult::CmdName = "GetOfficialLeapSecondResult";
    const char* const GetOfficialLeapSecondResult::Documentation = "Result of GetOfficialLeapSecond";

    REGISTER_COMMAND_RESULT_FACTORY(GetOfficialLeapSecondResult);


    GetOfficialLeapSecondResult::GetOfficialLeapSecondResult()
      : CommandResult(CmdName)
    {}

    GetOfficialLeapSecondResult::GetOfficialLeapSecondResult(CommandBasePtr relatedCommand, int leapSecond)
      : CommandResult(CmdName, relatedCommand)
    {

      setLeapSecond(leapSecond);
    }


    GetOfficialLeapSecondResultPtr GetOfficialLeapSecondResult::create(CommandBasePtr relatedCommand, int leapSecond)
    {
      return std::make_shared<GetOfficialLeapSecondResult>(relatedCommand, leapSecond);
    }

    GetOfficialLeapSecondResultPtr GetOfficialLeapSecondResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetOfficialLeapSecondResult>(ptr);
    }

    bool GetOfficialLeapSecondResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["LeapSecond"])
        ;

    }

    std::string GetOfficialLeapSecondResult::documentation() const { return Documentation; }


    int GetOfficialLeapSecondResult::leapSecond() const
    {
      return parse_json<int>::parse(m_values["LeapSecond"]);
    }

    void GetOfficialLeapSecondResult::setLeapSecond(int leapSecond)
    {
      m_values.AddMember("LeapSecond", parse_json<int>::format(leapSecond, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetLastLeapSecondDate
///
#include "gen/GetLastLeapSecondDate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLastLeapSecondDate::CmdName = "GetLastLeapSecondDate";
    const char* const GetLastLeapSecondDate::Documentation = "Returns the last known leap second date";

    REGISTER_COMMAND_FACTORY(GetLastLeapSecondDate);


    GetLastLeapSecondDate::GetLastLeapSecondDate()
      : CommandBase(CmdName)
    {

    }


    GetLastLeapSecondDatePtr GetLastLeapSecondDate::create()
    {
      return std::make_shared<GetLastLeapSecondDate>();
    }

    GetLastLeapSecondDatePtr GetLastLeapSecondDate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLastLeapSecondDate>(ptr);
    }

    bool GetLastLeapSecondDate::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLastLeapSecondDate::documentation() const { return Documentation; }


    int GetLastLeapSecondDate::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetLastLeapSecondDateResult
///
#include "gen/GetLastLeapSecondDateResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLastLeapSecondDateResult::CmdName = "GetLastLeapSecondDateResult";
    const char* const GetLastLeapSecondDateResult::Documentation = "Result of GetLastLeapSecondDate.";

    REGISTER_COMMAND_RESULT_FACTORY(GetLastLeapSecondDateResult);


    GetLastLeapSecondDateResult::GetLastLeapSecondDateResult()
      : CommandResult(CmdName)
    {}

    GetLastLeapSecondDateResult::GetLastLeapSecondDateResult(CommandBasePtr relatedCommand, const Sdx::Date& date)
      : CommandResult(CmdName, relatedCommand)
    {

      setDate(date);
    }


    GetLastLeapSecondDateResultPtr GetLastLeapSecondDateResult::create(CommandBasePtr relatedCommand, const Sdx::Date& date)
    {
      return std::make_shared<GetLastLeapSecondDateResult>(relatedCommand, date);
    }

    GetLastLeapSecondDateResultPtr GetLastLeapSecondDateResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLastLeapSecondDateResult>(ptr);
    }

    bool GetLastLeapSecondDateResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::Date>::is_valid(m_values["Date"])
        ;

    }

    std::string GetLastLeapSecondDateResult::documentation() const { return Documentation; }


    Sdx::Date GetLastLeapSecondDateResult::date() const
    {
      return parse_json<Sdx::Date>::parse(m_values["Date"]);
    }

    void GetLastLeapSecondDateResult::setDate(const Sdx::Date& date)
    {
      m_values.AddMember("Date", parse_json<Sdx::Date>::format(date, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaGain
///
#include "gen/SetWFAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaGain::CmdName = "SetWFAntennaGain";
    const char* const SetWFAntennaGain::Documentation = "Set The CRPA LNA gain";

    REGISTER_COMMAND_FACTORY(SetWFAntennaGain);


    SetWFAntennaGain::SetWFAntennaGain()
      : CommandBase(CmdName)
    {}

    SetWFAntennaGain::SetWFAntennaGain(int gain)
      : CommandBase(CmdName)
    {

      setGain(gain);
    }


    SetWFAntennaGainPtr SetWFAntennaGain::create(int gain)
    {
      return std::make_shared<SetWFAntennaGain>(gain);
    }

    SetWFAntennaGainPtr SetWFAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaGain>(ptr);
    }

    bool SetWFAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Gain"])
        ;

    }

    std::string SetWFAntennaGain::documentation() const { return Documentation; }


    int SetWFAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetWFAntennaGain::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void SetWFAntennaGain::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaGain
///
#include "gen/GetWFAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaGain::CmdName = "GetWFAntennaGain";
    const char* const GetWFAntennaGain::Documentation = "Get The CRPA LNA gain";

    REGISTER_COMMAND_FACTORY(GetWFAntennaGain);


    GetWFAntennaGain::GetWFAntennaGain()
      : CommandBase(CmdName)
    {

    }


    GetWFAntennaGainPtr GetWFAntennaGain::create()
    {
      return std::make_shared<GetWFAntennaGain>();
    }

    GetWFAntennaGainPtr GetWFAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaGain>(ptr);
    }

    bool GetWFAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetWFAntennaGain::documentation() const { return Documentation; }


    int GetWFAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetWFAntennaGainResult
///
#include "gen/GetWFAntennaGainResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaGainResult::CmdName = "GetWFAntennaGainResult";
    const char* const GetWFAntennaGainResult::Documentation = "Result of GetWFAntennaGain.";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaGainResult);


    GetWFAntennaGainResult::GetWFAntennaGainResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaGainResult::GetWFAntennaGainResult(CommandBasePtr relatedCommand, int gain)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
    }


    GetWFAntennaGainResultPtr GetWFAntennaGainResult::create(CommandBasePtr relatedCommand, int gain)
    {
      return std::make_shared<GetWFAntennaGainResult>(relatedCommand, gain);
    }

    GetWFAntennaGainResultPtr GetWFAntennaGainResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaGainResult>(ptr);
    }

    bool GetWFAntennaGainResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Gain"])
        ;

    }

    std::string GetWFAntennaGainResult::documentation() const { return Documentation; }


    int GetWFAntennaGainResult::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void GetWFAntennaGainResult::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddCustomSignal
///
#include "gen/AddCustomSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddCustomSignal::CmdName = "AddCustomSignal";
    const char* const AddCustomSignal::Documentation = "Adds a custom signal";

    REGISTER_COMMAND_FACTORY(AddCustomSignal);


    AddCustomSignal::AddCustomSignal()
      : CommandBase(CmdName)
    {}

    AddCustomSignal::AddCustomSignal(const std::string& path, const std::string& id)
      : CommandBase(CmdName)
    {

      setPath(path);
      setId(id);
    }


    AddCustomSignalPtr AddCustomSignal::create(const std::string& path, const std::string& id)
    {
      return std::make_shared<AddCustomSignal>(path, id);
    }

    AddCustomSignalPtr AddCustomSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddCustomSignal>(ptr);
    }

    bool AddCustomSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string AddCustomSignal::documentation() const { return Documentation; }


    int AddCustomSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddCustomSignal::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void AddCustomSignal::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddCustomSignal::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void AddCustomSignal::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveCustomSignal
///
#include "gen/RemoveCustomSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveCustomSignal::CmdName = "RemoveCustomSignal";
    const char* const RemoveCustomSignal::Documentation = "Removes the custom signal with the given ID";

    REGISTER_COMMAND_FACTORY(RemoveCustomSignal);


    RemoveCustomSignal::RemoveCustomSignal()
      : CommandBase(CmdName)
    {}

    RemoveCustomSignal::RemoveCustomSignal(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveCustomSignalPtr RemoveCustomSignal::create(const std::string& id)
    {
      return std::make_shared<RemoveCustomSignal>(id);
    }

    RemoveCustomSignalPtr RemoveCustomSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveCustomSignal>(ptr);
    }

    bool RemoveCustomSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveCustomSignal::documentation() const { return Documentation; }


    int RemoveCustomSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveCustomSignal::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveCustomSignal::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllCustomSignals
///
#include "gen/RemoveAllCustomSignals.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllCustomSignals::CmdName = "RemoveAllCustomSignals";
    const char* const RemoveAllCustomSignals::Documentation = "Removes all the custom signals";

    REGISTER_COMMAND_FACTORY(RemoveAllCustomSignals);


    RemoveAllCustomSignals::RemoveAllCustomSignals()
      : CommandBase(CmdName)
    {

    }


    RemoveAllCustomSignalsPtr RemoveAllCustomSignals::create()
    {
      return std::make_shared<RemoveAllCustomSignals>();
    }

    RemoveAllCustomSignalsPtr RemoveAllCustomSignals::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllCustomSignals>(ptr);
    }

    bool RemoveAllCustomSignals::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllCustomSignals::documentation() const { return Documentation; }


    int RemoveAllCustomSignals::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of ChangeCustomSignalColor
///
#include "gen/ChangeCustomSignalColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeCustomSignalColor::CmdName = "ChangeCustomSignalColor";
    const char* const ChangeCustomSignalColor::Documentation = "Changes the custom signal color";

    REGISTER_COMMAND_FACTORY(ChangeCustomSignalColor);


    ChangeCustomSignalColor::ChangeCustomSignalColor()
      : CommandBase(CmdName)
    {}

    ChangeCustomSignalColor::ChangeCustomSignalColor(const std::string& color, const std::string& id)
      : CommandBase(CmdName)
    {

      setColor(color);
      setId(id);
    }


    ChangeCustomSignalColorPtr ChangeCustomSignalColor::create(const std::string& color, const std::string& id)
    {
      return std::make_shared<ChangeCustomSignalColor>(color, id);
    }

    ChangeCustomSignalColorPtr ChangeCustomSignalColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeCustomSignalColor>(ptr);
    }

    bool ChangeCustomSignalColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ChangeCustomSignalColor::documentation() const { return Documentation; }


    int ChangeCustomSignalColor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ChangeCustomSignalColor::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void ChangeCustomSignalColor::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeCustomSignalColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeCustomSignalColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSpoofTxID
///
#include "gen/GetAllSpoofTxID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSpoofTxID::CmdName = "GetAllSpoofTxID";
    const char* const GetAllSpoofTxID::Documentation = "Get the ID of all spoofer transmitters.";

    REGISTER_COMMAND_FACTORY(GetAllSpoofTxID);


    GetAllSpoofTxID::GetAllSpoofTxID()
      : CommandBase(CmdName)
    {

    }


    GetAllSpoofTxIDPtr GetAllSpoofTxID::create()
    {
      return std::make_shared<GetAllSpoofTxID>();
    }

    GetAllSpoofTxIDPtr GetAllSpoofTxID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSpoofTxID>(ptr);
    }

    bool GetAllSpoofTxID::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAllSpoofTxID::documentation() const { return Documentation; }


    int GetAllSpoofTxID::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetAllSpoofTxIDResult
///
#include "gen/GetAllSpoofTxIDResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSpoofTxIDResult::CmdName = "GetAllSpoofTxIDResult";
    const char* const GetAllSpoofTxIDResult::Documentation = "Result of GetAllSpoofTxID.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllSpoofTxIDResult);


    GetAllSpoofTxIDResult::GetAllSpoofTxIDResult()
      : CommandResult(CmdName)
    {}

    GetAllSpoofTxIDResult::GetAllSpoofTxIDResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllSpoofTxIDResultPtr GetAllSpoofTxIDResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return std::make_shared<GetAllSpoofTxIDResult>(relatedCommand, ids);
    }

    GetAllSpoofTxIDResultPtr GetAllSpoofTxIDResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSpoofTxIDResult>(ptr);
    }

    bool GetAllSpoofTxIDResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllSpoofTxIDResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllSpoofTxIDResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllSpoofTxIDResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddSpoofTx
///
#include "gen/AddSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddSpoofTx::CmdName = "AddSpoofTx";
    const char* const AddSpoofTx::Documentation = "Set a spoofer transmitter. For set : the transmitter Id parameter is not set (empty string),\nSkydel will assign a unique Id to the transmitter. If the Id is set and already used by Skydel, the\ncommand will fail.";

    REGISTER_COMMAND_FACTORY(AddSpoofTx);


    AddSpoofTx::AddSpoofTx()
      : CommandBase(CmdName)
    {}

    AddSpoofTx::AddSpoofTx(const std::string& usualName, bool enabled, const std::string& address, int instanceId, const std::string& id)
      : CommandBase(CmdName)
    {

      setUsualName(usualName);
      setEnabled(enabled);
      setAddress(address);
      setInstanceId(instanceId);
      setId(id);
    }


    AddSpoofTxPtr AddSpoofTx::create(const std::string& usualName, bool enabled, const std::string& address, int instanceId, const std::string& id)
    {
      return std::make_shared<AddSpoofTx>(usualName, enabled, address, instanceId, id);
    }

    AddSpoofTxPtr AddSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddSpoofTx>(ptr);
    }

    bool AddSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<int>::is_valid(m_values["InstanceId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string AddSpoofTx::documentation() const { return Documentation; }


    int AddSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddSpoofTx::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void AddSpoofTx::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool AddSpoofTx::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void AddSpoofTx::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddSpoofTx::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void AddSpoofTx::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int AddSpoofTx::instanceId() const
    {
      return parse_json<int>::parse(m_values["InstanceId"]);
    }

    void AddSpoofTx::setInstanceId(int instanceId)
    {
      m_values.AddMember("InstanceId", parse_json<int>::format(instanceId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void AddSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTx
///
#include "gen/GetSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTx::CmdName = "GetSpoofTx";
    const char* const GetSpoofTx::Documentation = "Get a spoofer transmitter. For set : the transmitter Id parameter is not set (empty string),\nSkydel will assign a unique Id to the transmitter. If the Id is set and already used by Skydel, the\ncommand will fail.";

    REGISTER_COMMAND_FACTORY(GetSpoofTx);


    GetSpoofTx::GetSpoofTx()
      : CommandBase(CmdName)
    {}

    GetSpoofTx::GetSpoofTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxPtr GetSpoofTx::create(const std::string& id)
    {
      return std::make_shared<GetSpoofTx>(id);
    }

    GetSpoofTxPtr GetSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTx>(ptr);
    }

    bool GetSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTx::documentation() const { return Documentation; }


    int GetSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxResult
///
#include "gen/GetSpoofTxResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxResult::CmdName = "GetSpoofTxResult";
    const char* const GetSpoofTxResult::Documentation = "Result of GetSpoofTx.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxResult);


    GetSpoofTxResult::GetSpoofTxResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxResult::GetSpoofTxResult(CommandBasePtr relatedCommand, const std::string& usualName, bool enabled, const std::string& address, int instanceId, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setUsualName(usualName);
      setEnabled(enabled);
      setAddress(address);
      setInstanceId(instanceId);
      setId(id);
    }


    GetSpoofTxResultPtr GetSpoofTxResult::create(CommandBasePtr relatedCommand, const std::string& usualName, bool enabled, const std::string& address, int instanceId, const std::string& id)
    {
      return std::make_shared<GetSpoofTxResult>(relatedCommand, usualName, enabled, address, instanceId, id);
    }

    GetSpoofTxResultPtr GetSpoofTxResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxResult>(ptr);
    }

    bool GetSpoofTxResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<int>::is_valid(m_values["InstanceId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxResult::documentation() const { return Documentation; }


    std::string GetSpoofTxResult::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void GetSpoofTxResult::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetSpoofTxResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetSpoofTxResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxResult::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void GetSpoofTxResult::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSpoofTxResult::instanceId() const
    {
      return parse_json<int>::parse(m_values["InstanceId"]);
    }

    void GetSpoofTxResult::setInstanceId(int instanceId)
    {
      m_values.AddMember("InstanceId", parse_json<int>::format(instanceId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveSpoofTx
///
#include "gen/RemoveSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveSpoofTx::CmdName = "RemoveSpoofTx";
    const char* const RemoveSpoofTx::Documentation = "Removes the spoofer transmitter. See EnableSpoofTx if all you want is to\ndisable the interference temporarily.";

    REGISTER_COMMAND_FACTORY(RemoveSpoofTx);


    RemoveSpoofTx::RemoveSpoofTx()
      : CommandBase(CmdName)
    {}

    RemoveSpoofTx::RemoveSpoofTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveSpoofTxPtr RemoveSpoofTx::create(const std::string& id)
    {
      return std::make_shared<RemoveSpoofTx>(id);
    }

    RemoveSpoofTxPtr RemoveSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveSpoofTx>(ptr);
    }

    bool RemoveSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveSpoofTx::documentation() const { return Documentation; }


    int RemoveSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RenameSpoofTx
///
#include "gen/RenameSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RenameSpoofTx::CmdName = "RenameSpoofTx";
    const char* const RenameSpoofTx::Documentation = "Rename a spoofer.";

    REGISTER_COMMAND_FACTORY(RenameSpoofTx);


    RenameSpoofTx::RenameSpoofTx()
      : CommandBase(CmdName)
    {}

    RenameSpoofTx::RenameSpoofTx(const std::string& usualName, const std::string& id)
      : CommandBase(CmdName)
    {

      setUsualName(usualName);
      setId(id);
    }


    RenameSpoofTxPtr RenameSpoofTx::create(const std::string& usualName, const std::string& id)
    {
      return std::make_shared<RenameSpoofTx>(usualName, id);
    }

    RenameSpoofTxPtr RenameSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RenameSpoofTx>(ptr);
    }

    bool RenameSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RenameSpoofTx::documentation() const { return Documentation; }


    int RenameSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RenameSpoofTx::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void RenameSpoofTx::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RenameSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeSpoofTxColor
///
#include "gen/ChangeSpoofTxColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeSpoofTxColor::CmdName = "ChangeSpoofTxColor";
    const char* const ChangeSpoofTxColor::Documentation = "Set a spoofer color in spectrums";

    REGISTER_COMMAND_FACTORY(ChangeSpoofTxColor);


    ChangeSpoofTxColor::ChangeSpoofTxColor()
      : CommandBase(CmdName)
    {}

    ChangeSpoofTxColor::ChangeSpoofTxColor(const std::string& color, const std::string& id)
      : CommandBase(CmdName)
    {

      setColor(color);
      setId(id);
    }


    ChangeSpoofTxColorPtr ChangeSpoofTxColor::create(const std::string& color, const std::string& id)
    {
      return std::make_shared<ChangeSpoofTxColor>(color, id);
    }

    ChangeSpoofTxColorPtr ChangeSpoofTxColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeSpoofTxColor>(ptr);
    }

    bool ChangeSpoofTxColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ChangeSpoofTxColor::documentation() const { return Documentation; }


    int ChangeSpoofTxColor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ChangeSpoofTxColor::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void ChangeSpoofTxColor::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeSpoofTxColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeSpoofTxColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxColor
///
#include "gen/GetSpoofTxColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxColor::CmdName = "GetSpoofTxColor";
    const char* const GetSpoofTxColor::Documentation = "Get a spoofer color in spectrums";

    REGISTER_COMMAND_FACTORY(GetSpoofTxColor);


    GetSpoofTxColor::GetSpoofTxColor()
      : CommandBase(CmdName)
    {}

    GetSpoofTxColor::GetSpoofTxColor(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxColorPtr GetSpoofTxColor::create(const std::string& id)
    {
      return std::make_shared<GetSpoofTxColor>(id);
    }

    GetSpoofTxColorPtr GetSpoofTxColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxColor>(ptr);
    }

    bool GetSpoofTxColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxColor::documentation() const { return Documentation; }


    int GetSpoofTxColor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxColorResult
///
#include "gen/GetSpoofTxColorResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxColorResult::CmdName = "GetSpoofTxColorResult";
    const char* const GetSpoofTxColorResult::Documentation = "Result of GetSpoofTxColor.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxColorResult);


    GetSpoofTxColorResult::GetSpoofTxColorResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxColorResult::GetSpoofTxColorResult(CommandBasePtr relatedCommand, const std::string& color, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setColor(color);
      setId(id);
    }


    GetSpoofTxColorResultPtr GetSpoofTxColorResult::create(CommandBasePtr relatedCommand, const std::string& color, const std::string& id)
    {
      return std::make_shared<GetSpoofTxColorResult>(relatedCommand, color, id);
    }

    GetSpoofTxColorResultPtr GetSpoofTxColorResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxColorResult>(ptr);
    }

    bool GetSpoofTxColorResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxColorResult::documentation() const { return Documentation; }


    std::string GetSpoofTxColorResult::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void GetSpoofTxColorResult::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxColorResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxColorResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSpoofTx
///
#include "gen/EnableSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSpoofTx::CmdName = "EnableSpoofTx";
    const char* const EnableSpoofTx::Documentation = "Enable/Disable the spoofer.";

    REGISTER_COMMAND_FACTORY(EnableSpoofTx);


    EnableSpoofTx::EnableSpoofTx()
      : CommandBase(CmdName)
    {}

    EnableSpoofTx::EnableSpoofTx(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    EnableSpoofTxPtr EnableSpoofTx::create(bool enabled, const std::string& id)
    {
      return std::make_shared<EnableSpoofTx>(enabled, id);
    }

    EnableSpoofTxPtr EnableSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSpoofTx>(ptr);
    }

    bool EnableSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EnableSpoofTx::documentation() const { return Documentation; }


    int EnableSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool EnableSpoofTx::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSpoofTx::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EnableSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofSignalManualPropagationLoss
///
#include "gen/SetSpoofSignalManualPropagationLoss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofSignalManualPropagationLoss::CmdName = "SetSpoofSignalManualPropagationLoss";
    const char* const SetSpoofSignalManualPropagationLoss::Documentation = "Set the manual propagation loss for the given spoofer signal. Value is used only if SetSpoofTxUseManualPropagationLoss has been set on the corresponding spoofer. This value is not preserved after simulation end.";

    REGISTER_COMMAND_FACTORY(SetSpoofSignalManualPropagationLoss);


    SetSpoofSignalManualPropagationLoss::SetSpoofSignalManualPropagationLoss()
      : CommandBase(CmdName)
    {}

    SetSpoofSignalManualPropagationLoss::SetSpoofSignalManualPropagationLoss(double propagationLoss, const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setPropagationLoss(propagationLoss);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    SetSpoofSignalManualPropagationLossPtr SetSpoofSignalManualPropagationLoss::create(double propagationLoss, const std::string& transmitterId, const std::string& signalId)
    {
      return std::make_shared<SetSpoofSignalManualPropagationLoss>(propagationLoss, transmitterId, signalId);
    }

    SetSpoofSignalManualPropagationLossPtr SetSpoofSignalManualPropagationLoss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofSignalManualPropagationLoss>(ptr);
    }

    bool SetSpoofSignalManualPropagationLoss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["PropagationLoss"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string SetSpoofSignalManualPropagationLoss::documentation() const { return Documentation; }


    int SetSpoofSignalManualPropagationLoss::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetSpoofSignalManualPropagationLoss::propagationLoss() const
    {
      return parse_json<double>::parse(m_values["PropagationLoss"]);
    }

    void SetSpoofSignalManualPropagationLoss::setPropagationLoss(double propagationLoss)
    {
      m_values.AddMember("PropagationLoss", parse_json<double>::format(propagationLoss, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofSignalManualPropagationLoss::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetSpoofSignalManualPropagationLoss::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofSignalManualPropagationLoss::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetSpoofSignalManualPropagationLoss::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxUseManualPropagationLoss
///
#include "gen/SetSpoofTxUseManualPropagationLoss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxUseManualPropagationLoss::CmdName = "SetSpoofTxUseManualPropagationLoss";
    const char* const SetSpoofTxUseManualPropagationLoss::Documentation = "Set whether a spoofer should only use user-provided propagation loss values. Propagation loss will not update automatically if set. This state is not preserved after simulation end.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxUseManualPropagationLoss);


    SetSpoofTxUseManualPropagationLoss::SetSpoofTxUseManualPropagationLoss()
      : CommandBase(CmdName)
    {}

    SetSpoofTxUseManualPropagationLoss::SetSpoofTxUseManualPropagationLoss(bool manual, const std::string& id)
      : CommandBase(CmdName)
    {

      setManual(manual);
      setId(id);
    }


    SetSpoofTxUseManualPropagationLossPtr SetSpoofTxUseManualPropagationLoss::create(bool manual, const std::string& id)
    {
      return std::make_shared<SetSpoofTxUseManualPropagationLoss>(manual, id);
    }

    SetSpoofTxUseManualPropagationLossPtr SetSpoofTxUseManualPropagationLoss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxUseManualPropagationLoss>(ptr);
    }

    bool SetSpoofTxUseManualPropagationLoss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Manual"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxUseManualPropagationLoss::documentation() const { return Documentation; }


    int SetSpoofTxUseManualPropagationLoss::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetSpoofTxUseManualPropagationLoss::manual() const
    {
      return parse_json<bool>::parse(m_values["Manual"]);
    }

    void SetSpoofTxUseManualPropagationLoss::setManual(bool manual)
    {
      m_values.AddMember("Manual", parse_json<bool>::format(manual, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxUseManualPropagationLoss::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxUseManualPropagationLoss::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxIgnorePropagationLoss
///
#include "gen/SetSpoofTxIgnorePropagationLoss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxIgnorePropagationLoss::CmdName = "SetSpoofTxIgnorePropagationLoss";
    const char* const SetSpoofTxIgnorePropagationLoss::Documentation = "Set whether a spoofer should ignore propagation loss or not.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxIgnorePropagationLoss);


    SetSpoofTxIgnorePropagationLoss::SetSpoofTxIgnorePropagationLoss()
      : CommandBase(CmdName)
    {}

    SetSpoofTxIgnorePropagationLoss::SetSpoofTxIgnorePropagationLoss(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetSpoofTxIgnorePropagationLossPtr SetSpoofTxIgnorePropagationLoss::create(bool ignore, const std::string& id)
    {
      return std::make_shared<SetSpoofTxIgnorePropagationLoss>(ignore, id);
    }

    SetSpoofTxIgnorePropagationLossPtr SetSpoofTxIgnorePropagationLoss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxIgnorePropagationLoss>(ptr);
    }

    bool SetSpoofTxIgnorePropagationLoss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxIgnorePropagationLoss::documentation() const { return Documentation; }


    int SetSpoofTxIgnorePropagationLoss::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool SetSpoofTxIgnorePropagationLoss::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetSpoofTxIgnorePropagationLoss::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxIgnorePropagationLoss::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxIgnorePropagationLoss::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxIgnoreRxAntennaPatterns
///
#include "gen/SetSpoofTxIgnoreRxAntennaPatterns.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxIgnoreRxAntennaPatterns::CmdName = "SetSpoofTxIgnoreRxAntennaPatterns";
    const char* const SetSpoofTxIgnoreRxAntennaPatterns::Documentation = "Set whether a spoofer should ignore the receiver's antenna patterns (gain and phase).";

    REGISTER_COMMAND_FACTORY(SetSpoofTxIgnoreRxAntennaPatterns);


    SetSpoofTxIgnoreRxAntennaPatterns::SetSpoofTxIgnoreRxAntennaPatterns()
      : CommandBase(CmdName)
    {}

    SetSpoofTxIgnoreRxAntennaPatterns::SetSpoofTxIgnoreRxAntennaPatterns(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetSpoofTxIgnoreRxAntennaPatternsPtr SetSpoofTxIgnoreRxAntennaPatterns::create(bool ignore, const std::string& id)
    {
      return std::make_shared<SetSpoofTxIgnoreRxAntennaPatterns>(ignore, id);
    }

    SetSpoofTxIgnoreRxAntennaPatternsPtr SetSpoofTxIgnoreRxAntennaPatterns::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxIgnoreRxAntennaPatterns>(ptr);
    }

    bool SetSpoofTxIgnoreRxAntennaPatterns::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxIgnoreRxAntennaPatterns::documentation() const { return Documentation; }


    int SetSpoofTxIgnoreRxAntennaPatterns::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool SetSpoofTxIgnoreRxAntennaPatterns::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetSpoofTxIgnoreRxAntennaPatterns::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxIgnoreRxAntennaPatterns::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxIgnoreRxAntennaPatterns::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxIgnoreRxAntennaGainPattern
///
#include "gen/SetSpoofTxIgnoreRxAntennaGainPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxIgnoreRxAntennaGainPattern::CmdName = "SetSpoofTxIgnoreRxAntennaGainPattern";
    const char* const SetSpoofTxIgnoreRxAntennaGainPattern::Documentation = "Set whether a spoofer should ignore the receiver's antenna gain pattern.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxIgnoreRxAntennaGainPattern);


    SetSpoofTxIgnoreRxAntennaGainPattern::SetSpoofTxIgnoreRxAntennaGainPattern()
      : CommandBase(CmdName)
    {}

    SetSpoofTxIgnoreRxAntennaGainPattern::SetSpoofTxIgnoreRxAntennaGainPattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetSpoofTxIgnoreRxAntennaGainPatternPtr SetSpoofTxIgnoreRxAntennaGainPattern::create(bool ignore, const std::string& id)
    {
      return std::make_shared<SetSpoofTxIgnoreRxAntennaGainPattern>(ignore, id);
    }

    SetSpoofTxIgnoreRxAntennaGainPatternPtr SetSpoofTxIgnoreRxAntennaGainPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxIgnoreRxAntennaGainPattern>(ptr);
    }

    bool SetSpoofTxIgnoreRxAntennaGainPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxIgnoreRxAntennaGainPattern::documentation() const { return Documentation; }


    int SetSpoofTxIgnoreRxAntennaGainPattern::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool SetSpoofTxIgnoreRxAntennaGainPattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetSpoofTxIgnoreRxAntennaGainPattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxIgnoreRxAntennaGainPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxIgnoreRxAntennaGainPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpoofTxIgnoreRxAntennaGainPattern
///
#include "gen/IsSpoofTxIgnoreRxAntennaGainPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpoofTxIgnoreRxAntennaGainPattern::CmdName = "IsSpoofTxIgnoreRxAntennaGainPattern";
    const char* const IsSpoofTxIgnoreRxAntennaGainPattern::Documentation = "Get whether a spoofer ignore the receiver's antenna gain pattern.";

    REGISTER_COMMAND_FACTORY(IsSpoofTxIgnoreRxAntennaGainPattern);


    IsSpoofTxIgnoreRxAntennaGainPattern::IsSpoofTxIgnoreRxAntennaGainPattern()
      : CommandBase(CmdName)
    {}

    IsSpoofTxIgnoreRxAntennaGainPattern::IsSpoofTxIgnoreRxAntennaGainPattern(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsSpoofTxIgnoreRxAntennaGainPatternPtr IsSpoofTxIgnoreRxAntennaGainPattern::create(const std::string& id)
    {
      return std::make_shared<IsSpoofTxIgnoreRxAntennaGainPattern>(id);
    }

    IsSpoofTxIgnoreRxAntennaGainPatternPtr IsSpoofTxIgnoreRxAntennaGainPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpoofTxIgnoreRxAntennaGainPattern>(ptr);
    }

    bool IsSpoofTxIgnoreRxAntennaGainPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsSpoofTxIgnoreRxAntennaGainPattern::documentation() const { return Documentation; }


    int IsSpoofTxIgnoreRxAntennaGainPattern::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSpoofTxIgnoreRxAntennaGainPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsSpoofTxIgnoreRxAntennaGainPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpoofTxIgnoreRxAntennaGainPatternResult
///
#include "gen/IsSpoofTxIgnoreRxAntennaGainPatternResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpoofTxIgnoreRxAntennaGainPatternResult::CmdName = "IsSpoofTxIgnoreRxAntennaGainPatternResult";
    const char* const IsSpoofTxIgnoreRxAntennaGainPatternResult::Documentation = "Result of IsSpoofTxIgnoreRxAntennaGainPattern.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSpoofTxIgnoreRxAntennaGainPatternResult);


    IsSpoofTxIgnoreRxAntennaGainPatternResult::IsSpoofTxIgnoreRxAntennaGainPatternResult()
      : CommandResult(CmdName)
    {}

    IsSpoofTxIgnoreRxAntennaGainPatternResult::IsSpoofTxIgnoreRxAntennaGainPatternResult(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setIgnore(ignore);
      setId(id);
    }


    IsSpoofTxIgnoreRxAntennaGainPatternResultPtr IsSpoofTxIgnoreRxAntennaGainPatternResult::create(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
    {
      return std::make_shared<IsSpoofTxIgnoreRxAntennaGainPatternResult>(relatedCommand, ignore, id);
    }

    IsSpoofTxIgnoreRxAntennaGainPatternResultPtr IsSpoofTxIgnoreRxAntennaGainPatternResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpoofTxIgnoreRxAntennaGainPatternResult>(ptr);
    }

    bool IsSpoofTxIgnoreRxAntennaGainPatternResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsSpoofTxIgnoreRxAntennaGainPatternResult::documentation() const { return Documentation; }


    bool IsSpoofTxIgnoreRxAntennaGainPatternResult::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void IsSpoofTxIgnoreRxAntennaGainPatternResult::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsSpoofTxIgnoreRxAntennaGainPatternResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsSpoofTxIgnoreRxAntennaGainPatternResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxIgnoreRxAntennaPhasePattern
///
#include "gen/SetSpoofTxIgnoreRxAntennaPhasePattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxIgnoreRxAntennaPhasePattern::CmdName = "SetSpoofTxIgnoreRxAntennaPhasePattern";
    const char* const SetSpoofTxIgnoreRxAntennaPhasePattern::Documentation = "Set whether a spoofer should ignore the receiver's antenna phase pattern.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxIgnoreRxAntennaPhasePattern);


    SetSpoofTxIgnoreRxAntennaPhasePattern::SetSpoofTxIgnoreRxAntennaPhasePattern()
      : CommandBase(CmdName)
    {}

    SetSpoofTxIgnoreRxAntennaPhasePattern::SetSpoofTxIgnoreRxAntennaPhasePattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetSpoofTxIgnoreRxAntennaPhasePatternPtr SetSpoofTxIgnoreRxAntennaPhasePattern::create(bool ignore, const std::string& id)
    {
      return std::make_shared<SetSpoofTxIgnoreRxAntennaPhasePattern>(ignore, id);
    }

    SetSpoofTxIgnoreRxAntennaPhasePatternPtr SetSpoofTxIgnoreRxAntennaPhasePattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxIgnoreRxAntennaPhasePattern>(ptr);
    }

    bool SetSpoofTxIgnoreRxAntennaPhasePattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxIgnoreRxAntennaPhasePattern::documentation() const { return Documentation; }


    int SetSpoofTxIgnoreRxAntennaPhasePattern::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool SetSpoofTxIgnoreRxAntennaPhasePattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetSpoofTxIgnoreRxAntennaPhasePattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxIgnoreRxAntennaPhasePattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxIgnoreRxAntennaPhasePattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpoofTxIgnoreRxAntennaPhasePattern
///
#include "gen/IsSpoofTxIgnoreRxAntennaPhasePattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpoofTxIgnoreRxAntennaPhasePattern::CmdName = "IsSpoofTxIgnoreRxAntennaPhasePattern";
    const char* const IsSpoofTxIgnoreRxAntennaPhasePattern::Documentation = "Get whether a spoofer ignore the receiver's antenna phase pattern.";

    REGISTER_COMMAND_FACTORY(IsSpoofTxIgnoreRxAntennaPhasePattern);


    IsSpoofTxIgnoreRxAntennaPhasePattern::IsSpoofTxIgnoreRxAntennaPhasePattern()
      : CommandBase(CmdName)
    {}

    IsSpoofTxIgnoreRxAntennaPhasePattern::IsSpoofTxIgnoreRxAntennaPhasePattern(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsSpoofTxIgnoreRxAntennaPhasePatternPtr IsSpoofTxIgnoreRxAntennaPhasePattern::create(const std::string& id)
    {
      return std::make_shared<IsSpoofTxIgnoreRxAntennaPhasePattern>(id);
    }

    IsSpoofTxIgnoreRxAntennaPhasePatternPtr IsSpoofTxIgnoreRxAntennaPhasePattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpoofTxIgnoreRxAntennaPhasePattern>(ptr);
    }

    bool IsSpoofTxIgnoreRxAntennaPhasePattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsSpoofTxIgnoreRxAntennaPhasePattern::documentation() const { return Documentation; }


    int IsSpoofTxIgnoreRxAntennaPhasePattern::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSpoofTxIgnoreRxAntennaPhasePattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsSpoofTxIgnoreRxAntennaPhasePattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpoofTxIgnoreRxAntennaPhasePatternResult
///
#include "gen/IsSpoofTxIgnoreRxAntennaPhasePatternResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpoofTxIgnoreRxAntennaPhasePatternResult::CmdName = "IsSpoofTxIgnoreRxAntennaPhasePatternResult";
    const char* const IsSpoofTxIgnoreRxAntennaPhasePatternResult::Documentation = "Result of IsSpoofTxIgnoreRxAntennaPhasePattern.";

    REGISTER_COMMAND_RESULT_FACTORY(IsSpoofTxIgnoreRxAntennaPhasePatternResult);


    IsSpoofTxIgnoreRxAntennaPhasePatternResult::IsSpoofTxIgnoreRxAntennaPhasePatternResult()
      : CommandResult(CmdName)
    {}

    IsSpoofTxIgnoreRxAntennaPhasePatternResult::IsSpoofTxIgnoreRxAntennaPhasePatternResult(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setIgnore(ignore);
      setId(id);
    }


    IsSpoofTxIgnoreRxAntennaPhasePatternResultPtr IsSpoofTxIgnoreRxAntennaPhasePatternResult::create(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
    {
      return std::make_shared<IsSpoofTxIgnoreRxAntennaPhasePatternResult>(relatedCommand, ignore, id);
    }

    IsSpoofTxIgnoreRxAntennaPhasePatternResultPtr IsSpoofTxIgnoreRxAntennaPhasePatternResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpoofTxIgnoreRxAntennaPhasePatternResult>(ptr);
    }

    bool IsSpoofTxIgnoreRxAntennaPhasePatternResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsSpoofTxIgnoreRxAntennaPhasePatternResult::documentation() const { return Documentation; }


    bool IsSpoofTxIgnoreRxAntennaPhasePatternResult::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void IsSpoofTxIgnoreRxAntennaPhasePatternResult::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsSpoofTxIgnoreRxAntennaPhasePatternResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsSpoofTxIgnoreRxAntennaPhasePatternResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxFix
///
#include "gen/SetSpoofTxFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxFix::CmdName = "SetSpoofTxFix";
    const char* const SetSpoofTxFix::Documentation = "Set spoofer transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(SetSpoofTxFix);


    SetSpoofTxFix::SetSpoofTxFix()
      : CommandBase(CmdName)
    {}

    SetSpoofTxFix::SetSpoofTxFix(double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetSpoofTxFixPtr SetSpoofTxFix::create(double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<SetSpoofTxFix>(lat, lon, alt, yaw, pitch, roll, id);
    }

    SetSpoofTxFixPtr SetSpoofTxFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxFix>(ptr);
    }

    bool SetSpoofTxFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxFix::documentation() const { return Documentation; }


    int SetSpoofTxFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSpoofTxFix::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetSpoofTxFix::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetSpoofTxFix::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetSpoofTxFix::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetSpoofTxFix::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetSpoofTxFix::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetSpoofTxFix::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxFix::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxFix::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxFix
///
#include "gen/GetSpoofTxFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxFix::CmdName = "GetSpoofTxFix";
    const char* const GetSpoofTxFix::Documentation = "Get spoofer transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(GetSpoofTxFix);


    GetSpoofTxFix::GetSpoofTxFix()
      : CommandBase(CmdName)
    {}

    GetSpoofTxFix::GetSpoofTxFix(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxFixPtr GetSpoofTxFix::create(const std::string& id)
    {
      return std::make_shared<GetSpoofTxFix>(id);
    }

    GetSpoofTxFixPtr GetSpoofTxFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxFix>(ptr);
    }

    bool GetSpoofTxFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxFix::documentation() const { return Documentation; }


    int GetSpoofTxFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxFix::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxFix::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxFixResult
///
#include "gen/GetSpoofTxFixResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxFixResult::CmdName = "GetSpoofTxFixResult";
    const char* const GetSpoofTxFixResult::Documentation = "Result of GetSpoofTxFix.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxFixResult);


    GetSpoofTxFixResult::GetSpoofTxFixResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxFixResult::GetSpoofTxFixResult(CommandBasePtr relatedCommand, double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetSpoofTxFixResultPtr GetSpoofTxFixResult::create(CommandBasePtr relatedCommand, double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<GetSpoofTxFixResult>(relatedCommand, lat, lon, alt, yaw, pitch, roll, id);
    }

    GetSpoofTxFixResultPtr GetSpoofTxFixResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxFixResult>(ptr);
    }

    bool GetSpoofTxFixResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxFixResult::documentation() const { return Documentation; }


    double GetSpoofTxFixResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetSpoofTxFixResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetSpoofTxFixResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetSpoofTxFixResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetSpoofTxFixResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetSpoofTxFixResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetSpoofTxFixResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxFixResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxFixResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxFixEcef
///
#include "gen/SetSpoofTxFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxFixEcef::CmdName = "SetSpoofTxFixEcef";
    const char* const SetSpoofTxFixEcef::Documentation = "Set spoofer transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(SetSpoofTxFixEcef);


    SetSpoofTxFixEcef::SetSpoofTxFixEcef()
      : CommandBase(CmdName)
    {}

    SetSpoofTxFixEcef::SetSpoofTxFixEcef(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetSpoofTxFixEcefPtr SetSpoofTxFixEcef::create(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<SetSpoofTxFixEcef>(x, y, z, yaw, pitch, roll, id);
    }

    SetSpoofTxFixEcefPtr SetSpoofTxFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxFixEcef>(ptr);
    }

    bool SetSpoofTxFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxFixEcef::documentation() const { return Documentation; }


    int SetSpoofTxFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSpoofTxFixEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetSpoofTxFixEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetSpoofTxFixEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetSpoofTxFixEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetSpoofTxFixEcef::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetSpoofTxFixEcef::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetSpoofTxFixEcef::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxFixEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxFixEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxFixEcef
///
#include "gen/GetSpoofTxFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxFixEcef::CmdName = "GetSpoofTxFixEcef";
    const char* const GetSpoofTxFixEcef::Documentation = "Get spoofer transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(GetSpoofTxFixEcef);


    GetSpoofTxFixEcef::GetSpoofTxFixEcef()
      : CommandBase(CmdName)
    {}

    GetSpoofTxFixEcef::GetSpoofTxFixEcef(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxFixEcefPtr GetSpoofTxFixEcef::create(const std::string& id)
    {
      return std::make_shared<GetSpoofTxFixEcef>(id);
    }

    GetSpoofTxFixEcefPtr GetSpoofTxFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxFixEcef>(ptr);
    }

    bool GetSpoofTxFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxFixEcef::documentation() const { return Documentation; }


    int GetSpoofTxFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxFixEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxFixEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxFixEcefResult
///
#include "gen/GetSpoofTxFixEcefResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxFixEcefResult::CmdName = "GetSpoofTxFixEcefResult";
    const char* const GetSpoofTxFixEcefResult::Documentation = "Result of GetSpoofTxFixEcef.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxFixEcefResult);


    GetSpoofTxFixEcefResult::GetSpoofTxFixEcefResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxFixEcefResult::GetSpoofTxFixEcefResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetSpoofTxFixEcefResultPtr GetSpoofTxFixEcefResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<GetSpoofTxFixEcefResult>(relatedCommand, x, y, z, yaw, pitch, roll, id);
    }

    GetSpoofTxFixEcefResultPtr GetSpoofTxFixEcefResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxFixEcefResult>(ptr);
    }

    bool GetSpoofTxFixEcefResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxFixEcefResult::documentation() const { return Documentation; }


    double GetSpoofTxFixEcefResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetSpoofTxFixEcefResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetSpoofTxFixEcefResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetSpoofTxFixEcefResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetSpoofTxFixEcefResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetSpoofTxFixEcefResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetSpoofTxFixEcefResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxFixEcefResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxFixEcefResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxCircular
///
#include "gen/SetSpoofTxCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxCircular::CmdName = "SetSpoofTxCircular";
    const char* const SetSpoofTxCircular::Documentation = "Set spoofer transmitter circular trajectory";

    REGISTER_COMMAND_FACTORY(SetSpoofTxCircular);


    SetSpoofTxCircular::SetSpoofTxCircular()
      : CommandBase(CmdName)
    {}

    SetSpoofTxCircular::SetSpoofTxCircular(double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
      : CommandBase(CmdName)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setId(id);
      setOriginAngle(originAngle);
    }


    SetSpoofTxCircularPtr SetSpoofTxCircular::create(double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
    {
      return std::make_shared<SetSpoofTxCircular>(lat, lon, alt, radius, speed, clockwise, id, originAngle);
    }

    SetSpoofTxCircularPtr SetSpoofTxCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxCircular>(ptr);
    }

    bool SetSpoofTxCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string SetSpoofTxCircular::documentation() const { return Documentation; }


    int SetSpoofTxCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSpoofTxCircular::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetSpoofTxCircular::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxCircular::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetSpoofTxCircular::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxCircular::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetSpoofTxCircular::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxCircular::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void SetSpoofTxCircular::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxCircular::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void SetSpoofTxCircular::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSpoofTxCircular::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void SetSpoofTxCircular::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxCircular::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxCircular::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> SetSpoofTxCircular::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void SetSpoofTxCircular::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxCircular
///
#include "gen/GetSpoofTxCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxCircular::CmdName = "GetSpoofTxCircular";
    const char* const GetSpoofTxCircular::Documentation = "Get spoofer transmitter circular trajectory";

    REGISTER_COMMAND_FACTORY(GetSpoofTxCircular);


    GetSpoofTxCircular::GetSpoofTxCircular()
      : CommandBase(CmdName)
    {}

    GetSpoofTxCircular::GetSpoofTxCircular(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxCircularPtr GetSpoofTxCircular::create(const std::string& id)
    {
      return std::make_shared<GetSpoofTxCircular>(id);
    }

    GetSpoofTxCircularPtr GetSpoofTxCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxCircular>(ptr);
    }

    bool GetSpoofTxCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxCircular::documentation() const { return Documentation; }


    int GetSpoofTxCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxCircular::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxCircular::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxCircularResult
///
#include "gen/GetSpoofTxCircularResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxCircularResult::CmdName = "GetSpoofTxCircularResult";
    const char* const GetSpoofTxCircularResult::Documentation = "Result of GetSpoofTxCircular.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxCircularResult);


    GetSpoofTxCircularResult::GetSpoofTxCircularResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxCircularResult::GetSpoofTxCircularResult(CommandBasePtr relatedCommand, double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
      : CommandResult(CmdName, relatedCommand)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setId(id);
      setOriginAngle(originAngle);
    }


    GetSpoofTxCircularResultPtr GetSpoofTxCircularResult::create(CommandBasePtr relatedCommand, double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
    {
      return std::make_shared<GetSpoofTxCircularResult>(relatedCommand, lat, lon, alt, radius, speed, clockwise, id, originAngle);
    }

    GetSpoofTxCircularResultPtr GetSpoofTxCircularResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxCircularResult>(ptr);
    }

    bool GetSpoofTxCircularResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string GetSpoofTxCircularResult::documentation() const { return Documentation; }


    double GetSpoofTxCircularResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetSpoofTxCircularResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxCircularResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetSpoofTxCircularResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxCircularResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetSpoofTxCircularResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxCircularResult::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void GetSpoofTxCircularResult::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxCircularResult::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void GetSpoofTxCircularResult::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetSpoofTxCircularResult::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void GetSpoofTxCircularResult::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxCircularResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxCircularResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetSpoofTxCircularResult::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void GetSpoofTxCircularResult::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxHil
///
#include "gen/SetSpoofTxHil.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxHil::CmdName = "SetSpoofTxHil";
    const char* const SetSpoofTxHil::Documentation = "Set spoofer transmitter HIL trajectory";

    REGISTER_COMMAND_FACTORY(SetSpoofTxHil);


    SetSpoofTxHil::SetSpoofTxHil()
      : CommandBase(CmdName)
    {}

    SetSpoofTxHil::SetSpoofTxHil(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    SetSpoofTxHilPtr SetSpoofTxHil::create(const std::string& id)
    {
      return std::make_shared<SetSpoofTxHil>(id);
    }

    SetSpoofTxHilPtr SetSpoofTxHil::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxHil>(ptr);
    }

    bool SetSpoofTxHil::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxHil::documentation() const { return Documentation; }


    int SetSpoofTxHil::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSpoofTxHil::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxHil::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxTrajectory
///
#include "gen/GetSpoofTxTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxTrajectory::CmdName = "GetSpoofTxTrajectory";
    const char* const GetSpoofTxTrajectory::Documentation = "Get spoofer transmitter trajectory";

    REGISTER_COMMAND_FACTORY(GetSpoofTxTrajectory);


    GetSpoofTxTrajectory::GetSpoofTxTrajectory()
      : CommandBase(CmdName)
    {}

    GetSpoofTxTrajectory::GetSpoofTxTrajectory(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxTrajectoryPtr GetSpoofTxTrajectory::create(const std::string& id)
    {
      return std::make_shared<GetSpoofTxTrajectory>(id);
    }

    GetSpoofTxTrajectoryPtr GetSpoofTxTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxTrajectory>(ptr);
    }

    bool GetSpoofTxTrajectory::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxTrajectory::documentation() const { return Documentation; }


    int GetSpoofTxTrajectory::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxTrajectory::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxTrajectory::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxTrajectoryResult
///
#include "gen/GetSpoofTxTrajectoryResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxTrajectoryResult::CmdName = "GetSpoofTxTrajectoryResult";
    const char* const GetSpoofTxTrajectoryResult::Documentation = "Result of GetSpoofTxTrajectory.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxTrajectoryResult);


    GetSpoofTxTrajectoryResult::GetSpoofTxTrajectoryResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxTrajectoryResult::GetSpoofTxTrajectoryResult(CommandBasePtr relatedCommand, const std::string& trajectoryType, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setTrajectoryType(trajectoryType);
      setId(id);
    }


    GetSpoofTxTrajectoryResultPtr GetSpoofTxTrajectoryResult::create(CommandBasePtr relatedCommand, const std::string& trajectoryType, const std::string& id)
    {
      return std::make_shared<GetSpoofTxTrajectoryResult>(relatedCommand, trajectoryType, id);
    }

    GetSpoofTxTrajectoryResultPtr GetSpoofTxTrajectoryResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxTrajectoryResult>(ptr);
    }

    bool GetSpoofTxTrajectoryResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TrajectoryType"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxTrajectoryResult::documentation() const { return Documentation; }


    std::string GetSpoofTxTrajectoryResult::trajectoryType() const
    {
      return parse_json<std::string>::parse(m_values["TrajectoryType"]);
    }

    void GetSpoofTxTrajectoryResult::setTrajectoryType(const std::string& trajectoryType)
    {
      m_values.AddMember("TrajectoryType", parse_json<std::string>::format(trajectoryType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxTrajectoryResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxTrajectoryResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxAntenna
///
#include "gen/SetSpoofTxAntenna.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxAntenna::CmdName = "SetSpoofTxAntenna";
    const char* const SetSpoofTxAntenna::Documentation = "Set transmitter antenna pattern.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxAntenna);


    SetSpoofTxAntenna::SetSpoofTxAntenna()
      : CommandBase(CmdName)
    {}

    SetSpoofTxAntenna::SetSpoofTxAntenna(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
      : CommandBase(CmdName)
    {

      setGain(gain);
      setType(type);
      setId(id);
    }


    SetSpoofTxAntennaPtr SetSpoofTxAntenna::create(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
    {
      return std::make_shared<SetSpoofTxAntenna>(gain, type, id);
    }

    SetSpoofTxAntennaPtr SetSpoofTxAntenna::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxAntenna>(ptr);
    }

    bool SetSpoofTxAntenna::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxAntenna::documentation() const { return Documentation; }


    int SetSpoofTxAntenna::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetSpoofTxAntenna::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void SetSpoofTxAntenna::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSpoofTxAntenna::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSpoofTxAntenna::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxAntenna::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxAntenna::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxAntenna
///
#include "gen/GetSpoofTxAntenna.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxAntenna::CmdName = "GetSpoofTxAntenna";
    const char* const GetSpoofTxAntenna::Documentation = "Get transmitter antenna pattern.";

    REGISTER_COMMAND_FACTORY(GetSpoofTxAntenna);


    GetSpoofTxAntenna::GetSpoofTxAntenna()
      : CommandBase(CmdName)
    {}

    GetSpoofTxAntenna::GetSpoofTxAntenna(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxAntennaPtr GetSpoofTxAntenna::create(const std::string& id)
    {
      return std::make_shared<GetSpoofTxAntenna>(id);
    }

    GetSpoofTxAntennaPtr GetSpoofTxAntenna::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxAntenna>(ptr);
    }

    bool GetSpoofTxAntenna::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxAntenna::documentation() const { return Documentation; }


    int GetSpoofTxAntenna::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxAntenna::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxAntenna::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxAntennaResult
///
#include "gen/GetSpoofTxAntennaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxAntennaResult::CmdName = "GetSpoofTxAntennaResult";
    const char* const GetSpoofTxAntennaResult::Documentation = "Result of GetSpoofTxAntenna.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxAntennaResult);


    GetSpoofTxAntennaResult::GetSpoofTxAntennaResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxAntennaResult::GetSpoofTxAntennaResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
      setType(type);
      setId(id);
    }


    GetSpoofTxAntennaResultPtr GetSpoofTxAntennaResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
    {
      return std::make_shared<GetSpoofTxAntennaResult>(relatedCommand, gain, type, id);
    }

    GetSpoofTxAntennaResultPtr GetSpoofTxAntennaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxAntennaResult>(ptr);
    }

    bool GetSpoofTxAntennaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxAntennaResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetSpoofTxAntennaResult::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void GetSpoofTxAntennaResult::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetSpoofTxAntennaResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetSpoofTxAntennaResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxAntennaResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxAntennaResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxAntennaOffset
///
#include "gen/SetSpoofTxAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxAntennaOffset::CmdName = "SetSpoofTxAntennaOffset";
    const char* const SetSpoofTxAntennaOffset::Documentation = "Set antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the transmitter trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxAntennaOffset);


    SetSpoofTxAntennaOffset::SetSpoofTxAntennaOffset()
      : CommandBase(CmdName)
    {}

    SetSpoofTxAntennaOffset::SetSpoofTxAntennaOffset(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetSpoofTxAntennaOffsetPtr SetSpoofTxAntennaOffset::create(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<SetSpoofTxAntennaOffset>(x, y, z, yaw, pitch, roll, id);
    }

    SetSpoofTxAntennaOffsetPtr SetSpoofTxAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxAntennaOffset>(ptr);
    }

    bool SetSpoofTxAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxAntennaOffset::documentation() const { return Documentation; }


    int SetSpoofTxAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSpoofTxAntennaOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetSpoofTxAntennaOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetSpoofTxAntennaOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetSpoofTxAntennaOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetSpoofTxAntennaOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetSpoofTxAntennaOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetSpoofTxAntennaOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxAntennaOffset::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxAntennaOffset::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxAntennaOffset
///
#include "gen/GetSpoofTxAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxAntennaOffset::CmdName = "GetSpoofTxAntennaOffset";
    const char* const GetSpoofTxAntennaOffset::Documentation = "Get antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the transmitter trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(GetSpoofTxAntennaOffset);


    GetSpoofTxAntennaOffset::GetSpoofTxAntennaOffset()
      : CommandBase(CmdName)
    {}

    GetSpoofTxAntennaOffset::GetSpoofTxAntennaOffset(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxAntennaOffsetPtr GetSpoofTxAntennaOffset::create(const std::string& id)
    {
      return std::make_shared<GetSpoofTxAntennaOffset>(id);
    }

    GetSpoofTxAntennaOffsetPtr GetSpoofTxAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxAntennaOffset>(ptr);
    }

    bool GetSpoofTxAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxAntennaOffset::documentation() const { return Documentation; }


    int GetSpoofTxAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxAntennaOffset::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxAntennaOffset::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxAntennaOffsetResult
///
#include "gen/GetSpoofTxAntennaOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxAntennaOffsetResult::CmdName = "GetSpoofTxAntennaOffsetResult";
    const char* const GetSpoofTxAntennaOffsetResult::Documentation = "Result of GetSpoofTxAntennaOffset.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxAntennaOffsetResult);


    GetSpoofTxAntennaOffsetResult::GetSpoofTxAntennaOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxAntennaOffsetResult::GetSpoofTxAntennaOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetSpoofTxAntennaOffsetResultPtr GetSpoofTxAntennaOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return std::make_shared<GetSpoofTxAntennaOffsetResult>(relatedCommand, x, y, z, yaw, pitch, roll, id);
    }

    GetSpoofTxAntennaOffsetResultPtr GetSpoofTxAntennaOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxAntennaOffsetResult>(ptr);
    }

    bool GetSpoofTxAntennaOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxAntennaOffsetResult::documentation() const { return Documentation; }


    double GetSpoofTxAntennaOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetSpoofTxAntennaOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetSpoofTxAntennaOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetSpoofTxAntennaOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetSpoofTxAntennaOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetSpoofTxAntennaOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetSpoofTxAntennaOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxAntennaOffsetResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxAntennaOffsetResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxRemoteAddress
///
#include "gen/SetSpoofTxRemoteAddress.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxRemoteAddress::CmdName = "SetSpoofTxRemoteAddress";
    const char* const SetSpoofTxRemoteAddress::Documentation = "Set the address of the spoofer instance that will\ngenerate the signal for this spoofer transmitter.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxRemoteAddress);


    SetSpoofTxRemoteAddress::SetSpoofTxRemoteAddress()
      : CommandBase(CmdName)
    {}

    SetSpoofTxRemoteAddress::SetSpoofTxRemoteAddress(const std::string& address, int instanceId, const std::string& id)
      : CommandBase(CmdName)
    {

      setAddress(address);
      setInstanceId(instanceId);
      setId(id);
    }


    SetSpoofTxRemoteAddressPtr SetSpoofTxRemoteAddress::create(const std::string& address, int instanceId, const std::string& id)
    {
      return std::make_shared<SetSpoofTxRemoteAddress>(address, instanceId, id);
    }

    SetSpoofTxRemoteAddressPtr SetSpoofTxRemoteAddress::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxRemoteAddress>(ptr);
    }

    bool SetSpoofTxRemoteAddress::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<int>::is_valid(m_values["InstanceId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxRemoteAddress::documentation() const { return Documentation; }


    int SetSpoofTxRemoteAddress::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSpoofTxRemoteAddress::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void SetSpoofTxRemoteAddress::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSpoofTxRemoteAddress::instanceId() const
    {
      return parse_json<int>::parse(m_values["InstanceId"]);
    }

    void SetSpoofTxRemoteAddress::setInstanceId(int instanceId)
    {
      m_values.AddMember("InstanceId", parse_json<int>::format(instanceId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxRemoteAddress::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxRemoteAddress::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxRemoteAddress
///
#include "gen/GetSpoofTxRemoteAddress.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxRemoteAddress::CmdName = "GetSpoofTxRemoteAddress";
    const char* const GetSpoofTxRemoteAddress::Documentation = "Get the address of the spoofer instance that will\ngenerate the signal for this spoofer transmitter.";

    REGISTER_COMMAND_FACTORY(GetSpoofTxRemoteAddress);


    GetSpoofTxRemoteAddress::GetSpoofTxRemoteAddress()
      : CommandBase(CmdName)
    {}

    GetSpoofTxRemoteAddress::GetSpoofTxRemoteAddress(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxRemoteAddressPtr GetSpoofTxRemoteAddress::create(const std::string& id)
    {
      return std::make_shared<GetSpoofTxRemoteAddress>(id);
    }

    GetSpoofTxRemoteAddressPtr GetSpoofTxRemoteAddress::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxRemoteAddress>(ptr);
    }

    bool GetSpoofTxRemoteAddress::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxRemoteAddress::documentation() const { return Documentation; }


    int GetSpoofTxRemoteAddress::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxRemoteAddress::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxRemoteAddress::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxRemoteAddressResult
///
#include "gen/GetSpoofTxRemoteAddressResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxRemoteAddressResult::CmdName = "GetSpoofTxRemoteAddressResult";
    const char* const GetSpoofTxRemoteAddressResult::Documentation = "Result of GetSpoofTxRemoteAddress.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxRemoteAddressResult);


    GetSpoofTxRemoteAddressResult::GetSpoofTxRemoteAddressResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxRemoteAddressResult::GetSpoofTxRemoteAddressResult(CommandBasePtr relatedCommand, const std::string& address, int instanceId, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setAddress(address);
      setInstanceId(instanceId);
      setId(id);
    }


    GetSpoofTxRemoteAddressResultPtr GetSpoofTxRemoteAddressResult::create(CommandBasePtr relatedCommand, const std::string& address, int instanceId, const std::string& id)
    {
      return std::make_shared<GetSpoofTxRemoteAddressResult>(relatedCommand, address, instanceId, id);
    }

    GetSpoofTxRemoteAddressResultPtr GetSpoofTxRemoteAddressResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxRemoteAddressResult>(ptr);
    }

    bool GetSpoofTxRemoteAddressResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<int>::is_valid(m_values["InstanceId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxRemoteAddressResult::documentation() const { return Documentation; }


    std::string GetSpoofTxRemoteAddressResult::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void GetSpoofTxRemoteAddressResult::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSpoofTxRemoteAddressResult::instanceId() const
    {
      return parse_json<int>::parse(m_values["InstanceId"]);
    }

    void GetSpoofTxRemoteAddressResult::setInstanceId(int instanceId)
    {
      m_values.AddMember("InstanceId", parse_json<int>::format(instanceId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxRemoteAddressResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxRemoteAddressResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxRefPower
///
#include "gen/SetSpoofTxRefPower.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxRefPower::CmdName = "SetSpoofTxRefPower";
    const char* const SetSpoofTxRefPower::Documentation = "Set the spoofing transmitter reference power.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxRefPower);


    SetSpoofTxRefPower::SetSpoofTxRefPower()
      : CommandBase(CmdName)
    {}

    SetSpoofTxRefPower::SetSpoofTxRefPower(double power, const std::string& id)
      : CommandBase(CmdName)
    {

      setPower(power);
      setId(id);
    }


    SetSpoofTxRefPowerPtr SetSpoofTxRefPower::create(double power, const std::string& id)
    {
      return std::make_shared<SetSpoofTxRefPower>(power, id);
    }

    SetSpoofTxRefPowerPtr SetSpoofTxRefPower::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxRefPower>(ptr);
    }

    bool SetSpoofTxRefPower::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxRefPower::documentation() const { return Documentation; }


    int SetSpoofTxRefPower::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    double SetSpoofTxRefPower::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetSpoofTxRefPower::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxRefPower::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxRefPower::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearSpoofTxGpuIdx
///
#include "gen/ClearSpoofTxGpuIdx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearSpoofTxGpuIdx::CmdName = "ClearSpoofTxGpuIdx";
    const char* const ClearSpoofTxGpuIdx::Documentation = "Reset the spoofer's signal GPU index to default.";

    REGISTER_COMMAND_FACTORY(ClearSpoofTxGpuIdx);


    ClearSpoofTxGpuIdx::ClearSpoofTxGpuIdx()
      : CommandBase(CmdName)
    {}

    ClearSpoofTxGpuIdx::ClearSpoofTxGpuIdx(int signalId, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalId(signalId);
      setId(id);
    }


    ClearSpoofTxGpuIdxPtr ClearSpoofTxGpuIdx::create(int signalId, const std::string& id)
    {
      return std::make_shared<ClearSpoofTxGpuIdx>(signalId, id);
    }

    ClearSpoofTxGpuIdxPtr ClearSpoofTxGpuIdx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearSpoofTxGpuIdx>(ptr);
    }

    bool ClearSpoofTxGpuIdx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SignalId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ClearSpoofTxGpuIdx::documentation() const { return Documentation; }


    int ClearSpoofTxGpuIdx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ClearSpoofTxGpuIdx::signalId() const
    {
      return parse_json<int>::parse(m_values["SignalId"]);
    }

    void ClearSpoofTxGpuIdx::setSignalId(int signalId)
    {
      m_values.AddMember("SignalId", parse_json<int>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ClearSpoofTxGpuIdx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ClearSpoofTxGpuIdx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxGpuIdx
///
#include "gen/SetSpoofTxGpuIdx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxGpuIdx::CmdName = "SetSpoofTxGpuIdx";
    const char* const SetSpoofTxGpuIdx::Documentation = "Set the GPU index on which this spoofer signal will be modulated.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxGpuIdx);


    SetSpoofTxGpuIdx::SetSpoofTxGpuIdx()
      : CommandBase(CmdName)
    {}

    SetSpoofTxGpuIdx::SetSpoofTxGpuIdx(int gpuIdx, int signalId, const std::string& id)
      : CommandBase(CmdName)
    {

      setGpuIdx(gpuIdx);
      setSignalId(signalId);
      setId(id);
    }


    SetSpoofTxGpuIdxPtr SetSpoofTxGpuIdx::create(int gpuIdx, int signalId, const std::string& id)
    {
      return std::make_shared<SetSpoofTxGpuIdx>(gpuIdx, signalId, id);
    }

    SetSpoofTxGpuIdxPtr SetSpoofTxGpuIdx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxGpuIdx>(ptr);
    }

    bool SetSpoofTxGpuIdx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["GpuIdx"])
          && parse_json<int>::is_valid(m_values["SignalId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxGpuIdx::documentation() const { return Documentation; }


    int SetSpoofTxGpuIdx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetSpoofTxGpuIdx::gpuIdx() const
    {
      return parse_json<int>::parse(m_values["GpuIdx"]);
    }

    void SetSpoofTxGpuIdx::setGpuIdx(int gpuIdx)
    {
      m_values.AddMember("GpuIdx", parse_json<int>::format(gpuIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSpoofTxGpuIdx::signalId() const
    {
      return parse_json<int>::parse(m_values["SignalId"]);
    }

    void SetSpoofTxGpuIdx::setSignalId(int signalId)
    {
      m_values.AddMember("SignalId", parse_json<int>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxGpuIdx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxGpuIdx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetExternalChannelsPath
///
#include "gen/SetExternalChannelsPath.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetExternalChannelsPath::CmdName = "SetExternalChannelsPath";
    const char* const SetExternalChannelsPath::Documentation = "Set external channels path.";

    REGISTER_COMMAND_FACTORY(SetExternalChannelsPath);


    SetExternalChannelsPath::SetExternalChannelsPath()
      : CommandBase(CmdName)
    {}

    SetExternalChannelsPath::SetExternalChannelsPath(const std::string& path)
      : CommandBase(CmdName)
    {

      setPath(path);
    }


    SetExternalChannelsPathPtr SetExternalChannelsPath::create(const std::string& path)
    {
      return std::make_shared<SetExternalChannelsPath>(path);
    }

    SetExternalChannelsPathPtr SetExternalChannelsPath::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetExternalChannelsPath>(ptr);
    }

    bool SetExternalChannelsPath::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string SetExternalChannelsPath::documentation() const { return Documentation; }


    int SetExternalChannelsPath::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    std::string SetExternalChannelsPath::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void SetExternalChannelsPath::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVIDsOfPrn
///
#include "gen/GetSVIDsOfPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVIDsOfPrn::CmdName = "GetSVIDsOfPrn";
    const char* const GetSVIDsOfPrn::Documentation = "Mapping PRN to the corresponding SV ID. Get a list of SV IDs based on a specific signal. Accepted signal keys: \"L1CA\", \"L1C\", \"L1P\", \"L1ME\", \"L1MR\", \"L2C\", \"L2P\", \"L5\", \"G1\", \"G2\", \"E1\", \"E1PRS\", \"E5a\", \"E5b\", \"E6BC\", \"E6PRS\", \"B1\", \"B2\", \"B2a\", \"B1C\", \"SBASL1\", \"SBASL5\", \"QZSSL1CA\", \"QZSSL1CB\", \"QZSSL1C\", \"QZSSL2C\", \"QZSSL5\", \"QZSSL1S\", \"QZSSL5S\" and \"NAVICL5\"";

    REGISTER_COMMAND_FACTORY(GetSVIDsOfPrn);


    GetSVIDsOfPrn::GetSVIDsOfPrn()
      : CommandBase(CmdName)
    {}

    GetSVIDsOfPrn::GetSVIDsOfPrn(const std::string& signal, int prn)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setPrn(prn);
    }


    GetSVIDsOfPrnPtr GetSVIDsOfPrn::create(const std::string& signal, int prn)
    {
      return std::make_shared<GetSVIDsOfPrn>(signal, prn);
    }

    GetSVIDsOfPrnPtr GetSVIDsOfPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVIDsOfPrn>(ptr);
    }

    bool GetSVIDsOfPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetSVIDsOfPrn::documentation() const { return Documentation; }


    int GetSVIDsOfPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSVIDsOfPrn::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetSVIDsOfPrn::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVIDsOfPrn::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSVIDsOfPrn::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVIDsOfPrnResult
///
#include "gen/GetSVIDsOfPrnResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVIDsOfPrnResult::CmdName = "GetSVIDsOfPrnResult";
    const char* const GetSVIDsOfPrnResult::Documentation = "Result of GetSVIDsOfPrn.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVIDsOfPrnResult);


    GetSVIDsOfPrnResult::GetSVIDsOfPrnResult()
      : CommandResult(CmdName)
    {}

    GetSVIDsOfPrnResult::GetSVIDsOfPrnResult(CommandBasePtr relatedCommand, const std::string& signal, int prn, const std::vector<int>& svIdList)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setPrn(prn);
      setSvIdList(svIdList);
    }


    GetSVIDsOfPrnResultPtr GetSVIDsOfPrnResult::create(CommandBasePtr relatedCommand, const std::string& signal, int prn, const std::vector<int>& svIdList)
    {
      return std::make_shared<GetSVIDsOfPrnResult>(relatedCommand, signal, prn, svIdList);
    }

    GetSVIDsOfPrnResultPtr GetSVIDsOfPrnResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVIDsOfPrnResult>(ptr);
    }

    bool GetSVIDsOfPrnResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::vector<int>>::is_valid(m_values["SvIdList"])
        ;

    }

    std::string GetSVIDsOfPrnResult::documentation() const { return Documentation; }


    std::string GetSVIDsOfPrnResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetSVIDsOfPrnResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVIDsOfPrnResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSVIDsOfPrnResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetSVIDsOfPrnResult::svIdList() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvIdList"]);
    }

    void GetSVIDsOfPrnResult::setSvIdList(const std::vector<int>& svIdList)
    {
      m_values.AddMember("SvIdList", parse_json<std::vector<int>>::format(svIdList, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL1SAugmentation
///
#include "gen/SetQzssL1SAugmentation.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL1SAugmentation::CmdName = "SetQzssL1SAugmentation";
    const char* const SetQzssL1SAugmentation::Documentation = "Set Add an augmentation to the L1S navigation messages.";

    REGISTER_COMMAND_FACTORY(SetQzssL1SAugmentation);


    SetQzssL1SAugmentation::SetQzssL1SAugmentation()
      : CommandBase(CmdName)
    {}

    SetQzssL1SAugmentation::SetQzssL1SAugmentation(const std::string& system, int prn, bool augmentIOD, bool augmentPRC, double prc, const std::string& id)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setAugmentIOD(augmentIOD);
      setAugmentPRC(augmentPRC);
      setPrc(prc);
      setId(id);
    }


    SetQzssL1SAugmentationPtr SetQzssL1SAugmentation::create(const std::string& system, int prn, bool augmentIOD, bool augmentPRC, double prc, const std::string& id)
    {
      return std::make_shared<SetQzssL1SAugmentation>(system, prn, augmentIOD, augmentPRC, prc, id);
    }

    SetQzssL1SAugmentationPtr SetQzssL1SAugmentation::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL1SAugmentation>(ptr);
    }

    bool SetQzssL1SAugmentation::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["AugmentIOD"])
          && parse_json<bool>::is_valid(m_values["AugmentPRC"])
          && parse_json<double>::is_valid(m_values["Prc"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetQzssL1SAugmentation::documentation() const { return Documentation; }


    int SetQzssL1SAugmentation::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssL1SAugmentation::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetQzssL1SAugmentation::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssL1SAugmentation::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetQzssL1SAugmentation::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL1SAugmentation::augmentIOD() const
    {
      return parse_json<bool>::parse(m_values["AugmentIOD"]);
    }

    void SetQzssL1SAugmentation::setAugmentIOD(bool augmentIOD)
    {
      m_values.AddMember("AugmentIOD", parse_json<bool>::format(augmentIOD, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL1SAugmentation::augmentPRC() const
    {
      return parse_json<bool>::parse(m_values["AugmentPRC"]);
    }

    void SetQzssL1SAugmentation::setAugmentPRC(bool augmentPRC)
    {
      m_values.AddMember("AugmentPRC", parse_json<bool>::format(augmentPRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssL1SAugmentation::prc() const
    {
      return parse_json<double>::parse(m_values["Prc"]);
    }

    void SetQzssL1SAugmentation::setPrc(double prc)
    {
      m_values.AddMember("Prc", parse_json<double>::format(prc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssL1SAugmentation::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetQzssL1SAugmentation::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1SAugmentation
///
#include "gen/GetQzssL1SAugmentation.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SAugmentation::CmdName = "GetQzssL1SAugmentation";
    const char* const GetQzssL1SAugmentation::Documentation = "Get Add an augmentation to the L1S navigation messages.";

    REGISTER_COMMAND_FACTORY(GetQzssL1SAugmentation);


    GetQzssL1SAugmentation::GetQzssL1SAugmentation()
      : CommandBase(CmdName)
    {}

    GetQzssL1SAugmentation::GetQzssL1SAugmentation(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetQzssL1SAugmentationPtr GetQzssL1SAugmentation::create(const std::string& id)
    {
      return std::make_shared<GetQzssL1SAugmentation>(id);
    }

    GetQzssL1SAugmentationPtr GetQzssL1SAugmentation::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SAugmentation>(ptr);
    }

    bool GetQzssL1SAugmentation::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetQzssL1SAugmentation::documentation() const { return Documentation; }


    int GetQzssL1SAugmentation::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssL1SAugmentation::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetQzssL1SAugmentation::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1SAugmentationResult
///
#include "gen/GetQzssL1SAugmentationResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SAugmentationResult::CmdName = "GetQzssL1SAugmentationResult";
    const char* const GetQzssL1SAugmentationResult::Documentation = "Result of GetQzssL1SAugmentation.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1SAugmentationResult);


    GetQzssL1SAugmentationResult::GetQzssL1SAugmentationResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1SAugmentationResult::GetQzssL1SAugmentationResult(CommandBasePtr relatedCommand, const std::string& system, int prn, bool augmentIOD, bool augmentPRC, double prc, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setAugmentIOD(augmentIOD);
      setAugmentPRC(augmentPRC);
      setPrc(prc);
      setId(id);
    }


    GetQzssL1SAugmentationResultPtr GetQzssL1SAugmentationResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, bool augmentIOD, bool augmentPRC, double prc, const std::string& id)
    {
      return std::make_shared<GetQzssL1SAugmentationResult>(relatedCommand, system, prn, augmentIOD, augmentPRC, prc, id);
    }

    GetQzssL1SAugmentationResultPtr GetQzssL1SAugmentationResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SAugmentationResult>(ptr);
    }

    bool GetQzssL1SAugmentationResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["AugmentIOD"])
          && parse_json<bool>::is_valid(m_values["AugmentPRC"])
          && parse_json<double>::is_valid(m_values["Prc"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetQzssL1SAugmentationResult::documentation() const { return Documentation; }


    std::string GetQzssL1SAugmentationResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetQzssL1SAugmentationResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssL1SAugmentationResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetQzssL1SAugmentationResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL1SAugmentationResult::augmentIOD() const
    {
      return parse_json<bool>::parse(m_values["AugmentIOD"]);
    }

    void GetQzssL1SAugmentationResult::setAugmentIOD(bool augmentIOD)
    {
      m_values.AddMember("AugmentIOD", parse_json<bool>::format(augmentIOD, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL1SAugmentationResult::augmentPRC() const
    {
      return parse_json<bool>::parse(m_values["AugmentPRC"]);
    }

    void GetQzssL1SAugmentationResult::setAugmentPRC(bool augmentPRC)
    {
      m_values.AddMember("AugmentPRC", parse_json<bool>::format(augmentPRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssL1SAugmentationResult::prc() const
    {
      return parse_json<double>::parse(m_values["Prc"]);
    }

    void GetQzssL1SAugmentationResult::setPrc(double prc)
    {
      m_values.AddMember("Prc", parse_json<double>::format(prc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssL1SAugmentationResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetQzssL1SAugmentationResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveQzssL1SAugmentation
///
#include "gen/RemoveQzssL1SAugmentation.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveQzssL1SAugmentation::CmdName = "RemoveQzssL1SAugmentation";
    const char* const RemoveQzssL1SAugmentation::Documentation = "Removes a QZSS L1S augmentation.";

    REGISTER_COMMAND_FACTORY(RemoveQzssL1SAugmentation);


    RemoveQzssL1SAugmentation::RemoveQzssL1SAugmentation()
      : CommandBase(CmdName)
    {}

    RemoveQzssL1SAugmentation::RemoveQzssL1SAugmentation(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveQzssL1SAugmentationPtr RemoveQzssL1SAugmentation::create(const std::string& id)
    {
      return std::make_shared<RemoveQzssL1SAugmentation>(id);
    }

    RemoveQzssL1SAugmentationPtr RemoveQzssL1SAugmentation::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveQzssL1SAugmentation>(ptr);
    }

    bool RemoveQzssL1SAugmentation::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveQzssL1SAugmentation::documentation() const { return Documentation; }


    int RemoveQzssL1SAugmentation::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveQzssL1SAugmentation::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveQzssL1SAugmentation::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearQzssL1SAugmentations
///
#include "gen/ClearQzssL1SAugmentations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearQzssL1SAugmentations::CmdName = "ClearQzssL1SAugmentations";
    const char* const ClearQzssL1SAugmentations::Documentation = "Clears all QZSS L1S augmentations.";

    REGISTER_COMMAND_FACTORY(ClearQzssL1SAugmentations);


    ClearQzssL1SAugmentations::ClearQzssL1SAugmentations()
      : CommandBase(CmdName)
    {

    }


    ClearQzssL1SAugmentationsPtr ClearQzssL1SAugmentations::create()
    {
      return std::make_shared<ClearQzssL1SAugmentations>();
    }

    ClearQzssL1SAugmentationsPtr ClearQzssL1SAugmentations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearQzssL1SAugmentations>(ptr);
    }

    bool ClearQzssL1SAugmentations::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearQzssL1SAugmentations::documentation() const { return Documentation; }


    int ClearQzssL1SAugmentations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetQzssL1SAugmentations
///
#include "gen/GetQzssL1SAugmentations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SAugmentations::CmdName = "GetQzssL1SAugmentations";
    const char* const GetQzssL1SAugmentations::Documentation = "Get all QZSS L1S augmentation's IDs.";

    REGISTER_COMMAND_FACTORY(GetQzssL1SAugmentations);


    GetQzssL1SAugmentations::GetQzssL1SAugmentations()
      : CommandBase(CmdName)
    {

    }


    GetQzssL1SAugmentationsPtr GetQzssL1SAugmentations::create()
    {
      return std::make_shared<GetQzssL1SAugmentations>();
    }

    GetQzssL1SAugmentationsPtr GetQzssL1SAugmentations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SAugmentations>(ptr);
    }

    bool GetQzssL1SAugmentations::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetQzssL1SAugmentations::documentation() const { return Documentation; }


    int GetQzssL1SAugmentations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetQzssL1SAugmentationsResult
///
#include "gen/GetQzssL1SAugmentationsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SAugmentationsResult::CmdName = "GetQzssL1SAugmentationsResult";
    const char* const GetQzssL1SAugmentationsResult::Documentation = "Result of GetQzssL1SAugmentations.";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1SAugmentationsResult);


    GetQzssL1SAugmentationsResult::GetQzssL1SAugmentationsResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1SAugmentationsResult::GetQzssL1SAugmentationsResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetQzssL1SAugmentationsResultPtr GetQzssL1SAugmentationsResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return std::make_shared<GetQzssL1SAugmentationsResult>(relatedCommand, ids);
    }

    GetQzssL1SAugmentationsResultPtr GetQzssL1SAugmentationsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SAugmentationsResult>(ptr);
    }

    bool GetQzssL1SAugmentationsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetQzssL1SAugmentationsResult::documentation() const { return Documentation; }


    std::vector<std::string> GetQzssL1SAugmentationsResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetQzssL1SAugmentationsResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWavefrontJamCalibrationState
///
#include "gen/SetWavefrontJamCalibrationState.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWavefrontJamCalibrationState::CmdName = "SetWavefrontJamCalibrationState";
    const char* const SetWavefrontJamCalibrationState::Documentation = "Set whether the JAM Calibration output is transmitting.";

    REGISTER_COMMAND_FACTORY(SetWavefrontJamCalibrationState);


    SetWavefrontJamCalibrationState::SetWavefrontJamCalibrationState()
      : CommandBase(CmdName)
    {}

    SetWavefrontJamCalibrationState::SetWavefrontJamCalibrationState(bool state)
      : CommandBase(CmdName)
    {

      setState(state);
    }


    SetWavefrontJamCalibrationStatePtr SetWavefrontJamCalibrationState::create(bool state)
    {
      return std::make_shared<SetWavefrontJamCalibrationState>(state);
    }

    SetWavefrontJamCalibrationStatePtr SetWavefrontJamCalibrationState::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWavefrontJamCalibrationState>(ptr);
    }

    bool SetWavefrontJamCalibrationState::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["State"])
        ;

    }

    std::string SetWavefrontJamCalibrationState::documentation() const { return Documentation; }


    int SetWavefrontJamCalibrationState::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    bool SetWavefrontJamCalibrationState::state() const
    {
      return parse_json<bool>::parse(m_values["State"]);
    }

    void SetWavefrontJamCalibrationState::setState(bool state)
    {
      m_values.AddMember("State", parse_json<bool>::format(state, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddDataSet
///
#include "gen/AddDataSet.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddDataSet::CmdName = "AddDataSet";
    const char* const AddDataSet::Documentation = "Add a new data set for the specified constellation. This could come from a Rinex, SEM or YUMA file for GPS. Only Rinex for the others.";

    REGISTER_COMMAND_FACTORY(AddDataSet);


    AddDataSet::AddDataSet()
      : CommandBase(CmdName)
    {}

    AddDataSet::AddDataSet(const std::string& system, const std::string& path, const Sdx::optional<int>& rollover, const Sdx::optional<std::string>& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPath(path);
      setRollover(rollover);
      setDataSetName(dataSetName);
    }


    AddDataSetPtr AddDataSet::create(const std::string& system, const std::string& path, const Sdx::optional<int>& rollover, const Sdx::optional<std::string>& dataSetName)
    {
      return std::make_shared<AddDataSet>(system, path, rollover, dataSetName);
    }

    AddDataSetPtr AddDataSet::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddDataSet>(ptr);
    }

    bool AddDataSet::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Rollover"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string AddDataSet::documentation() const { return Documentation; }


    int AddDataSet::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddDataSet::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void AddDataSet::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddDataSet::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void AddDataSet::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> AddDataSet::rollover() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Rollover"]);
    }

    void AddDataSet::setRollover(const Sdx::optional<int>& rollover)
    {
      m_values.AddMember("Rollover", parse_json<Sdx::optional<int>>::format(rollover, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> AddDataSet::dataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["DataSetName"]);
    }

    void AddDataSet::setDataSetName(const Sdx::optional<std::string>& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<Sdx::optional<std::string>>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetDataSetAssignation
///
#include "gen/SetDataSetAssignation.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetDataSetAssignation::CmdName = "SetDataSetAssignation";
    const char* const SetDataSetAssignation::Documentation = "Set data set assignation for the specified constellation.";

    REGISTER_COMMAND_FACTORY(SetDataSetAssignation);


    SetDataSetAssignation::SetDataSetAssignation()
      : CommandBase(CmdName)
    {}

    SetDataSetAssignation::SetDataSetAssignation(const std::string& system, const std::string& dataSetType, const std::string& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setDataSetType(dataSetType);
      setDataSetName(dataSetName);
    }


    SetDataSetAssignationPtr SetDataSetAssignation::create(const std::string& system, const std::string& dataSetType, const std::string& dataSetName)
    {
      return std::make_shared<SetDataSetAssignation>(system, dataSetType, dataSetName);
    }

    SetDataSetAssignationPtr SetDataSetAssignation::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetDataSetAssignation>(ptr);
    }

    bool SetDataSetAssignation::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["DataSetType"])
          && parse_json<std::string>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetDataSetAssignation::documentation() const { return Documentation; }


    int SetDataSetAssignation::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetDataSetAssignation::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetDataSetAssignation::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetDataSetAssignation::dataSetType() const
    {
      return parse_json<std::string>::parse(m_values["DataSetType"]);
    }

    void SetDataSetAssignation::setDataSetType(const std::string& dataSetType)
    {
      m_values.AddMember("DataSetType", parse_json<std::string>::format(dataSetType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetDataSetAssignation::dataSetName() const
    {
      return parse_json<std::string>::parse(m_values["DataSetName"]);
    }

    void SetDataSetAssignation::setDataSetName(const std::string& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<std::string>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetDataSetAssignation
///
#include "gen/GetDataSetAssignation.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDataSetAssignation::CmdName = "GetDataSetAssignation";
    const char* const GetDataSetAssignation::Documentation = "Get data set assignation for the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetDataSetAssignation);


    GetDataSetAssignation::GetDataSetAssignation()
      : CommandBase(CmdName)
    {}

    GetDataSetAssignation::GetDataSetAssignation(const std::string& system, const std::string& dataSetType)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setDataSetType(dataSetType);
    }


    GetDataSetAssignationPtr GetDataSetAssignation::create(const std::string& system, const std::string& dataSetType)
    {
      return std::make_shared<GetDataSetAssignation>(system, dataSetType);
    }

    GetDataSetAssignationPtr GetDataSetAssignation::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDataSetAssignation>(ptr);
    }

    bool GetDataSetAssignation::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["DataSetType"])
        ;

    }

    std::string GetDataSetAssignation::documentation() const { return Documentation; }


    int GetDataSetAssignation::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetDataSetAssignation::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetDataSetAssignation::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetDataSetAssignation::dataSetType() const
    {
      return parse_json<std::string>::parse(m_values["DataSetType"]);
    }

    void GetDataSetAssignation::setDataSetType(const std::string& dataSetType)
    {
      m_values.AddMember("DataSetType", parse_json<std::string>::format(dataSetType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetDataSetAssignationResult
///
#include "gen/GetDataSetAssignationResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDataSetAssignationResult::CmdName = "GetDataSetAssignationResult";
    const char* const GetDataSetAssignationResult::Documentation = "Result of GetDataSetAssignation.";

    REGISTER_COMMAND_RESULT_FACTORY(GetDataSetAssignationResult);


    GetDataSetAssignationResult::GetDataSetAssignationResult()
      : CommandResult(CmdName)
    {}

    GetDataSetAssignationResult::GetDataSetAssignationResult(CommandBasePtr relatedCommand, const std::string& system, const std::string& dataSetType, const std::string& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setDataSetType(dataSetType);
      setDataSetName(dataSetName);
    }


    GetDataSetAssignationResultPtr GetDataSetAssignationResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::string& dataSetType, const std::string& dataSetName)
    {
      return std::make_shared<GetDataSetAssignationResult>(relatedCommand, system, dataSetType, dataSetName);
    }

    GetDataSetAssignationResultPtr GetDataSetAssignationResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDataSetAssignationResult>(ptr);
    }

    bool GetDataSetAssignationResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["DataSetType"])
          && parse_json<std::string>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetDataSetAssignationResult::documentation() const { return Documentation; }


    std::string GetDataSetAssignationResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetDataSetAssignationResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetDataSetAssignationResult::dataSetType() const
    {
      return parse_json<std::string>::parse(m_values["DataSetType"]);
    }

    void GetDataSetAssignationResult::setDataSetType(const std::string& dataSetType)
    {
      m_values.AddMember("DataSetType", parse_json<std::string>::format(dataSetType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetDataSetAssignationResult::dataSetName() const
    {
      return parse_json<std::string>::parse(m_values["DataSetName"]);
    }

    void GetDataSetAssignationResult::setDataSetName(const std::string& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<std::string>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RenameDataSet
///
#include "gen/RenameDataSet.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RenameDataSet::CmdName = "RenameDataSet";
    const char* const RenameDataSet::Documentation = "Rename data set.";

    REGISTER_COMMAND_FACTORY(RenameDataSet);


    RenameDataSet::RenameDataSet()
      : CommandBase(CmdName)
    {}

    RenameDataSet::RenameDataSet(const std::string& system, const std::string& dataSetName, const std::string& newDataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setDataSetName(dataSetName);
      setNewDataSetName(newDataSetName);
    }


    RenameDataSetPtr RenameDataSet::create(const std::string& system, const std::string& dataSetName, const std::string& newDataSetName)
    {
      return std::make_shared<RenameDataSet>(system, dataSetName, newDataSetName);
    }

    RenameDataSetPtr RenameDataSet::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RenameDataSet>(ptr);
    }

    bool RenameDataSet::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["DataSetName"])
          && parse_json<std::string>::is_valid(m_values["NewDataSetName"])
        ;

    }

    std::string RenameDataSet::documentation() const { return Documentation; }


    int RenameDataSet::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RenameDataSet::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RenameDataSet::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameDataSet::dataSetName() const
    {
      return parse_json<std::string>::parse(m_values["DataSetName"]);
    }

    void RenameDataSet::setDataSetName(const std::string& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<std::string>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameDataSet::newDataSetName() const
    {
      return parse_json<std::string>::parse(m_values["NewDataSetName"]);
    }

    void RenameDataSet::setNewDataSetName(const std::string& newDataSetName)
    {
      m_values.AddMember("NewDataSetName", parse_json<std::string>::format(newDataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of DeleteDataSet
///
#include "gen/DeleteDataSet.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const DeleteDataSet::CmdName = "DeleteDataSet";
    const char* const DeleteDataSet::Documentation = "Delete data set.";

    REGISTER_COMMAND_FACTORY(DeleteDataSet);


    DeleteDataSet::DeleteDataSet()
      : CommandBase(CmdName)
    {}

    DeleteDataSet::DeleteDataSet(const std::string& system, const std::string& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setDataSetName(dataSetName);
    }


    DeleteDataSetPtr DeleteDataSet::create(const std::string& system, const std::string& dataSetName)
    {
      return std::make_shared<DeleteDataSet>(system, dataSetName);
    }

    DeleteDataSetPtr DeleteDataSet::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<DeleteDataSet>(ptr);
    }

    bool DeleteDataSet::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string DeleteDataSet::documentation() const { return Documentation; }


    int DeleteDataSet::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string DeleteDataSet::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void DeleteDataSet::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string DeleteDataSet::dataSetName() const
    {
      return parse_json<std::string>::parse(m_values["DataSetName"]);
    }

    void DeleteDataSet::setDataSetName(const std::string& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<std::string>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetActiveDataSet
///
#include "gen/SetActiveDataSet.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetActiveDataSet::CmdName = "SetActiveDataSet";
    const char* const SetActiveDataSet::Documentation = "Set active data set.";

    REGISTER_COMMAND_FACTORY(SetActiveDataSet);


    SetActiveDataSet::SetActiveDataSet()
      : CommandBase(CmdName)
    {}

    SetActiveDataSet::SetActiveDataSet(const std::string& system, const std::string& dataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setDataSetName(dataSetName);
    }


    SetActiveDataSetPtr SetActiveDataSet::create(const std::string& system, const std::string& dataSetName)
    {
      return std::make_shared<SetActiveDataSet>(system, dataSetName);
    }

    SetActiveDataSetPtr SetActiveDataSet::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetActiveDataSet>(ptr);
    }

    bool SetActiveDataSet::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string SetActiveDataSet::documentation() const { return Documentation; }


    int SetActiveDataSet::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string SetActiveDataSet::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetActiveDataSet::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetActiveDataSet::dataSetName() const
    {
      return parse_json<std::string>::parse(m_values["DataSetName"]);
    }

    void SetActiveDataSet::setDataSetName(const std::string& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<std::string>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetActiveDataSet
///
#include "gen/GetActiveDataSet.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetActiveDataSet::CmdName = "GetActiveDataSet";
    const char* const GetActiveDataSet::Documentation = "Get active data set.";

    REGISTER_COMMAND_FACTORY(GetActiveDataSet);


    GetActiveDataSet::GetActiveDataSet()
      : CommandBase(CmdName)
    {}

    GetActiveDataSet::GetActiveDataSet(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetActiveDataSetPtr GetActiveDataSet::create(const std::string& system)
    {
      return std::make_shared<GetActiveDataSet>(system);
    }

    GetActiveDataSetPtr GetActiveDataSet::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetActiveDataSet>(ptr);
    }

    bool GetActiveDataSet::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetActiveDataSet::documentation() const { return Documentation; }


    int GetActiveDataSet::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetActiveDataSet::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetActiveDataSet::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetActiveDataSetResult
///
#include "gen/GetActiveDataSetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetActiveDataSetResult::CmdName = "GetActiveDataSetResult";
    const char* const GetActiveDataSetResult::Documentation = "Result of GetActiveDataSet.";

    REGISTER_COMMAND_RESULT_FACTORY(GetActiveDataSetResult);


    GetActiveDataSetResult::GetActiveDataSetResult()
      : CommandResult(CmdName)
    {}

    GetActiveDataSetResult::GetActiveDataSetResult(CommandBasePtr relatedCommand, const std::string& system, const std::string& dataSetName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setDataSetName(dataSetName);
    }


    GetActiveDataSetResultPtr GetActiveDataSetResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::string& dataSetName)
    {
      return std::make_shared<GetActiveDataSetResult>(relatedCommand, system, dataSetName);
    }

    GetActiveDataSetResultPtr GetActiveDataSetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetActiveDataSetResult>(ptr);
    }

    bool GetActiveDataSetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["DataSetName"])
        ;

    }

    std::string GetActiveDataSetResult::documentation() const { return Documentation; }


    std::string GetActiveDataSetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetActiveDataSetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetActiveDataSetResult::dataSetName() const
    {
      return parse_json<std::string>::parse(m_values["DataSetName"]);
    }

    void GetActiveDataSetResult::setDataSetName(const std::string& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<std::string>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of DuplicateDataSet
///
#include "gen/DuplicateDataSet.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const DuplicateDataSet::CmdName = "DuplicateDataSet";
    const char* const DuplicateDataSet::Documentation = "Duplicate an existing data set.";

    REGISTER_COMMAND_FACTORY(DuplicateDataSet);


    DuplicateDataSet::DuplicateDataSet()
      : CommandBase(CmdName)
    {}

    DuplicateDataSet::DuplicateDataSet(const std::string& system, const std::string& dataSetName, const Sdx::optional<std::string>& newDataSetName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setDataSetName(dataSetName);
      setNewDataSetName(newDataSetName);
    }


    DuplicateDataSetPtr DuplicateDataSet::create(const std::string& system, const std::string& dataSetName, const Sdx::optional<std::string>& newDataSetName)
    {
      return std::make_shared<DuplicateDataSet>(system, dataSetName, newDataSetName);
    }

    DuplicateDataSetPtr DuplicateDataSet::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<DuplicateDataSet>(ptr);
    }

    bool DuplicateDataSet::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["DataSetName"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["NewDataSetName"])
        ;

    }

    std::string DuplicateDataSet::documentation() const { return Documentation; }


    int DuplicateDataSet::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string DuplicateDataSet::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void DuplicateDataSet::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string DuplicateDataSet::dataSetName() const
    {
      return parse_json<std::string>::parse(m_values["DataSetName"]);
    }

    void DuplicateDataSet::setDataSetName(const std::string& dataSetName)
    {
      m_values.AddMember("DataSetName", parse_json<std::string>::format(dataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> DuplicateDataSet::newDataSetName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["NewDataSetName"]);
    }

    void DuplicateDataSet::setNewDataSetName(const Sdx::optional<std::string>& newDataSetName)
    {
      m_values.AddMember("NewDataSetName", parse_json<Sdx::optional<std::string>>::format(newDataSetName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetElevationAzimuthForEachSV
///
#include "gen/GetElevationAzimuthForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationAzimuthForEachSV::CmdName = "GetElevationAzimuthForEachSV";
    const char* const GetElevationAzimuthForEachSV::Documentation = "Get elevation and azimuth position angles for all satellites.";

    REGISTER_COMMAND_FACTORY(GetElevationAzimuthForEachSV);


    GetElevationAzimuthForEachSV::GetElevationAzimuthForEachSV()
      : CommandBase(CmdName)
    {}

    GetElevationAzimuthForEachSV::GetElevationAzimuthForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetElevationAzimuthForEachSVPtr GetElevationAzimuthForEachSV::create(const std::string& system)
    {
      return std::make_shared<GetElevationAzimuthForEachSV>(system);
    }

    GetElevationAzimuthForEachSVPtr GetElevationAzimuthForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationAzimuthForEachSV>(ptr);
    }

    bool GetElevationAzimuthForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetElevationAzimuthForEachSV::documentation() const { return Documentation; }


    int GetElevationAzimuthForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string GetElevationAzimuthForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetElevationAzimuthForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetElevationAzimuthForEachSVResult
///
#include "gen/GetElevationAzimuthForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationAzimuthForEachSVResult::CmdName = "GetElevationAzimuthForEachSVResult";
    const char* const GetElevationAzimuthForEachSVResult::Documentation = "Result of GetElevationAzimuthForEachSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetElevationAzimuthForEachSVResult);


    GetElevationAzimuthForEachSVResult::GetElevationAzimuthForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetElevationAzimuthForEachSVResult::GetElevationAzimuthForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<Sdx::optional<Sdx::ElevationAzimuth>>& elevationAzimuths)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setElevationAzimuths(elevationAzimuths);
    }


    GetElevationAzimuthForEachSVResultPtr GetElevationAzimuthForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<Sdx::optional<Sdx::ElevationAzimuth>>& elevationAzimuths)
    {
      return std::make_shared<GetElevationAzimuthForEachSVResult>(relatedCommand, system, elevationAzimuths);
    }

    GetElevationAzimuthForEachSVResultPtr GetElevationAzimuthForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationAzimuthForEachSVResult>(ptr);
    }

    bool GetElevationAzimuthForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<Sdx::optional<Sdx::ElevationAzimuth>>>::is_valid(m_values["ElevationAzimuths"])
        ;

    }

    std::string GetElevationAzimuthForEachSVResult::documentation() const { return Documentation; }


    std::string GetElevationAzimuthForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetElevationAzimuthForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<Sdx::optional<Sdx::ElevationAzimuth>> GetElevationAzimuthForEachSVResult::elevationAzimuths() const
    {
      return parse_json<std::vector<Sdx::optional<Sdx::ElevationAzimuth>>>::parse(m_values["ElevationAzimuths"]);
    }

    void GetElevationAzimuthForEachSVResult::setElevationAzimuths(const std::vector<Sdx::optional<Sdx::ElevationAzimuth>>& elevationAzimuths)
    {
      m_values.AddMember("ElevationAzimuths", parse_json<std::vector<Sdx::optional<Sdx::ElevationAzimuth>>>::format(elevationAzimuths, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetElevationAzimuthForSV
///
#include "gen/GetElevationAzimuthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationAzimuthForSV::CmdName = "GetElevationAzimuthForSV";
    const char* const GetElevationAzimuthForSV::Documentation = "Get elevation and azimuth position angles for satellite.";

    REGISTER_COMMAND_FACTORY(GetElevationAzimuthForSV);


    GetElevationAzimuthForSV::GetElevationAzimuthForSV()
      : CommandBase(CmdName)
    {}

    GetElevationAzimuthForSV::GetElevationAzimuthForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetElevationAzimuthForSVPtr GetElevationAzimuthForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<GetElevationAzimuthForSV>(system, svId);
    }

    GetElevationAzimuthForSVPtr GetElevationAzimuthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationAzimuthForSV>(ptr);
    }

    bool GetElevationAzimuthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetElevationAzimuthForSV::documentation() const { return Documentation; }


    int GetElevationAzimuthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string GetElevationAzimuthForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetElevationAzimuthForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetElevationAzimuthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetElevationAzimuthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetElevationAzimuthForSVResult
///
#include "gen/GetElevationAzimuthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationAzimuthForSVResult::CmdName = "GetElevationAzimuthForSVResult";
    const char* const GetElevationAzimuthForSVResult::Documentation = "Result of GetElevationAzimuthForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetElevationAzimuthForSVResult);


    GetElevationAzimuthForSVResult::GetElevationAzimuthForSVResult()
      : CommandResult(CmdName)
    {}

    GetElevationAzimuthForSVResult::GetElevationAzimuthForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::optional<Sdx::ElevationAzimuth>& elevationAzimuth)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setElevationAzimuth(elevationAzimuth);
    }


    GetElevationAzimuthForSVResultPtr GetElevationAzimuthForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::optional<Sdx::ElevationAzimuth>& elevationAzimuth)
    {
      return std::make_shared<GetElevationAzimuthForSVResult>(relatedCommand, system, svId, elevationAzimuth);
    }

    GetElevationAzimuthForSVResultPtr GetElevationAzimuthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationAzimuthForSVResult>(ptr);
    }

    bool GetElevationAzimuthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::optional<Sdx::ElevationAzimuth>>::is_valid(m_values["ElevationAzimuth"])
        ;

    }

    std::string GetElevationAzimuthForSVResult::documentation() const { return Documentation; }


    std::string GetElevationAzimuthForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetElevationAzimuthForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetElevationAzimuthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetElevationAzimuthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::ElevationAzimuth> GetElevationAzimuthForSVResult::elevationAzimuth() const
    {
      return parse_json<Sdx::optional<Sdx::ElevationAzimuth>>::parse(m_values["ElevationAzimuth"]);
    }

    void GetElevationAzimuthForSVResult::setElevationAzimuth(const Sdx::optional<Sdx::ElevationAzimuth>& elevationAzimuth)
    {
      m_values.AddMember("ElevationAzimuth", parse_json<Sdx::optional<Sdx::ElevationAzimuth>>::format(elevationAzimuth, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasServiceMessageRegionGroup
///
#include "gen/SetSbasServiceMessageRegionGroup.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasServiceMessageRegionGroup::CmdName = "SetSbasServiceMessageRegionGroup";
    const char* const SetSbasServiceMessageRegionGroup::Documentation = "Set (or Modify) a SBAS service message region group.";

    REGISTER_COMMAND_FACTORY(SetSbasServiceMessageRegionGroup);


    SetSbasServiceMessageRegionGroup::SetSbasServiceMessageRegionGroup()
      : CommandBase(CmdName)
    {}

    SetSbasServiceMessageRegionGroup::SetSbasServiceMessageRegionGroup(const std::string& serviceProvider, int deltaUdrei, int priorityCode, const std::vector<Sdx::SbasServiceMessageRegion>& regions, const std::string& id)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setDeltaUdrei(deltaUdrei);
      setPriorityCode(priorityCode);
      setRegions(regions);
      setId(id);
    }


    SetSbasServiceMessageRegionGroupPtr SetSbasServiceMessageRegionGroup::create(const std::string& serviceProvider, int deltaUdrei, int priorityCode, const std::vector<Sdx::SbasServiceMessageRegion>& regions, const std::string& id)
    {
      return std::make_shared<SetSbasServiceMessageRegionGroup>(serviceProvider, deltaUdrei, priorityCode, regions, id);
    }

    SetSbasServiceMessageRegionGroupPtr SetSbasServiceMessageRegionGroup::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasServiceMessageRegionGroup>(ptr);
    }

    bool SetSbasServiceMessageRegionGroup::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["DeltaUdrei"])
          && parse_json<int>::is_valid(m_values["PriorityCode"])
          && parse_json<std::vector<Sdx::SbasServiceMessageRegion>>::is_valid(m_values["Regions"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSbasServiceMessageRegionGroup::documentation() const { return Documentation; }


    int SetSbasServiceMessageRegionGroup::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSbasServiceMessageRegionGroup::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void SetSbasServiceMessageRegionGroup::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSbasServiceMessageRegionGroup::deltaUdrei() const
    {
      return parse_json<int>::parse(m_values["DeltaUdrei"]);
    }

    void SetSbasServiceMessageRegionGroup::setDeltaUdrei(int deltaUdrei)
    {
      m_values.AddMember("DeltaUdrei", parse_json<int>::format(deltaUdrei, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSbasServiceMessageRegionGroup::priorityCode() const
    {
      return parse_json<int>::parse(m_values["PriorityCode"]);
    }

    void SetSbasServiceMessageRegionGroup::setPriorityCode(int priorityCode)
    {
      m_values.AddMember("PriorityCode", parse_json<int>::format(priorityCode, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<Sdx::SbasServiceMessageRegion> SetSbasServiceMessageRegionGroup::regions() const
    {
      return parse_json<std::vector<Sdx::SbasServiceMessageRegion>>::parse(m_values["Regions"]);
    }

    void SetSbasServiceMessageRegionGroup::setRegions(const std::vector<Sdx::SbasServiceMessageRegion>& regions)
    {
      m_values.AddMember("Regions", parse_json<std::vector<Sdx::SbasServiceMessageRegion>>::format(regions, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSbasServiceMessageRegionGroup::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSbasServiceMessageRegionGroup::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasServiceMessageRegionGroup
///
#include "gen/GetSbasServiceMessageRegionGroup.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasServiceMessageRegionGroup::CmdName = "GetSbasServiceMessageRegionGroup";
    const char* const GetSbasServiceMessageRegionGroup::Documentation = "Get infos about the SBAS service message region group at this index.";

    REGISTER_COMMAND_FACTORY(GetSbasServiceMessageRegionGroup);


    GetSbasServiceMessageRegionGroup::GetSbasServiceMessageRegionGroup()
      : CommandBase(CmdName)
    {}

    GetSbasServiceMessageRegionGroup::GetSbasServiceMessageRegionGroup(const std::string& serviceProvider, const std::string& id)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setId(id);
    }


    GetSbasServiceMessageRegionGroupPtr GetSbasServiceMessageRegionGroup::create(const std::string& serviceProvider, const std::string& id)
    {
      return std::make_shared<GetSbasServiceMessageRegionGroup>(serviceProvider, id);
    }

    GetSbasServiceMessageRegionGroupPtr GetSbasServiceMessageRegionGroup::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasServiceMessageRegionGroup>(ptr);
    }

    bool GetSbasServiceMessageRegionGroup::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSbasServiceMessageRegionGroup::documentation() const { return Documentation; }


    int GetSbasServiceMessageRegionGroup::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSbasServiceMessageRegionGroup::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetSbasServiceMessageRegionGroup::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSbasServiceMessageRegionGroup::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSbasServiceMessageRegionGroup::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasServiceMessageRegionGroupResult
///
#include "gen/GetSbasServiceMessageRegionGroupResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasServiceMessageRegionGroupResult::CmdName = "GetSbasServiceMessageRegionGroupResult";
    const char* const GetSbasServiceMessageRegionGroupResult::Documentation = "Result of GetSbasServiceMessageRegionGroup.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasServiceMessageRegionGroupResult);


    GetSbasServiceMessageRegionGroupResult::GetSbasServiceMessageRegionGroupResult()
      : CommandResult(CmdName)
    {}

    GetSbasServiceMessageRegionGroupResult::GetSbasServiceMessageRegionGroupResult(CommandBasePtr relatedCommand, const std::string& serviceProvider, int deltaUdrei, int priorityCode, const std::vector<Sdx::SbasServiceMessageRegion>& regions, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setServiceProvider(serviceProvider);
      setDeltaUdrei(deltaUdrei);
      setPriorityCode(priorityCode);
      setRegions(regions);
      setId(id);
    }


    GetSbasServiceMessageRegionGroupResultPtr GetSbasServiceMessageRegionGroupResult::create(CommandBasePtr relatedCommand, const std::string& serviceProvider, int deltaUdrei, int priorityCode, const std::vector<Sdx::SbasServiceMessageRegion>& regions, const std::string& id)
    {
      return std::make_shared<GetSbasServiceMessageRegionGroupResult>(relatedCommand, serviceProvider, deltaUdrei, priorityCode, regions, id);
    }

    GetSbasServiceMessageRegionGroupResultPtr GetSbasServiceMessageRegionGroupResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasServiceMessageRegionGroupResult>(ptr);
    }

    bool GetSbasServiceMessageRegionGroupResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["DeltaUdrei"])
          && parse_json<int>::is_valid(m_values["PriorityCode"])
          && parse_json<std::vector<Sdx::SbasServiceMessageRegion>>::is_valid(m_values["Regions"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSbasServiceMessageRegionGroupResult::documentation() const { return Documentation; }


    std::string GetSbasServiceMessageRegionGroupResult::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetSbasServiceMessageRegionGroupResult::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSbasServiceMessageRegionGroupResult::deltaUdrei() const
    {
      return parse_json<int>::parse(m_values["DeltaUdrei"]);
    }

    void GetSbasServiceMessageRegionGroupResult::setDeltaUdrei(int deltaUdrei)
    {
      m_values.AddMember("DeltaUdrei", parse_json<int>::format(deltaUdrei, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSbasServiceMessageRegionGroupResult::priorityCode() const
    {
      return parse_json<int>::parse(m_values["PriorityCode"]);
    }

    void GetSbasServiceMessageRegionGroupResult::setPriorityCode(int priorityCode)
    {
      m_values.AddMember("PriorityCode", parse_json<int>::format(priorityCode, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<Sdx::SbasServiceMessageRegion> GetSbasServiceMessageRegionGroupResult::regions() const
    {
      return parse_json<std::vector<Sdx::SbasServiceMessageRegion>>::parse(m_values["Regions"]);
    }

    void GetSbasServiceMessageRegionGroupResult::setRegions(const std::vector<Sdx::SbasServiceMessageRegion>& regions)
    {
      m_values.AddMember("Regions", parse_json<std::vector<Sdx::SbasServiceMessageRegion>>::format(regions, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSbasServiceMessageRegionGroupResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSbasServiceMessageRegionGroupResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasDeltaUdreiOutsideOfRegions
///
#include "gen/SetSbasDeltaUdreiOutsideOfRegions.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasDeltaUdreiOutsideOfRegions::CmdName = "SetSbasDeltaUdreiOutsideOfRegions";
    const char* const SetSbasDeltaUdreiOutsideOfRegions::Documentation = "Set SBAS delta UDREI outside all the defined regions for this service provider.";

    REGISTER_COMMAND_FACTORY(SetSbasDeltaUdreiOutsideOfRegions);


    SetSbasDeltaUdreiOutsideOfRegions::SetSbasDeltaUdreiOutsideOfRegions()
      : CommandBase(CmdName)
    {}

    SetSbasDeltaUdreiOutsideOfRegions::SetSbasDeltaUdreiOutsideOfRegions(const std::string& serviceProvider, int deltaUdrei)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setDeltaUdrei(deltaUdrei);
    }


    SetSbasDeltaUdreiOutsideOfRegionsPtr SetSbasDeltaUdreiOutsideOfRegions::create(const std::string& serviceProvider, int deltaUdrei)
    {
      return std::make_shared<SetSbasDeltaUdreiOutsideOfRegions>(serviceProvider, deltaUdrei);
    }

    SetSbasDeltaUdreiOutsideOfRegionsPtr SetSbasDeltaUdreiOutsideOfRegions::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasDeltaUdreiOutsideOfRegions>(ptr);
    }

    bool SetSbasDeltaUdreiOutsideOfRegions::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["DeltaUdrei"])
        ;

    }

    std::string SetSbasDeltaUdreiOutsideOfRegions::documentation() const { return Documentation; }


    int SetSbasDeltaUdreiOutsideOfRegions::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSbasDeltaUdreiOutsideOfRegions::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void SetSbasDeltaUdreiOutsideOfRegions::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSbasDeltaUdreiOutsideOfRegions::deltaUdrei() const
    {
      return parse_json<int>::parse(m_values["DeltaUdrei"]);
    }

    void SetSbasDeltaUdreiOutsideOfRegions::setDeltaUdrei(int deltaUdrei)
    {
      m_values.AddMember("DeltaUdrei", parse_json<int>::format(deltaUdrei, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasDeltaUdreiOutsideOfRegions
///
#include "gen/GetSbasDeltaUdreiOutsideOfRegions.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasDeltaUdreiOutsideOfRegions::CmdName = "GetSbasDeltaUdreiOutsideOfRegions";
    const char* const GetSbasDeltaUdreiOutsideOfRegions::Documentation = "Get SBAS delta UDREI outside all the defined regions for this service provider.";

    REGISTER_COMMAND_FACTORY(GetSbasDeltaUdreiOutsideOfRegions);


    GetSbasDeltaUdreiOutsideOfRegions::GetSbasDeltaUdreiOutsideOfRegions()
      : CommandBase(CmdName)
    {}

    GetSbasDeltaUdreiOutsideOfRegions::GetSbasDeltaUdreiOutsideOfRegions(const std::string& serviceProvider)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
    }


    GetSbasDeltaUdreiOutsideOfRegionsPtr GetSbasDeltaUdreiOutsideOfRegions::create(const std::string& serviceProvider)
    {
      return std::make_shared<GetSbasDeltaUdreiOutsideOfRegions>(serviceProvider);
    }

    GetSbasDeltaUdreiOutsideOfRegionsPtr GetSbasDeltaUdreiOutsideOfRegions::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasDeltaUdreiOutsideOfRegions>(ptr);
    }

    bool GetSbasDeltaUdreiOutsideOfRegions::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetSbasDeltaUdreiOutsideOfRegions::documentation() const { return Documentation; }


    int GetSbasDeltaUdreiOutsideOfRegions::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSbasDeltaUdreiOutsideOfRegions::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetSbasDeltaUdreiOutsideOfRegions::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasDeltaUdreiOutsideOfRegionsResult
///
#include "gen/GetSbasDeltaUdreiOutsideOfRegionsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasDeltaUdreiOutsideOfRegionsResult::CmdName = "GetSbasDeltaUdreiOutsideOfRegionsResult";
    const char* const GetSbasDeltaUdreiOutsideOfRegionsResult::Documentation = "Result of GetSbasDeltaUdreiOutsideOfRegions.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasDeltaUdreiOutsideOfRegionsResult);


    GetSbasDeltaUdreiOutsideOfRegionsResult::GetSbasDeltaUdreiOutsideOfRegionsResult()
      : CommandResult(CmdName)
    {}

    GetSbasDeltaUdreiOutsideOfRegionsResult::GetSbasDeltaUdreiOutsideOfRegionsResult(CommandBasePtr relatedCommand, const std::string& serviceProvider, int deltaUdrei)
      : CommandResult(CmdName, relatedCommand)
    {

      setServiceProvider(serviceProvider);
      setDeltaUdrei(deltaUdrei);
    }


    GetSbasDeltaUdreiOutsideOfRegionsResultPtr GetSbasDeltaUdreiOutsideOfRegionsResult::create(CommandBasePtr relatedCommand, const std::string& serviceProvider, int deltaUdrei)
    {
      return std::make_shared<GetSbasDeltaUdreiOutsideOfRegionsResult>(relatedCommand, serviceProvider, deltaUdrei);
    }

    GetSbasDeltaUdreiOutsideOfRegionsResultPtr GetSbasDeltaUdreiOutsideOfRegionsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasDeltaUdreiOutsideOfRegionsResult>(ptr);
    }

    bool GetSbasDeltaUdreiOutsideOfRegionsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["DeltaUdrei"])
        ;

    }

    std::string GetSbasDeltaUdreiOutsideOfRegionsResult::documentation() const { return Documentation; }


    std::string GetSbasDeltaUdreiOutsideOfRegionsResult::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetSbasDeltaUdreiOutsideOfRegionsResult::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSbasDeltaUdreiOutsideOfRegionsResult::deltaUdrei() const
    {
      return parse_json<int>::parse(m_values["DeltaUdrei"]);
    }

    void GetSbasDeltaUdreiOutsideOfRegionsResult::setDeltaUdrei(int deltaUdrei)
    {
      m_values.AddMember("DeltaUdrei", parse_json<int>::format(deltaUdrei, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveSbasServiceMessageRegionGroup
///
#include "gen/RemoveSbasServiceMessageRegionGroup.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveSbasServiceMessageRegionGroup::CmdName = "RemoveSbasServiceMessageRegionGroup";
    const char* const RemoveSbasServiceMessageRegionGroup::Documentation = "Removes a SBAS service message region group for the service provider.";

    REGISTER_COMMAND_FACTORY(RemoveSbasServiceMessageRegionGroup);


    RemoveSbasServiceMessageRegionGroup::RemoveSbasServiceMessageRegionGroup()
      : CommandBase(CmdName)
    {}

    RemoveSbasServiceMessageRegionGroup::RemoveSbasServiceMessageRegionGroup(const std::string& serviceProvider, const std::string& id)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setId(id);
    }


    RemoveSbasServiceMessageRegionGroupPtr RemoveSbasServiceMessageRegionGroup::create(const std::string& serviceProvider, const std::string& id)
    {
      return std::make_shared<RemoveSbasServiceMessageRegionGroup>(serviceProvider, id);
    }

    RemoveSbasServiceMessageRegionGroupPtr RemoveSbasServiceMessageRegionGroup::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveSbasServiceMessageRegionGroup>(ptr);
    }

    bool RemoveSbasServiceMessageRegionGroup::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveSbasServiceMessageRegionGroup::documentation() const { return Documentation; }


    int RemoveSbasServiceMessageRegionGroup::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveSbasServiceMessageRegionGroup::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void RemoveSbasServiceMessageRegionGroup::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveSbasServiceMessageRegionGroup::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveSbasServiceMessageRegionGroup::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllSbasServiceMessageRegionGroup
///
#include "gen/ClearAllSbasServiceMessageRegionGroup.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllSbasServiceMessageRegionGroup::CmdName = "ClearAllSbasServiceMessageRegionGroup";
    const char* const ClearAllSbasServiceMessageRegionGroup::Documentation = "Clears all SBAS service message region group for this service provider.";

    REGISTER_COMMAND_FACTORY(ClearAllSbasServiceMessageRegionGroup);


    ClearAllSbasServiceMessageRegionGroup::ClearAllSbasServiceMessageRegionGroup()
      : CommandBase(CmdName)
    {}

    ClearAllSbasServiceMessageRegionGroup::ClearAllSbasServiceMessageRegionGroup(const std::string& serviceProvider)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
    }


    ClearAllSbasServiceMessageRegionGroupPtr ClearAllSbasServiceMessageRegionGroup::create(const std::string& serviceProvider)
    {
      return std::make_shared<ClearAllSbasServiceMessageRegionGroup>(serviceProvider);
    }

    ClearAllSbasServiceMessageRegionGroupPtr ClearAllSbasServiceMessageRegionGroup::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllSbasServiceMessageRegionGroup>(ptr);
    }

    bool ClearAllSbasServiceMessageRegionGroup::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string ClearAllSbasServiceMessageRegionGroup::documentation() const { return Documentation; }


    int ClearAllSbasServiceMessageRegionGroup::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ClearAllSbasServiceMessageRegionGroup::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void ClearAllSbasServiceMessageRegionGroup::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SwapSbasServiceMessageRegionGroup
///
#include "gen/SwapSbasServiceMessageRegionGroup.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SwapSbasServiceMessageRegionGroup::CmdName = "SwapSbasServiceMessageRegionGroup";
    const char* const SwapSbasServiceMessageRegionGroup::Documentation = "Swaps 2 SBAS service message region group.";

    REGISTER_COMMAND_FACTORY(SwapSbasServiceMessageRegionGroup);


    SwapSbasServiceMessageRegionGroup::SwapSbasServiceMessageRegionGroup()
      : CommandBase(CmdName)
    {}

    SwapSbasServiceMessageRegionGroup::SwapSbasServiceMessageRegionGroup(const std::string& serviceProvider, const std::string& firstId, const std::string& secondId)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setFirstId(firstId);
      setSecondId(secondId);
    }


    SwapSbasServiceMessageRegionGroupPtr SwapSbasServiceMessageRegionGroup::create(const std::string& serviceProvider, const std::string& firstId, const std::string& secondId)
    {
      return std::make_shared<SwapSbasServiceMessageRegionGroup>(serviceProvider, firstId, secondId);
    }

    SwapSbasServiceMessageRegionGroupPtr SwapSbasServiceMessageRegionGroup::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SwapSbasServiceMessageRegionGroup>(ptr);
    }

    bool SwapSbasServiceMessageRegionGroup::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<std::string>::is_valid(m_values["FirstId"])
          && parse_json<std::string>::is_valid(m_values["SecondId"])
        ;

    }

    std::string SwapSbasServiceMessageRegionGroup::documentation() const { return Documentation; }


    int SwapSbasServiceMessageRegionGroup::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SwapSbasServiceMessageRegionGroup::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void SwapSbasServiceMessageRegionGroup::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SwapSbasServiceMessageRegionGroup::firstId() const
    {
      return parse_json<std::string>::parse(m_values["FirstId"]);
    }

    void SwapSbasServiceMessageRegionGroup::setFirstId(const std::string& firstId)
    {
      m_values.AddMember("FirstId", parse_json<std::string>::format(firstId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SwapSbasServiceMessageRegionGroup::secondId() const
    {
      return parse_json<std::string>::parse(m_values["SecondId"]);
    }

    void SwapSbasServiceMessageRegionGroup::setSecondId(const std::string& secondId)
    {
      m_values.AddMember("SecondId", parse_json<std::string>::format(secondId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetComputerSystemTimeSinceEpochAtPps0
///
#include "gen/GetComputerSystemTimeSinceEpochAtPps0.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetComputerSystemTimeSinceEpochAtPps0::CmdName = "GetComputerSystemTimeSinceEpochAtPps0";
    const char* const GetComputerSystemTimeSinceEpochAtPps0::Documentation = "Get  the computer system time since epoch at PPS0, for the computer running this Skydel instance.\nUse this command after StartPPS.";

    REGISTER_COMMAND_FACTORY(GetComputerSystemTimeSinceEpochAtPps0);


    GetComputerSystemTimeSinceEpochAtPps0::GetComputerSystemTimeSinceEpochAtPps0()
      : CommandBase(CmdName)
    {

    }


    GetComputerSystemTimeSinceEpochAtPps0Ptr GetComputerSystemTimeSinceEpochAtPps0::create()
    {
      return std::make_shared<GetComputerSystemTimeSinceEpochAtPps0>();
    }

    GetComputerSystemTimeSinceEpochAtPps0Ptr GetComputerSystemTimeSinceEpochAtPps0::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetComputerSystemTimeSinceEpochAtPps0>(ptr);
    }

    bool GetComputerSystemTimeSinceEpochAtPps0::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetComputerSystemTimeSinceEpochAtPps0::documentation() const { return Documentation; }


    int GetComputerSystemTimeSinceEpochAtPps0::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetComputerSystemTimeSinceEpochAtPps0Result
///
#include "gen/GetComputerSystemTimeSinceEpochAtPps0Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetComputerSystemTimeSinceEpochAtPps0Result::CmdName = "GetComputerSystemTimeSinceEpochAtPps0Result";
    const char* const GetComputerSystemTimeSinceEpochAtPps0Result::Documentation = "Result of GetComputerSystemTimeSinceEpochAtPps0.";

    REGISTER_COMMAND_RESULT_FACTORY(GetComputerSystemTimeSinceEpochAtPps0Result);


    GetComputerSystemTimeSinceEpochAtPps0Result::GetComputerSystemTimeSinceEpochAtPps0Result()
      : CommandResult(CmdName)
    {}

    GetComputerSystemTimeSinceEpochAtPps0Result::GetComputerSystemTimeSinceEpochAtPps0Result(CommandBasePtr relatedCommand, double milliseconds)
      : CommandResult(CmdName, relatedCommand)
    {

      setMilliseconds(milliseconds);
    }


    GetComputerSystemTimeSinceEpochAtPps0ResultPtr GetComputerSystemTimeSinceEpochAtPps0Result::create(CommandBasePtr relatedCommand, double milliseconds)
    {
      return std::make_shared<GetComputerSystemTimeSinceEpochAtPps0Result>(relatedCommand, milliseconds);
    }

    GetComputerSystemTimeSinceEpochAtPps0ResultPtr GetComputerSystemTimeSinceEpochAtPps0Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetComputerSystemTimeSinceEpochAtPps0Result>(ptr);
    }

    bool GetComputerSystemTimeSinceEpochAtPps0Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Milliseconds"])
        ;

    }

    std::string GetComputerSystemTimeSinceEpochAtPps0Result::documentation() const { return Documentation; }


    double GetComputerSystemTimeSinceEpochAtPps0Result::milliseconds() const
    {
      return parse_json<double>::parse(m_values["Milliseconds"]);
    }

    void GetComputerSystemTimeSinceEpochAtPps0Result::setMilliseconds(double milliseconds)
    {
      m_values.AddMember("Milliseconds", parse_json<double>::format(milliseconds, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetHilWarning
///
#include "gen/ResetHilWarning.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetHilWarning::CmdName = "ResetHilWarning";
    const char* const ResetHilWarning::Documentation = "Please note the command ResetHilWarning is deprecated since 22.5. You may use GetHilExtrapolationState.\n\nReset Hardware in the loop trajectory server warning message.";

    REGISTER_COMMAND_FACTORY(ResetHilWarning);


    ResetHilWarning::ResetHilWarning()
      : CommandBase(CmdName)
    {

    }


    ResetHilWarningPtr ResetHilWarning::create()
    {
      return std::make_shared<ResetHilWarning>();
    }

    ResetHilWarningPtr ResetHilWarning::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetHilWarning>(ptr);
    }

    bool ResetHilWarning::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ResetHilWarning::documentation() const { return Documentation; }


    int ResetHilWarning::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetLastHilWarning
///
#include "gen/GetLastHilWarning.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLastHilWarning::CmdName = "GetLastHilWarning";
    const char* const GetLastHilWarning::Documentation = "Please note the command GetLastHilWarning is deprecated since 22.5. You may use GetHilExtrapolationState.\n\nGet last Hardware in the loop trajectory server warning message. Returns HilWarningResult.";

    REGISTER_COMMAND_FACTORY(GetLastHilWarning);


    GetLastHilWarning::GetLastHilWarning()
      : CommandBase(CmdName)
    {

    }


    GetLastHilWarningPtr GetLastHilWarning::create()
    {
      return std::make_shared<GetLastHilWarning>();
    }

    GetLastHilWarningPtr GetLastHilWarning::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLastHilWarning>(ptr);
    }

    bool GetLastHilWarning::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLastHilWarning::documentation() const { return Documentation; }


    int GetLastHilWarning::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of HilWarningResult
///
#include "gen/HilWarningResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const HilWarningResult::CmdName = "HilWarningResult";
    const char* const HilWarningResult::Documentation = "Result of GetLastHilWarning.";

    REGISTER_COMMAND_RESULT_FACTORY(HilWarningResult);


    HilWarningResult::HilWarningResult()
      : CommandResult(CmdName)
    {}

    HilWarningResult::HilWarningResult(CommandBasePtr relatedCommand, bool isExtrapolated, int extrapolationTime)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsExtrapolated(isExtrapolated);
      setExtrapolationTime(extrapolationTime);
    }


    HilWarningResultPtr HilWarningResult::create(CommandBasePtr relatedCommand, bool isExtrapolated, int extrapolationTime)
    {
      return std::make_shared<HilWarningResult>(relatedCommand, isExtrapolated, extrapolationTime);
    }

    HilWarningResultPtr HilWarningResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<HilWarningResult>(ptr);
    }

    bool HilWarningResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsExtrapolated"])
          && parse_json<int>::is_valid(m_values["ExtrapolationTime"])
        ;

    }

    std::string HilWarningResult::documentation() const { return Documentation; }


    bool HilWarningResult::isExtrapolated() const
    {
      return parse_json<bool>::parse(m_values["IsExtrapolated"]);
    }

    void HilWarningResult::setIsExtrapolated(bool isExtrapolated)
    {
      m_values.AddMember("IsExtrapolated", parse_json<bool>::format(isExtrapolated, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int HilWarningResult::extrapolationTime() const
    {
      return parse_json<int>::parse(m_values["ExtrapolationTime"]);
    }

    void HilWarningResult::setExtrapolationTime(int extrapolationTime)
    {
      m_values.AddMember("ExtrapolationTime", parse_json<int>::format(extrapolationTime, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasUdrei
///
#include "gen/SetSbasUdrei.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasUdrei::CmdName = "SetSbasUdrei";
    const char* const SetSbasUdrei::Documentation = "Please note the command SetSbasUdrei is deprecated since 22.2. You may use SetUdreiForSV.\n\nSet the global UDREI value transmitted by SBAS";

    REGISTER_COMMAND_FACTORY(SetSbasUdrei);


    SetSbasUdrei::SetSbasUdrei()
      : CommandBase(CmdName)
    {}

    SetSbasUdrei::SetSbasUdrei(int udrei)
      : CommandBase(CmdName)
    {

      setUdrei(udrei);
    }


    SetSbasUdreiPtr SetSbasUdrei::create(int udrei)
    {
      return std::make_shared<SetSbasUdrei>(udrei);
    }

    SetSbasUdreiPtr SetSbasUdrei::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasUdrei>(ptr);
    }

    bool SetSbasUdrei::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Udrei"])
        ;

    }

    std::string SetSbasUdrei::documentation() const { return Documentation; }


    int SetSbasUdrei::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetSbasUdrei::udrei() const
    {
      return parse_json<int>::parse(m_values["Udrei"]);
    }

    void SetSbasUdrei::setUdrei(int udrei)
    {
      m_values.AddMember("Udrei", parse_json<int>::format(udrei, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasUdrei
///
#include "gen/GetSbasUdrei.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasUdrei::CmdName = "GetSbasUdrei";
    const char* const GetSbasUdrei::Documentation = "Please note the command GetSbasUdrei is deprecated since 22.2. You may use GetUdreiForSV.\n\nGet the global UDREI value transmitted by SBAS";

    REGISTER_COMMAND_FACTORY(GetSbasUdrei);


    GetSbasUdrei::GetSbasUdrei()
      : CommandBase(CmdName)
    {

    }


    GetSbasUdreiPtr GetSbasUdrei::create()
    {
      return std::make_shared<GetSbasUdrei>();
    }

    GetSbasUdreiPtr GetSbasUdrei::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasUdrei>(ptr);
    }

    bool GetSbasUdrei::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSbasUdrei::documentation() const { return Documentation; }


    int GetSbasUdrei::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetSbasUdreiResult
///
#include "gen/GetSbasUdreiResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasUdreiResult::CmdName = "GetSbasUdreiResult";
    const char* const GetSbasUdreiResult::Documentation = "Result of GetSbasUdrei.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasUdreiResult);


    GetSbasUdreiResult::GetSbasUdreiResult()
      : CommandResult(CmdName)
    {}

    GetSbasUdreiResult::GetSbasUdreiResult(CommandBasePtr relatedCommand, int udrei)
      : CommandResult(CmdName, relatedCommand)
    {

      setUdrei(udrei);
    }


    GetSbasUdreiResultPtr GetSbasUdreiResult::create(CommandBasePtr relatedCommand, int udrei)
    {
      return std::make_shared<GetSbasUdreiResult>(relatedCommand, udrei);
    }

    GetSbasUdreiResultPtr GetSbasUdreiResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasUdreiResult>(ptr);
    }

    bool GetSbasUdreiResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Udrei"])
        ;

    }

    std::string GetSbasUdreiResult::documentation() const { return Documentation; }


    int GetSbasUdreiResult::udrei() const
    {
      return parse_json<int>::parse(m_values["Udrei"]);
    }

    void GetSbasUdreiResult::setUdrei(int udrei)
    {
      m_values.AddMember("Udrei", parse_json<int>::format(udrei, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPowerForSV
///
#include "gen/SetPowerForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPowerForSV::CmdName = "SetPowerForSV";
    const char* const SetPowerForSV::Documentation = "Please note the command SetPowerForSV is deprecated since 22.7. You may use SetManualPowerOffsetForSV.\n\nSet power offset for specified satellite SV ID. Use SV ID 0 to set power for all satellites.";

    REGISTER_COMMAND_FACTORY(SetPowerForSV);


    SetPowerForSV::SetPowerForSV()
      : CommandBase(CmdName)
    {}

    SetPowerForSV::SetPowerForSV(const std::string& system, int svId, double powerOffset, bool otherSatsFollow)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setPowerOffset(powerOffset);
      setOtherSatsFollow(otherSatsFollow);
    }


    SetPowerForSVPtr SetPowerForSV::create(const std::string& system, int svId, double powerOffset, bool otherSatsFollow)
    {
      return std::make_shared<SetPowerForSV>(system, svId, powerOffset, otherSatsFollow);
    }

    SetPowerForSVPtr SetPowerForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPowerForSV>(ptr);
    }

    bool SetPowerForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["PowerOffset"])
          && parse_json<bool>::is_valid(m_values["OtherSatsFollow"])
        ;

    }

    std::string SetPowerForSV::documentation() const { return Documentation; }


    int SetPowerForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string SetPowerForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPowerForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPowerForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPowerForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPowerForSV::powerOffset() const
    {
      return parse_json<double>::parse(m_values["PowerOffset"]);
    }

    void SetPowerForSV::setPowerOffset(double powerOffset)
    {
      m_values.AddMember("PowerOffset", parse_json<double>::format(powerOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPowerForSV::otherSatsFollow() const
    {
      return parse_json<bool>::parse(m_values["OtherSatsFollow"]);
    }

    void SetPowerForSV::setOtherSatsFollow(bool otherSatsFollow)
    {
      m_values.AddMember("OtherSatsFollow", parse_json<bool>::format(otherSatsFollow, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerForSV
///
#include "gen/GetPowerForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerForSV::CmdName = "GetPowerForSV";
    const char* const GetPowerForSV::Documentation = "Please note the command GetPowerForSV is deprecated since 22.7. You may use GetAllPowerForSV.\n\nGet the power offset for specified satellite SV ID.";

    REGISTER_COMMAND_FACTORY(GetPowerForSV);


    GetPowerForSV::GetPowerForSV()
      : CommandBase(CmdName)
    {}

    GetPowerForSV::GetPowerForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetPowerForSVPtr GetPowerForSV::create(const std::string& system, int svId)
    {
      return std::make_shared<GetPowerForSV>(system, svId);
    }

    GetPowerForSVPtr GetPowerForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerForSV>(ptr);
    }

    bool GetPowerForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetPowerForSV::documentation() const { return Documentation; }


    int GetPowerForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string GetPowerForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPowerForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPowerForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPowerForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerForSVResult
///
#include "gen/GetPowerForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerForSVResult::CmdName = "GetPowerForSVResult";
    const char* const GetPowerForSVResult::Documentation = "Result of GetPowerForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPowerForSVResult);


    GetPowerForSVResult::GetPowerForSVResult()
      : CommandResult(CmdName)
    {}

    GetPowerForSVResult::GetPowerForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, double nominalPower, double signalStrengthModel, double antenna, double signalLevelOffset, double manualGain, double total)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setNominalPower(nominalPower);
      setSignalStrengthModel(signalStrengthModel);
      setAntenna(antenna);
      setSignalLevelOffset(signalLevelOffset);
      setManualGain(manualGain);
      setTotal(total);
    }


    GetPowerForSVResultPtr GetPowerForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, double nominalPower, double signalStrengthModel, double antenna, double signalLevelOffset, double manualGain, double total)
    {
      return std::make_shared<GetPowerForSVResult>(relatedCommand, system, svId, nominalPower, signalStrengthModel, antenna, signalLevelOffset, manualGain, total);
    }

    GetPowerForSVResultPtr GetPowerForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerForSVResult>(ptr);
    }

    bool GetPowerForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["NominalPower"])
          && parse_json<double>::is_valid(m_values["SignalStrengthModel"])
          && parse_json<double>::is_valid(m_values["Antenna"])
          && parse_json<double>::is_valid(m_values["SignalLevelOffset"])
          && parse_json<double>::is_valid(m_values["ManualGain"])
          && parse_json<double>::is_valid(m_values["Total"])
        ;

    }

    std::string GetPowerForSVResult::documentation() const { return Documentation; }


    std::string GetPowerForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPowerForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPowerForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPowerForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::nominalPower() const
    {
      return parse_json<double>::parse(m_values["NominalPower"]);
    }

    void GetPowerForSVResult::setNominalPower(double nominalPower)
    {
      m_values.AddMember("NominalPower", parse_json<double>::format(nominalPower, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::signalStrengthModel() const
    {
      return parse_json<double>::parse(m_values["SignalStrengthModel"]);
    }

    void GetPowerForSVResult::setSignalStrengthModel(double signalStrengthModel)
    {
      m_values.AddMember("SignalStrengthModel", parse_json<double>::format(signalStrengthModel, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::antenna() const
    {
      return parse_json<double>::parse(m_values["Antenna"]);
    }

    void GetPowerForSVResult::setAntenna(double antenna)
    {
      m_values.AddMember("Antenna", parse_json<double>::format(antenna, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::signalLevelOffset() const
    {
      return parse_json<double>::parse(m_values["SignalLevelOffset"]);
    }

    void GetPowerForSVResult::setSignalLevelOffset(double signalLevelOffset)
    {
      m_values.AddMember("SignalLevelOffset", parse_json<double>::format(signalLevelOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::manualGain() const
    {
      return parse_json<double>::parse(m_values["ManualGain"]);
    }

    void GetPowerForSVResult::setManualGain(double manualGain)
    {
      m_values.AddMember("ManualGain", parse_json<double>::format(manualGain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::total() const
    {
      return parse_json<double>::parse(m_values["Total"]);
    }

    void GetPowerForSVResult::setTotal(double total)
    {
      m_values.AddMember("Total", parse_json<double>::format(total, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}

