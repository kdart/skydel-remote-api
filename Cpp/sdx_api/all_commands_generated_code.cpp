#include "command_factory.h"
#include "command_result_factory.h"
#include "parse_json.hpp"

///
/// Definition of SuccessResult
///
#include "gen/SuccessResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SuccessResult::CmdName = "SuccessResult";
    const char* const SuccessResult::Documentation = "When command succeed.";

    REGISTER_COMMAND_RESULT_FACTORY(SuccessResult);


    SuccessResult::SuccessResult()
      : CommandResult(CmdName)
    {}

    SuccessResult::SuccessResult(CommandBasePtr relatedCommand)
      : CommandResult(CmdName, relatedCommand)
    {

    }


    SuccessResultPtr SuccessResult::create(CommandBasePtr relatedCommand)
    {
      return SuccessResultPtr(new SuccessResult(relatedCommand));
    }

    SuccessResultPtr SuccessResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SuccessResult>(ptr);
    }

    bool SuccessResult::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string SuccessResult::documentation() const { return Documentation; }

  }
}


///
/// Definition of FailureResult
///
#include "gen/FailureResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const FailureResult::CmdName = "FailureResult";
    const char* const FailureResult::Documentation = "When command failed";

    REGISTER_COMMAND_RESULT_FACTORY(FailureResult);


    FailureResult::FailureResult()
      : CommandResult(CmdName)
    {}

    FailureResult::FailureResult(CommandBasePtr relatedCommand, const std::string& errorMsg)
      : CommandResult(CmdName, relatedCommand)
    {

      setErrorMsg(errorMsg);
    }


    FailureResultPtr FailureResult::create(CommandBasePtr relatedCommand, const std::string& errorMsg)
    {
      return FailureResultPtr(new FailureResult(relatedCommand, errorMsg));
    }

    FailureResultPtr FailureResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<FailureResult>(ptr);
    }

    bool FailureResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ErrorMsg"])
        ;

    }

    std::string FailureResult::documentation() const { return Documentation; }


    std::string FailureResult::errorMsg() const
    {
      return parse_json<std::string>::parse(m_values["ErrorMsg"]);
    }

    void FailureResult::setErrorMsg(const std::string& errorMsg)
    {
      m_values.AddMember("ErrorMsg", parse_json<std::string>::format(errorMsg, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of UndoCmd
///
#include "gen/UndoCmd.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const UndoCmd::CmdName = "UndoCmd";
    const char* const UndoCmd::Documentation = "Undo the last command like Ctrl+Z in the UI";

    REGISTER_COMMAND_FACTORY(UndoCmd);


    UndoCmd::UndoCmd()
      : CommandBase(CmdName)
    {

    }


    UndoCmdPtr UndoCmd::create()
    {
      return UndoCmdPtr(new UndoCmd());
    }

    UndoCmdPtr UndoCmd::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<UndoCmd>(ptr);
    }

    bool UndoCmd::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string UndoCmd::documentation() const { return Documentation; }


    int UndoCmd::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of RedoCmd
///
#include "gen/RedoCmd.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RedoCmd::CmdName = "RedoCmd";
    const char* const RedoCmd::Documentation = "Redo the last undone command like Ctrl+Shift+Z in the UI";

    REGISTER_COMMAND_FACTORY(RedoCmd);


    RedoCmd::RedoCmd()
      : CommandBase(CmdName)
    {

    }


    RedoCmdPtr RedoCmd::create()
    {
      return RedoCmdPtr(new RedoCmd());
    }

    RedoCmdPtr RedoCmd::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RedoCmd>(ptr);
    }

    bool RedoCmd::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RedoCmd::documentation() const { return Documentation; }


    int RedoCmd::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetDataFolder
///
#include "gen/GetDataFolder.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDataFolder::CmdName = "GetDataFolder";
    const char* const GetDataFolder::Documentation = "Ask Skydel's Data Folder. The user can changed it in the GUI's Preferences.";

    REGISTER_COMMAND_FACTORY(GetDataFolder);


    GetDataFolder::GetDataFolder()
      : CommandBase(CmdName)
    {

    }


    GetDataFolderPtr GetDataFolder::create()
    {
      return GetDataFolderPtr(new GetDataFolder());
    }

    GetDataFolderPtr GetDataFolder::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDataFolder>(ptr);
    }

    bool GetDataFolder::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetDataFolder::documentation() const { return Documentation; }


    int GetDataFolder::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of DataFolderResult
///
#include "gen/DataFolderResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const DataFolderResult::CmdName = "DataFolderResult";
    const char* const DataFolderResult::Documentation = "Result of the command \"GetDataFolder\"";

    REGISTER_COMMAND_RESULT_FACTORY(DataFolderResult);


    DataFolderResult::DataFolderResult()
      : CommandResult(CmdName)
    {}

    DataFolderResult::DataFolderResult(CommandBasePtr relatedCommand, const std::string& folder)
      : CommandResult(CmdName, relatedCommand)
    {

      setFolder(folder);
    }


    DataFolderResultPtr DataFolderResult::create(CommandBasePtr relatedCommand, const std::string& folder)
    {
      return DataFolderResultPtr(new DataFolderResult(relatedCommand, folder));
    }

    DataFolderResultPtr DataFolderResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<DataFolderResult>(ptr);
    }

    bool DataFolderResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Folder"])
        ;

    }

    std::string DataFolderResult::documentation() const { return Documentation; }


    std::string DataFolderResult::folder() const
    {
      return parse_json<std::string>::parse(m_values["Folder"]);
    }

    void DataFolderResult::setFolder(const std::string& folder)
    {
      m_values.AddMember("Folder", parse_json<std::string>::format(folder, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVersion
///
#include "gen/GetVersion.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVersion::CmdName = "GetVersion";
    const char* const GetVersion::Documentation = "Ask Skydel version.";

    REGISTER_COMMAND_FACTORY(GetVersion);


    GetVersion::GetVersion()
      : CommandBase(CmdName)
    {

    }


    GetVersionPtr GetVersion::create()
    {
      return GetVersionPtr(new GetVersion());
    }

    GetVersionPtr GetVersion::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVersion>(ptr);
    }

    bool GetVersion::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVersion::documentation() const { return Documentation; }


    int GetVersion::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of VersionResult
///
#include "gen/VersionResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const VersionResult::CmdName = "VersionResult";
    const char* const VersionResult::Documentation = "Result of the command \"GetVersion\"";

    REGISTER_COMMAND_RESULT_FACTORY(VersionResult);


    VersionResult::VersionResult()
      : CommandResult(CmdName)
    {}

    VersionResult::VersionResult(CommandBasePtr relatedCommand, const std::string& version)
      : CommandResult(CmdName, relatedCommand)
    {

      setVersion(version);
    }


    VersionResultPtr VersionResult::create(CommandBasePtr relatedCommand, const std::string& version)
    {
      return VersionResultPtr(new VersionResult(relatedCommand, version));
    }

    VersionResultPtr VersionResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<VersionResult>(ptr);
    }

    bool VersionResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Version"])
        ;

    }

    std::string VersionResult::documentation() const { return Documentation; }


    std::string VersionResult::version() const
    {
      return parse_json<std::string>::parse(m_values["Version"]);
    }

    void VersionResult::setVersion(const std::string& version)
    {
      m_values.AddMember("Version", parse_json<std::string>::format(version, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSimulationElapsedTime
///
#include "gen/GetSimulationElapsedTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSimulationElapsedTime::CmdName = "GetSimulationElapsedTime";
    const char* const GetSimulationElapsedTime::Documentation = "Return simulation elapsed time in milliseconds.";

    REGISTER_COMMAND_FACTORY(GetSimulationElapsedTime);


    GetSimulationElapsedTime::GetSimulationElapsedTime()
      : CommandBase(CmdName)
    {

    }


    GetSimulationElapsedTimePtr GetSimulationElapsedTime::create()
    {
      return GetSimulationElapsedTimePtr(new GetSimulationElapsedTime());
    }

    GetSimulationElapsedTimePtr GetSimulationElapsedTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSimulationElapsedTime>(ptr);
    }

    bool GetSimulationElapsedTime::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSimulationElapsedTime::documentation() const { return Documentation; }


    int GetSimulationElapsedTime::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of SimulationElapsedTimeResult
///
#include "gen/SimulationElapsedTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SimulationElapsedTimeResult::CmdName = "SimulationElapsedTimeResult";
    const char* const SimulationElapsedTimeResult::Documentation = "Result of the command \"GetSimulationElapsedTime\"";

    REGISTER_COMMAND_RESULT_FACTORY(SimulationElapsedTimeResult);


    SimulationElapsedTimeResult::SimulationElapsedTimeResult()
      : CommandResult(CmdName)
    {}

    SimulationElapsedTimeResult::SimulationElapsedTimeResult(CommandBasePtr relatedCommand, int milliseconds)
      : CommandResult(CmdName, relatedCommand)
    {

      setMilliseconds(milliseconds);
    }


    SimulationElapsedTimeResultPtr SimulationElapsedTimeResult::create(CommandBasePtr relatedCommand, int milliseconds)
    {
      return SimulationElapsedTimeResultPtr(new SimulationElapsedTimeResult(relatedCommand, milliseconds));
    }

    SimulationElapsedTimeResultPtr SimulationElapsedTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SimulationElapsedTimeResult>(ptr);
    }

    bool SimulationElapsedTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Milliseconds"])
        ;

    }

    std::string SimulationElapsedTimeResult::documentation() const { return Documentation; }


    int SimulationElapsedTimeResult::milliseconds() const
    {
      return parse_json<int>::parse(m_values["Milliseconds"]);
    }

    void SimulationElapsedTimeResult::setMilliseconds(int milliseconds)
    {
      m_values.AddMember("Milliseconds", parse_json<int>::format(milliseconds, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of New
///
#include "gen/New.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const New::CmdName = "New";
    const char* const New::Documentation = "Create a new configuration.";

    REGISTER_COMMAND_FACTORY(New);


    New::New()
      : CommandBase(CmdName)
    {}

    New::New(bool discardCurrentConfig, const Sdx::optional<bool>& loadDefaultConfig)
      : CommandBase(CmdName)
    {

      setDiscardCurrentConfig(discardCurrentConfig);
      setLoadDefaultConfig(loadDefaultConfig);
    }


    NewPtr New::create(bool discardCurrentConfig, const Sdx::optional<bool>& loadDefaultConfig)
    {
      return NewPtr(new New(discardCurrentConfig, loadDefaultConfig));
    }

    NewPtr New::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<New>(ptr);
    }

    bool New::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["DiscardCurrentConfig"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["LoadDefaultConfig"])
        ;

    }

    std::string New::documentation() const { return Documentation; }


    int New::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    bool New::discardCurrentConfig() const
    {
      return parse_json<bool>::parse(m_values["DiscardCurrentConfig"]);
    }

    void New::setDiscardCurrentConfig(bool discardCurrentConfig)
    {
      m_values.AddMember("DiscardCurrentConfig", parse_json<bool>::format(discardCurrentConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> New::loadDefaultConfig() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["LoadDefaultConfig"]);
    }

    void New::setLoadDefaultConfig(const Sdx::optional<bool>& loadDefaultConfig)
    {
      m_values.AddMember("LoadDefaultConfig", parse_json<Sdx::optional<bool>>::format(loadDefaultConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SaveAs
///
#include "gen/SaveAs.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SaveAs::CmdName = "SaveAs";
    const char* const SaveAs::Documentation = "Save configuration with new name.";

    REGISTER_COMMAND_FACTORY(SaveAs);


    SaveAs::SaveAs()
      : CommandBase(CmdName)
    {}

    SaveAs::SaveAs(const std::string& path, bool overwrite)
      : CommandBase(CmdName)
    {

      setPath(path);
      setOverwrite(overwrite);
    }


    SaveAsPtr SaveAs::create(const std::string& path, bool overwrite)
    {
      return SaveAsPtr(new SaveAs(path, overwrite));
    }

    SaveAsPtr SaveAs::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SaveAs>(ptr);
    }

    bool SaveAs::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<bool>::is_valid(m_values["Overwrite"])
        ;

    }

    std::string SaveAs::documentation() const { return Documentation; }


    int SaveAs::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SaveAs::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void SaveAs::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SaveAs::overwrite() const
    {
      return parse_json<bool>::parse(m_values["Overwrite"]);
    }

    void SaveAs::setOverwrite(bool overwrite)
    {
      m_values.AddMember("Overwrite", parse_json<bool>::format(overwrite, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of Save
///
#include "gen/Save.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Save::CmdName = "Save";
    const char* const Save::Documentation = "Save configuration.";

    REGISTER_COMMAND_FACTORY(Save);


    Save::Save()
      : CommandBase(CmdName)
    {

    }


    SavePtr Save::create()
    {
      return SavePtr(new Save());
    }

    SavePtr Save::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Save>(ptr);
    }

    bool Save::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Save::documentation() const { return Documentation; }


    int Save::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Open
///
#include "gen/Open.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Open::CmdName = "Open";
    const char* const Open::Documentation = "Open configuration.";

    REGISTER_COMMAND_FACTORY(Open);


    Open::Open()
      : CommandBase(CmdName)
    {}

    Open::Open(const std::string& path, bool discardCurrentConfig)
      : CommandBase(CmdName)
    {

      setPath(path);
      setDiscardCurrentConfig(discardCurrentConfig);
    }


    OpenPtr Open::create(const std::string& path, bool discardCurrentConfig)
    {
      return OpenPtr(new Open(path, discardCurrentConfig));
    }

    OpenPtr Open::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Open>(ptr);
    }

    bool Open::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<bool>::is_valid(m_values["DiscardCurrentConfig"])
        ;

    }

    std::string Open::documentation() const { return Documentation; }


    int Open::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    std::string Open::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void Open::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool Open::discardCurrentConfig() const
    {
      return parse_json<bool>::parse(m_values["DiscardCurrentConfig"]);
    }

    void Open::setDiscardCurrentConfig(bool discardCurrentConfig)
    {
      m_values.AddMember("DiscardCurrentConfig", parse_json<bool>::format(discardCurrentConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetDefaultConfiguration
///
#include "gen/SetDefaultConfiguration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetDefaultConfiguration::CmdName = "SetDefaultConfiguration";
    const char* const SetDefaultConfiguration::Documentation = "Set current configuration as default configuration.";

    REGISTER_COMMAND_FACTORY(SetDefaultConfiguration);


    SetDefaultConfiguration::SetDefaultConfiguration()
      : CommandBase(CmdName)
    {

    }


    SetDefaultConfigurationPtr SetDefaultConfiguration::create()
    {
      return SetDefaultConfigurationPtr(new SetDefaultConfiguration());
    }

    SetDefaultConfigurationPtr SetDefaultConfiguration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetDefaultConfiguration>(ptr);
    }

    bool SetDefaultConfiguration::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string SetDefaultConfiguration::documentation() const { return Documentation; }


    int SetDefaultConfiguration::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of ResetDefaultConfiguration
///
#include "gen/ResetDefaultConfiguration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetDefaultConfiguration::CmdName = "ResetDefaultConfiguration";
    const char* const ResetDefaultConfiguration::Documentation = "Reset the default configuration.";

    REGISTER_COMMAND_FACTORY(ResetDefaultConfiguration);


    ResetDefaultConfiguration::ResetDefaultConfiguration()
      : CommandBase(CmdName)
    {

    }


    ResetDefaultConfigurationPtr ResetDefaultConfiguration::create()
    {
      return ResetDefaultConfigurationPtr(new ResetDefaultConfiguration());
    }

    ResetDefaultConfigurationPtr ResetDefaultConfiguration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetDefaultConfiguration>(ptr);
    }

    bool ResetDefaultConfiguration::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ResetDefaultConfiguration::documentation() const { return Documentation; }


    int ResetDefaultConfiguration::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of ClearAutomatePage
///
#include "gen/ClearAutomatePage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAutomatePage::CmdName = "ClearAutomatePage";
    const char* const ClearAutomatePage::Documentation = "Clear automate page.";

    REGISTER_COMMAND_FACTORY(ClearAutomatePage);


    ClearAutomatePage::ClearAutomatePage()
      : CommandBase(CmdName)
    {

    }


    ClearAutomatePagePtr ClearAutomatePage::create()
    {
      return ClearAutomatePagePtr(new ClearAutomatePage());
    }

    ClearAutomatePagePtr ClearAutomatePage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAutomatePage>(ptr);
    }

    bool ClearAutomatePage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAutomatePage::documentation() const { return Documentation; }


    int ClearAutomatePage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Start
///
#include "gen/Start.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Start::CmdName = "Start";
    const char* const Start::Documentation = "Start the simulation. Simulation may or may not start depending on the current state of the simulator.";

    REGISTER_COMMAND_FACTORY(Start);


    Start::Start()
      : CommandBase(CmdName)
    {

    }


    StartPtr Start::create()
    {
      return StartPtr(new Start());
    }

    StartPtr Start::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Start>(ptr);
    }

    bool Start::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Start::documentation() const { return Documentation; }


    int Start::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Arm
///
#include "gen/Arm.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Arm::CmdName = "Arm";
    const char* const Arm::Documentation = "Arm the simulation. Simulation may or may not arm depending on the current state of the simulator.";

    REGISTER_COMMAND_FACTORY(Arm);


    Arm::Arm()
      : CommandBase(CmdName)
    {

    }


    ArmPtr Arm::create()
    {
      return ArmPtr(new Arm());
    }

    ArmPtr Arm::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Arm>(ptr);
    }

    bool Arm::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Arm::documentation() const { return Documentation; }


    int Arm::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Pause
///
#include "gen/Pause.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Pause::CmdName = "Pause";
    const char* const Pause::Documentation = "Pause vehicle motion during simulation.";

    REGISTER_COMMAND_FACTORY(Pause);


    Pause::Pause()
      : CommandBase(CmdName)
    {

    }


    PausePtr Pause::create()
    {
      return PausePtr(new Pause());
    }

    PausePtr Pause::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Pause>(ptr);
    }

    bool Pause::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Pause::documentation() const { return Documentation; }


    int Pause::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of Resume
///
#include "gen/Resume.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Resume::CmdName = "Resume";
    const char* const Resume::Documentation = "Resume vehicle motion during simulation.";

    REGISTER_COMMAND_FACTORY(Resume);


    Resume::Resume()
      : CommandBase(CmdName)
    {

    }


    ResumePtr Resume::create()
    {
      return ResumePtr(new Resume());
    }

    ResumePtr Resume::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Resume>(ptr);
    }

    bool Resume::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Resume::documentation() const { return Documentation; }


    int Resume::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of Stop
///
#include "gen/Stop.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Stop::CmdName = "Stop";
    const char* const Stop::Documentation = "Stop the simulation.";

    REGISTER_COMMAND_FACTORY(Stop);


    Stop::Stop()
      : CommandBase(CmdName)
    {

    }


    StopPtr Stop::create()
    {
      return StopPtr(new Stop());
    }

    StopPtr Stop::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Stop>(ptr);
    }

    bool Stop::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string Stop::documentation() const { return Documentation; }


    int Stop::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of Quit
///
#include "gen/Quit.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const Quit::CmdName = "Quit";
    const char* const Quit::Documentation = "Quit/Exit Skydel. Simulation must be stopped to be able to quit Skydel";

    REGISTER_COMMAND_FACTORY(Quit);


    Quit::Quit()
      : CommandBase(CmdName)
    {}

    Quit::Quit(bool forceQuit)
      : CommandBase(CmdName)
    {

      setForceQuit(forceQuit);
    }


    QuitPtr Quit::create(bool forceQuit)
    {
      return QuitPtr(new Quit(forceQuit));
    }

    QuitPtr Quit::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<Quit>(ptr);
    }

    bool Quit::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["ForceQuit"])
        ;

    }

    std::string Quit::documentation() const { return Documentation; }


    int Quit::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    bool Quit::forceQuit() const
    {
      return parse_json<bool>::parse(m_values["ForceQuit"]);
    }

    void Quit::setForceQuit(bool forceQuit)
    {
      m_values.AddMember("ForceQuit", parse_json<bool>::format(forceQuit, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of LockGUI
///
#include "gen/LockGUI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const LockGUI::CmdName = "LockGUI";
    const char* const LockGUI::Documentation = "Prevent GUI updates while modify the configuration. Use UnlockGUI when done with\nconfiguration modifications.";

    REGISTER_COMMAND_FACTORY(LockGUI);


    LockGUI::LockGUI()
      : CommandBase(CmdName)
    {

    }


    LockGUIPtr LockGUI::create()
    {
      return LockGUIPtr(new LockGUI());
    }

    LockGUIPtr LockGUI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<LockGUI>(ptr);
    }

    bool LockGUI::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string LockGUI::documentation() const { return Documentation; }


    int LockGUI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of UnlockGUI
///
#include "gen/UnlockGUI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const UnlockGUI::CmdName = "UnlockGUI";
    const char* const UnlockGUI::Documentation = "Resume GUI updates and force one update immediately.";

    REGISTER_COMMAND_FACTORY(UnlockGUI);


    UnlockGUI::UnlockGUI()
      : CommandBase(CmdName)
    {

    }


    UnlockGUIPtr UnlockGUI::create()
    {
      return UnlockGUIPtr(new UnlockGUI());
    }

    UnlockGUIPtr UnlockGUI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<UnlockGUI>(ptr);
    }

    bool UnlockGUI::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string UnlockGUI::documentation() const { return Documentation; }


    int UnlockGUI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of EnableRFOutputForSV
///
#include "gen/EnableRFOutputForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableRFOutputForSV::CmdName = "EnableRFOutputForSV";
    const char* const EnableRFOutputForSV::Documentation = "Enable (or disable) RF output for specified satellite. Use SV ID 0 to enabled/disable all satellites.";

    REGISTER_COMMAND_FACTORY(EnableRFOutputForSV);


    EnableRFOutputForSV::EnableRFOutputForSV()
      : CommandBase(CmdName)
    {}

    EnableRFOutputForSV::EnableRFOutputForSV(const std::string& system, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnableRFOutputForSVPtr EnableRFOutputForSV::create(const std::string& system, int svId, bool enabled)
    {
      return EnableRFOutputForSVPtr(new EnableRFOutputForSV(system, svId, enabled));
    }

    EnableRFOutputForSVPtr EnableRFOutputForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableRFOutputForSV>(ptr);
    }

    bool EnableRFOutputForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableRFOutputForSV::documentation() const { return Documentation; }


    int EnableRFOutputForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableRFOutputForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableRFOutputForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnableRFOutputForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnableRFOutputForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableRFOutputForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableRFOutputForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFOutputEnabled
///
#include "gen/IsRFOutputEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFOutputEnabled::CmdName = "IsRFOutputEnabled";
    const char* const IsRFOutputEnabled::Documentation = "Tells if the RF output is enabled or disabled for the specified satellite.";

    REGISTER_COMMAND_FACTORY(IsRFOutputEnabled);


    IsRFOutputEnabled::IsRFOutputEnabled()
      : CommandBase(CmdName)
    {}

    IsRFOutputEnabled::IsRFOutputEnabled(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    IsRFOutputEnabledPtr IsRFOutputEnabled::create(const std::string& system, int svId)
    {
      return IsRFOutputEnabledPtr(new IsRFOutputEnabled(system, svId));
    }

    IsRFOutputEnabledPtr IsRFOutputEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFOutputEnabled>(ptr);
    }

    bool IsRFOutputEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsRFOutputEnabled::documentation() const { return Documentation; }


    int IsRFOutputEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsRFOutputEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFOutputEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsRFOutputEnabled::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsRFOutputEnabled::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFOutputEnabledResult
///
#include "gen/IsRFOutputEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFOutputEnabledResult::CmdName = "IsRFOutputEnabledResult";
    const char* const IsRFOutputEnabledResult::Documentation = "Result of IsRFOutputEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsRFOutputEnabledResult);


    IsRFOutputEnabledResult::IsRFOutputEnabledResult()
      : CommandResult(CmdName)
    {}

    IsRFOutputEnabledResult::IsRFOutputEnabledResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsRFOutputEnabledResultPtr IsRFOutputEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
    {
      return IsRFOutputEnabledResultPtr(new IsRFOutputEnabledResult(relatedCommand, system, svId, enabled));
    }

    IsRFOutputEnabledResultPtr IsRFOutputEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFOutputEnabledResult>(ptr);
    }

    bool IsRFOutputEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsRFOutputEnabledResult::documentation() const { return Documentation; }


    std::string IsRFOutputEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFOutputEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsRFOutputEnabledResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsRFOutputEnabledResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsRFOutputEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsRFOutputEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableRFOutputForEachSV
///
#include "gen/EnableRFOutputForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableRFOutputForEachSV::CmdName = "EnableRFOutputForEachSV";
    const char* const EnableRFOutputForEachSV::Documentation = "Enable (or disable) RF output for each satellite individually.";

    REGISTER_COMMAND_FACTORY(EnableRFOutputForEachSV);


    EnableRFOutputForEachSV::EnableRFOutputForEachSV()
      : CommandBase(CmdName)
    {}

    EnableRFOutputForEachSV::EnableRFOutputForEachSV(const std::string& system, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    EnableRFOutputForEachSVPtr EnableRFOutputForEachSV::create(const std::string& system, const std::vector<bool>& enabled)
    {
      return EnableRFOutputForEachSVPtr(new EnableRFOutputForEachSV(system, enabled));
    }

    EnableRFOutputForEachSVPtr EnableRFOutputForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableRFOutputForEachSV>(ptr);
    }

    bool EnableRFOutputForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableRFOutputForEachSV::documentation() const { return Documentation; }


    int EnableRFOutputForEachSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableRFOutputForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableRFOutputForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableRFOutputForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableRFOutputForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFOutputEnabledForEachSV
///
#include "gen/IsRFOutputEnabledForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFOutputEnabledForEachSV::CmdName = "IsRFOutputEnabledForEachSV";
    const char* const IsRFOutputEnabledForEachSV::Documentation = "Tells if the RF output is enabled or disabled for each satellite.";

    REGISTER_COMMAND_FACTORY(IsRFOutputEnabledForEachSV);


    IsRFOutputEnabledForEachSV::IsRFOutputEnabledForEachSV()
      : CommandBase(CmdName)
    {}

    IsRFOutputEnabledForEachSV::IsRFOutputEnabledForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsRFOutputEnabledForEachSVPtr IsRFOutputEnabledForEachSV::create(const std::string& system)
    {
      return IsRFOutputEnabledForEachSVPtr(new IsRFOutputEnabledForEachSV(system));
    }

    IsRFOutputEnabledForEachSVPtr IsRFOutputEnabledForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFOutputEnabledForEachSV>(ptr);
    }

    bool IsRFOutputEnabledForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsRFOutputEnabledForEachSV::documentation() const { return Documentation; }


    int IsRFOutputEnabledForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsRFOutputEnabledForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFOutputEnabledForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFOutputEnabledForEachSVResult
///
#include "gen/IsRFOutputEnabledForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFOutputEnabledForEachSVResult::CmdName = "IsRFOutputEnabledForEachSVResult";
    const char* const IsRFOutputEnabledForEachSVResult::Documentation = "Result of IsRFOutputEnabledForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(IsRFOutputEnabledForEachSVResult);


    IsRFOutputEnabledForEachSVResult::IsRFOutputEnabledForEachSVResult()
      : CommandResult(CmdName)
    {}

    IsRFOutputEnabledForEachSVResult::IsRFOutputEnabledForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    IsRFOutputEnabledForEachSVResultPtr IsRFOutputEnabledForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
    {
      return IsRFOutputEnabledForEachSVResultPtr(new IsRFOutputEnabledForEachSVResult(relatedCommand, system, enabled));
    }

    IsRFOutputEnabledForEachSVResultPtr IsRFOutputEnabledForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFOutputEnabledForEachSVResult>(ptr);
    }

    bool IsRFOutputEnabledForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsRFOutputEnabledForEachSVResult::documentation() const { return Documentation; }


    std::string IsRFOutputEnabledForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFOutputEnabledForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsRFOutputEnabledForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsRFOutputEnabledForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSignalForSV
///
#include "gen/EnableSignalForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSignalForSV::CmdName = "EnableSignalForSV";
    const char* const EnableSignalForSV::Documentation = "Enable (or disable) signal for specified satellite.";

    REGISTER_COMMAND_FACTORY(EnableSignalForSV);


    EnableSignalForSV::EnableSignalForSV()
      : CommandBase(CmdName)
    {}

    EnableSignalForSV::EnableSignalForSV(const std::string& signal, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnableSignalForSVPtr EnableSignalForSV::create(const std::string& signal, int svId, bool enabled)
    {
      return EnableSignalForSVPtr(new EnableSignalForSV(signal, svId, enabled));
    }

    EnableSignalForSVPtr EnableSignalForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSignalForSV>(ptr);
    }

    bool EnableSignalForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSignalForSV::documentation() const { return Documentation; }


    int EnableSignalForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableSignalForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnableSignalForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnableSignalForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnableSignalForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableSignalForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSignalForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabledForSV
///
#include "gen/IsSignalEnabledForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabledForSV::CmdName = "IsSignalEnabledForSV";
    const char* const IsSignalEnabledForSV::Documentation = "Tells if the signal is enabled or disabled.";

    REGISTER_COMMAND_FACTORY(IsSignalEnabledForSV);


    IsSignalEnabledForSV::IsSignalEnabledForSV()
      : CommandBase(CmdName)
    {}

    IsSignalEnabledForSV::IsSignalEnabledForSV(const std::string& signal, int svId)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
    }


    IsSignalEnabledForSVPtr IsSignalEnabledForSV::create(const std::string& signal, int svId)
    {
      return IsSignalEnabledForSVPtr(new IsSignalEnabledForSV(signal, svId));
    }

    IsSignalEnabledForSVPtr IsSignalEnabledForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabledForSV>(ptr);
    }

    bool IsSignalEnabledForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsSignalEnabledForSV::documentation() const { return Documentation; }


    int IsSignalEnabledForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSignalEnabledForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabledForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSignalEnabledForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSignalEnabledForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabledForSVResult
///
#include "gen/IsSignalEnabledForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabledForSVResult::CmdName = "IsSignalEnabledForSVResult";
    const char* const IsSignalEnabledForSVResult::Documentation = "Result of IsSignalEnabledForSV";

    REGISTER_COMMAND_RESULT_FACTORY(IsSignalEnabledForSVResult);


    IsSignalEnabledForSVResult::IsSignalEnabledForSVResult()
      : CommandResult(CmdName)
    {}

    IsSignalEnabledForSVResult::IsSignalEnabledForSVResult(CommandBasePtr relatedCommand, const std::string& signal, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsSignalEnabledForSVResultPtr IsSignalEnabledForSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, int svId, bool enabled)
    {
      return IsSignalEnabledForSVResultPtr(new IsSignalEnabledForSVResult(relatedCommand, signal, svId, enabled));
    }

    IsSignalEnabledForSVResultPtr IsSignalEnabledForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabledForSVResult>(ptr);
    }

    bool IsSignalEnabledForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSignalEnabledForSVResult::documentation() const { return Documentation; }


    std::string IsSignalEnabledForSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabledForSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSignalEnabledForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSignalEnabledForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSignalEnabledForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSignalEnabledForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSignalForEachSV
///
#include "gen/EnableSignalForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSignalForEachSV::CmdName = "EnableSignalForEachSV";
    const char* const EnableSignalForEachSV::Documentation = "Enable (or disable) signal for each satellite individually.";

    REGISTER_COMMAND_FACTORY(EnableSignalForEachSV);


    EnableSignalForEachSV::EnableSignalForEachSV()
      : CommandBase(CmdName)
    {}

    EnableSignalForEachSV::EnableSignalForEachSV(const std::string& signal, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    EnableSignalForEachSVPtr EnableSignalForEachSV::create(const std::string& signal, const std::vector<bool>& enabled)
    {
      return EnableSignalForEachSVPtr(new EnableSignalForEachSV(signal, enabled));
    }

    EnableSignalForEachSVPtr EnableSignalForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSignalForEachSV>(ptr);
    }

    bool EnableSignalForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSignalForEachSV::documentation() const { return Documentation; }


    int EnableSignalForEachSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableSignalForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnableSignalForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableSignalForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableSignalForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabledForEachSV
///
#include "gen/IsSignalEnabledForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabledForEachSV::CmdName = "IsSignalEnabledForEachSV";
    const char* const IsSignalEnabledForEachSV::Documentation = "Tells if the signal is enabled or disabled for each satellite.";

    REGISTER_COMMAND_FACTORY(IsSignalEnabledForEachSV);


    IsSignalEnabledForEachSV::IsSignalEnabledForEachSV()
      : CommandBase(CmdName)
    {}

    IsSignalEnabledForEachSV::IsSignalEnabledForEachSV(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    IsSignalEnabledForEachSVPtr IsSignalEnabledForEachSV::create(const std::string& signal)
    {
      return IsSignalEnabledForEachSVPtr(new IsSignalEnabledForEachSV(signal));
    }

    IsSignalEnabledForEachSVPtr IsSignalEnabledForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabledForEachSV>(ptr);
    }

    bool IsSignalEnabledForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string IsSignalEnabledForEachSV::documentation() const { return Documentation; }


    int IsSignalEnabledForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSignalEnabledForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabledForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabledForEachSVResult
///
#include "gen/IsSignalEnabledForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabledForEachSVResult::CmdName = "IsSignalEnabledForEachSVResult";
    const char* const IsSignalEnabledForEachSVResult::Documentation = "Result of IsSignalEnabledForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(IsSignalEnabledForEachSVResult);


    IsSignalEnabledForEachSVResult::IsSignalEnabledForEachSVResult()
      : CommandResult(CmdName)
    {}

    IsSignalEnabledForEachSVResult::IsSignalEnabledForEachSVResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    IsSignalEnabledForEachSVResultPtr IsSignalEnabledForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
    {
      return IsSignalEnabledForEachSVResultPtr(new IsSignalEnabledForEachSVResult(relatedCommand, signal, enabled));
    }

    IsSignalEnabledForEachSVResultPtr IsSignalEnabledForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabledForEachSVResult>(ptr);
    }

    bool IsSignalEnabledForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSignalEnabledForEachSVResult::documentation() const { return Documentation; }


    std::string IsSignalEnabledForEachSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabledForEachSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsSignalEnabledForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsSignalEnabledForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnablePYCodeForSV
///
#include "gen/EnablePYCodeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnablePYCodeForSV::CmdName = "EnablePYCodeForSV";
    const char* const EnablePYCodeForSV::Documentation = "Enable (or disable) P(Y)-Code for specified satellite.";

    REGISTER_COMMAND_FACTORY(EnablePYCodeForSV);


    EnablePYCodeForSV::EnablePYCodeForSV()
      : CommandBase(CmdName)
    {}

    EnablePYCodeForSV::EnablePYCodeForSV(const std::string& signal, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnablePYCodeForSVPtr EnablePYCodeForSV::create(const std::string& signal, int svId, bool enabled)
    {
      return EnablePYCodeForSVPtr(new EnablePYCodeForSV(signal, svId, enabled));
    }

    EnablePYCodeForSVPtr EnablePYCodeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnablePYCodeForSV>(ptr);
    }

    bool EnablePYCodeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnablePYCodeForSV::documentation() const { return Documentation; }


    int EnablePYCodeForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnablePYCodeForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnablePYCodeForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnablePYCodeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnablePYCodeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnablePYCodeForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnablePYCodeForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYCodeEnabledForSV
///
#include "gen/IsPYCodeEnabledForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYCodeEnabledForSV::CmdName = "IsPYCodeEnabledForSV";
    const char* const IsPYCodeEnabledForSV::Documentation = "Tells if P(Y)-Code is enabled for the specified satellite.";

    REGISTER_COMMAND_FACTORY(IsPYCodeEnabledForSV);


    IsPYCodeEnabledForSV::IsPYCodeEnabledForSV()
      : CommandBase(CmdName)
    {}

    IsPYCodeEnabledForSV::IsPYCodeEnabledForSV(const std::string& signal, int svId)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
    }


    IsPYCodeEnabledForSVPtr IsPYCodeEnabledForSV::create(const std::string& signal, int svId)
    {
      return IsPYCodeEnabledForSVPtr(new IsPYCodeEnabledForSV(signal, svId));
    }

    IsPYCodeEnabledForSVPtr IsPYCodeEnabledForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYCodeEnabledForSV>(ptr);
    }

    bool IsPYCodeEnabledForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsPYCodeEnabledForSV::documentation() const { return Documentation; }


    int IsPYCodeEnabledForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsPYCodeEnabledForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYCodeEnabledForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsPYCodeEnabledForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsPYCodeEnabledForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYCodeEnabledForSVResult
///
#include "gen/IsPYCodeEnabledForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYCodeEnabledForSVResult::CmdName = "IsPYCodeEnabledForSVResult";
    const char* const IsPYCodeEnabledForSVResult::Documentation = "Result of IsPYCodeEnabledForSV";

    REGISTER_COMMAND_RESULT_FACTORY(IsPYCodeEnabledForSVResult);


    IsPYCodeEnabledForSVResult::IsPYCodeEnabledForSVResult()
      : CommandResult(CmdName)
    {}

    IsPYCodeEnabledForSVResult::IsPYCodeEnabledForSVResult(CommandBasePtr relatedCommand, const std::string& signal, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsPYCodeEnabledForSVResultPtr IsPYCodeEnabledForSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, int svId, bool enabled)
    {
      return IsPYCodeEnabledForSVResultPtr(new IsPYCodeEnabledForSVResult(relatedCommand, signal, svId, enabled));
    }

    IsPYCodeEnabledForSVResultPtr IsPYCodeEnabledForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYCodeEnabledForSVResult>(ptr);
    }

    bool IsPYCodeEnabledForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsPYCodeEnabledForSVResult::documentation() const { return Documentation; }


    std::string IsPYCodeEnabledForSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYCodeEnabledForSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsPYCodeEnabledForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsPYCodeEnabledForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsPYCodeEnabledForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsPYCodeEnabledForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnablePYCodeForEachSV
///
#include "gen/EnablePYCodeForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnablePYCodeForEachSV::CmdName = "EnablePYCodeForEachSV";
    const char* const EnablePYCodeForEachSV::Documentation = "Enable (or disable) P(Y)-Code for each satellite individually.";

    REGISTER_COMMAND_FACTORY(EnablePYCodeForEachSV);


    EnablePYCodeForEachSV::EnablePYCodeForEachSV()
      : CommandBase(CmdName)
    {}

    EnablePYCodeForEachSV::EnablePYCodeForEachSV(const std::string& signal, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    EnablePYCodeForEachSVPtr EnablePYCodeForEachSV::create(const std::string& signal, const std::vector<bool>& enabled)
    {
      return EnablePYCodeForEachSVPtr(new EnablePYCodeForEachSV(signal, enabled));
    }

    EnablePYCodeForEachSVPtr EnablePYCodeForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnablePYCodeForEachSV>(ptr);
    }

    bool EnablePYCodeForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnablePYCodeForEachSV::documentation() const { return Documentation; }


    int EnablePYCodeForEachSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnablePYCodeForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnablePYCodeForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnablePYCodeForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnablePYCodeForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYCodeEnabledForEachSV
///
#include "gen/IsPYCodeEnabledForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYCodeEnabledForEachSV::CmdName = "IsPYCodeEnabledForEachSV";
    const char* const IsPYCodeEnabledForEachSV::Documentation = "Tells if the P(Y)-Code is enabled or disabled for each satellite.";

    REGISTER_COMMAND_FACTORY(IsPYCodeEnabledForEachSV);


    IsPYCodeEnabledForEachSV::IsPYCodeEnabledForEachSV()
      : CommandBase(CmdName)
    {}

    IsPYCodeEnabledForEachSV::IsPYCodeEnabledForEachSV(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    IsPYCodeEnabledForEachSVPtr IsPYCodeEnabledForEachSV::create(const std::string& signal)
    {
      return IsPYCodeEnabledForEachSVPtr(new IsPYCodeEnabledForEachSV(signal));
    }

    IsPYCodeEnabledForEachSVPtr IsPYCodeEnabledForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYCodeEnabledForEachSV>(ptr);
    }

    bool IsPYCodeEnabledForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string IsPYCodeEnabledForEachSV::documentation() const { return Documentation; }


    int IsPYCodeEnabledForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsPYCodeEnabledForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYCodeEnabledForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYCodeEnabledForEachSVResult
///
#include "gen/IsPYCodeEnabledForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYCodeEnabledForEachSVResult::CmdName = "IsPYCodeEnabledForEachSVResult";
    const char* const IsPYCodeEnabledForEachSVResult::Documentation = "Result of IsPYCodeEnabledForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(IsPYCodeEnabledForEachSVResult);


    IsPYCodeEnabledForEachSVResult::IsPYCodeEnabledForEachSVResult()
      : CommandResult(CmdName)
    {}

    IsPYCodeEnabledForEachSVResult::IsPYCodeEnabledForEachSVResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    IsPYCodeEnabledForEachSVResultPtr IsPYCodeEnabledForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
    {
      return IsPYCodeEnabledForEachSVResultPtr(new IsPYCodeEnabledForEachSVResult(relatedCommand, signal, enabled));
    }

    IsPYCodeEnabledForEachSVResultPtr IsPYCodeEnabledForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYCodeEnabledForEachSVResult>(ptr);
    }

    bool IsPYCodeEnabledForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsPYCodeEnabledForEachSVResult::documentation() const { return Documentation; }


    std::string IsPYCodeEnabledForEachSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYCodeEnabledForEachSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsPYCodeEnabledForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsPYCodeEnabledForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPowerForSV
///
#include "gen/SetPowerForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPowerForSV::CmdName = "SetPowerForSV";
    const char* const SetPowerForSV::Documentation = "Set power offset for specified satellite SV ID. Use SV ID 0 to set power for all satellites.";

    REGISTER_COMMAND_FACTORY(SetPowerForSV);


    SetPowerForSV::SetPowerForSV()
      : CommandBase(CmdName)
    {}

    SetPowerForSV::SetPowerForSV(const std::string& system, int svId, double powerOffset, bool otherSatsFollow)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setPowerOffset(powerOffset);
      setOtherSatsFollow(otherSatsFollow);
    }


    SetPowerForSVPtr SetPowerForSV::create(const std::string& system, int svId, double powerOffset, bool otherSatsFollow)
    {
      return SetPowerForSVPtr(new SetPowerForSV(system, svId, powerOffset, otherSatsFollow));
    }

    SetPowerForSVPtr SetPowerForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPowerForSV>(ptr);
    }

    bool SetPowerForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["PowerOffset"])
          && parse_json<bool>::is_valid(m_values["OtherSatsFollow"])
        ;

    }

    std::string SetPowerForSV::documentation() const { return Documentation; }


    int SetPowerForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string SetPowerForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPowerForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPowerForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPowerForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPowerForSV::powerOffset() const
    {
      return parse_json<double>::parse(m_values["PowerOffset"]);
    }

    void SetPowerForSV::setPowerOffset(double powerOffset)
    {
      m_values.AddMember("PowerOffset", parse_json<double>::format(powerOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPowerForSV::otherSatsFollow() const
    {
      return parse_json<bool>::parse(m_values["OtherSatsFollow"]);
    }

    void SetPowerForSV::setOtherSatsFollow(bool otherSatsFollow)
    {
      m_values.AddMember("OtherSatsFollow", parse_json<bool>::format(otherSatsFollow, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerForSV
///
#include "gen/GetPowerForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerForSV::CmdName = "GetPowerForSV";
    const char* const GetPowerForSV::Documentation = "Get power offset for specified satellite SV ID.";

    REGISTER_COMMAND_FACTORY(GetPowerForSV);


    GetPowerForSV::GetPowerForSV()
      : CommandBase(CmdName)
    {}

    GetPowerForSV::GetPowerForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetPowerForSVPtr GetPowerForSV::create(const std::string& system, int svId)
    {
      return GetPowerForSVPtr(new GetPowerForSV(system, svId));
    }

    GetPowerForSVPtr GetPowerForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerForSV>(ptr);
    }

    bool GetPowerForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetPowerForSV::documentation() const { return Documentation; }


    int GetPowerForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string GetPowerForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPowerForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPowerForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPowerForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerForSVResult
///
#include "gen/GetPowerForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerForSVResult::CmdName = "GetPowerForSVResult";
    const char* const GetPowerForSVResult::Documentation = "Result of GetPowerForSV.";

    REGISTER_COMMAND_RESULT_FACTORY(GetPowerForSVResult);


    GetPowerForSVResult::GetPowerForSVResult()
      : CommandResult(CmdName)
    {}

    GetPowerForSVResult::GetPowerForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, double nominalPower, double signalStrengthModel, double antenna, double signalLevelOffset, double manualGain, double total)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setNominalPower(nominalPower);
      setSignalStrengthModel(signalStrengthModel);
      setAntenna(antenna);
      setSignalLevelOffset(signalLevelOffset);
      setManualGain(manualGain);
      setTotal(total);
    }


    GetPowerForSVResultPtr GetPowerForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, double nominalPower, double signalStrengthModel, double antenna, double signalLevelOffset, double manualGain, double total)
    {
      return GetPowerForSVResultPtr(new GetPowerForSVResult(relatedCommand, system, svId, nominalPower, signalStrengthModel, antenna, signalLevelOffset, manualGain, total));
    }

    GetPowerForSVResultPtr GetPowerForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerForSVResult>(ptr);
    }

    bool GetPowerForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["NominalPower"])
          && parse_json<double>::is_valid(m_values["SignalStrengthModel"])
          && parse_json<double>::is_valid(m_values["Antenna"])
          && parse_json<double>::is_valid(m_values["SignalLevelOffset"])
          && parse_json<double>::is_valid(m_values["ManualGain"])
          && parse_json<double>::is_valid(m_values["Total"])
        ;

    }

    std::string GetPowerForSVResult::documentation() const { return Documentation; }


    std::string GetPowerForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPowerForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPowerForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPowerForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::nominalPower() const
    {
      return parse_json<double>::parse(m_values["NominalPower"]);
    }

    void GetPowerForSVResult::setNominalPower(double nominalPower)
    {
      m_values.AddMember("NominalPower", parse_json<double>::format(nominalPower, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::signalStrengthModel() const
    {
      return parse_json<double>::parse(m_values["SignalStrengthModel"]);
    }

    void GetPowerForSVResult::setSignalStrengthModel(double signalStrengthModel)
    {
      m_values.AddMember("SignalStrengthModel", parse_json<double>::format(signalStrengthModel, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::antenna() const
    {
      return parse_json<double>::parse(m_values["Antenna"]);
    }

    void GetPowerForSVResult::setAntenna(double antenna)
    {
      m_values.AddMember("Antenna", parse_json<double>::format(antenna, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::signalLevelOffset() const
    {
      return parse_json<double>::parse(m_values["SignalLevelOffset"]);
    }

    void GetPowerForSVResult::setSignalLevelOffset(double signalLevelOffset)
    {
      m_values.AddMember("SignalLevelOffset", parse_json<double>::format(signalLevelOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::manualGain() const
    {
      return parse_json<double>::parse(m_values["ManualGain"]);
    }

    void GetPowerForSVResult::setManualGain(double manualGain)
    {
      m_values.AddMember("ManualGain", parse_json<double>::format(manualGain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerForSVResult::total() const
    {
      return parse_json<double>::parse(m_values["Total"]);
    }

    void GetPowerForSVResult::setTotal(double total)
    {
      m_values.AddMember("Total", parse_json<double>::format(total, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetAllSatPower
///
#include "gen/ResetAllSatPower.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetAllSatPower::CmdName = "ResetAllSatPower";
    const char* const ResetAllSatPower::Documentation = "Reset power offset for all satellites is specified system to default value";

    REGISTER_COMMAND_FACTORY(ResetAllSatPower);


    ResetAllSatPower::ResetAllSatPower()
      : CommandBase(CmdName)
    {}

    ResetAllSatPower::ResetAllSatPower(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    ResetAllSatPowerPtr ResetAllSatPower::create(const std::string& system)
    {
      return ResetAllSatPowerPtr(new ResetAllSatPower(system));
    }

    ResetAllSatPowerPtr ResetAllSatPower::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetAllSatPower>(ptr);
    }

    bool ResetAllSatPower::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string ResetAllSatPower::documentation() const { return Documentation; }


    int ResetAllSatPower::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string ResetAllSatPower::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ResetAllSatPower::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPropagationDelay
///
#include "gen/SetPropagationDelay.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPropagationDelay::CmdName = "SetPropagationDelay";
    const char* const SetPropagationDelay::Documentation = "Enable (or disable) the satellite signal propagation delay. If disabled, the signal is immediately received\nby the receiver. The delay should always be enabled, unless your are doing a PPS calibration for the simulator.";

    REGISTER_COMMAND_FACTORY(SetPropagationDelay);


    SetPropagationDelay::SetPropagationDelay()
      : CommandBase(CmdName)
    {}

    SetPropagationDelay::SetPropagationDelay(const std::string& system, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    SetPropagationDelayPtr SetPropagationDelay::create(const std::string& system, bool enabled)
    {
      return SetPropagationDelayPtr(new SetPropagationDelay(system, enabled));
    }

    SetPropagationDelayPtr SetPropagationDelay::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPropagationDelay>(ptr);
    }

    bool SetPropagationDelay::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string SetPropagationDelay::documentation() const { return Documentation; }


    int SetPropagationDelay::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPropagationDelay::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPropagationDelay::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPropagationDelay::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPropagationDelay::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPropagationDelayEnabled
///
#include "gen/IsPropagationDelayEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPropagationDelayEnabled::CmdName = "IsPropagationDelayEnabled";
    const char* const IsPropagationDelayEnabled::Documentation = "Tells if the propagation delay is enabled.";

    REGISTER_COMMAND_FACTORY(IsPropagationDelayEnabled);


    IsPropagationDelayEnabled::IsPropagationDelayEnabled()
      : CommandBase(CmdName)
    {}

    IsPropagationDelayEnabled::IsPropagationDelayEnabled(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsPropagationDelayEnabledPtr IsPropagationDelayEnabled::create(const std::string& system)
    {
      return IsPropagationDelayEnabledPtr(new IsPropagationDelayEnabled(system));
    }

    IsPropagationDelayEnabledPtr IsPropagationDelayEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPropagationDelayEnabled>(ptr);
    }

    bool IsPropagationDelayEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsPropagationDelayEnabled::documentation() const { return Documentation; }


    int IsPropagationDelayEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsPropagationDelayEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsPropagationDelayEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPropagationDelayEnabledResult
///
#include "gen/IsPropagationDelayEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPropagationDelayEnabledResult::CmdName = "IsPropagationDelayEnabledResult";
    const char* const IsPropagationDelayEnabledResult::Documentation = "Result of IsPropagationDelayEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsPropagationDelayEnabledResult);


    IsPropagationDelayEnabledResult::IsPropagationDelayEnabledResult()
      : CommandResult(CmdName)
    {}

    IsPropagationDelayEnabledResult::IsPropagationDelayEnabledResult(CommandBasePtr relatedCommand, const std::string& system, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    IsPropagationDelayEnabledResultPtr IsPropagationDelayEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, bool enabled)
    {
      return IsPropagationDelayEnabledResultPtr(new IsPropagationDelayEnabledResult(relatedCommand, system, enabled));
    }

    IsPropagationDelayEnabledResultPtr IsPropagationDelayEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPropagationDelayEnabledResult>(ptr);
    }

    bool IsPropagationDelayEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsPropagationDelayEnabledResult::documentation() const { return Documentation; }


    std::string IsPropagationDelayEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsPropagationDelayEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsPropagationDelayEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsPropagationDelayEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSatMotionFixed
///
#include "gen/SetSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSatMotionFixed::CmdName = "SetSatMotionFixed";
    const char* const SetSatMotionFixed::Documentation = "If IsFixed is set to true, the satellite will not move during the simulation and keep its initial position calculated at the beginning of the simulation.";

    REGISTER_COMMAND_FACTORY(SetSatMotionFixed);


    SetSatMotionFixed::SetSatMotionFixed()
      : CommandBase(CmdName)
    {}

    SetSatMotionFixed::SetSatMotionFixed(const std::string& system, int svId, bool isFixed)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setIsFixed(isFixed);
    }


    SetSatMotionFixedPtr SetSatMotionFixed::create(const std::string& system, int svId, bool isFixed)
    {
      return SetSatMotionFixedPtr(new SetSatMotionFixed(system, svId, isFixed));
    }

    SetSatMotionFixedPtr SetSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSatMotionFixed>(ptr);
    }

    bool SetSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string SetSatMotionFixed::documentation() const { return Documentation; }


    int SetSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSatMotionFixed::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSatMotionFixed::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatMotionFixed::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSatMotionFixed::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSatMotionFixed::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void SetSatMotionFixed::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSatMotionFixed
///
#include "gen/IsSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSatMotionFixed::CmdName = "IsSatMotionFixed";
    const char* const IsSatMotionFixed::Documentation = "Tells if the satellite is fixed (True) or not fixed (false).";

    REGISTER_COMMAND_FACTORY(IsSatMotionFixed);


    IsSatMotionFixed::IsSatMotionFixed()
      : CommandBase(CmdName)
    {}

    IsSatMotionFixed::IsSatMotionFixed(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    IsSatMotionFixedPtr IsSatMotionFixed::create(const std::string& system, int svId)
    {
      return IsSatMotionFixedPtr(new IsSatMotionFixed(system, svId));
    }

    IsSatMotionFixedPtr IsSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSatMotionFixed>(ptr);
    }

    bool IsSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsSatMotionFixed::documentation() const { return Documentation; }


    int IsSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSatMotionFixed::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSatMotionFixed::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSatMotionFixed::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSatMotionFixed::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSatMotionFixedResult
///
#include "gen/IsSatMotionFixedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSatMotionFixedResult::CmdName = "IsSatMotionFixedResult";
    const char* const IsSatMotionFixedResult::Documentation = "Result of IsSatMotionFixed";

    REGISTER_COMMAND_RESULT_FACTORY(IsSatMotionFixedResult);


    IsSatMotionFixedResult::IsSatMotionFixedResult()
      : CommandResult(CmdName)
    {}

    IsSatMotionFixedResult::IsSatMotionFixedResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool isFixed)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setIsFixed(isFixed);
    }


    IsSatMotionFixedResultPtr IsSatMotionFixedResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool isFixed)
    {
      return IsSatMotionFixedResultPtr(new IsSatMotionFixedResult(relatedCommand, system, svId, isFixed));
    }

    IsSatMotionFixedResultPtr IsSatMotionFixedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSatMotionFixedResult>(ptr);
    }

    bool IsSatMotionFixedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string IsSatMotionFixedResult::documentation() const { return Documentation; }


    std::string IsSatMotionFixedResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSatMotionFixedResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSatMotionFixedResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSatMotionFixedResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSatMotionFixedResult::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void IsSatMotionFixedResult::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoAlpha
///
#include "gen/SetIonoAlpha.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoAlpha::CmdName = "SetIonoAlpha";
    const char* const SetIonoAlpha::Documentation = "Set the GPS ionospheric Alpha coefficient\nAlpha 0 is in seconds\nAlpha 1 is in seconds/semicircle\nAlpha 2 is in seconds/semicircle^2\nAlpha 3 is in seconds/semicircle^3";

    REGISTER_COMMAND_FACTORY(SetIonoAlpha);


    SetIonoAlpha::SetIonoAlpha()
      : CommandBase(CmdName)
    {}

    SetIonoAlpha::SetIonoAlpha(int index, double val)
      : CommandBase(CmdName)
    {

      setIndex(index);
      setVal(val);
    }


    SetIonoAlphaPtr SetIonoAlpha::create(int index, double val)
    {
      return SetIonoAlphaPtr(new SetIonoAlpha(index, val));
    }

    SetIonoAlphaPtr SetIonoAlpha::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoAlpha>(ptr);
    }

    bool SetIonoAlpha::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetIonoAlpha::documentation() const { return Documentation; }


    int SetIonoAlpha::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoAlpha::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void SetIonoAlpha::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIonoAlpha::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetIonoAlpha::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoAlpha
///
#include "gen/GetIonoAlpha.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoAlpha::CmdName = "GetIonoAlpha";
    const char* const GetIonoAlpha::Documentation = "Get the GPS ionospheric Alpha coefficient\nAlpha 0 is in seconds\nAlpha 1 is in seconds/semicircle\nAlpha 2 is in seconds/semicircle^2\nAlpha 3 is in seconds/semicircle^3";

    REGISTER_COMMAND_FACTORY(GetIonoAlpha);


    GetIonoAlpha::GetIonoAlpha()
      : CommandBase(CmdName)
    {}

    GetIonoAlpha::GetIonoAlpha(int index)
      : CommandBase(CmdName)
    {

      setIndex(index);
    }


    GetIonoAlphaPtr GetIonoAlpha::create(int index)
    {
      return GetIonoAlphaPtr(new GetIonoAlpha(index));
    }

    GetIonoAlphaPtr GetIonoAlpha::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoAlpha>(ptr);
    }

    bool GetIonoAlpha::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
        ;

    }

    std::string GetIonoAlpha::documentation() const { return Documentation; }


    int GetIonoAlpha::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoAlpha::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoAlpha::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoAlphaResult
///
#include "gen/GetIonoAlphaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoAlphaResult::CmdName = "GetIonoAlphaResult";
    const char* const GetIonoAlphaResult::Documentation = "Result of GetIonoAlpha";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoAlphaResult);


    GetIonoAlphaResult::GetIonoAlphaResult()
      : CommandResult(CmdName)
    {}

    GetIonoAlphaResult::GetIonoAlphaResult(CommandBasePtr relatedCommand, int index, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setIndex(index);
      setVal(val);
    }


    GetIonoAlphaResultPtr GetIonoAlphaResult::create(CommandBasePtr relatedCommand, int index, double val)
    {
      return GetIonoAlphaResultPtr(new GetIonoAlphaResult(relatedCommand, index, val));
    }

    GetIonoAlphaResultPtr GetIonoAlphaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoAlphaResult>(ptr);
    }

    bool GetIonoAlphaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetIonoAlphaResult::documentation() const { return Documentation; }


    int GetIonoAlphaResult::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoAlphaResult::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIonoAlphaResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetIonoAlphaResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoBeta
///
#include "gen/SetIonoBeta.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoBeta::CmdName = "SetIonoBeta";
    const char* const SetIonoBeta::Documentation = "Set the GPS ionospheric Beta coefficient\nBeta 0 is in seconds\nBeta 1 is in seconds/semicircle\nBeta 2 is in seconds/semicircle^2\nBeta 3 is in seconds/semicircle^3";

    REGISTER_COMMAND_FACTORY(SetIonoBeta);


    SetIonoBeta::SetIonoBeta()
      : CommandBase(CmdName)
    {}

    SetIonoBeta::SetIonoBeta(int index, double val)
      : CommandBase(CmdName)
    {

      setIndex(index);
      setVal(val);
    }


    SetIonoBetaPtr SetIonoBeta::create(int index, double val)
    {
      return SetIonoBetaPtr(new SetIonoBeta(index, val));
    }

    SetIonoBetaPtr SetIonoBeta::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoBeta>(ptr);
    }

    bool SetIonoBeta::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetIonoBeta::documentation() const { return Documentation; }


    int SetIonoBeta::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoBeta::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void SetIonoBeta::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIonoBeta::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetIonoBeta::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoBeta
///
#include "gen/GetIonoBeta.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoBeta::CmdName = "GetIonoBeta";
    const char* const GetIonoBeta::Documentation = "Get the GPS ionospheric Beta coefficient\nBeta 0 is in seconds\nBeta 1 is in seconds/semicircle\nBeta 2 is in seconds/semicircle^2\nBeta 3 is in seconds/semicircle^3";

    REGISTER_COMMAND_FACTORY(GetIonoBeta);


    GetIonoBeta::GetIonoBeta()
      : CommandBase(CmdName)
    {}

    GetIonoBeta::GetIonoBeta(int index)
      : CommandBase(CmdName)
    {

      setIndex(index);
    }


    GetIonoBetaPtr GetIonoBeta::create(int index)
    {
      return GetIonoBetaPtr(new GetIonoBeta(index));
    }

    GetIonoBetaPtr GetIonoBeta::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoBeta>(ptr);
    }

    bool GetIonoBeta::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
        ;

    }

    std::string GetIonoBeta::documentation() const { return Documentation; }


    int GetIonoBeta::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoBeta::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoBeta::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoBetaResult
///
#include "gen/GetIonoBetaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoBetaResult::CmdName = "GetIonoBetaResult";
    const char* const GetIonoBetaResult::Documentation = "Result of GetIonoBeta";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoBetaResult);


    GetIonoBetaResult::GetIonoBetaResult()
      : CommandResult(CmdName)
    {}

    GetIonoBetaResult::GetIonoBetaResult(CommandBasePtr relatedCommand, int index, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setIndex(index);
      setVal(val);
    }


    GetIonoBetaResultPtr GetIonoBetaResult::create(CommandBasePtr relatedCommand, int index, double val)
    {
      return GetIonoBetaResultPtr(new GetIonoBetaResult(relatedCommand, index, val));
    }

    GetIonoBetaResultPtr GetIonoBetaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoBetaResult>(ptr);
    }

    bool GetIonoBetaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetIonoBetaResult::documentation() const { return Documentation; }


    int GetIonoBetaResult::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoBetaResult::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIonoBetaResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetIonoBetaResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoBdgimAlpha
///
#include "gen/SetIonoBdgimAlpha.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoBdgimAlpha::CmdName = "SetIonoBdgimAlpha";
    const char* const SetIonoBdgimAlpha::Documentation = "Set the BeiDou (BDGIM) ionospheric Alpha coefficient (in TECu)";

    REGISTER_COMMAND_FACTORY(SetIonoBdgimAlpha);


    SetIonoBdgimAlpha::SetIonoBdgimAlpha()
      : CommandBase(CmdName)
    {}

    SetIonoBdgimAlpha::SetIonoBdgimAlpha(int index, double val)
      : CommandBase(CmdName)
    {

      setIndex(index);
      setVal(val);
    }


    SetIonoBdgimAlphaPtr SetIonoBdgimAlpha::create(int index, double val)
    {
      return SetIonoBdgimAlphaPtr(new SetIonoBdgimAlpha(index, val));
    }

    SetIonoBdgimAlphaPtr SetIonoBdgimAlpha::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoBdgimAlpha>(ptr);
    }

    bool SetIonoBdgimAlpha::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetIonoBdgimAlpha::documentation() const { return Documentation; }


    int SetIonoBdgimAlpha::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoBdgimAlpha::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void SetIonoBdgimAlpha::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIonoBdgimAlpha::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetIonoBdgimAlpha::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoBdgimAlpha
///
#include "gen/GetIonoBdgimAlpha.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoBdgimAlpha::CmdName = "GetIonoBdgimAlpha";
    const char* const GetIonoBdgimAlpha::Documentation = "Get the BeiDou (BDGIM) ionospheric Alpha coefficient (in TECu)";

    REGISTER_COMMAND_FACTORY(GetIonoBdgimAlpha);


    GetIonoBdgimAlpha::GetIonoBdgimAlpha()
      : CommandBase(CmdName)
    {}

    GetIonoBdgimAlpha::GetIonoBdgimAlpha(int index)
      : CommandBase(CmdName)
    {

      setIndex(index);
    }


    GetIonoBdgimAlphaPtr GetIonoBdgimAlpha::create(int index)
    {
      return GetIonoBdgimAlphaPtr(new GetIonoBdgimAlpha(index));
    }

    GetIonoBdgimAlphaPtr GetIonoBdgimAlpha::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoBdgimAlpha>(ptr);
    }

    bool GetIonoBdgimAlpha::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
        ;

    }

    std::string GetIonoBdgimAlpha::documentation() const { return Documentation; }


    int GetIonoBdgimAlpha::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoBdgimAlpha::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoBdgimAlpha::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoBdgimAlphaResult
///
#include "gen/GetIonoBdgimAlphaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoBdgimAlphaResult::CmdName = "GetIonoBdgimAlphaResult";
    const char* const GetIonoBdgimAlphaResult::Documentation = "Result of GetIonoBdgimAlpha";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoBdgimAlphaResult);


    GetIonoBdgimAlphaResult::GetIonoBdgimAlphaResult()
      : CommandResult(CmdName)
    {}

    GetIonoBdgimAlphaResult::GetIonoBdgimAlphaResult(CommandBasePtr relatedCommand, int index, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setIndex(index);
      setVal(val);
    }


    GetIonoBdgimAlphaResultPtr GetIonoBdgimAlphaResult::create(CommandBasePtr relatedCommand, int index, double val)
    {
      return GetIonoBdgimAlphaResultPtr(new GetIonoBdgimAlphaResult(relatedCommand, index, val));
    }

    GetIonoBdgimAlphaResultPtr GetIonoBdgimAlphaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoBdgimAlphaResult>(ptr);
    }

    bool GetIonoBdgimAlphaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetIonoBdgimAlphaResult::documentation() const { return Documentation; }


    int GetIonoBdgimAlphaResult::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void GetIonoBdgimAlphaResult::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIonoBdgimAlphaResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetIonoBdgimAlphaResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoModel
///
#include "gen/SetIonoModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoModel::CmdName = "SetIonoModel";
    const char* const SetIonoModel::Documentation = "Set ionospheric model";

    REGISTER_COMMAND_FACTORY(SetIonoModel);


    SetIonoModel::SetIonoModel()
      : CommandBase(CmdName)
    {}

    SetIonoModel::SetIonoModel(const std::string& model)
      : CommandBase(CmdName)
    {

      setModel(model);
    }


    SetIonoModelPtr SetIonoModel::create(const std::string& model)
    {
      return SetIonoModelPtr(new SetIonoModel(model));
    }

    SetIonoModelPtr SetIonoModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoModel>(ptr);
    }

    bool SetIonoModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Model"])
        ;

    }

    std::string SetIonoModel::documentation() const { return Documentation; }


    int SetIonoModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetIonoModel::model() const
    {
      return parse_json<std::string>::parse(m_values["Model"]);
    }

    void SetIonoModel::setModel(const std::string& model)
    {
      m_values.AddMember("Model", parse_json<std::string>::format(model, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoModel
///
#include "gen/GetIonoModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoModel::CmdName = "GetIonoModel";
    const char* const GetIonoModel::Documentation = "Get ionospheric model";

    REGISTER_COMMAND_FACTORY(GetIonoModel);


    GetIonoModel::GetIonoModel()
      : CommandBase(CmdName)
    {

    }


    GetIonoModelPtr GetIonoModel::create()
    {
      return GetIonoModelPtr(new GetIonoModel());
    }

    GetIonoModelPtr GetIonoModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoModel>(ptr);
    }

    bool GetIonoModel::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIonoModel::documentation() const { return Documentation; }


    int GetIonoModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIonoModelResult
///
#include "gen/GetIonoModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoModelResult::CmdName = "GetIonoModelResult";
    const char* const GetIonoModelResult::Documentation = "Result of GetIonoModel";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoModelResult);


    GetIonoModelResult::GetIonoModelResult()
      : CommandResult(CmdName)
    {}

    GetIonoModelResult::GetIonoModelResult(CommandBasePtr relatedCommand, const std::string& model)
      : CommandResult(CmdName, relatedCommand)
    {

      setModel(model);
    }


    GetIonoModelResultPtr GetIonoModelResult::create(CommandBasePtr relatedCommand, const std::string& model)
    {
      return GetIonoModelResultPtr(new GetIonoModelResult(relatedCommand, model));
    }

    GetIonoModelResultPtr GetIonoModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoModelResult>(ptr);
    }

    bool GetIonoModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Model"])
        ;

    }

    std::string GetIonoModelResult::documentation() const { return Documentation; }


    std::string GetIonoModelResult::model() const
    {
      return parse_json<std::string>::parse(m_values["Model"]);
    }

    void GetIonoModelResult::setModel(const std::string& model)
    {
      m_values.AddMember("Model", parse_json<std::string>::format(model, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetTropoModel
///
#include "gen/SetTropoModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetTropoModel::CmdName = "SetTropoModel";
    const char* const SetTropoModel::Documentation = "Set tropospheric model";

    REGISTER_COMMAND_FACTORY(SetTropoModel);


    SetTropoModel::SetTropoModel()
      : CommandBase(CmdName)
    {}

    SetTropoModel::SetTropoModel(const std::string& model)
      : CommandBase(CmdName)
    {

      setModel(model);
    }


    SetTropoModelPtr SetTropoModel::create(const std::string& model)
    {
      return SetTropoModelPtr(new SetTropoModel(model));
    }

    SetTropoModelPtr SetTropoModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetTropoModel>(ptr);
    }

    bool SetTropoModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Model"])
        ;

    }

    std::string SetTropoModel::documentation() const { return Documentation; }


    int SetTropoModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetTropoModel::model() const
    {
      return parse_json<std::string>::parse(m_values["Model"]);
    }

    void SetTropoModel::setModel(const std::string& model)
    {
      m_values.AddMember("Model", parse_json<std::string>::format(model, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetTropoModel
///
#include "gen/GetTropoModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetTropoModel::CmdName = "GetTropoModel";
    const char* const GetTropoModel::Documentation = "Get tropospheric model";

    REGISTER_COMMAND_FACTORY(GetTropoModel);


    GetTropoModel::GetTropoModel()
      : CommandBase(CmdName)
    {

    }


    GetTropoModelPtr GetTropoModel::create()
    {
      return GetTropoModelPtr(new GetTropoModel());
    }

    GetTropoModelPtr GetTropoModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetTropoModel>(ptr);
    }

    bool GetTropoModel::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetTropoModel::documentation() const { return Documentation; }


    int GetTropoModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetTropoModelResult
///
#include "gen/GetTropoModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetTropoModelResult::CmdName = "GetTropoModelResult";
    const char* const GetTropoModelResult::Documentation = "Result of GetTropoModel";

    REGISTER_COMMAND_RESULT_FACTORY(GetTropoModelResult);


    GetTropoModelResult::GetTropoModelResult()
      : CommandResult(CmdName)
    {}

    GetTropoModelResult::GetTropoModelResult(CommandBasePtr relatedCommand, const std::string& model)
      : CommandResult(CmdName, relatedCommand)
    {

      setModel(model);
    }


    GetTropoModelResultPtr GetTropoModelResult::create(CommandBasePtr relatedCommand, const std::string& model)
    {
      return GetTropoModelResultPtr(new GetTropoModelResult(relatedCommand, model));
    }

    GetTropoModelResultPtr GetTropoModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetTropoModelResult>(ptr);
    }

    bool GetTropoModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Model"])
        ;

    }

    std::string GetTropoModelResult::documentation() const { return Documentation; }


    std::string GetTropoModelResult::model() const
    {
      return parse_json<std::string>::parse(m_values["Model"]);
    }

    void GetTropoModelResult::setModel(const std::string& model)
    {
      m_values.AddMember("Model", parse_json<std::string>::format(model, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetStartTimeMode
///
#include "gen/SetStartTimeMode.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetStartTimeMode::CmdName = "SetStartTimeMode";
    const char* const SetStartTimeMode::Documentation = "Set the simulation start time mode.";

    REGISTER_COMMAND_FACTORY(SetStartTimeMode);


    SetStartTimeMode::SetStartTimeMode()
      : CommandBase(CmdName)
    {}

    SetStartTimeMode::SetStartTimeMode(const std::string& mode)
      : CommandBase(CmdName)
    {

      setMode(mode);
    }


    SetStartTimeModePtr SetStartTimeMode::create(const std::string& mode)
    {
      return SetStartTimeModePtr(new SetStartTimeMode(mode));
    }

    SetStartTimeModePtr SetStartTimeMode::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetStartTimeMode>(ptr);
    }

    bool SetStartTimeMode::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Mode"])
        ;

    }

    std::string SetStartTimeMode::documentation() const { return Documentation; }


    int SetStartTimeMode::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetStartTimeMode::mode() const
    {
      return parse_json<std::string>::parse(m_values["Mode"]);
    }

    void SetStartTimeMode::setMode(const std::string& mode)
    {
      m_values.AddMember("Mode", parse_json<std::string>::format(mode, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetStartTimeMode
///
#include "gen/GetStartTimeMode.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStartTimeMode::CmdName = "GetStartTimeMode";
    const char* const GetStartTimeMode::Documentation = "Get the simulation start time mode.";

    REGISTER_COMMAND_FACTORY(GetStartTimeMode);


    GetStartTimeMode::GetStartTimeMode()
      : CommandBase(CmdName)
    {

    }


    GetStartTimeModePtr GetStartTimeMode::create()
    {
      return GetStartTimeModePtr(new GetStartTimeMode());
    }

    GetStartTimeModePtr GetStartTimeMode::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStartTimeMode>(ptr);
    }

    bool GetStartTimeMode::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetStartTimeMode::documentation() const { return Documentation; }


    int GetStartTimeMode::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetStartTimeModeResult
///
#include "gen/GetStartTimeModeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStartTimeModeResult::CmdName = "GetStartTimeModeResult";
    const char* const GetStartTimeModeResult::Documentation = "Result of GetStartTimeMode";

    REGISTER_COMMAND_RESULT_FACTORY(GetStartTimeModeResult);


    GetStartTimeModeResult::GetStartTimeModeResult()
      : CommandResult(CmdName)
    {}

    GetStartTimeModeResult::GetStartTimeModeResult(CommandBasePtr relatedCommand, const std::string& mode)
      : CommandResult(CmdName, relatedCommand)
    {

      setMode(mode);
    }


    GetStartTimeModeResultPtr GetStartTimeModeResult::create(CommandBasePtr relatedCommand, const std::string& mode)
    {
      return GetStartTimeModeResultPtr(new GetStartTimeModeResult(relatedCommand, mode));
    }

    GetStartTimeModeResultPtr GetStartTimeModeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStartTimeModeResult>(ptr);
    }

    bool GetStartTimeModeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Mode"])
        ;

    }

    std::string GetStartTimeModeResult::documentation() const { return Documentation; }


    std::string GetStartTimeModeResult::mode() const
    {
      return parse_json<std::string>::parse(m_values["Mode"]);
    }

    void GetStartTimeModeResult::setMode(const std::string& mode)
    {
      m_values.AddMember("Mode", parse_json<std::string>::format(mode, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsTimingReceiver
///
#include "gen/SetGpsTimingReceiver.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsTimingReceiver::CmdName = "SetGpsTimingReceiver";
    const char* const SetGpsTimingReceiver::Documentation = "Set the connection parameters to the GPS Receiver from which the simulator will get the simulation start time.";

    REGISTER_COMMAND_FACTORY(SetGpsTimingReceiver);


    SetGpsTimingReceiver::SetGpsTimingReceiver()
      : CommandBase(CmdName)
    {}

    SetGpsTimingReceiver::SetGpsTimingReceiver(const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
      : CommandBase(CmdName)
    {

      setPort(port);
      setBaudRate(baudRate);
      setDataBits(dataBits);
      setParity(parity);
      setStopBits(stopBits);
      setFlowControl(flowControl);
    }


    SetGpsTimingReceiverPtr SetGpsTimingReceiver::create(const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      return SetGpsTimingReceiverPtr(new SetGpsTimingReceiver(port, baudRate, dataBits, parity, stopBits, flowControl));
    }

    SetGpsTimingReceiverPtr SetGpsTimingReceiver::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsTimingReceiver>(ptr);
    }

    bool SetGpsTimingReceiver::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Port"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["BaudRate"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["DataBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortParity>>::is_valid(m_values["Parity"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["StopBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::is_valid(m_values["FlowControl"])
        ;

    }

    std::string SetGpsTimingReceiver::documentation() const { return Documentation; }


    int SetGpsTimingReceiver::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsTimingReceiver::port() const
    {
      return parse_json<std::string>::parse(m_values["Port"]);
    }

    void SetGpsTimingReceiver::setPort(const std::string& port)
    {
      m_values.AddMember("Port", parse_json<std::string>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetGpsTimingReceiver::baudRate() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["BaudRate"]);
    }

    void SetGpsTimingReceiver::setBaudRate(const Sdx::optional<int>& baudRate)
    {
      m_values.AddMember("BaudRate", parse_json<Sdx::optional<int>>::format(baudRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetGpsTimingReceiver::dataBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["DataBits"]);
    }

    void SetGpsTimingReceiver::setDataBits(const Sdx::optional<int>& dataBits)
    {
      m_values.AddMember("DataBits", parse_json<Sdx::optional<int>>::format(dataBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortParity> SetGpsTimingReceiver::parity() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortParity>>::parse(m_values["Parity"]);
    }

    void SetGpsTimingReceiver::setParity(const Sdx::optional<Sdx::SerialPortParity>& parity)
    {
      m_values.AddMember("Parity", parse_json<Sdx::optional<Sdx::SerialPortParity>>::format(parity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetGpsTimingReceiver::stopBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["StopBits"]);
    }

    void SetGpsTimingReceiver::setStopBits(const Sdx::optional<int>& stopBits)
    {
      m_values.AddMember("StopBits", parse_json<Sdx::optional<int>>::format(stopBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortFlowControl> SetGpsTimingReceiver::flowControl() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::parse(m_values["FlowControl"]);
    }

    void SetGpsTimingReceiver::setFlowControl(const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      m_values.AddMember("FlowControl", parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::format(flowControl, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsTimingReceiver
///
#include "gen/GetGpsTimingReceiver.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsTimingReceiver::CmdName = "GetGpsTimingReceiver";
    const char* const GetGpsTimingReceiver::Documentation = "Get the connection parameters to the GPS Receiver from which the simulator will get the simulation start time.";

    REGISTER_COMMAND_FACTORY(GetGpsTimingReceiver);


    GetGpsTimingReceiver::GetGpsTimingReceiver()
      : CommandBase(CmdName)
    {

    }


    GetGpsTimingReceiverPtr GetGpsTimingReceiver::create()
    {
      return GetGpsTimingReceiverPtr(new GetGpsTimingReceiver());
    }

    GetGpsTimingReceiverPtr GetGpsTimingReceiver::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsTimingReceiver>(ptr);
    }

    bool GetGpsTimingReceiver::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGpsTimingReceiver::documentation() const { return Documentation; }


    int GetGpsTimingReceiver::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsTimingReceiverResult
///
#include "gen/GetGpsTimingReceiverResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsTimingReceiverResult::CmdName = "GetGpsTimingReceiverResult";
    const char* const GetGpsTimingReceiverResult::Documentation = "Result of GetGpsTimingReceiver";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsTimingReceiverResult);


    GetGpsTimingReceiverResult::GetGpsTimingReceiverResult()
      : CommandResult(CmdName)
    {}

    GetGpsTimingReceiverResult::GetGpsTimingReceiverResult(CommandBasePtr relatedCommand, const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
      : CommandResult(CmdName, relatedCommand)
    {

      setPort(port);
      setBaudRate(baudRate);
      setDataBits(dataBits);
      setParity(parity);
      setStopBits(stopBits);
      setFlowControl(flowControl);
    }


    GetGpsTimingReceiverResultPtr GetGpsTimingReceiverResult::create(CommandBasePtr relatedCommand, const std::string& port, const Sdx::optional<int>& baudRate, const Sdx::optional<int>& dataBits, const Sdx::optional<Sdx::SerialPortParity>& parity, const Sdx::optional<int>& stopBits, const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      return GetGpsTimingReceiverResultPtr(new GetGpsTimingReceiverResult(relatedCommand, port, baudRate, dataBits, parity, stopBits, flowControl));
    }

    GetGpsTimingReceiverResultPtr GetGpsTimingReceiverResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsTimingReceiverResult>(ptr);
    }

    bool GetGpsTimingReceiverResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Port"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["BaudRate"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["DataBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortParity>>::is_valid(m_values["Parity"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["StopBits"])
          && parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::is_valid(m_values["FlowControl"])
        ;

    }

    std::string GetGpsTimingReceiverResult::documentation() const { return Documentation; }


    std::string GetGpsTimingReceiverResult::port() const
    {
      return parse_json<std::string>::parse(m_values["Port"]);
    }

    void GetGpsTimingReceiverResult::setPort(const std::string& port)
    {
      m_values.AddMember("Port", parse_json<std::string>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetGpsTimingReceiverResult::baudRate() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["BaudRate"]);
    }

    void GetGpsTimingReceiverResult::setBaudRate(const Sdx::optional<int>& baudRate)
    {
      m_values.AddMember("BaudRate", parse_json<Sdx::optional<int>>::format(baudRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetGpsTimingReceiverResult::dataBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["DataBits"]);
    }

    void GetGpsTimingReceiverResult::setDataBits(const Sdx::optional<int>& dataBits)
    {
      m_values.AddMember("DataBits", parse_json<Sdx::optional<int>>::format(dataBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortParity> GetGpsTimingReceiverResult::parity() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortParity>>::parse(m_values["Parity"]);
    }

    void GetGpsTimingReceiverResult::setParity(const Sdx::optional<Sdx::SerialPortParity>& parity)
    {
      m_values.AddMember("Parity", parse_json<Sdx::optional<Sdx::SerialPortParity>>::format(parity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetGpsTimingReceiverResult::stopBits() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["StopBits"]);
    }

    void GetGpsTimingReceiverResult::setStopBits(const Sdx::optional<int>& stopBits)
    {
      m_values.AddMember("StopBits", parse_json<Sdx::optional<int>>::format(stopBits, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<Sdx::SerialPortFlowControl> GetGpsTimingReceiverResult::flowControl() const
    {
      return parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::parse(m_values["FlowControl"]);
    }

    void GetGpsTimingReceiverResult::setFlowControl(const Sdx::optional<Sdx::SerialPortFlowControl>& flowControl)
    {
      m_values.AddMember("FlowControl", parse_json<Sdx::optional<Sdx::SerialPortFlowControl>>::format(flowControl, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetStartTimeOffset
///
#include "gen/SetStartTimeOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetStartTimeOffset::CmdName = "SetStartTimeOffset";
    const char* const SetStartTimeOffset::Documentation = "Set offset between the simulated GPS time and time given by GPS Timing receiver when using GPS Timing receiver to set the start time of the simulation.\nThis value has no effect when GPS start time is \"custom\" or \"computer\".";

    REGISTER_COMMAND_FACTORY(SetStartTimeOffset);


    SetStartTimeOffset::SetStartTimeOffset()
      : CommandBase(CmdName)
    {}

    SetStartTimeOffset::SetStartTimeOffset(int offset)
      : CommandBase(CmdName)
    {

      setOffset(offset);
    }


    SetStartTimeOffsetPtr SetStartTimeOffset::create(int offset)
    {
      return SetStartTimeOffsetPtr(new SetStartTimeOffset(offset));
    }

    SetStartTimeOffsetPtr SetStartTimeOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetStartTimeOffset>(ptr);
    }

    bool SetStartTimeOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetStartTimeOffset::documentation() const { return Documentation; }


    int SetStartTimeOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetStartTimeOffset::offset() const
    {
      return parse_json<int>::parse(m_values["Offset"]);
    }

    void SetStartTimeOffset::setOffset(int offset)
    {
      m_values.AddMember("Offset", parse_json<int>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetStartTimeOffset
///
#include "gen/GetStartTimeOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStartTimeOffset::CmdName = "GetStartTimeOffset";
    const char* const GetStartTimeOffset::Documentation = "Get offset between the simulated GPS time and time given by GPS Timing receiver when using GPS Timing receiver to set the start time of the simulation.\nThis value has no effect when GPS start time is \"custom\" or \"computer\".";

    REGISTER_COMMAND_FACTORY(GetStartTimeOffset);


    GetStartTimeOffset::GetStartTimeOffset()
      : CommandBase(CmdName)
    {

    }


    GetStartTimeOffsetPtr GetStartTimeOffset::create()
    {
      return GetStartTimeOffsetPtr(new GetStartTimeOffset());
    }

    GetStartTimeOffsetPtr GetStartTimeOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStartTimeOffset>(ptr);
    }

    bool GetStartTimeOffset::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetStartTimeOffset::documentation() const { return Documentation; }


    int GetStartTimeOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetStartTimeOffsetResult
///
#include "gen/GetStartTimeOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStartTimeOffsetResult::CmdName = "GetStartTimeOffsetResult";
    const char* const GetStartTimeOffsetResult::Documentation = "Result of GetStartTimeOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetStartTimeOffsetResult);


    GetStartTimeOffsetResult::GetStartTimeOffsetResult()
      : CommandResult(CmdName)
    {}

    GetStartTimeOffsetResult::GetStartTimeOffsetResult(CommandBasePtr relatedCommand, int offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setOffset(offset);
    }


    GetStartTimeOffsetResultPtr GetStartTimeOffsetResult::create(CommandBasePtr relatedCommand, int offset)
    {
      return GetStartTimeOffsetResultPtr(new GetStartTimeOffsetResult(relatedCommand, offset));
    }

    GetStartTimeOffsetResultPtr GetStartTimeOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStartTimeOffsetResult>(ptr);
    }

    bool GetStartTimeOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetStartTimeOffsetResult::documentation() const { return Documentation; }


    int GetStartTimeOffsetResult::offset() const
    {
      return parse_json<int>::parse(m_values["Offset"]);
    }

    void GetStartTimeOffsetResult::setOffset(int offset)
    {
      m_values.AddMember("Offset", parse_json<int>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetLeapSecond
///
#include "gen/SetLeapSecond.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetLeapSecond::CmdName = "SetLeapSecond";
    const char* const SetLeapSecond::Documentation = "Set the UTC leap seconds added since GPS epoch.";

    REGISTER_COMMAND_FACTORY(SetLeapSecond);


    SetLeapSecond::SetLeapSecond()
      : CommandBase(CmdName)
    {}

    SetLeapSecond::SetLeapSecond(int leapSecond)
      : CommandBase(CmdName)
    {

      setLeapSecond(leapSecond);
    }


    SetLeapSecondPtr SetLeapSecond::create(int leapSecond)
    {
      return SetLeapSecondPtr(new SetLeapSecond(leapSecond));
    }

    SetLeapSecondPtr SetLeapSecond::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetLeapSecond>(ptr);
    }

    bool SetLeapSecond::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["LeapSecond"])
        ;

    }

    std::string SetLeapSecond::documentation() const { return Documentation; }


    int SetLeapSecond::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetLeapSecond::leapSecond() const
    {
      return parse_json<int>::parse(m_values["LeapSecond"]);
    }

    void SetLeapSecond::setLeapSecond(int leapSecond)
    {
      m_values.AddMember("LeapSecond", parse_json<int>::format(leapSecond, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsStartTime
///
#include "gen/SetGpsStartTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsStartTime::CmdName = "SetGpsStartTime";
    const char* const SetGpsStartTime::Documentation = "Set the simulation start date and time";

    REGISTER_COMMAND_FACTORY(SetGpsStartTime);


    SetGpsStartTime::SetGpsStartTime()
      : CommandBase(CmdName)
    {}

    SetGpsStartTime::SetGpsStartTime(const Sdx::DateTime& start)
      : CommandBase(CmdName)
    {

      setStart(start);
    }


    SetGpsStartTimePtr SetGpsStartTime::create(const Sdx::DateTime& start)
    {
      return SetGpsStartTimePtr(new SetGpsStartTime(start));
    }

    SetGpsStartTimePtr SetGpsStartTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsStartTime>(ptr);
    }

    bool SetGpsStartTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::DateTime>::is_valid(m_values["Start"])
        ;

    }

    std::string SetGpsStartTime::documentation() const { return Documentation; }


    int SetGpsStartTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::DateTime SetGpsStartTime::start() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Start"]);
    }

    void SetGpsStartTime::setStart(const Sdx::DateTime& start)
    {
      m_values.AddMember("Start", parse_json<Sdx::DateTime>::format(start, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsStartTime
///
#include "gen/GetGpsStartTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsStartTime::CmdName = "GetGpsStartTime";
    const char* const GetGpsStartTime::Documentation = "Get the simulation GPS start date and time and leap second to convert into UTC time";

    REGISTER_COMMAND_FACTORY(GetGpsStartTime);


    GetGpsStartTime::GetGpsStartTime()
      : CommandBase(CmdName)
    {

    }


    GetGpsStartTimePtr GetGpsStartTime::create()
    {
      return GetGpsStartTimePtr(new GetGpsStartTime());
    }

    GetGpsStartTimePtr GetGpsStartTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsStartTime>(ptr);
    }

    bool GetGpsStartTime::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGpsStartTime::documentation() const { return Documentation; }


    int GetGpsStartTime::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsStartTimeResult
///
#include "gen/GetGpsStartTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsStartTimeResult::CmdName = "GetGpsStartTimeResult";
    const char* const GetGpsStartTimeResult::Documentation = "Result for GetGpsStartTime";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsStartTimeResult);


    GetGpsStartTimeResult::GetGpsStartTimeResult()
      : CommandResult(CmdName)
    {}

    GetGpsStartTimeResult::GetGpsStartTimeResult(CommandBasePtr relatedCommand, const Sdx::DateTime& startTime, int leapSecond)
      : CommandResult(CmdName, relatedCommand)
    {

      setStartTime(startTime);
      setLeapSecond(leapSecond);
    }


    GetGpsStartTimeResultPtr GetGpsStartTimeResult::create(CommandBasePtr relatedCommand, const Sdx::DateTime& startTime, int leapSecond)
    {
      return GetGpsStartTimeResultPtr(new GetGpsStartTimeResult(relatedCommand, startTime, leapSecond));
    }

    GetGpsStartTimeResultPtr GetGpsStartTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsStartTimeResult>(ptr);
    }

    bool GetGpsStartTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::DateTime>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["LeapSecond"])
        ;

    }

    std::string GetGpsStartTimeResult::documentation() const { return Documentation; }


    Sdx::DateTime GetGpsStartTimeResult::startTime() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["StartTime"]);
    }

    void GetGpsStartTimeResult::setStartTime(const Sdx::DateTime& startTime)
    {
      m_values.AddMember("StartTime", parse_json<Sdx::DateTime>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsStartTimeResult::leapSecond() const
    {
      return parse_json<int>::parse(m_values["LeapSecond"]);
    }

    void GetGpsStartTimeResult::setLeapSecond(int leapSecond)
    {
      m_values.AddMember("LeapSecond", parse_json<int>::format(leapSecond, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetDuration
///
#include "gen/SetDuration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetDuration::CmdName = "SetDuration";
    const char* const SetDuration::Documentation = "Set the simulation duration. The simulation will stop automatically when this duration is reached";

    REGISTER_COMMAND_FACTORY(SetDuration);


    SetDuration::SetDuration()
      : CommandBase(CmdName)
    {}

    SetDuration::SetDuration(int second)
      : CommandBase(CmdName)
    {

      setSecond(second);
    }


    SetDurationPtr SetDuration::create(int second)
    {
      return SetDurationPtr(new SetDuration(second));
    }

    SetDurationPtr SetDuration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetDuration>(ptr);
    }

    bool SetDuration::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Second"])
        ;

    }

    std::string SetDuration::documentation() const { return Documentation; }


    int SetDuration::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetDuration::second() const
    {
      return parse_json<int>::parse(m_values["Second"]);
    }

    void SetDuration::setSecond(int second)
    {
      m_values.AddMember("Second", parse_json<int>::format(second, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetDuration
///
#include "gen/GetDuration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDuration::CmdName = "GetDuration";
    const char* const GetDuration::Documentation = "Get the simulation duration.";

    REGISTER_COMMAND_FACTORY(GetDuration);


    GetDuration::GetDuration()
      : CommandBase(CmdName)
    {

    }


    GetDurationPtr GetDuration::create()
    {
      return GetDurationPtr(new GetDuration());
    }

    GetDurationPtr GetDuration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDuration>(ptr);
    }

    bool GetDuration::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetDuration::documentation() const { return Documentation; }


    int GetDuration::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetDurationResult
///
#include "gen/GetDurationResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDurationResult::CmdName = "GetDurationResult";
    const char* const GetDurationResult::Documentation = "Result of GetDuration";

    REGISTER_COMMAND_RESULT_FACTORY(GetDurationResult);


    GetDurationResult::GetDurationResult()
      : CommandResult(CmdName)
    {}

    GetDurationResult::GetDurationResult(CommandBasePtr relatedCommand, int second)
      : CommandResult(CmdName, relatedCommand)
    {

      setSecond(second);
    }


    GetDurationResultPtr GetDurationResult::create(CommandBasePtr relatedCommand, int second)
    {
      return GetDurationResultPtr(new GetDurationResult(relatedCommand, second));
    }

    GetDurationResultPtr GetDurationResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDurationResult>(ptr);
    }

    bool GetDurationResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Second"])
        ;

    }

    std::string GetDurationResult::documentation() const { return Documentation; }


    int GetDurationResult::second() const
    {
      return parse_json<int>::parse(m_values["Second"]);
    }

    void GetDurationResult::setSecond(int second)
    {
      m_values.AddMember("Second", parse_json<int>::format(second, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogRaw
///
#include "gen/EnableLogRaw.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogRaw::CmdName = "EnableLogRaw";
    const char* const EnableLogRaw::Documentation = "Enable (or disable) raw data logging (pseudorange, antenna gain, receiver position, satellite position, etc.)";

    REGISTER_COMMAND_FACTORY(EnableLogRaw);


    EnableLogRaw::EnableLogRaw()
      : CommandBase(CmdName)
    {}

    EnableLogRaw::EnableLogRaw(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableLogRawPtr EnableLogRaw::create(bool enabled)
    {
      return EnableLogRawPtr(new EnableLogRaw(enabled));
    }

    EnableLogRawPtr EnableLogRaw::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogRaw>(ptr);
    }

    bool EnableLogRaw::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLogRaw::documentation() const { return Documentation; }


    int EnableLogRaw::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogRaw::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogRaw::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogRawEnabled
///
#include "gen/IsLogRawEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogRawEnabled::CmdName = "IsLogRawEnabled";
    const char* const IsLogRawEnabled::Documentation = "Tells if raw data logging is enabled.";

    REGISTER_COMMAND_FACTORY(IsLogRawEnabled);


    IsLogRawEnabled::IsLogRawEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogRawEnabledPtr IsLogRawEnabled::create()
    {
      return IsLogRawEnabledPtr(new IsLogRawEnabled());
    }

    IsLogRawEnabledPtr IsLogRawEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogRawEnabled>(ptr);
    }

    bool IsLogRawEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogRawEnabled::documentation() const { return Documentation; }


    int IsLogRawEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogRawEnabledResult
///
#include "gen/IsLogRawEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogRawEnabledResult::CmdName = "IsLogRawEnabledResult";
    const char* const IsLogRawEnabledResult::Documentation = "Result of IsLogRawEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogRawEnabledResult);


    IsLogRawEnabledResult::IsLogRawEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogRawEnabledResult::IsLogRawEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsLogRawEnabledResultPtr IsLogRawEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsLogRawEnabledResultPtr(new IsLogRawEnabledResult(relatedCommand, enabled));
    }

    IsLogRawEnabledResultPtr IsLogRawEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogRawEnabledResult>(ptr);
    }

    bool IsLogRawEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLogRawEnabledResult::documentation() const { return Documentation; }


    bool IsLogRawEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogRawEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogDownlink
///
#include "gen/EnableLogDownlink.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogDownlink::CmdName = "EnableLogDownlink";
    const char* const EnableLogDownlink::Documentation = "Enable (or disable) downlink data logging in csv format";

    REGISTER_COMMAND_FACTORY(EnableLogDownlink);


    EnableLogDownlink::EnableLogDownlink()
      : CommandBase(CmdName)
    {}

    EnableLogDownlink::EnableLogDownlink(bool enabled, const Sdx::optional<bool>& beforeEncoding, const Sdx::optional<bool>& afterEncoding)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setBeforeEncoding(beforeEncoding);
      setAfterEncoding(afterEncoding);
    }


    EnableLogDownlinkPtr EnableLogDownlink::create(bool enabled, const Sdx::optional<bool>& beforeEncoding, const Sdx::optional<bool>& afterEncoding)
    {
      return EnableLogDownlinkPtr(new EnableLogDownlink(enabled, beforeEncoding, afterEncoding));
    }

    EnableLogDownlinkPtr EnableLogDownlink::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogDownlink>(ptr);
    }

    bool EnableLogDownlink::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["BeforeEncoding"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["AfterEncoding"])
        ;

    }

    std::string EnableLogDownlink::documentation() const { return Documentation; }


    int EnableLogDownlink::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogDownlink::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogDownlink::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> EnableLogDownlink::beforeEncoding() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["BeforeEncoding"]);
    }

    void EnableLogDownlink::setBeforeEncoding(const Sdx::optional<bool>& beforeEncoding)
    {
      m_values.AddMember("BeforeEncoding", parse_json<Sdx::optional<bool>>::format(beforeEncoding, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> EnableLogDownlink::afterEncoding() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["AfterEncoding"]);
    }

    void EnableLogDownlink::setAfterEncoding(const Sdx::optional<bool>& afterEncoding)
    {
      m_values.AddMember("AfterEncoding", parse_json<Sdx::optional<bool>>::format(afterEncoding, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogDownlinkEnabled
///
#include "gen/IsLogDownlinkEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogDownlinkEnabled::CmdName = "IsLogDownlinkEnabled";
    const char* const IsLogDownlinkEnabled::Documentation = "Tells if downlink data Logging is enabled";

    REGISTER_COMMAND_FACTORY(IsLogDownlinkEnabled);


    IsLogDownlinkEnabled::IsLogDownlinkEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogDownlinkEnabledPtr IsLogDownlinkEnabled::create()
    {
      return IsLogDownlinkEnabledPtr(new IsLogDownlinkEnabled());
    }

    IsLogDownlinkEnabledPtr IsLogDownlinkEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogDownlinkEnabled>(ptr);
    }

    bool IsLogDownlinkEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogDownlinkEnabled::documentation() const { return Documentation; }


    int IsLogDownlinkEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogDownlinkEnabledResult
///
#include "gen/IsLogDownlinkEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogDownlinkEnabledResult::CmdName = "IsLogDownlinkEnabledResult";
    const char* const IsLogDownlinkEnabledResult::Documentation = "Result of IsLogDownlinkEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogDownlinkEnabledResult);


    IsLogDownlinkEnabledResult::IsLogDownlinkEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogDownlinkEnabledResult::IsLogDownlinkEnabledResult(CommandBasePtr relatedCommand, bool enabled, const Sdx::optional<bool>& beforeEncoding, const Sdx::optional<bool>& afterEncoding)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setBeforeEncoding(beforeEncoding);
      setAfterEncoding(afterEncoding);
    }


    IsLogDownlinkEnabledResultPtr IsLogDownlinkEnabledResult::create(CommandBasePtr relatedCommand, bool enabled, const Sdx::optional<bool>& beforeEncoding, const Sdx::optional<bool>& afterEncoding)
    {
      return IsLogDownlinkEnabledResultPtr(new IsLogDownlinkEnabledResult(relatedCommand, enabled, beforeEncoding, afterEncoding));
    }

    IsLogDownlinkEnabledResultPtr IsLogDownlinkEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogDownlinkEnabledResult>(ptr);
    }

    bool IsLogDownlinkEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["BeforeEncoding"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["AfterEncoding"])
        ;

    }

    std::string IsLogDownlinkEnabledResult::documentation() const { return Documentation; }


    bool IsLogDownlinkEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogDownlinkEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> IsLogDownlinkEnabledResult::beforeEncoding() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["BeforeEncoding"]);
    }

    void IsLogDownlinkEnabledResult::setBeforeEncoding(const Sdx::optional<bool>& beforeEncoding)
    {
      m_values.AddMember("BeforeEncoding", parse_json<Sdx::optional<bool>>::format(beforeEncoding, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> IsLogDownlinkEnabledResult::afterEncoding() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["AfterEncoding"]);
    }

    void IsLogDownlinkEnabledResult::setAfterEncoding(const Sdx::optional<bool>& afterEncoding)
    {
      m_values.AddMember("AfterEncoding", parse_json<Sdx::optional<bool>>::format(afterEncoding, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogRinex
///
#include "gen/EnableLogRinex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogRinex::CmdName = "EnableLogRinex";
    const char* const EnableLogRinex::Documentation = "Enable (or disable) ephemeris data logging in RINEX v3.03 format";

    REGISTER_COMMAND_FACTORY(EnableLogRinex);


    EnableLogRinex::EnableLogRinex()
      : CommandBase(CmdName)
    {}

    EnableLogRinex::EnableLogRinex(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableLogRinexPtr EnableLogRinex::create(bool enabled)
    {
      return EnableLogRinexPtr(new EnableLogRinex(enabled));
    }

    EnableLogRinexPtr EnableLogRinex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogRinex>(ptr);
    }

    bool EnableLogRinex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLogRinex::documentation() const { return Documentation; }


    int EnableLogRinex::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogRinex::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogRinex::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogRinexEnabled
///
#include "gen/IsLogRinexEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogRinexEnabled::CmdName = "IsLogRinexEnabled";
    const char* const IsLogRinexEnabled::Documentation = "Tells if ephemeris data Logging is enabled";

    REGISTER_COMMAND_FACTORY(IsLogRinexEnabled);


    IsLogRinexEnabled::IsLogRinexEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogRinexEnabledPtr IsLogRinexEnabled::create()
    {
      return IsLogRinexEnabledPtr(new IsLogRinexEnabled());
    }

    IsLogRinexEnabledPtr IsLogRinexEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogRinexEnabled>(ptr);
    }

    bool IsLogRinexEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogRinexEnabled::documentation() const { return Documentation; }


    int IsLogRinexEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogRinexEnabledResult
///
#include "gen/IsLogRinexEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogRinexEnabledResult::CmdName = "IsLogRinexEnabledResult";
    const char* const IsLogRinexEnabledResult::Documentation = "Result of IsLogRinexEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogRinexEnabledResult);


    IsLogRinexEnabledResult::IsLogRinexEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogRinexEnabledResult::IsLogRinexEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsLogRinexEnabledResultPtr IsLogRinexEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsLogRinexEnabledResultPtr(new IsLogRinexEnabledResult(relatedCommand, enabled));
    }

    IsLogRinexEnabledResultPtr IsLogRinexEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogRinexEnabledResult>(ptr);
    }

    bool IsLogRinexEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLogRinexEnabledResult::documentation() const { return Documentation; }


    bool IsLogRinexEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogRinexEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogHILInput
///
#include "gen/EnableLogHILInput.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogHILInput::CmdName = "EnableLogHILInput";
    const char* const EnableLogHILInput::Documentation = "Enable (or disable) log of all the data received on the HIL API in a CSV format";

    REGISTER_COMMAND_FACTORY(EnableLogHILInput);


    EnableLogHILInput::EnableLogHILInput()
      : CommandBase(CmdName)
    {}

    EnableLogHILInput::EnableLogHILInput(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableLogHILInputPtr EnableLogHILInput::create(bool enabled)
    {
      return EnableLogHILInputPtr(new EnableLogHILInput(enabled));
    }

    EnableLogHILInputPtr EnableLogHILInput::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogHILInput>(ptr);
    }

    bool EnableLogHILInput::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLogHILInput::documentation() const { return Documentation; }


    int EnableLogHILInput::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogHILInput::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogHILInput::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogHILInputEnabled
///
#include "gen/IsLogHILInputEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogHILInputEnabled::CmdName = "IsLogHILInputEnabled";
    const char* const IsLogHILInputEnabled::Documentation = "Tells if data received on the HIL API logging is enabled";

    REGISTER_COMMAND_FACTORY(IsLogHILInputEnabled);


    IsLogHILInputEnabled::IsLogHILInputEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogHILInputEnabledPtr IsLogHILInputEnabled::create()
    {
      return IsLogHILInputEnabledPtr(new IsLogHILInputEnabled());
    }

    IsLogHILInputEnabledPtr IsLogHILInputEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogHILInputEnabled>(ptr);
    }

    bool IsLogHILInputEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogHILInputEnabled::documentation() const { return Documentation; }


    int IsLogHILInputEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogHILInputEnabledResult
///
#include "gen/IsLogHILInputEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogHILInputEnabledResult::CmdName = "IsLogHILInputEnabledResult";
    const char* const IsLogHILInputEnabledResult::Documentation = "Result of IsLogHILInputEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogHILInputEnabledResult);


    IsLogHILInputEnabledResult::IsLogHILInputEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogHILInputEnabledResult::IsLogHILInputEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsLogHILInputEnabledResultPtr IsLogHILInputEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsLogHILInputEnabledResultPtr(new IsLogHILInputEnabledResult(relatedCommand, enabled));
    }

    IsLogHILInputEnabledResultPtr IsLogHILInputEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogHILInputEnabledResult>(ptr);
    }

    bool IsLogHILInputEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLogHILInputEnabledResult::documentation() const { return Documentation; }


    bool IsLogHILInputEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogHILInputEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetLogRawRate
///
#include "gen/SetLogRawRate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetLogRawRate::CmdName = "SetLogRawRate";
    const char* const SetLogRawRate::Documentation = "Set Rate logging of raw data";

    REGISTER_COMMAND_FACTORY(SetLogRawRate);


    SetLogRawRate::SetLogRawRate()
      : CommandBase(CmdName)
    {}

    SetLogRawRate::SetLogRawRate(int rate)
      : CommandBase(CmdName)
    {

      setRate(rate);
    }


    SetLogRawRatePtr SetLogRawRate::create(int rate)
    {
      return SetLogRawRatePtr(new SetLogRawRate(rate));
    }

    SetLogRawRatePtr SetLogRawRate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetLogRawRate>(ptr);
    }

    bool SetLogRawRate::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Rate"])
        ;

    }

    std::string SetLogRawRate::documentation() const { return Documentation; }


    int SetLogRawRate::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetLogRawRate::rate() const
    {
      return parse_json<int>::parse(m_values["Rate"]);
    }

    void SetLogRawRate::setRate(int rate)
    {
      m_values.AddMember("Rate", parse_json<int>::format(rate, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetLogRawRate
///
#include "gen/GetLogRawRate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLogRawRate::CmdName = "GetLogRawRate";
    const char* const GetLogRawRate::Documentation = "Get Rate logging of raw data";

    REGISTER_COMMAND_FACTORY(GetLogRawRate);


    GetLogRawRate::GetLogRawRate()
      : CommandBase(CmdName)
    {

    }


    GetLogRawRatePtr GetLogRawRate::create()
    {
      return GetLogRawRatePtr(new GetLogRawRate());
    }

    GetLogRawRatePtr GetLogRawRate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLogRawRate>(ptr);
    }

    bool GetLogRawRate::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLogRawRate::documentation() const { return Documentation; }


    int GetLogRawRate::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of LogRawRateResult
///
#include "gen/LogRawRateResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const LogRawRateResult::CmdName = "LogRawRateResult";
    const char* const LogRawRateResult::Documentation = "Result of GetLogRawRate";

    REGISTER_COMMAND_RESULT_FACTORY(LogRawRateResult);


    LogRawRateResult::LogRawRateResult()
      : CommandResult(CmdName)
    {}

    LogRawRateResult::LogRawRateResult(CommandBasePtr relatedCommand, int rate)
      : CommandResult(CmdName, relatedCommand)
    {

      setRate(rate);
    }


    LogRawRateResultPtr LogRawRateResult::create(CommandBasePtr relatedCommand, int rate)
    {
      return LogRawRateResultPtr(new LogRawRateResult(relatedCommand, rate));
    }

    LogRawRateResultPtr LogRawRateResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<LogRawRateResult>(ptr);
    }

    bool LogRawRateResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Rate"])
        ;

    }

    std::string LogRawRateResult::documentation() const { return Documentation; }


    int LogRawRateResult::rate() const
    {
      return parse_json<int>::parse(m_values["Rate"]);
    }

    void LogRawRateResult::setRate(int rate)
    {
      m_values.AddMember("Rate", parse_json<int>::format(rate, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLogNmea
///
#include "gen/EnableLogNmea.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLogNmea::CmdName = "EnableLogNmea";
    const char* const EnableLogNmea::Documentation = "Set Logging of NMEA for the simulated position enable/disable.\nIf a receiver is connected, that NMEA is saved as well.";

    REGISTER_COMMAND_FACTORY(EnableLogNmea);


    EnableLogNmea::EnableLogNmea()
      : CommandBase(CmdName)
    {}

    EnableLogNmea::EnableLogNmea(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableLogNmeaPtr EnableLogNmea::create(bool enabled)
    {
      return EnableLogNmeaPtr(new EnableLogNmea(enabled));
    }

    EnableLogNmeaPtr EnableLogNmea::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLogNmea>(ptr);
    }

    bool EnableLogNmea::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLogNmea::documentation() const { return Documentation; }


    int EnableLogNmea::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableLogNmea::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLogNmea::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLogNmeaEnabled
///
#include "gen/IsLogNmeaEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogNmeaEnabled::CmdName = "IsLogNmeaEnabled";
    const char* const IsLogNmeaEnabled::Documentation = "Get Logging of NMEA for the simulated position enable/disable.\nIf a receiver is connected, that NMEA is saved as well.";

    REGISTER_COMMAND_FACTORY(IsLogNmeaEnabled);


    IsLogNmeaEnabled::IsLogNmeaEnabled()
      : CommandBase(CmdName)
    {

    }


    IsLogNmeaEnabledPtr IsLogNmeaEnabled::create()
    {
      return IsLogNmeaEnabledPtr(new IsLogNmeaEnabled());
    }

    IsLogNmeaEnabledPtr IsLogNmeaEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogNmeaEnabled>(ptr);
    }

    bool IsLogNmeaEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsLogNmeaEnabled::documentation() const { return Documentation; }


    int IsLogNmeaEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsLogNmeaEnabledResult
///
#include "gen/IsLogNmeaEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLogNmeaEnabledResult::CmdName = "IsLogNmeaEnabledResult";
    const char* const IsLogNmeaEnabledResult::Documentation = "Result of IsLogNmeaEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsLogNmeaEnabledResult);


    IsLogNmeaEnabledResult::IsLogNmeaEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLogNmeaEnabledResult::IsLogNmeaEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsLogNmeaEnabledResultPtr IsLogNmeaEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsLogNmeaEnabledResultPtr(new IsLogNmeaEnabledResult(relatedCommand, enabled));
    }

    IsLogNmeaEnabledResultPtr IsLogNmeaEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLogNmeaEnabledResult>(ptr);
    }

    bool IsLogNmeaEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLogNmeaEnabledResult::documentation() const { return Documentation; }


    bool IsLogNmeaEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLogNmeaEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetLogNmeaRate
///
#include "gen/SetLogNmeaRate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetLogNmeaRate::CmdName = "SetLogNmeaRate";
    const char* const SetLogNmeaRate::Documentation = "Set Rate logging of NMEA data";

    REGISTER_COMMAND_FACTORY(SetLogNmeaRate);


    SetLogNmeaRate::SetLogNmeaRate()
      : CommandBase(CmdName)
    {}

    SetLogNmeaRate::SetLogNmeaRate(int rate)
      : CommandBase(CmdName)
    {

      setRate(rate);
    }


    SetLogNmeaRatePtr SetLogNmeaRate::create(int rate)
    {
      return SetLogNmeaRatePtr(new SetLogNmeaRate(rate));
    }

    SetLogNmeaRatePtr SetLogNmeaRate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetLogNmeaRate>(ptr);
    }

    bool SetLogNmeaRate::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Rate"])
        ;

    }

    std::string SetLogNmeaRate::documentation() const { return Documentation; }


    int SetLogNmeaRate::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetLogNmeaRate::rate() const
    {
      return parse_json<int>::parse(m_values["Rate"]);
    }

    void SetLogNmeaRate::setRate(int rate)
    {
      m_values.AddMember("Rate", parse_json<int>::format(rate, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetLogNmeaRate
///
#include "gen/GetLogNmeaRate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLogNmeaRate::CmdName = "GetLogNmeaRate";
    const char* const GetLogNmeaRate::Documentation = "Get Rate logging of NMEA data";

    REGISTER_COMMAND_FACTORY(GetLogNmeaRate);


    GetLogNmeaRate::GetLogNmeaRate()
      : CommandBase(CmdName)
    {

    }


    GetLogNmeaRatePtr GetLogNmeaRate::create()
    {
      return GetLogNmeaRatePtr(new GetLogNmeaRate());
    }

    GetLogNmeaRatePtr GetLogNmeaRate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLogNmeaRate>(ptr);
    }

    bool GetLogNmeaRate::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLogNmeaRate::documentation() const { return Documentation; }


    int GetLogNmeaRate::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of LogNmeaRateResult
///
#include "gen/LogNmeaRateResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const LogNmeaRateResult::CmdName = "LogNmeaRateResult";
    const char* const LogNmeaRateResult::Documentation = "Result of GetLogNmeaRate";

    REGISTER_COMMAND_RESULT_FACTORY(LogNmeaRateResult);


    LogNmeaRateResult::LogNmeaRateResult()
      : CommandResult(CmdName)
    {}

    LogNmeaRateResult::LogNmeaRateResult(CommandBasePtr relatedCommand, int rate)
      : CommandResult(CmdName, relatedCommand)
    {

      setRate(rate);
    }


    LogNmeaRateResultPtr LogNmeaRateResult::create(CommandBasePtr relatedCommand, int rate)
    {
      return LogNmeaRateResultPtr(new LogNmeaRateResult(relatedCommand, rate));
    }

    LogNmeaRateResultPtr LogNmeaRateResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<LogNmeaRateResult>(ptr);
    }

    bool LogNmeaRateResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Rate"])
        ;

    }

    std::string LogNmeaRateResult::documentation() const { return Documentation; }


    int LogNmeaRateResult::rate() const
    {
      return parse_json<int>::parse(m_values["Rate"]);
    }

    void LogNmeaRateResult::setRate(int rate)
    {
      m_values.AddMember("Rate", parse_json<int>::format(rate, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableMasterPps
///
#include "gen/EnableMasterPps.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableMasterPps::CmdName = "EnableMasterPps";
    const char* const EnableMasterPps::Documentation = "Enable/Disable Time Synchronization Master.\nThe Master will control other Skydel simulators with Slave PPS Enabled.";

    REGISTER_COMMAND_FACTORY(EnableMasterPps);


    EnableMasterPps::EnableMasterPps()
      : CommandBase(CmdName)
    {}

    EnableMasterPps::EnableMasterPps(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableMasterPpsPtr EnableMasterPps::create(bool enabled)
    {
      return EnableMasterPpsPtr(new EnableMasterPps(enabled));
    }

    EnableMasterPpsPtr EnableMasterPps::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableMasterPps>(ptr);
    }

    bool EnableMasterPps::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableMasterPps::documentation() const { return Documentation; }


    int EnableMasterPps::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableMasterPps::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableMasterPps::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMasterStatus
///
#include "gen/GetMasterStatus.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMasterStatus::CmdName = "GetMasterStatus";
    const char* const GetMasterStatus::Documentation = "Request for the master status, returns a GetMasterStatusResult";

    REGISTER_COMMAND_FACTORY(GetMasterStatus);


    GetMasterStatus::GetMasterStatus()
      : CommandBase(CmdName)
    {

    }


    GetMasterStatusPtr GetMasterStatus::create()
    {
      return GetMasterStatusPtr(new GetMasterStatus());
    }

    GetMasterStatusPtr GetMasterStatus::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMasterStatus>(ptr);
    }

    bool GetMasterStatus::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetMasterStatus::documentation() const { return Documentation; }


    int GetMasterStatus::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetMasterStatusResult
///
#include "gen/GetMasterStatusResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMasterStatusResult::CmdName = "GetMasterStatusResult";
    const char* const GetMasterStatusResult::Documentation = "Result of GetMasterStatus";

    REGISTER_COMMAND_RESULT_FACTORY(GetMasterStatusResult);


    GetMasterStatusResult::GetMasterStatusResult()
      : CommandResult(CmdName)
    {}

    GetMasterStatusResult::GetMasterStatusResult(CommandBasePtr relatedCommand, bool isMaster, int slaveConnected, int port)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsMaster(isMaster);
      setSlaveConnected(slaveConnected);
      setPort(port);
    }


    GetMasterStatusResultPtr GetMasterStatusResult::create(CommandBasePtr relatedCommand, bool isMaster, int slaveConnected, int port)
    {
      return GetMasterStatusResultPtr(new GetMasterStatusResult(relatedCommand, isMaster, slaveConnected, port));
    }

    GetMasterStatusResultPtr GetMasterStatusResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMasterStatusResult>(ptr);
    }

    bool GetMasterStatusResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsMaster"])
          && parse_json<int>::is_valid(m_values["SlaveConnected"])
          && parse_json<int>::is_valid(m_values["Port"])
        ;

    }

    std::string GetMasterStatusResult::documentation() const { return Documentation; }


    bool GetMasterStatusResult::isMaster() const
    {
      return parse_json<bool>::parse(m_values["IsMaster"]);
    }

    void GetMasterStatusResult::setIsMaster(bool isMaster)
    {
      m_values.AddMember("IsMaster", parse_json<bool>::format(isMaster, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMasterStatusResult::slaveConnected() const
    {
      return parse_json<int>::parse(m_values["SlaveConnected"]);
    }

    void GetMasterStatusResult::setSlaveConnected(int slaveConnected)
    {
      m_values.AddMember("SlaveConnected", parse_json<int>::format(slaveConnected, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMasterStatusResult::port() const
    {
      return parse_json<int>::parse(m_values["Port"]);
    }

    void GetMasterStatusResult::setPort(int port)
    {
      m_values.AddMember("Port", parse_json<int>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSlavePps
///
#include "gen/EnableSlavePps.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSlavePps::CmdName = "EnableSlavePps";
    const char* const EnableSlavePps::Documentation = "Enable/Disable Time Synchronization Slave.\nThe Slave will wait for the Master to synchronize the simulators.";

    REGISTER_COMMAND_FACTORY(EnableSlavePps);


    EnableSlavePps::EnableSlavePps()
      : CommandBase(CmdName)
    {}

    EnableSlavePps::EnableSlavePps(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableSlavePpsPtr EnableSlavePps::create(bool enabled)
    {
      return EnableSlavePpsPtr(new EnableSlavePps(enabled));
    }

    EnableSlavePpsPtr EnableSlavePps::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSlavePps>(ptr);
    }

    bool EnableSlavePps::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSlavePps::documentation() const { return Documentation; }


    int EnableSlavePps::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableSlavePps::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSlavePps::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSlaveStatus
///
#include "gen/GetSlaveStatus.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSlaveStatus::CmdName = "GetSlaveStatus";
    const char* const GetSlaveStatus::Documentation = "Request for the slave status, returns a GetSlaveStatusResult";

    REGISTER_COMMAND_FACTORY(GetSlaveStatus);


    GetSlaveStatus::GetSlaveStatus()
      : CommandBase(CmdName)
    {

    }


    GetSlaveStatusPtr GetSlaveStatus::create()
    {
      return GetSlaveStatusPtr(new GetSlaveStatus());
    }

    GetSlaveStatusPtr GetSlaveStatus::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSlaveStatus>(ptr);
    }

    bool GetSlaveStatus::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSlaveStatus::documentation() const { return Documentation; }


    int GetSlaveStatus::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetSlaveStatusResult
///
#include "gen/GetSlaveStatusResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSlaveStatusResult::CmdName = "GetSlaveStatusResult";
    const char* const GetSlaveStatusResult::Documentation = "Result of GetSlaveStatus";

    REGISTER_COMMAND_RESULT_FACTORY(GetSlaveStatusResult);


    GetSlaveStatusResult::GetSlaveStatusResult()
      : CommandResult(CmdName)
    {}

    GetSlaveStatusResult::GetSlaveStatusResult(CommandBasePtr relatedCommand, bool isSlave, bool isConnected, const std::string& hostName, int hostPort)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsSlave(isSlave);
      setIsConnected(isConnected);
      setHostName(hostName);
      setHostPort(hostPort);
    }


    GetSlaveStatusResultPtr GetSlaveStatusResult::create(CommandBasePtr relatedCommand, bool isSlave, bool isConnected, const std::string& hostName, int hostPort)
    {
      return GetSlaveStatusResultPtr(new GetSlaveStatusResult(relatedCommand, isSlave, isConnected, hostName, hostPort));
    }

    GetSlaveStatusResultPtr GetSlaveStatusResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSlaveStatusResult>(ptr);
    }

    bool GetSlaveStatusResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsSlave"])
          && parse_json<bool>::is_valid(m_values["IsConnected"])
          && parse_json<std::string>::is_valid(m_values["HostName"])
          && parse_json<int>::is_valid(m_values["HostPort"])
        ;

    }

    std::string GetSlaveStatusResult::documentation() const { return Documentation; }


    bool GetSlaveStatusResult::isSlave() const
    {
      return parse_json<bool>::parse(m_values["IsSlave"]);
    }

    void GetSlaveStatusResult::setIsSlave(bool isSlave)
    {
      m_values.AddMember("IsSlave", parse_json<bool>::format(isSlave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetSlaveStatusResult::isConnected() const
    {
      return parse_json<bool>::parse(m_values["IsConnected"]);
    }

    void GetSlaveStatusResult::setIsConnected(bool isConnected)
    {
      m_values.AddMember("IsConnected", parse_json<bool>::format(isConnected, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSlaveStatusResult::hostName() const
    {
      return parse_json<std::string>::parse(m_values["HostName"]);
    }

    void GetSlaveStatusResult::setHostName(const std::string& hostName)
    {
      m_values.AddMember("HostName", parse_json<std::string>::format(hostName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSlaveStatusResult::hostPort() const
    {
      return parse_json<int>::parse(m_values["HostPort"]);
    }

    void GetSlaveStatusResult::setHostPort(int hostPort)
    {
      m_values.AddMember("HostPort", parse_json<int>::format(hostPort, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetLeapSecondFuture
///
#include "gen/SetLeapSecondFuture.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetLeapSecondFuture::CmdName = "SetLeapSecondFuture";
    const char* const SetLeapSecondFuture::Documentation = "Set the next leap second event";

    REGISTER_COMMAND_FACTORY(SetLeapSecondFuture);


    SetLeapSecondFuture::SetLeapSecondFuture()
      : CommandBase(CmdName)
    {}

    SetLeapSecondFuture::SetLeapSecondFuture(bool enabled, int seconds, const Sdx::Date& date)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setSeconds(seconds);
      setDate(date);
    }


    SetLeapSecondFuturePtr SetLeapSecondFuture::create(bool enabled, int seconds, const Sdx::Date& date)
    {
      return SetLeapSecondFuturePtr(new SetLeapSecondFuture(enabled, seconds, date));
    }

    SetLeapSecondFuturePtr SetLeapSecondFuture::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetLeapSecondFuture>(ptr);
    }

    bool SetLeapSecondFuture::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["Seconds"])
          && parse_json<Sdx::Date>::is_valid(m_values["Date"])
        ;

    }

    std::string SetLeapSecondFuture::documentation() const { return Documentation; }


    int SetLeapSecondFuture::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool SetLeapSecondFuture::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetLeapSecondFuture::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetLeapSecondFuture::seconds() const
    {
      return parse_json<int>::parse(m_values["Seconds"]);
    }

    void SetLeapSecondFuture::setSeconds(int seconds)
    {
      m_values.AddMember("Seconds", parse_json<int>::format(seconds, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::Date SetLeapSecondFuture::date() const
    {
      return parse_json<Sdx::Date>::parse(m_values["Date"]);
    }

    void SetLeapSecondFuture::setDate(const Sdx::Date& date)
    {
      m_values.AddMember("Date", parse_json<Sdx::Date>::format(date, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetLeapSecondFuture
///
#include "gen/GetLeapSecondFuture.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLeapSecondFuture::CmdName = "GetLeapSecondFuture";
    const char* const GetLeapSecondFuture::Documentation = "Get the next leap second event";

    REGISTER_COMMAND_FACTORY(GetLeapSecondFuture);


    GetLeapSecondFuture::GetLeapSecondFuture()
      : CommandBase(CmdName)
    {

    }


    GetLeapSecondFuturePtr GetLeapSecondFuture::create()
    {
      return GetLeapSecondFuturePtr(new GetLeapSecondFuture());
    }

    GetLeapSecondFuturePtr GetLeapSecondFuture::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLeapSecondFuture>(ptr);
    }

    bool GetLeapSecondFuture::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLeapSecondFuture::documentation() const { return Documentation; }


    int GetLeapSecondFuture::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetLeapSecondFutureResult
///
#include "gen/GetLeapSecondFutureResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLeapSecondFutureResult::CmdName = "GetLeapSecondFutureResult";
    const char* const GetLeapSecondFutureResult::Documentation = "Result of GetLeapSecondFuture";

    REGISTER_COMMAND_RESULT_FACTORY(GetLeapSecondFutureResult);


    GetLeapSecondFutureResult::GetLeapSecondFutureResult()
      : CommandResult(CmdName)
    {}

    GetLeapSecondFutureResult::GetLeapSecondFutureResult(CommandBasePtr relatedCommand, bool enabled, int seconds, const Sdx::Date& date)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setSeconds(seconds);
      setDate(date);
    }


    GetLeapSecondFutureResultPtr GetLeapSecondFutureResult::create(CommandBasePtr relatedCommand, bool enabled, int seconds, const Sdx::Date& date)
    {
      return GetLeapSecondFutureResultPtr(new GetLeapSecondFutureResult(relatedCommand, enabled, seconds, date));
    }

    GetLeapSecondFutureResultPtr GetLeapSecondFutureResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLeapSecondFutureResult>(ptr);
    }

    bool GetLeapSecondFutureResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["Seconds"])
          && parse_json<Sdx::Date>::is_valid(m_values["Date"])
        ;

    }

    std::string GetLeapSecondFutureResult::documentation() const { return Documentation; }


    bool GetLeapSecondFutureResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetLeapSecondFutureResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetLeapSecondFutureResult::seconds() const
    {
      return parse_json<int>::parse(m_values["Seconds"]);
    }

    void GetLeapSecondFutureResult::setSeconds(int seconds)
    {
      m_values.AddMember("Seconds", parse_json<int>::format(seconds, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::Date GetLeapSecondFutureResult::date() const
    {
      return parse_json<Sdx::Date>::parse(m_values["Date"]);
    }

    void GetLeapSecondFutureResult::setDate(const Sdx::Date& date)
    {
      m_values.AddMember("Date", parse_json<Sdx::Date>::format(date, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSignalStrengthModel
///
#include "gen/EnableSignalStrengthModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSignalStrengthModel::CmdName = "EnableSignalStrengthModel";
    const char* const EnableSignalStrengthModel::Documentation = "Set signal strength model Enable/Disable which affect satellite transmission strength based on their elevation angle";

    REGISTER_COMMAND_FACTORY(EnableSignalStrengthModel);


    EnableSignalStrengthModel::EnableSignalStrengthModel()
      : CommandBase(CmdName)
    {}

    EnableSignalStrengthModel::EnableSignalStrengthModel(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableSignalStrengthModelPtr EnableSignalStrengthModel::create(bool enabled)
    {
      return EnableSignalStrengthModelPtr(new EnableSignalStrengthModel(enabled));
    }

    EnableSignalStrengthModelPtr EnableSignalStrengthModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSignalStrengthModel>(ptr);
    }

    bool EnableSignalStrengthModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSignalStrengthModel::documentation() const { return Documentation; }


    int EnableSignalStrengthModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableSignalStrengthModel::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSignalStrengthModel::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalStrengthModelEnabled
///
#include "gen/IsSignalStrengthModelEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalStrengthModelEnabled::CmdName = "IsSignalStrengthModelEnabled";
    const char* const IsSignalStrengthModelEnabled::Documentation = "Get signal strength model Enable/Disable which affect satellite transmission strength based on their elevation angle";

    REGISTER_COMMAND_FACTORY(IsSignalStrengthModelEnabled);


    IsSignalStrengthModelEnabled::IsSignalStrengthModelEnabled()
      : CommandBase(CmdName)
    {

    }


    IsSignalStrengthModelEnabledPtr IsSignalStrengthModelEnabled::create()
    {
      return IsSignalStrengthModelEnabledPtr(new IsSignalStrengthModelEnabled());
    }

    IsSignalStrengthModelEnabledPtr IsSignalStrengthModelEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalStrengthModelEnabled>(ptr);
    }

    bool IsSignalStrengthModelEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsSignalStrengthModelEnabled::documentation() const { return Documentation; }


    int IsSignalStrengthModelEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsSignalStrengthModelEnabledResult
///
#include "gen/IsSignalStrengthModelEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalStrengthModelEnabledResult::CmdName = "IsSignalStrengthModelEnabledResult";
    const char* const IsSignalStrengthModelEnabledResult::Documentation = "Result of IsSignalStrengthModelEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsSignalStrengthModelEnabledResult);


    IsSignalStrengthModelEnabledResult::IsSignalStrengthModelEnabledResult()
      : CommandResult(CmdName)
    {}

    IsSignalStrengthModelEnabledResult::IsSignalStrengthModelEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsSignalStrengthModelEnabledResultPtr IsSignalStrengthModelEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsSignalStrengthModelEnabledResultPtr(new IsSignalStrengthModelEnabledResult(relatedCommand, enabled));
    }

    IsSignalStrengthModelEnabledResultPtr IsSignalStrengthModelEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalStrengthModelEnabledResult>(ptr);
    }

    bool IsSignalStrengthModelEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSignalStrengthModelEnabledResult::documentation() const { return Documentation; }


    bool IsSignalStrengthModelEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSignalStrengthModelEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableElevationMaskBelow
///
#include "gen/EnableElevationMaskBelow.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableElevationMaskBelow::CmdName = "EnableElevationMaskBelow";
    const char* const EnableElevationMaskBelow::Documentation = "Set GNSS satellite mask based on elevation enabled or disabled (See SetElevationMaskBelow).";

    REGISTER_COMMAND_FACTORY(EnableElevationMaskBelow);


    EnableElevationMaskBelow::EnableElevationMaskBelow()
      : CommandBase(CmdName)
    {}

    EnableElevationMaskBelow::EnableElevationMaskBelow(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableElevationMaskBelowPtr EnableElevationMaskBelow::create(bool enabled)
    {
      return EnableElevationMaskBelowPtr(new EnableElevationMaskBelow(enabled));
    }

    EnableElevationMaskBelowPtr EnableElevationMaskBelow::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableElevationMaskBelow>(ptr);
    }

    bool EnableElevationMaskBelow::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableElevationMaskBelow::documentation() const { return Documentation; }


    int EnableElevationMaskBelow::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableElevationMaskBelow::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableElevationMaskBelow::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsElevationMaskBelowEnabled
///
#include "gen/IsElevationMaskBelowEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsElevationMaskBelowEnabled::CmdName = "IsElevationMaskBelowEnabled";
    const char* const IsElevationMaskBelowEnabled::Documentation = "Get GNSS satellite mask based on elevation enabled or disabled (See SetElevationMaskBelow).";

    REGISTER_COMMAND_FACTORY(IsElevationMaskBelowEnabled);


    IsElevationMaskBelowEnabled::IsElevationMaskBelowEnabled()
      : CommandBase(CmdName)
    {

    }


    IsElevationMaskBelowEnabledPtr IsElevationMaskBelowEnabled::create()
    {
      return IsElevationMaskBelowEnabledPtr(new IsElevationMaskBelowEnabled());
    }

    IsElevationMaskBelowEnabledPtr IsElevationMaskBelowEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsElevationMaskBelowEnabled>(ptr);
    }

    bool IsElevationMaskBelowEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsElevationMaskBelowEnabled::documentation() const { return Documentation; }


    int IsElevationMaskBelowEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsElevationMaskBelowEnabledResult
///
#include "gen/IsElevationMaskBelowEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsElevationMaskBelowEnabledResult::CmdName = "IsElevationMaskBelowEnabledResult";
    const char* const IsElevationMaskBelowEnabledResult::Documentation = "Result of IsElevationMaskBelowEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsElevationMaskBelowEnabledResult);


    IsElevationMaskBelowEnabledResult::IsElevationMaskBelowEnabledResult()
      : CommandResult(CmdName)
    {}

    IsElevationMaskBelowEnabledResult::IsElevationMaskBelowEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsElevationMaskBelowEnabledResultPtr IsElevationMaskBelowEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsElevationMaskBelowEnabledResultPtr(new IsElevationMaskBelowEnabledResult(relatedCommand, enabled));
    }

    IsElevationMaskBelowEnabledResultPtr IsElevationMaskBelowEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsElevationMaskBelowEnabledResult>(ptr);
    }

    bool IsElevationMaskBelowEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsElevationMaskBelowEnabledResult::documentation() const { return Documentation; }


    bool IsElevationMaskBelowEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsElevationMaskBelowEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableElevationMaskAbove
///
#include "gen/EnableElevationMaskAbove.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableElevationMaskAbove::CmdName = "EnableElevationMaskAbove";
    const char* const EnableElevationMaskAbove::Documentation = "Set GNSS satellite mask based on elevation enabled or disabled (See SetElevationMaskAbove).";

    REGISTER_COMMAND_FACTORY(EnableElevationMaskAbove);


    EnableElevationMaskAbove::EnableElevationMaskAbove()
      : CommandBase(CmdName)
    {}

    EnableElevationMaskAbove::EnableElevationMaskAbove(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableElevationMaskAbovePtr EnableElevationMaskAbove::create(bool enabled)
    {
      return EnableElevationMaskAbovePtr(new EnableElevationMaskAbove(enabled));
    }

    EnableElevationMaskAbovePtr EnableElevationMaskAbove::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableElevationMaskAbove>(ptr);
    }

    bool EnableElevationMaskAbove::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableElevationMaskAbove::documentation() const { return Documentation; }


    int EnableElevationMaskAbove::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableElevationMaskAbove::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableElevationMaskAbove::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsElevationMaskAboveEnabled
///
#include "gen/IsElevationMaskAboveEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsElevationMaskAboveEnabled::CmdName = "IsElevationMaskAboveEnabled";
    const char* const IsElevationMaskAboveEnabled::Documentation = "Get GNSS satellite mask based on elevation enabled or disabled (See SetElevationMaskAbove).";

    REGISTER_COMMAND_FACTORY(IsElevationMaskAboveEnabled);


    IsElevationMaskAboveEnabled::IsElevationMaskAboveEnabled()
      : CommandBase(CmdName)
    {

    }


    IsElevationMaskAboveEnabledPtr IsElevationMaskAboveEnabled::create()
    {
      return IsElevationMaskAboveEnabledPtr(new IsElevationMaskAboveEnabled());
    }

    IsElevationMaskAboveEnabledPtr IsElevationMaskAboveEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsElevationMaskAboveEnabled>(ptr);
    }

    bool IsElevationMaskAboveEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsElevationMaskAboveEnabled::documentation() const { return Documentation; }


    int IsElevationMaskAboveEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsElevationMaskAboveEnabledResult
///
#include "gen/IsElevationMaskAboveEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsElevationMaskAboveEnabledResult::CmdName = "IsElevationMaskAboveEnabledResult";
    const char* const IsElevationMaskAboveEnabledResult::Documentation = "Result of IsElevationMaskAboveEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsElevationMaskAboveEnabledResult);


    IsElevationMaskAboveEnabledResult::IsElevationMaskAboveEnabledResult()
      : CommandResult(CmdName)
    {}

    IsElevationMaskAboveEnabledResult::IsElevationMaskAboveEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsElevationMaskAboveEnabledResultPtr IsElevationMaskAboveEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsElevationMaskAboveEnabledResultPtr(new IsElevationMaskAboveEnabledResult(relatedCommand, enabled));
    }

    IsElevationMaskAboveEnabledResultPtr IsElevationMaskAboveEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsElevationMaskAboveEnabledResult>(ptr);
    }

    bool IsElevationMaskAboveEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsElevationMaskAboveEnabledResult::documentation() const { return Documentation; }


    bool IsElevationMaskAboveEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsElevationMaskAboveEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetElevationMaskBelow
///
#include "gen/SetElevationMaskBelow.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetElevationMaskBelow::CmdName = "SetElevationMaskBelow";
    const char* const SetElevationMaskBelow::Documentation = "Set elevation mask angle. See command EnableElevationMaskBelow";

    REGISTER_COMMAND_FACTORY(SetElevationMaskBelow);


    SetElevationMaskBelow::SetElevationMaskBelow()
      : CommandBase(CmdName)
    {}

    SetElevationMaskBelow::SetElevationMaskBelow(double angle)
      : CommandBase(CmdName)
    {

      setAngle(angle);
    }


    SetElevationMaskBelowPtr SetElevationMaskBelow::create(double angle)
    {
      return SetElevationMaskBelowPtr(new SetElevationMaskBelow(angle));
    }

    SetElevationMaskBelowPtr SetElevationMaskBelow::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetElevationMaskBelow>(ptr);
    }

    bool SetElevationMaskBelow::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Angle"])
        ;

    }

    std::string SetElevationMaskBelow::documentation() const { return Documentation; }


    int SetElevationMaskBelow::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetElevationMaskBelow::angle() const
    {
      return parse_json<double>::parse(m_values["Angle"]);
    }

    void SetElevationMaskBelow::setAngle(double angle)
    {
      m_values.AddMember("Angle", parse_json<double>::format(angle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetElevationMaskBelow
///
#include "gen/GetElevationMaskBelow.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationMaskBelow::CmdName = "GetElevationMaskBelow";
    const char* const GetElevationMaskBelow::Documentation = "Get elevation mask angle. See command EnableElevationMaskBelow";

    REGISTER_COMMAND_FACTORY(GetElevationMaskBelow);


    GetElevationMaskBelow::GetElevationMaskBelow()
      : CommandBase(CmdName)
    {

    }


    GetElevationMaskBelowPtr GetElevationMaskBelow::create()
    {
      return GetElevationMaskBelowPtr(new GetElevationMaskBelow());
    }

    GetElevationMaskBelowPtr GetElevationMaskBelow::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationMaskBelow>(ptr);
    }

    bool GetElevationMaskBelow::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetElevationMaskBelow::documentation() const { return Documentation; }


    int GetElevationMaskBelow::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetElevationMaskBelowResult
///
#include "gen/GetElevationMaskBelowResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationMaskBelowResult::CmdName = "GetElevationMaskBelowResult";
    const char* const GetElevationMaskBelowResult::Documentation = "Result of GetElevationMaskBelow";

    REGISTER_COMMAND_RESULT_FACTORY(GetElevationMaskBelowResult);


    GetElevationMaskBelowResult::GetElevationMaskBelowResult()
      : CommandResult(CmdName)
    {}

    GetElevationMaskBelowResult::GetElevationMaskBelowResult(CommandBasePtr relatedCommand, double angle)
      : CommandResult(CmdName, relatedCommand)
    {

      setAngle(angle);
    }


    GetElevationMaskBelowResultPtr GetElevationMaskBelowResult::create(CommandBasePtr relatedCommand, double angle)
    {
      return GetElevationMaskBelowResultPtr(new GetElevationMaskBelowResult(relatedCommand, angle));
    }

    GetElevationMaskBelowResultPtr GetElevationMaskBelowResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationMaskBelowResult>(ptr);
    }

    bool GetElevationMaskBelowResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Angle"])
        ;

    }

    std::string GetElevationMaskBelowResult::documentation() const { return Documentation; }


    double GetElevationMaskBelowResult::angle() const
    {
      return parse_json<double>::parse(m_values["Angle"]);
    }

    void GetElevationMaskBelowResult::setAngle(double angle)
    {
      m_values.AddMember("Angle", parse_json<double>::format(angle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetElevationMaskAbove
///
#include "gen/SetElevationMaskAbove.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetElevationMaskAbove::CmdName = "SetElevationMaskAbove";
    const char* const SetElevationMaskAbove::Documentation = "Set elevation mask angle. See command EnableElevationMaskAbove";

    REGISTER_COMMAND_FACTORY(SetElevationMaskAbove);


    SetElevationMaskAbove::SetElevationMaskAbove()
      : CommandBase(CmdName)
    {}

    SetElevationMaskAbove::SetElevationMaskAbove(double angle)
      : CommandBase(CmdName)
    {

      setAngle(angle);
    }


    SetElevationMaskAbovePtr SetElevationMaskAbove::create(double angle)
    {
      return SetElevationMaskAbovePtr(new SetElevationMaskAbove(angle));
    }

    SetElevationMaskAbovePtr SetElevationMaskAbove::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetElevationMaskAbove>(ptr);
    }

    bool SetElevationMaskAbove::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Angle"])
        ;

    }

    std::string SetElevationMaskAbove::documentation() const { return Documentation; }


    int SetElevationMaskAbove::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetElevationMaskAbove::angle() const
    {
      return parse_json<double>::parse(m_values["Angle"]);
    }

    void SetElevationMaskAbove::setAngle(double angle)
    {
      m_values.AddMember("Angle", parse_json<double>::format(angle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetElevationMaskAbove
///
#include "gen/GetElevationMaskAbove.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationMaskAbove::CmdName = "GetElevationMaskAbove";
    const char* const GetElevationMaskAbove::Documentation = "Get elevation mask angle. See command EnableElevationMaskAbove";

    REGISTER_COMMAND_FACTORY(GetElevationMaskAbove);


    GetElevationMaskAbove::GetElevationMaskAbove()
      : CommandBase(CmdName)
    {

    }


    GetElevationMaskAbovePtr GetElevationMaskAbove::create()
    {
      return GetElevationMaskAbovePtr(new GetElevationMaskAbove());
    }

    GetElevationMaskAbovePtr GetElevationMaskAbove::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationMaskAbove>(ptr);
    }

    bool GetElevationMaskAbove::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetElevationMaskAbove::documentation() const { return Documentation; }


    int GetElevationMaskAbove::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetElevationMaskAboveResult
///
#include "gen/GetElevationMaskAboveResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetElevationMaskAboveResult::CmdName = "GetElevationMaskAboveResult";
    const char* const GetElevationMaskAboveResult::Documentation = "Result of GetElevationMaskAbove";

    REGISTER_COMMAND_RESULT_FACTORY(GetElevationMaskAboveResult);


    GetElevationMaskAboveResult::GetElevationMaskAboveResult()
      : CommandResult(CmdName)
    {}

    GetElevationMaskAboveResult::GetElevationMaskAboveResult(CommandBasePtr relatedCommand, double angle)
      : CommandResult(CmdName, relatedCommand)
    {

      setAngle(angle);
    }


    GetElevationMaskAboveResultPtr GetElevationMaskAboveResult::create(CommandBasePtr relatedCommand, double angle)
    {
      return GetElevationMaskAboveResultPtr(new GetElevationMaskAboveResult(relatedCommand, angle));
    }

    GetElevationMaskAboveResultPtr GetElevationMaskAboveResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetElevationMaskAboveResult>(ptr);
    }

    bool GetElevationMaskAboveResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Angle"])
        ;

    }

    std::string GetElevationMaskAboveResult::documentation() const { return Documentation; }


    double GetElevationMaskAboveResult::angle() const
    {
      return parse_json<double>::parse(m_values["Angle"]);
    }

    void GetElevationMaskAboveResult::setAngle(double angle)
    {
      m_values.AddMember("Angle", parse_json<double>::format(angle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfData
///
#include "gen/SetIssueOfData.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfData::CmdName = "SetIssueOfData";
    const char* const SetIssueOfData::Documentation = "Set GPS Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(SetIssueOfData);


    SetIssueOfData::SetIssueOfData()
      : CommandBase(CmdName)
    {}

    SetIssueOfData::SetIssueOfData(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    SetIssueOfDataPtr SetIssueOfData::create(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return SetIssueOfDataPtr(new SetIssueOfData(clock, ephemeris, overrideRinex));
    }

    SetIssueOfDataPtr SetIssueOfData::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfData>(ptr);
    }

    bool SetIssueOfData::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetIssueOfData::documentation() const { return Documentation; }


    int SetIssueOfData::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfData::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void SetIssueOfData::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIssueOfData::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void SetIssueOfData::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetIssueOfData::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetIssueOfData::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfData
///
#include "gen/GetIssueOfData.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfData::CmdName = "GetIssueOfData";
    const char* const GetIssueOfData::Documentation = "Get GPS Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(GetIssueOfData);


    GetIssueOfData::GetIssueOfData()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataPtr GetIssueOfData::create()
    {
      return GetIssueOfDataPtr(new GetIssueOfData());
    }

    GetIssueOfDataPtr GetIssueOfData::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfData>(ptr);
    }

    bool GetIssueOfData::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfData::documentation() const { return Documentation; }


    int GetIssueOfData::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataResult
///
#include "gen/GetIssueOfDataResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataResult::CmdName = "GetIssueOfDataResult";
    const char* const GetIssueOfDataResult::Documentation = "Result of GetIssueOfData";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataResult);


    GetIssueOfDataResult::GetIssueOfDataResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataResult::GetIssueOfDataResult(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    GetIssueOfDataResultPtr GetIssueOfDataResult::create(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return GetIssueOfDataResultPtr(new GetIssueOfDataResult(relatedCommand, clock, ephemeris, overrideRinex));
    }

    GetIssueOfDataResultPtr GetIssueOfDataResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataResult>(ptr);
    }

    bool GetIssueOfDataResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetIssueOfDataResult::documentation() const { return Documentation; }


    int GetIssueOfDataResult::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void GetIssueOfDataResult::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIssueOfDataResult::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void GetIssueOfDataResult::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetIssueOfDataResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetIssueOfDataResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfDataGalileo
///
#include "gen/SetIssueOfDataGalileo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfDataGalileo::CmdName = "SetIssueOfDataGalileo";
    const char* const SetIssueOfDataGalileo::Documentation = "Set Galileo Issue of data, Navigation (IODNAV) and Issue of data, Almanac (IODA)";

    REGISTER_COMMAND_FACTORY(SetIssueOfDataGalileo);


    SetIssueOfDataGalileo::SetIssueOfDataGalileo()
      : CommandBase(CmdName)
    {}

    SetIssueOfDataGalileo::SetIssueOfDataGalileo(int navigation, int almanac, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setNavigation(navigation);
      setAlmanac(almanac);
      setOverrideRinex(overrideRinex);
    }


    SetIssueOfDataGalileoPtr SetIssueOfDataGalileo::create(int navigation, int almanac, const Sdx::optional<bool>& overrideRinex)
    {
      return SetIssueOfDataGalileoPtr(new SetIssueOfDataGalileo(navigation, almanac, overrideRinex));
    }

    SetIssueOfDataGalileoPtr SetIssueOfDataGalileo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfDataGalileo>(ptr);
    }

    bool SetIssueOfDataGalileo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Navigation"])
          && parse_json<int>::is_valid(m_values["Almanac"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetIssueOfDataGalileo::documentation() const { return Documentation; }


    int SetIssueOfDataGalileo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfDataGalileo::navigation() const
    {
      return parse_json<int>::parse(m_values["Navigation"]);
    }

    void SetIssueOfDataGalileo::setNavigation(int navigation)
    {
      m_values.AddMember("Navigation", parse_json<int>::format(navigation, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIssueOfDataGalileo::almanac() const
    {
      return parse_json<int>::parse(m_values["Almanac"]);
    }

    void SetIssueOfDataGalileo::setAlmanac(int almanac)
    {
      m_values.AddMember("Almanac", parse_json<int>::format(almanac, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetIssueOfDataGalileo::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetIssueOfDataGalileo::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfDataGalileo
///
#include "gen/GetIssueOfDataGalileo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataGalileo::CmdName = "GetIssueOfDataGalileo";
    const char* const GetIssueOfDataGalileo::Documentation = "Get Galileo Issue of data, Navigation (IODNAV) and Issue of data, Almanac (IODA)";

    REGISTER_COMMAND_FACTORY(GetIssueOfDataGalileo);


    GetIssueOfDataGalileo::GetIssueOfDataGalileo()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataGalileoPtr GetIssueOfDataGalileo::create()
    {
      return GetIssueOfDataGalileoPtr(new GetIssueOfDataGalileo());
    }

    GetIssueOfDataGalileoPtr GetIssueOfDataGalileo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataGalileo>(ptr);
    }

    bool GetIssueOfDataGalileo::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfDataGalileo::documentation() const { return Documentation; }


    int GetIssueOfDataGalileo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataGalileoResult
///
#include "gen/GetIssueOfDataGalileoResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataGalileoResult::CmdName = "GetIssueOfDataGalileoResult";
    const char* const GetIssueOfDataGalileoResult::Documentation = "Result of GetIssueOfDataGalileo";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataGalileoResult);


    GetIssueOfDataGalileoResult::GetIssueOfDataGalileoResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataGalileoResult::GetIssueOfDataGalileoResult(CommandBasePtr relatedCommand, int navigation, int almanac, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setNavigation(navigation);
      setAlmanac(almanac);
      setOverrideRinex(overrideRinex);
    }


    GetIssueOfDataGalileoResultPtr GetIssueOfDataGalileoResult::create(CommandBasePtr relatedCommand, int navigation, int almanac, const Sdx::optional<bool>& overrideRinex)
    {
      return GetIssueOfDataGalileoResultPtr(new GetIssueOfDataGalileoResult(relatedCommand, navigation, almanac, overrideRinex));
    }

    GetIssueOfDataGalileoResultPtr GetIssueOfDataGalileoResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataGalileoResult>(ptr);
    }

    bool GetIssueOfDataGalileoResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Navigation"])
          && parse_json<int>::is_valid(m_values["Almanac"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetIssueOfDataGalileoResult::documentation() const { return Documentation; }


    int GetIssueOfDataGalileoResult::navigation() const
    {
      return parse_json<int>::parse(m_values["Navigation"]);
    }

    void GetIssueOfDataGalileoResult::setNavigation(int navigation)
    {
      m_values.AddMember("Navigation", parse_json<int>::format(navigation, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIssueOfDataGalileoResult::almanac() const
    {
      return parse_json<int>::parse(m_values["Almanac"]);
    }

    void GetIssueOfDataGalileoResult::setAlmanac(int almanac)
    {
      m_values.AddMember("Almanac", parse_json<int>::format(almanac, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetIssueOfDataGalileoResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetIssueOfDataGalileoResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAgeOfDataBeiDou
///
#include "gen/SetAgeOfDataBeiDou.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAgeOfDataBeiDou::CmdName = "SetAgeOfDataBeiDou";
    const char* const SetAgeOfDataBeiDou::Documentation = "Set BeiDou Age of data, Ephemeris (AODE) and Age of data, Clock (AODC)";

    REGISTER_COMMAND_FACTORY(SetAgeOfDataBeiDou);


    SetAgeOfDataBeiDou::SetAgeOfDataBeiDou()
      : CommandBase(CmdName)
    {}

    SetAgeOfDataBeiDou::SetAgeOfDataBeiDou(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    SetAgeOfDataBeiDouPtr SetAgeOfDataBeiDou::create(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return SetAgeOfDataBeiDouPtr(new SetAgeOfDataBeiDou(clock, ephemeris, overrideRinex));
    }

    SetAgeOfDataBeiDouPtr SetAgeOfDataBeiDou::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAgeOfDataBeiDou>(ptr);
    }

    bool SetAgeOfDataBeiDou::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetAgeOfDataBeiDou::documentation() const { return Documentation; }


    int SetAgeOfDataBeiDou::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetAgeOfDataBeiDou::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void SetAgeOfDataBeiDou::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAgeOfDataBeiDou::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void SetAgeOfDataBeiDou::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetAgeOfDataBeiDou::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetAgeOfDataBeiDou::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAgeOfDataBeiDou
///
#include "gen/GetAgeOfDataBeiDou.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAgeOfDataBeiDou::CmdName = "GetAgeOfDataBeiDou";
    const char* const GetAgeOfDataBeiDou::Documentation = "Get BeiDou Age of data, Ephemeris (AODE) and Age of data, Clock (AODC)";

    REGISTER_COMMAND_FACTORY(GetAgeOfDataBeiDou);


    GetAgeOfDataBeiDou::GetAgeOfDataBeiDou()
      : CommandBase(CmdName)
    {

    }


    GetAgeOfDataBeiDouPtr GetAgeOfDataBeiDou::create()
    {
      return GetAgeOfDataBeiDouPtr(new GetAgeOfDataBeiDou());
    }

    GetAgeOfDataBeiDouPtr GetAgeOfDataBeiDou::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAgeOfDataBeiDou>(ptr);
    }

    bool GetAgeOfDataBeiDou::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAgeOfDataBeiDou::documentation() const { return Documentation; }


    int GetAgeOfDataBeiDou::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAgeOfDataBeiDouResult
///
#include "gen/GetAgeOfDataBeiDouResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAgeOfDataBeiDouResult::CmdName = "GetAgeOfDataBeiDouResult";
    const char* const GetAgeOfDataBeiDouResult::Documentation = "Result of GetAgeOfDataBeiDou";

    REGISTER_COMMAND_RESULT_FACTORY(GetAgeOfDataBeiDouResult);


    GetAgeOfDataBeiDouResult::GetAgeOfDataBeiDouResult()
      : CommandResult(CmdName)
    {}

    GetAgeOfDataBeiDouResult::GetAgeOfDataBeiDouResult(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    GetAgeOfDataBeiDouResultPtr GetAgeOfDataBeiDouResult::create(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return GetAgeOfDataBeiDouResultPtr(new GetAgeOfDataBeiDouResult(relatedCommand, clock, ephemeris, overrideRinex));
    }

    GetAgeOfDataBeiDouResultPtr GetAgeOfDataBeiDouResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAgeOfDataBeiDouResult>(ptr);
    }

    bool GetAgeOfDataBeiDouResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetAgeOfDataBeiDouResult::documentation() const { return Documentation; }


    int GetAgeOfDataBeiDouResult::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void GetAgeOfDataBeiDouResult::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAgeOfDataBeiDouResult::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void GetAgeOfDataBeiDouResult::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetAgeOfDataBeiDouResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetAgeOfDataBeiDouResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfDataBeiDou
///
#include "gen/SetIssueOfDataBeiDou.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfDataBeiDou::CmdName = "SetIssueOfDataBeiDou";
    const char* const SetIssueOfDataBeiDou::Documentation = "Set BeiDou Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(SetIssueOfDataBeiDou);


    SetIssueOfDataBeiDou::SetIssueOfDataBeiDou()
      : CommandBase(CmdName)
    {}

    SetIssueOfDataBeiDou::SetIssueOfDataBeiDou(int clock, int ephemeris)
      : CommandBase(CmdName)
    {

      setClock(clock);
      setEphemeris(ephemeris);
    }


    SetIssueOfDataBeiDouPtr SetIssueOfDataBeiDou::create(int clock, int ephemeris)
    {
      return SetIssueOfDataBeiDouPtr(new SetIssueOfDataBeiDou(clock, ephemeris));
    }

    SetIssueOfDataBeiDouPtr SetIssueOfDataBeiDou::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfDataBeiDou>(ptr);
    }

    bool SetIssueOfDataBeiDou::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
        ;

    }

    std::string SetIssueOfDataBeiDou::documentation() const { return Documentation; }


    int SetIssueOfDataBeiDou::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfDataBeiDou::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void SetIssueOfDataBeiDou::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIssueOfDataBeiDou::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void SetIssueOfDataBeiDou::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfDataBeiDou
///
#include "gen/GetIssueOfDataBeiDou.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataBeiDou::CmdName = "GetIssueOfDataBeiDou";
    const char* const GetIssueOfDataBeiDou::Documentation = "Get BeiDou Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(GetIssueOfDataBeiDou);


    GetIssueOfDataBeiDou::GetIssueOfDataBeiDou()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataBeiDouPtr GetIssueOfDataBeiDou::create()
    {
      return GetIssueOfDataBeiDouPtr(new GetIssueOfDataBeiDou());
    }

    GetIssueOfDataBeiDouPtr GetIssueOfDataBeiDou::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataBeiDou>(ptr);
    }

    bool GetIssueOfDataBeiDou::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfDataBeiDou::documentation() const { return Documentation; }


    int GetIssueOfDataBeiDou::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataBeiDouResult
///
#include "gen/GetIssueOfDataBeiDouResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataBeiDouResult::CmdName = "GetIssueOfDataBeiDouResult";
    const char* const GetIssueOfDataBeiDouResult::Documentation = "Result of GetIssueOfDataBeiDou";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataBeiDouResult);


    GetIssueOfDataBeiDouResult::GetIssueOfDataBeiDouResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataBeiDouResult::GetIssueOfDataBeiDouResult(CommandBasePtr relatedCommand, int clock, int ephemeris)
      : CommandResult(CmdName, relatedCommand)
    {

      setClock(clock);
      setEphemeris(ephemeris);
    }


    GetIssueOfDataBeiDouResultPtr GetIssueOfDataBeiDouResult::create(CommandBasePtr relatedCommand, int clock, int ephemeris)
    {
      return GetIssueOfDataBeiDouResultPtr(new GetIssueOfDataBeiDouResult(relatedCommand, clock, ephemeris));
    }

    GetIssueOfDataBeiDouResultPtr GetIssueOfDataBeiDouResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataBeiDouResult>(ptr);
    }

    bool GetIssueOfDataBeiDouResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
        ;

    }

    std::string GetIssueOfDataBeiDouResult::documentation() const { return Documentation; }


    int GetIssueOfDataBeiDouResult::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void GetIssueOfDataBeiDouResult::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIssueOfDataBeiDouResult::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void GetIssueOfDataBeiDouResult::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfDataQzss
///
#include "gen/SetIssueOfDataQzss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfDataQzss::CmdName = "SetIssueOfDataQzss";
    const char* const SetIssueOfDataQzss::Documentation = "Set QZSS Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(SetIssueOfDataQzss);


    SetIssueOfDataQzss::SetIssueOfDataQzss()
      : CommandBase(CmdName)
    {}

    SetIssueOfDataQzss::SetIssueOfDataQzss(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    SetIssueOfDataQzssPtr SetIssueOfDataQzss::create(int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return SetIssueOfDataQzssPtr(new SetIssueOfDataQzss(clock, ephemeris, overrideRinex));
    }

    SetIssueOfDataQzssPtr SetIssueOfDataQzss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfDataQzss>(ptr);
    }

    bool SetIssueOfDataQzss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetIssueOfDataQzss::documentation() const { return Documentation; }


    int SetIssueOfDataQzss::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfDataQzss::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void SetIssueOfDataQzss::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIssueOfDataQzss::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void SetIssueOfDataQzss::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetIssueOfDataQzss::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetIssueOfDataQzss::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfDataQzss
///
#include "gen/GetIssueOfDataQzss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataQzss::CmdName = "GetIssueOfDataQzss";
    const char* const GetIssueOfDataQzss::Documentation = "Get QZSS Issue of data, Ephemeris (IODE) and Issue of data, Clock (IODC)";

    REGISTER_COMMAND_FACTORY(GetIssueOfDataQzss);


    GetIssueOfDataQzss::GetIssueOfDataQzss()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataQzssPtr GetIssueOfDataQzss::create()
    {
      return GetIssueOfDataQzssPtr(new GetIssueOfDataQzss());
    }

    GetIssueOfDataQzssPtr GetIssueOfDataQzss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataQzss>(ptr);
    }

    bool GetIssueOfDataQzss::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfDataQzss::documentation() const { return Documentation; }


    int GetIssueOfDataQzss::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataQzssResult
///
#include "gen/GetIssueOfDataQzssResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataQzssResult::CmdName = "GetIssueOfDataQzssResult";
    const char* const GetIssueOfDataQzssResult::Documentation = "Result of GetIssueOfDataQzss";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataQzssResult);


    GetIssueOfDataQzssResult::GetIssueOfDataQzssResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataQzssResult::GetIssueOfDataQzssResult(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setClock(clock);
      setEphemeris(ephemeris);
      setOverrideRinex(overrideRinex);
    }


    GetIssueOfDataQzssResultPtr GetIssueOfDataQzssResult::create(CommandBasePtr relatedCommand, int clock, int ephemeris, const Sdx::optional<bool>& overrideRinex)
    {
      return GetIssueOfDataQzssResultPtr(new GetIssueOfDataQzssResult(relatedCommand, clock, ephemeris, overrideRinex));
    }

    GetIssueOfDataQzssResultPtr GetIssueOfDataQzssResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataQzssResult>(ptr);
    }

    bool GetIssueOfDataQzssResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Clock"])
          && parse_json<int>::is_valid(m_values["Ephemeris"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetIssueOfDataQzssResult::documentation() const { return Documentation; }


    int GetIssueOfDataQzssResult::clock() const
    {
      return parse_json<int>::parse(m_values["Clock"]);
    }

    void GetIssueOfDataQzssResult::setClock(int clock)
    {
      m_values.AddMember("Clock", parse_json<int>::format(clock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIssueOfDataQzssResult::ephemeris() const
    {
      return parse_json<int>::parse(m_values["Ephemeris"]);
    }

    void GetIssueOfDataQzssResult::setEphemeris(int ephemeris)
    {
      m_values.AddMember("Ephemeris", parse_json<int>::format(ephemeris, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetIssueOfDataQzssResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetIssueOfDataQzssResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIssueOfDataNavIC
///
#include "gen/SetIssueOfDataNavIC.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIssueOfDataNavIC::CmdName = "SetIssueOfDataNavIC";
    const char* const SetIssueOfDataNavIC::Documentation = "Set NavIC Issue of data, Ephemeris and Clock (IODEC)";

    REGISTER_COMMAND_FACTORY(SetIssueOfDataNavIC);


    SetIssueOfDataNavIC::SetIssueOfDataNavIC()
      : CommandBase(CmdName)
    {}

    SetIssueOfDataNavIC::SetIssueOfDataNavIC(int ephemerisAndClock, const Sdx::optional<bool>& overrideRinex)
      : CommandBase(CmdName)
    {

      setEphemerisAndClock(ephemerisAndClock);
      setOverrideRinex(overrideRinex);
    }


    SetIssueOfDataNavICPtr SetIssueOfDataNavIC::create(int ephemerisAndClock, const Sdx::optional<bool>& overrideRinex)
    {
      return SetIssueOfDataNavICPtr(new SetIssueOfDataNavIC(ephemerisAndClock, overrideRinex));
    }

    SetIssueOfDataNavICPtr SetIssueOfDataNavIC::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIssueOfDataNavIC>(ptr);
    }

    bool SetIssueOfDataNavIC::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["EphemerisAndClock"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string SetIssueOfDataNavIC::documentation() const { return Documentation; }


    int SetIssueOfDataNavIC::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIssueOfDataNavIC::ephemerisAndClock() const
    {
      return parse_json<int>::parse(m_values["EphemerisAndClock"]);
    }

    void SetIssueOfDataNavIC::setEphemerisAndClock(int ephemerisAndClock)
    {
      m_values.AddMember("EphemerisAndClock", parse_json<int>::format(ephemerisAndClock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> SetIssueOfDataNavIC::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void SetIssueOfDataNavIC::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIssueOfDataNavIC
///
#include "gen/GetIssueOfDataNavIC.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataNavIC::CmdName = "GetIssueOfDataNavIC";
    const char* const GetIssueOfDataNavIC::Documentation = "Get NavIC Issue of data, Ephemeris and Clock (IODEC)";

    REGISTER_COMMAND_FACTORY(GetIssueOfDataNavIC);


    GetIssueOfDataNavIC::GetIssueOfDataNavIC()
      : CommandBase(CmdName)
    {

    }


    GetIssueOfDataNavICPtr GetIssueOfDataNavIC::create()
    {
      return GetIssueOfDataNavICPtr(new GetIssueOfDataNavIC());
    }

    GetIssueOfDataNavICPtr GetIssueOfDataNavIC::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataNavIC>(ptr);
    }

    bool GetIssueOfDataNavIC::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIssueOfDataNavIC::documentation() const { return Documentation; }


    int GetIssueOfDataNavIC::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIssueOfDataNavICResult
///
#include "gen/GetIssueOfDataNavICResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIssueOfDataNavICResult::CmdName = "GetIssueOfDataNavICResult";
    const char* const GetIssueOfDataNavICResult::Documentation = "Result of GetIssueOfDataNavIC";

    REGISTER_COMMAND_RESULT_FACTORY(GetIssueOfDataNavICResult);


    GetIssueOfDataNavICResult::GetIssueOfDataNavICResult()
      : CommandResult(CmdName)
    {}

    GetIssueOfDataNavICResult::GetIssueOfDataNavICResult(CommandBasePtr relatedCommand, int ephemerisAndClock, const Sdx::optional<bool>& overrideRinex)
      : CommandResult(CmdName, relatedCommand)
    {

      setEphemerisAndClock(ephemerisAndClock);
      setOverrideRinex(overrideRinex);
    }


    GetIssueOfDataNavICResultPtr GetIssueOfDataNavICResult::create(CommandBasePtr relatedCommand, int ephemerisAndClock, const Sdx::optional<bool>& overrideRinex)
    {
      return GetIssueOfDataNavICResultPtr(new GetIssueOfDataNavICResult(relatedCommand, ephemerisAndClock, overrideRinex));
    }

    GetIssueOfDataNavICResultPtr GetIssueOfDataNavICResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIssueOfDataNavICResult>(ptr);
    }

    bool GetIssueOfDataNavICResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["EphemerisAndClock"])
          && parse_json<Sdx::optional<bool>>::is_valid(m_values["OverrideRinex"])
        ;

    }

    std::string GetIssueOfDataNavICResult::documentation() const { return Documentation; }


    int GetIssueOfDataNavICResult::ephemerisAndClock() const
    {
      return parse_json<int>::parse(m_values["EphemerisAndClock"]);
    }

    void GetIssueOfDataNavICResult::setEphemerisAndClock(int ephemerisAndClock)
    {
      m_values.AddMember("EphemerisAndClock", parse_json<int>::format(ephemerisAndClock, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<bool> GetIssueOfDataNavICResult::overrideRinex() const
    {
      return parse_json<Sdx::optional<bool>>::parse(m_values["OverrideRinex"]);
    }

    void GetIssueOfDataNavICResult::setOverrideRinex(const Sdx::optional<bool>& overrideRinex)
    {
      m_values.AddMember("OverrideRinex", parse_json<Sdx::optional<bool>>::format(overrideRinex, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsConfigurationCodeForSV
///
#include "gen/SetGpsConfigurationCodeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsConfigurationCodeForSV::CmdName = "SetGpsConfigurationCodeForSV";
    const char* const SetGpsConfigurationCodeForSV::Documentation = "Set GPS SV configuration flag for one satellite";

    REGISTER_COMMAND_FACTORY(SetGpsConfigurationCodeForSV);


    SetGpsConfigurationCodeForSV::SetGpsConfigurationCodeForSV()
      : CommandBase(CmdName)
    {}

    SetGpsConfigurationCodeForSV::SetGpsConfigurationCodeForSV(int svId, int svConfig)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSvConfig(svConfig);
    }


    SetGpsConfigurationCodeForSVPtr SetGpsConfigurationCodeForSV::create(int svId, int svConfig)
    {
      return SetGpsConfigurationCodeForSVPtr(new SetGpsConfigurationCodeForSV(svId, svConfig));
    }

    SetGpsConfigurationCodeForSVPtr SetGpsConfigurationCodeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsConfigurationCodeForSV>(ptr);
    }

    bool SetGpsConfigurationCodeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SvConfig"])
        ;

    }

    std::string SetGpsConfigurationCodeForSV::documentation() const { return Documentation; }


    int SetGpsConfigurationCodeForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGpsConfigurationCodeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsConfigurationCodeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsConfigurationCodeForSV::svConfig() const
    {
      return parse_json<int>::parse(m_values["SvConfig"]);
    }

    void SetGpsConfigurationCodeForSV::setSvConfig(int svConfig)
    {
      m_values.AddMember("SvConfig", parse_json<int>::format(svConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsConfigurationCodeForSV
///
#include "gen/GetGpsConfigurationCodeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsConfigurationCodeForSV::CmdName = "GetGpsConfigurationCodeForSV";
    const char* const GetGpsConfigurationCodeForSV::Documentation = "Get GPS SV configuration flag for one satellite";

    REGISTER_COMMAND_FACTORY(GetGpsConfigurationCodeForSV);


    GetGpsConfigurationCodeForSV::GetGpsConfigurationCodeForSV()
      : CommandBase(CmdName)
    {}

    GetGpsConfigurationCodeForSV::GetGpsConfigurationCodeForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsConfigurationCodeForSVPtr GetGpsConfigurationCodeForSV::create(int svId)
    {
      return GetGpsConfigurationCodeForSVPtr(new GetGpsConfigurationCodeForSV(svId));
    }

    GetGpsConfigurationCodeForSVPtr GetGpsConfigurationCodeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsConfigurationCodeForSV>(ptr);
    }

    bool GetGpsConfigurationCodeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsConfigurationCodeForSV::documentation() const { return Documentation; }


    int GetGpsConfigurationCodeForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsConfigurationCodeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsConfigurationCodeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsConfigurationCodeForSVResult
///
#include "gen/GetGpsConfigurationCodeForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsConfigurationCodeForSVResult::CmdName = "GetGpsConfigurationCodeForSVResult";
    const char* const GetGpsConfigurationCodeForSVResult::Documentation = "Result of GetGpsConfigurationCodeForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsConfigurationCodeForSVResult);


    GetGpsConfigurationCodeForSVResult::GetGpsConfigurationCodeForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsConfigurationCodeForSVResult::GetGpsConfigurationCodeForSVResult(CommandBasePtr relatedCommand, int svId, int svConfig)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setSvConfig(svConfig);
    }


    GetGpsConfigurationCodeForSVResultPtr GetGpsConfigurationCodeForSVResult::create(CommandBasePtr relatedCommand, int svId, int svConfig)
    {
      return GetGpsConfigurationCodeForSVResultPtr(new GetGpsConfigurationCodeForSVResult(relatedCommand, svId, svConfig));
    }

    GetGpsConfigurationCodeForSVResultPtr GetGpsConfigurationCodeForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsConfigurationCodeForSVResult>(ptr);
    }

    bool GetGpsConfigurationCodeForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SvConfig"])
        ;

    }

    std::string GetGpsConfigurationCodeForSVResult::documentation() const { return Documentation; }


    int GetGpsConfigurationCodeForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsConfigurationCodeForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsConfigurationCodeForSVResult::svConfig() const
    {
      return parse_json<int>::parse(m_values["SvConfig"]);
    }

    void GetGpsConfigurationCodeForSVResult::setSvConfig(int svConfig)
    {
      m_values.AddMember("SvConfig", parse_json<int>::format(svConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsConfigurationForEachSV
///
#include "gen/SetGpsConfigurationForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsConfigurationForEachSV::CmdName = "SetGpsConfigurationForEachSV";
    const char* const SetGpsConfigurationForEachSV::Documentation = "Set GPS SV configuration flag for each SVs";

    REGISTER_COMMAND_FACTORY(SetGpsConfigurationForEachSV);


    SetGpsConfigurationForEachSV::SetGpsConfigurationForEachSV()
      : CommandBase(CmdName)
    {}

    SetGpsConfigurationForEachSV::SetGpsConfigurationForEachSV(const std::vector<int>& svConfigs)
      : CommandBase(CmdName)
    {

      setSvConfigs(svConfigs);
    }


    SetGpsConfigurationForEachSVPtr SetGpsConfigurationForEachSV::create(const std::vector<int>& svConfigs)
    {
      return SetGpsConfigurationForEachSVPtr(new SetGpsConfigurationForEachSV(svConfigs));
    }

    SetGpsConfigurationForEachSVPtr SetGpsConfigurationForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsConfigurationForEachSV>(ptr);
    }

    bool SetGpsConfigurationForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["SvConfigs"])
        ;

    }

    std::string SetGpsConfigurationForEachSV::documentation() const { return Documentation; }


    int SetGpsConfigurationForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::vector<int> SetGpsConfigurationForEachSV::svConfigs() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvConfigs"]);
    }

    void SetGpsConfigurationForEachSV::setSvConfigs(const std::vector<int>& svConfigs)
    {
      m_values.AddMember("SvConfigs", parse_json<std::vector<int>>::format(svConfigs, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSVConfigurationForAllSat
///
#include "gen/SetGpsSVConfigurationForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSVConfigurationForAllSat::CmdName = "SetGpsSVConfigurationForAllSat";
    const char* const SetGpsSVConfigurationForAllSat::Documentation = "Please note the command SetGpsSVConfigurationForAllSat is deprecated since 21.3. You may use SetGpsConfigurationForEachSV.\n\nSet GPS SV configuration flag for each SVs";

    REGISTER_COMMAND_FACTORY(SetGpsSVConfigurationForAllSat);


    SetGpsSVConfigurationForAllSat::SetGpsSVConfigurationForAllSat()
      : CommandBase(CmdName)
    {}

    SetGpsSVConfigurationForAllSat::SetGpsSVConfigurationForAllSat(const std::vector<int>& svConfigs)
      : CommandBase(CmdName)
    {

      setSvConfigs(svConfigs);
    }


    SetGpsSVConfigurationForAllSatPtr SetGpsSVConfigurationForAllSat::create(const std::vector<int>& svConfigs)
    {
      return SetGpsSVConfigurationForAllSatPtr(new SetGpsSVConfigurationForAllSat(svConfigs));
    }

    SetGpsSVConfigurationForAllSatPtr SetGpsSVConfigurationForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSVConfigurationForAllSat>(ptr);
    }

    bool SetGpsSVConfigurationForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["SvConfigs"])
        ;

    }

    std::string SetGpsSVConfigurationForAllSat::documentation() const { return Documentation; }


    int SetGpsSVConfigurationForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::vector<int> SetGpsSVConfigurationForAllSat::svConfigs() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvConfigs"]);
    }

    void SetGpsSVConfigurationForAllSat::setSvConfigs(const std::vector<int>& svConfigs)
    {
      m_values.AddMember("SvConfigs", parse_json<std::vector<int>>::format(svConfigs, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsConfigurationForEachSV
///
#include "gen/GetGpsConfigurationForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsConfigurationForEachSV::CmdName = "GetGpsConfigurationForEachSV";
    const char* const GetGpsConfigurationForEachSV::Documentation = "Get GPS SV configuration flag for each SVs";

    REGISTER_COMMAND_FACTORY(GetGpsConfigurationForEachSV);


    GetGpsConfigurationForEachSV::GetGpsConfigurationForEachSV()
      : CommandBase(CmdName)
    {

    }


    GetGpsConfigurationForEachSVPtr GetGpsConfigurationForEachSV::create()
    {
      return GetGpsConfigurationForEachSVPtr(new GetGpsConfigurationForEachSV());
    }

    GetGpsConfigurationForEachSVPtr GetGpsConfigurationForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsConfigurationForEachSV>(ptr);
    }

    bool GetGpsConfigurationForEachSV::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGpsConfigurationForEachSV::documentation() const { return Documentation; }


    int GetGpsConfigurationForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsSVConfigurationForAllSat
///
#include "gen/GetGpsSVConfigurationForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSVConfigurationForAllSat::CmdName = "GetGpsSVConfigurationForAllSat";
    const char* const GetGpsSVConfigurationForAllSat::Documentation = "Please note the command GetGpsSVConfigurationForAllSat is deprecated since 21.3. You may use GetGpsConfigurationForEachSV.\n\nGet GPS SV configuration flag for each SVs";

    REGISTER_COMMAND_FACTORY(GetGpsSVConfigurationForAllSat);


    GetGpsSVConfigurationForAllSat::GetGpsSVConfigurationForAllSat()
      : CommandBase(CmdName)
    {

    }


    GetGpsSVConfigurationForAllSatPtr GetGpsSVConfigurationForAllSat::create()
    {
      return GetGpsSVConfigurationForAllSatPtr(new GetGpsSVConfigurationForAllSat());
    }

    GetGpsSVConfigurationForAllSatPtr GetGpsSVConfigurationForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSVConfigurationForAllSat>(ptr);
    }

    bool GetGpsSVConfigurationForAllSat::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGpsSVConfigurationForAllSat::documentation() const { return Documentation; }


    int GetGpsSVConfigurationForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsConfigurationForEachSVResult
///
#include "gen/GetGpsConfigurationForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsConfigurationForEachSVResult::CmdName = "GetGpsConfigurationForEachSVResult";
    const char* const GetGpsConfigurationForEachSVResult::Documentation = "Result of GetGpsConfigurationForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsConfigurationForEachSVResult);


    GetGpsConfigurationForEachSVResult::GetGpsConfigurationForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsConfigurationForEachSVResult::GetGpsConfigurationForEachSVResult(CommandBasePtr relatedCommand, const std::vector<int>& svConfigs)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvConfigs(svConfigs);
    }


    GetGpsConfigurationForEachSVResultPtr GetGpsConfigurationForEachSVResult::create(CommandBasePtr relatedCommand, const std::vector<int>& svConfigs)
    {
      return GetGpsConfigurationForEachSVResultPtr(new GetGpsConfigurationForEachSVResult(relatedCommand, svConfigs));
    }

    GetGpsConfigurationForEachSVResultPtr GetGpsConfigurationForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsConfigurationForEachSVResult>(ptr);
    }

    bool GetGpsConfigurationForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["SvConfigs"])
        ;

    }

    std::string GetGpsConfigurationForEachSVResult::documentation() const { return Documentation; }


    std::vector<int> GetGpsConfigurationForEachSVResult::svConfigs() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvConfigs"]);
    }

    void GetGpsConfigurationForEachSVResult::setSvConfigs(const std::vector<int>& svConfigs)
    {
      m_values.AddMember("SvConfigs", parse_json<std::vector<int>>::format(svConfigs, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsDataHealthForSV
///
#include "gen/SetGpsDataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsDataHealthForSV::CmdName = "SetGpsDataHealthForSV";
    const char* const SetGpsDataHealthForSV::Documentation = "Set GPS nav data health";

    REGISTER_COMMAND_FACTORY(SetGpsDataHealthForSV);


    SetGpsDataHealthForSV::SetGpsDataHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsDataHealthForSV::SetGpsDataHealthForSV(int svId, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGpsDataHealthForSVPtr SetGpsDataHealthForSV::create(int svId, int health)
    {
      return SetGpsDataHealthForSVPtr(new SetGpsDataHealthForSV(svId, health));
    }

    SetGpsDataHealthForSVPtr SetGpsDataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsDataHealthForSV>(ptr);
    }

    bool SetGpsDataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsDataHealthForSV::documentation() const { return Documentation; }


    int SetGpsDataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsDataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsDataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsDataHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetGpsDataHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsDataHealthForSV
///
#include "gen/GetGpsDataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsDataHealthForSV::CmdName = "GetGpsDataHealthForSV";
    const char* const GetGpsDataHealthForSV::Documentation = "Get GPS nav data health";

    REGISTER_COMMAND_FACTORY(GetGpsDataHealthForSV);


    GetGpsDataHealthForSV::GetGpsDataHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsDataHealthForSV::GetGpsDataHealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsDataHealthForSVPtr GetGpsDataHealthForSV::create(int svId)
    {
      return GetGpsDataHealthForSVPtr(new GetGpsDataHealthForSV(svId));
    }

    GetGpsDataHealthForSVPtr GetGpsDataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsDataHealthForSV>(ptr);
    }

    bool GetGpsDataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsDataHealthForSV::documentation() const { return Documentation; }


    int GetGpsDataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsDataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsDataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsDataHealthForSVResult
///
#include "gen/GetGpsDataHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsDataHealthForSVResult::CmdName = "GetGpsDataHealthForSVResult";
    const char* const GetGpsDataHealthForSVResult::Documentation = "Result of GetGpsDataHealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsDataHealthForSVResult);


    GetGpsDataHealthForSVResult::GetGpsDataHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsDataHealthForSVResult::GetGpsDataHealthForSVResult(CommandBasePtr relatedCommand, int svId, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGpsDataHealthForSVResultPtr GetGpsDataHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, int health)
    {
      return GetGpsDataHealthForSVResultPtr(new GetGpsDataHealthForSVResult(relatedCommand, svId, health));
    }

    GetGpsDataHealthForSVResultPtr GetGpsDataHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsDataHealthForSVResult>(ptr);
    }

    bool GetGpsDataHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsDataHealthForSVResult::documentation() const { return Documentation; }


    int GetGpsDataHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsDataHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsDataHealthForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetGpsDataHealthForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSignalHealthForSV
///
#include "gen/SetGpsSignalHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSignalHealthForSV::CmdName = "SetGpsSignalHealthForSV";
    const char* const SetGpsSignalHealthForSV::Documentation = "Set GPS signal health";

    REGISTER_COMMAND_FACTORY(SetGpsSignalHealthForSV);


    SetGpsSignalHealthForSV::SetGpsSignalHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsSignalHealthForSV::SetGpsSignalHealthForSV(int svId, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGpsSignalHealthForSVPtr SetGpsSignalHealthForSV::create(int svId, int health)
    {
      return SetGpsSignalHealthForSVPtr(new SetGpsSignalHealthForSV(svId, health));
    }

    SetGpsSignalHealthForSVPtr SetGpsSignalHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSignalHealthForSV>(ptr);
    }

    bool SetGpsSignalHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsSignalHealthForSV::documentation() const { return Documentation; }


    int SetGpsSignalHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSignalHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsSignalHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsSignalHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetGpsSignalHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSignalHealthForSV
///
#include "gen/GetGpsSignalHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSignalHealthForSV::CmdName = "GetGpsSignalHealthForSV";
    const char* const GetGpsSignalHealthForSV::Documentation = "Get GPS signal health";

    REGISTER_COMMAND_FACTORY(GetGpsSignalHealthForSV);


    GetGpsSignalHealthForSV::GetGpsSignalHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsSignalHealthForSV::GetGpsSignalHealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsSignalHealthForSVPtr GetGpsSignalHealthForSV::create(int svId)
    {
      return GetGpsSignalHealthForSVPtr(new GetGpsSignalHealthForSV(svId));
    }

    GetGpsSignalHealthForSVPtr GetGpsSignalHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSignalHealthForSV>(ptr);
    }

    bool GetGpsSignalHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsSignalHealthForSV::documentation() const { return Documentation; }


    int GetGpsSignalHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSignalHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsSignalHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSignalHealthForSVResult
///
#include "gen/GetGpsSignalHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSignalHealthForSVResult::CmdName = "GetGpsSignalHealthForSVResult";
    const char* const GetGpsSignalHealthForSVResult::Documentation = "Result of GetGpsSignalHealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSignalHealthForSVResult);


    GetGpsSignalHealthForSVResult::GetGpsSignalHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsSignalHealthForSVResult::GetGpsSignalHealthForSVResult(CommandBasePtr relatedCommand, int svId, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGpsSignalHealthForSVResultPtr GetGpsSignalHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, int health)
    {
      return GetGpsSignalHealthForSVResultPtr(new GetGpsSignalHealthForSVResult(relatedCommand, svId, health));
    }

    GetGpsSignalHealthForSVResultPtr GetGpsSignalHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSignalHealthForSVResult>(ptr);
    }

    bool GetGpsSignalHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsSignalHealthForSVResult::documentation() const { return Documentation; }


    int GetGpsSignalHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsSignalHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsSignalHealthForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetGpsSignalHealthForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoDataHealthForSV
///
#include "gen/SetGalileoDataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoDataHealthForSV::CmdName = "SetGalileoDataHealthForSV";
    const char* const SetGalileoDataHealthForSV::Documentation = "Set Galileo data health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(SetGalileoDataHealthForSV);


    SetGalileoDataHealthForSV::SetGalileoDataHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoDataHealthForSV::SetGalileoDataHealthForSV(int svId, const std::string& component, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setComponent(component);
      setHealth(health);
    }


    SetGalileoDataHealthForSVPtr SetGalileoDataHealthForSV::create(int svId, const std::string& component, bool health)
    {
      return SetGalileoDataHealthForSVPtr(new SetGalileoDataHealthForSV(svId, component, health));
    }

    SetGalileoDataHealthForSVPtr SetGalileoDataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoDataHealthForSV>(ptr);
    }

    bool SetGalileoDataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGalileoDataHealthForSV::documentation() const { return Documentation; }


    int SetGalileoDataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGalileoDataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoDataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGalileoDataHealthForSV::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void SetGalileoDataHealthForSV::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGalileoDataHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGalileoDataHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoDataHealthForSV
///
#include "gen/GetGalileoDataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoDataHealthForSV::CmdName = "GetGalileoDataHealthForSV";
    const char* const GetGalileoDataHealthForSV::Documentation = "Get Galileo data health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(GetGalileoDataHealthForSV);


    GetGalileoDataHealthForSV::GetGalileoDataHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGalileoDataHealthForSV::GetGalileoDataHealthForSV(int svId, const std::string& component)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setComponent(component);
    }


    GetGalileoDataHealthForSVPtr GetGalileoDataHealthForSV::create(int svId, const std::string& component)
    {
      return GetGalileoDataHealthForSVPtr(new GetGalileoDataHealthForSV(svId, component));
    }

    GetGalileoDataHealthForSVPtr GetGalileoDataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoDataHealthForSV>(ptr);
    }

    bool GetGalileoDataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
        ;

    }

    std::string GetGalileoDataHealthForSV::documentation() const { return Documentation; }


    int GetGalileoDataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoDataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoDataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoDataHealthForSV::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoDataHealthForSV::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoDataHealthForSVResult
///
#include "gen/GetGalileoDataHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoDataHealthForSVResult::CmdName = "GetGalileoDataHealthForSVResult";
    const char* const GetGalileoDataHealthForSVResult::Documentation = "Result of GetGalileoDataHealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoDataHealthForSVResult);


    GetGalileoDataHealthForSVResult::GetGalileoDataHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGalileoDataHealthForSVResult::GetGalileoDataHealthForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& component, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setComponent(component);
      setHealth(health);
    }


    GetGalileoDataHealthForSVResultPtr GetGalileoDataHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& component, bool health)
    {
      return GetGalileoDataHealthForSVResultPtr(new GetGalileoDataHealthForSVResult(relatedCommand, svId, component, health));
    }

    GetGalileoDataHealthForSVResultPtr GetGalileoDataHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoDataHealthForSVResult>(ptr);
    }

    bool GetGalileoDataHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGalileoDataHealthForSVResult::documentation() const { return Documentation; }


    int GetGalileoDataHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoDataHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoDataHealthForSVResult::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoDataHealthForSVResult::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGalileoDataHealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGalileoDataHealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSignalHealthForSV
///
#include "gen/SetGalileoSignalHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSignalHealthForSV::CmdName = "SetGalileoSignalHealthForSV";
    const char* const SetGalileoSignalHealthForSV::Documentation = "Set Galileo signal health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(SetGalileoSignalHealthForSV);


    SetGalileoSignalHealthForSV::SetGalileoSignalHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoSignalHealthForSV::SetGalileoSignalHealthForSV(int svId, const std::string& component, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setComponent(component);
      setHealth(health);
    }


    SetGalileoSignalHealthForSVPtr SetGalileoSignalHealthForSV::create(int svId, const std::string& component, int health)
    {
      return SetGalileoSignalHealthForSVPtr(new SetGalileoSignalHealthForSV(svId, component, health));
    }

    SetGalileoSignalHealthForSVPtr SetGalileoSignalHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSignalHealthForSV>(ptr);
    }

    bool SetGalileoSignalHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGalileoSignalHealthForSV::documentation() const { return Documentation; }


    int SetGalileoSignalHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGalileoSignalHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoSignalHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGalileoSignalHealthForSV::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void SetGalileoSignalHealthForSV::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoSignalHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetGalileoSignalHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoSignalHealthForSV
///
#include "gen/GetGalileoSignalHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoSignalHealthForSV::CmdName = "GetGalileoSignalHealthForSV";
    const char* const GetGalileoSignalHealthForSV::Documentation = "Get Galileo signal health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(GetGalileoSignalHealthForSV);


    GetGalileoSignalHealthForSV::GetGalileoSignalHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGalileoSignalHealthForSV::GetGalileoSignalHealthForSV(int svId, const std::string& component)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setComponent(component);
    }


    GetGalileoSignalHealthForSVPtr GetGalileoSignalHealthForSV::create(int svId, const std::string& component)
    {
      return GetGalileoSignalHealthForSVPtr(new GetGalileoSignalHealthForSV(svId, component));
    }

    GetGalileoSignalHealthForSVPtr GetGalileoSignalHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoSignalHealthForSV>(ptr);
    }

    bool GetGalileoSignalHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
        ;

    }

    std::string GetGalileoSignalHealthForSV::documentation() const { return Documentation; }


    int GetGalileoSignalHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoSignalHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoSignalHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoSignalHealthForSV::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoSignalHealthForSV::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoSignalHealthForSVResult
///
#include "gen/GetGalileoSignalHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoSignalHealthForSVResult::CmdName = "GetGalileoSignalHealthForSVResult";
    const char* const GetGalileoSignalHealthForSVResult::Documentation = "Result of GetGalileoSignalHealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoSignalHealthForSVResult);


    GetGalileoSignalHealthForSVResult::GetGalileoSignalHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGalileoSignalHealthForSVResult::GetGalileoSignalHealthForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& component, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setComponent(component);
      setHealth(health);
    }


    GetGalileoSignalHealthForSVResultPtr GetGalileoSignalHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& component, int health)
    {
      return GetGalileoSignalHealthForSVResultPtr(new GetGalileoSignalHealthForSVResult(relatedCommand, svId, component, health));
    }

    GetGalileoSignalHealthForSVResultPtr GetGalileoSignalHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoSignalHealthForSVResult>(ptr);
    }

    bool GetGalileoSignalHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGalileoSignalHealthForSVResult::documentation() const { return Documentation; }


    int GetGalileoSignalHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoSignalHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoSignalHealthForSVResult::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoSignalHealthForSVResult::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoSignalHealthForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetGalileoSignalHealthForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsL1HealthForSV
///
#include "gen/SetGpsL1HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsL1HealthForSV::CmdName = "SetGpsL1HealthForSV";
    const char* const SetGpsL1HealthForSV::Documentation = "Set GPS L1 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(SetGpsL1HealthForSV);


    SetGpsL1HealthForSV::SetGpsL1HealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsL1HealthForSV::SetGpsL1HealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGpsL1HealthForSVPtr SetGpsL1HealthForSV::create(int svId, bool health)
    {
      return SetGpsL1HealthForSVPtr(new SetGpsL1HealthForSV(svId, health));
    }

    SetGpsL1HealthForSVPtr SetGpsL1HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsL1HealthForSV>(ptr);
    }

    bool SetGpsL1HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsL1HealthForSV::documentation() const { return Documentation; }


    int SetGpsL1HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsL1HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsL1HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsL1HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsL1HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL1HealthForSV
///
#include "gen/GetGpsL1HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL1HealthForSV::CmdName = "GetGpsL1HealthForSV";
    const char* const GetGpsL1HealthForSV::Documentation = "Get GPS L1 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(GetGpsL1HealthForSV);


    GetGpsL1HealthForSV::GetGpsL1HealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsL1HealthForSV::GetGpsL1HealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsL1HealthForSVPtr GetGpsL1HealthForSV::create(int svId)
    {
      return GetGpsL1HealthForSVPtr(new GetGpsL1HealthForSV(svId));
    }

    GetGpsL1HealthForSVPtr GetGpsL1HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL1HealthForSV>(ptr);
    }

    bool GetGpsL1HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsL1HealthForSV::documentation() const { return Documentation; }


    int GetGpsL1HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsL1HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL1HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL1HealthForSVResult
///
#include "gen/GetGpsL1HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL1HealthForSVResult::CmdName = "GetGpsL1HealthForSVResult";
    const char* const GetGpsL1HealthForSVResult::Documentation = "Result of GetGpsL1HealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsL1HealthForSVResult);


    GetGpsL1HealthForSVResult::GetGpsL1HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsL1HealthForSVResult::GetGpsL1HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGpsL1HealthForSVResultPtr GetGpsL1HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetGpsL1HealthForSVResultPtr(new GetGpsL1HealthForSVResult(relatedCommand, svId, health));
    }

    GetGpsL1HealthForSVResultPtr GetGpsL1HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL1HealthForSVResult>(ptr);
    }

    bool GetGpsL1HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsL1HealthForSVResult::documentation() const { return Documentation; }


    int GetGpsL1HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL1HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsL1HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsL1HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsL2HealthForSV
///
#include "gen/SetGpsL2HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsL2HealthForSV::CmdName = "SetGpsL2HealthForSV";
    const char* const SetGpsL2HealthForSV::Documentation = "Set GPS L2 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(SetGpsL2HealthForSV);


    SetGpsL2HealthForSV::SetGpsL2HealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsL2HealthForSV::SetGpsL2HealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGpsL2HealthForSVPtr SetGpsL2HealthForSV::create(int svId, bool health)
    {
      return SetGpsL2HealthForSVPtr(new SetGpsL2HealthForSV(svId, health));
    }

    SetGpsL2HealthForSVPtr SetGpsL2HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsL2HealthForSV>(ptr);
    }

    bool SetGpsL2HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsL2HealthForSV::documentation() const { return Documentation; }


    int SetGpsL2HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsL2HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsL2HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsL2HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsL2HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL2HealthForSV
///
#include "gen/GetGpsL2HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL2HealthForSV::CmdName = "GetGpsL2HealthForSV";
    const char* const GetGpsL2HealthForSV::Documentation = "Get GPS L2 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(GetGpsL2HealthForSV);


    GetGpsL2HealthForSV::GetGpsL2HealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsL2HealthForSV::GetGpsL2HealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsL2HealthForSVPtr GetGpsL2HealthForSV::create(int svId)
    {
      return GetGpsL2HealthForSVPtr(new GetGpsL2HealthForSV(svId));
    }

    GetGpsL2HealthForSVPtr GetGpsL2HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL2HealthForSV>(ptr);
    }

    bool GetGpsL2HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsL2HealthForSV::documentation() const { return Documentation; }


    int GetGpsL2HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsL2HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL2HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL2HealthForSVResult
///
#include "gen/GetGpsL2HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL2HealthForSVResult::CmdName = "GetGpsL2HealthForSVResult";
    const char* const GetGpsL2HealthForSVResult::Documentation = "Result of GetGpsL2HealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsL2HealthForSVResult);


    GetGpsL2HealthForSVResult::GetGpsL2HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsL2HealthForSVResult::GetGpsL2HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGpsL2HealthForSVResultPtr GetGpsL2HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetGpsL2HealthForSVResultPtr(new GetGpsL2HealthForSVResult(relatedCommand, svId, health));
    }

    GetGpsL2HealthForSVResultPtr GetGpsL2HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL2HealthForSVResult>(ptr);
    }

    bool GetGpsL2HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsL2HealthForSVResult::documentation() const { return Documentation; }


    int GetGpsL2HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL2HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsL2HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsL2HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsL5HealthForSV
///
#include "gen/SetGpsL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsL5HealthForSV::CmdName = "SetGpsL5HealthForSV";
    const char* const SetGpsL5HealthForSV::Documentation = "Set GPS L5 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(SetGpsL5HealthForSV);


    SetGpsL5HealthForSV::SetGpsL5HealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsL5HealthForSV::SetGpsL5HealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGpsL5HealthForSVPtr SetGpsL5HealthForSV::create(int svId, bool health)
    {
      return SetGpsL5HealthForSVPtr(new SetGpsL5HealthForSV(svId, health));
    }

    SetGpsL5HealthForSVPtr SetGpsL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsL5HealthForSV>(ptr);
    }

    bool SetGpsL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsL5HealthForSV::documentation() const { return Documentation; }


    int SetGpsL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsL5HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsL5HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL5HealthForSV
///
#include "gen/GetGpsL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL5HealthForSV::CmdName = "GetGpsL5HealthForSV";
    const char* const GetGpsL5HealthForSV::Documentation = "Get GPS L5 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(GetGpsL5HealthForSV);


    GetGpsL5HealthForSV::GetGpsL5HealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsL5HealthForSV::GetGpsL5HealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsL5HealthForSVPtr GetGpsL5HealthForSV::create(int svId)
    {
      return GetGpsL5HealthForSVPtr(new GetGpsL5HealthForSV(svId));
    }

    GetGpsL5HealthForSVPtr GetGpsL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL5HealthForSV>(ptr);
    }

    bool GetGpsL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsL5HealthForSV::documentation() const { return Documentation; }


    int GetGpsL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL5HealthForSVResult
///
#include "gen/GetGpsL5HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL5HealthForSVResult::CmdName = "GetGpsL5HealthForSVResult";
    const char* const GetGpsL5HealthForSVResult::Documentation = "Result of GetGpsL5HealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsL5HealthForSVResult);


    GetGpsL5HealthForSVResult::GetGpsL5HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsL5HealthForSVResult::GetGpsL5HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGpsL5HealthForSVResultPtr GetGpsL5HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetGpsL5HealthForSVResultPtr(new GetGpsL5HealthForSVResult(relatedCommand, svId, health));
    }

    GetGpsL5HealthForSVResultPtr GetGpsL5HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL5HealthForSVResult>(ptr);
    }

    bool GetGpsL5HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsL5HealthForSVResult::documentation() const { return Documentation; }


    int GetGpsL5HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL5HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsL5HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsL5HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsL1cHealthForSV
///
#include "gen/SetGpsL1cHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsL1cHealthForSV::CmdName = "SetGpsL1cHealthForSV";
    const char* const SetGpsL1cHealthForSV::Documentation = "Set GPS L1C health (used in CNAV2 only)";

    REGISTER_COMMAND_FACTORY(SetGpsL1cHealthForSV);


    SetGpsL1cHealthForSV::SetGpsL1cHealthForSV()
      : CommandBase(CmdName)
    {}

    SetGpsL1cHealthForSV::SetGpsL1cHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGpsL1cHealthForSVPtr SetGpsL1cHealthForSV::create(int svId, bool health)
    {
      return SetGpsL1cHealthForSVPtr(new SetGpsL1cHealthForSV(svId, health));
    }

    SetGpsL1cHealthForSVPtr SetGpsL1cHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsL1cHealthForSV>(ptr);
    }

    bool SetGpsL1cHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsL1cHealthForSV::documentation() const { return Documentation; }


    int SetGpsL1cHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsL1cHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsL1cHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsL1cHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsL1cHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL1cHealthForSV
///
#include "gen/GetGpsL1cHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL1cHealthForSV::CmdName = "GetGpsL1cHealthForSV";
    const char* const GetGpsL1cHealthForSV::Documentation = "Get GPS L1C health (used in CNAV2 only)";

    REGISTER_COMMAND_FACTORY(GetGpsL1cHealthForSV);


    GetGpsL1cHealthForSV::GetGpsL1cHealthForSV()
      : CommandBase(CmdName)
    {}

    GetGpsL1cHealthForSV::GetGpsL1cHealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsL1cHealthForSVPtr GetGpsL1cHealthForSV::create(int svId)
    {
      return GetGpsL1cHealthForSVPtr(new GetGpsL1cHealthForSV(svId));
    }

    GetGpsL1cHealthForSVPtr GetGpsL1cHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL1cHealthForSV>(ptr);
    }

    bool GetGpsL1cHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsL1cHealthForSV::documentation() const { return Documentation; }


    int GetGpsL1cHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsL1cHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL1cHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsL1cHealthForSVResult
///
#include "gen/GetGpsL1cHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsL1cHealthForSVResult::CmdName = "GetGpsL1cHealthForSVResult";
    const char* const GetGpsL1cHealthForSVResult::Documentation = "Result of GetGpsL1cHealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsL1cHealthForSVResult);


    GetGpsL1cHealthForSVResult::GetGpsL1cHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsL1cHealthForSVResult::GetGpsL1cHealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGpsL1cHealthForSVResultPtr GetGpsL1cHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetGpsL1cHealthForSVResultPtr(new GetGpsL1cHealthForSVResult(relatedCommand, svId, health));
    }

    GetGpsL1cHealthForSVResultPtr GetGpsL1cHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsL1cHealthForSVResult>(ptr);
    }

    bool GetGpsL1cHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsL1cHealthForSVResult::documentation() const { return Documentation; }


    int GetGpsL1cHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsL1cHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsL1cHealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsL1cHealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsAntiSpoofingFlagForSV
///
#include "gen/SetGpsAntiSpoofingFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsAntiSpoofingFlagForSV::CmdName = "SetGpsAntiSpoofingFlagForSV";
    const char* const SetGpsAntiSpoofingFlagForSV::Documentation = "Set GPS Anti-Spoofing Flag";

    REGISTER_COMMAND_FACTORY(SetGpsAntiSpoofingFlagForSV);


    SetGpsAntiSpoofingFlagForSV::SetGpsAntiSpoofingFlagForSV()
      : CommandBase(CmdName)
    {}

    SetGpsAntiSpoofingFlagForSV::SetGpsAntiSpoofingFlagForSV(int svId, const Sdx::GpsASFlag& antiSpoofing)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAntiSpoofing(antiSpoofing);
    }


    SetGpsAntiSpoofingFlagForSVPtr SetGpsAntiSpoofingFlagForSV::create(int svId, const Sdx::GpsASFlag& antiSpoofing)
    {
      return SetGpsAntiSpoofingFlagForSVPtr(new SetGpsAntiSpoofingFlagForSV(svId, antiSpoofing));
    }

    SetGpsAntiSpoofingFlagForSVPtr SetGpsAntiSpoofingFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsAntiSpoofingFlagForSV>(ptr);
    }

    bool SetGpsAntiSpoofingFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::GpsASFlag>::is_valid(m_values["AntiSpoofing"])
        ;

    }

    std::string SetGpsAntiSpoofingFlagForSV::documentation() const { return Documentation; }


    int SetGpsAntiSpoofingFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsAntiSpoofingFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsAntiSpoofingFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GpsASFlag SetGpsAntiSpoofingFlagForSV::antiSpoofing() const
    {
      return parse_json<Sdx::GpsASFlag>::parse(m_values["AntiSpoofing"]);
    }

    void SetGpsAntiSpoofingFlagForSV::setAntiSpoofing(const Sdx::GpsASFlag& antiSpoofing)
    {
      m_values.AddMember("AntiSpoofing", parse_json<Sdx::GpsASFlag>::format(antiSpoofing, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsAntiSpoofingFlagForSV
///
#include "gen/GetGpsAntiSpoofingFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsAntiSpoofingFlagForSV::CmdName = "GetGpsAntiSpoofingFlagForSV";
    const char* const GetGpsAntiSpoofingFlagForSV::Documentation = "Get GPS Anti-Spoofing Flag";

    REGISTER_COMMAND_FACTORY(GetGpsAntiSpoofingFlagForSV);


    GetGpsAntiSpoofingFlagForSV::GetGpsAntiSpoofingFlagForSV()
      : CommandBase(CmdName)
    {}

    GetGpsAntiSpoofingFlagForSV::GetGpsAntiSpoofingFlagForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsAntiSpoofingFlagForSVPtr GetGpsAntiSpoofingFlagForSV::create(int svId)
    {
      return GetGpsAntiSpoofingFlagForSVPtr(new GetGpsAntiSpoofingFlagForSV(svId));
    }

    GetGpsAntiSpoofingFlagForSVPtr GetGpsAntiSpoofingFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsAntiSpoofingFlagForSV>(ptr);
    }

    bool GetGpsAntiSpoofingFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsAntiSpoofingFlagForSV::documentation() const { return Documentation; }


    int GetGpsAntiSpoofingFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsAntiSpoofingFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsAntiSpoofingFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsAntiSpoofingFlagForSVResult
///
#include "gen/GetGpsAntiSpoofingFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsAntiSpoofingFlagForSVResult::CmdName = "GetGpsAntiSpoofingFlagForSVResult";
    const char* const GetGpsAntiSpoofingFlagForSVResult::Documentation = "Result of GetGpsAntiSpoofingFlagForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsAntiSpoofingFlagForSVResult);


    GetGpsAntiSpoofingFlagForSVResult::GetGpsAntiSpoofingFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsAntiSpoofingFlagForSVResult::GetGpsAntiSpoofingFlagForSVResult(CommandBasePtr relatedCommand, int svId, const Sdx::GpsASFlag& antiSpoofing)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAntiSpoofing(antiSpoofing);
    }


    GetGpsAntiSpoofingFlagForSVResultPtr GetGpsAntiSpoofingFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, const Sdx::GpsASFlag& antiSpoofing)
    {
      return GetGpsAntiSpoofingFlagForSVResultPtr(new GetGpsAntiSpoofingFlagForSVResult(relatedCommand, svId, antiSpoofing));
    }

    GetGpsAntiSpoofingFlagForSVResultPtr GetGpsAntiSpoofingFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsAntiSpoofingFlagForSVResult>(ptr);
    }

    bool GetGpsAntiSpoofingFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::GpsASFlag>::is_valid(m_values["AntiSpoofing"])
        ;

    }

    std::string GetGpsAntiSpoofingFlagForSVResult::documentation() const { return Documentation; }


    int GetGpsAntiSpoofingFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsAntiSpoofingFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GpsASFlag GetGpsAntiSpoofingFlagForSVResult::antiSpoofing() const
    {
      return parse_json<Sdx::GpsASFlag>::parse(m_values["AntiSpoofing"]);
    }

    void GetGpsAntiSpoofingFlagForSVResult::setAntiSpoofing(const Sdx::GpsASFlag& antiSpoofing)
    {
      m_values.AddMember("AntiSpoofing", parse_json<Sdx::GpsASFlag>::format(antiSpoofing, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsNavAlertFlagForSV
///
#include "gen/SetGpsNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsNavAlertFlagForSV::CmdName = "SetGpsNavAlertFlagForSV";
    const char* const SetGpsNavAlertFlagForSV::Documentation = "Set GPS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetGpsNavAlertFlagForSV);


    SetGpsNavAlertFlagForSV::SetGpsNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    SetGpsNavAlertFlagForSV::SetGpsNavAlertFlagForSV(int svId, bool alert)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
    }


    SetGpsNavAlertFlagForSVPtr SetGpsNavAlertFlagForSV::create(int svId, bool alert)
    {
      return SetGpsNavAlertFlagForSVPtr(new SetGpsNavAlertFlagForSV(svId, alert));
    }

    SetGpsNavAlertFlagForSVPtr SetGpsNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsNavAlertFlagForSV>(ptr);
    }

    bool SetGpsNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string SetGpsNavAlertFlagForSV::documentation() const { return Documentation; }


    int SetGpsNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsNavAlertFlagForSV::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetGpsNavAlertFlagForSV::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsNavAlertFlagForSV
///
#include "gen/GetGpsNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsNavAlertFlagForSV::CmdName = "GetGpsNavAlertFlagForSV";
    const char* const GetGpsNavAlertFlagForSV::Documentation = "Get GPS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetGpsNavAlertFlagForSV);


    GetGpsNavAlertFlagForSV::GetGpsNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    GetGpsNavAlertFlagForSV::GetGpsNavAlertFlagForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsNavAlertFlagForSVPtr GetGpsNavAlertFlagForSV::create(int svId)
    {
      return GetGpsNavAlertFlagForSVPtr(new GetGpsNavAlertFlagForSV(svId));
    }

    GetGpsNavAlertFlagForSVPtr GetGpsNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsNavAlertFlagForSV>(ptr);
    }

    bool GetGpsNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsNavAlertFlagForSV::documentation() const { return Documentation; }


    int GetGpsNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsNavAlertFlagForSVResult
///
#include "gen/GetGpsNavAlertFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsNavAlertFlagForSVResult::CmdName = "GetGpsNavAlertFlagForSVResult";
    const char* const GetGpsNavAlertFlagForSVResult::Documentation = "Result of GetGpsNavAlertFlagForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsNavAlertFlagForSVResult);


    GetGpsNavAlertFlagForSVResult::GetGpsNavAlertFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsNavAlertFlagForSVResult::GetGpsNavAlertFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool alert)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAlert(alert);
    }


    GetGpsNavAlertFlagForSVResultPtr GetGpsNavAlertFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool alert)
    {
      return GetGpsNavAlertFlagForSVResultPtr(new GetGpsNavAlertFlagForSVResult(relatedCommand, svId, alert));
    }

    GetGpsNavAlertFlagForSVResultPtr GetGpsNavAlertFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsNavAlertFlagForSVResult>(ptr);
    }

    bool GetGpsNavAlertFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string GetGpsNavAlertFlagForSVResult::documentation() const { return Documentation; }


    int GetGpsNavAlertFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsNavAlertFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsNavAlertFlagForSVResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetGpsNavAlertFlagForSVResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsCNavAlertFlagToSV
///
#include "gen/SetGpsCNavAlertFlagToSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsCNavAlertFlagToSV::CmdName = "SetGpsCNavAlertFlagToSV";
    const char* const SetGpsCNavAlertFlagToSV::Documentation = "Set GPS CNAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetGpsCNavAlertFlagToSV);


    SetGpsCNavAlertFlagToSV::SetGpsCNavAlertFlagToSV()
      : CommandBase(CmdName)
    {}

    SetGpsCNavAlertFlagToSV::SetGpsCNavAlertFlagToSV(int svId, bool alert)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
    }


    SetGpsCNavAlertFlagToSVPtr SetGpsCNavAlertFlagToSV::create(int svId, bool alert)
    {
      return SetGpsCNavAlertFlagToSVPtr(new SetGpsCNavAlertFlagToSV(svId, alert));
    }

    SetGpsCNavAlertFlagToSVPtr SetGpsCNavAlertFlagToSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsCNavAlertFlagToSV>(ptr);
    }

    bool SetGpsCNavAlertFlagToSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string SetGpsCNavAlertFlagToSV::documentation() const { return Documentation; }


    int SetGpsCNavAlertFlagToSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsCNavAlertFlagToSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsCNavAlertFlagToSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsCNavAlertFlagToSV::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetGpsCNavAlertFlagToSV::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNavAlertFlagToSV
///
#include "gen/GetGpsCNavAlertFlagToSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNavAlertFlagToSV::CmdName = "GetGpsCNavAlertFlagToSV";
    const char* const GetGpsCNavAlertFlagToSV::Documentation = "Get GPS CNAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetGpsCNavAlertFlagToSV);


    GetGpsCNavAlertFlagToSV::GetGpsCNavAlertFlagToSV()
      : CommandBase(CmdName)
    {}

    GetGpsCNavAlertFlagToSV::GetGpsCNavAlertFlagToSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGpsCNavAlertFlagToSVPtr GetGpsCNavAlertFlagToSV::create(int svId)
    {
      return GetGpsCNavAlertFlagToSVPtr(new GetGpsCNavAlertFlagToSV(svId));
    }

    GetGpsCNavAlertFlagToSVPtr GetGpsCNavAlertFlagToSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNavAlertFlagToSV>(ptr);
    }

    bool GetGpsCNavAlertFlagToSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGpsCNavAlertFlagToSV::documentation() const { return Documentation; }


    int GetGpsCNavAlertFlagToSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsCNavAlertFlagToSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsCNavAlertFlagToSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNavAlertFlagToSVResult
///
#include "gen/GetGpsCNavAlertFlagToSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNavAlertFlagToSVResult::CmdName = "GetGpsCNavAlertFlagToSVResult";
    const char* const GetGpsCNavAlertFlagToSVResult::Documentation = "Result of GetGpsCNavAlertFlagToSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsCNavAlertFlagToSVResult);


    GetGpsCNavAlertFlagToSVResult::GetGpsCNavAlertFlagToSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsCNavAlertFlagToSVResult::GetGpsCNavAlertFlagToSVResult(CommandBasePtr relatedCommand, int svId, bool alert)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAlert(alert);
    }


    GetGpsCNavAlertFlagToSVResultPtr GetGpsCNavAlertFlagToSVResult::create(CommandBasePtr relatedCommand, int svId, bool alert)
    {
      return GetGpsCNavAlertFlagToSVResultPtr(new GetGpsCNavAlertFlagToSVResult(relatedCommand, svId, alert));
    }

    GetGpsCNavAlertFlagToSVResultPtr GetGpsCNavAlertFlagToSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNavAlertFlagToSVResult>(ptr);
    }

    bool GetGpsCNavAlertFlagToSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string GetGpsCNavAlertFlagToSVResult::documentation() const { return Documentation; }


    int GetGpsCNavAlertFlagToSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsCNavAlertFlagToSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsCNavAlertFlagToSVResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetGpsCNavAlertFlagToSVResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouHealthInfoForSV
///
#include "gen/SetBeiDouHealthInfoForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouHealthInfoForSV::CmdName = "SetBeiDouHealthInfoForSV";
    const char* const SetBeiDouHealthInfoForSV::Documentation = "Set BeiDou satellite health info";

    REGISTER_COMMAND_FACTORY(SetBeiDouHealthInfoForSV);


    SetBeiDouHealthInfoForSV::SetBeiDouHealthInfoForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouHealthInfoForSV::SetBeiDouHealthInfoForSV(int svId, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetBeiDouHealthInfoForSVPtr SetBeiDouHealthInfoForSV::create(int svId, int health)
    {
      return SetBeiDouHealthInfoForSVPtr(new SetBeiDouHealthInfoForSV(svId, health));
    }

    SetBeiDouHealthInfoForSVPtr SetBeiDouHealthInfoForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouHealthInfoForSV>(ptr);
    }

    bool SetBeiDouHealthInfoForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetBeiDouHealthInfoForSV::documentation() const { return Documentation; }


    int SetBeiDouHealthInfoForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouHealthInfoForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouHealthInfoForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouHealthInfoForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetBeiDouHealthInfoForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouHealthInfoForSV
///
#include "gen/GetBeiDouHealthInfoForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouHealthInfoForSV::CmdName = "GetBeiDouHealthInfoForSV";
    const char* const GetBeiDouHealthInfoForSV::Documentation = "Get BeiDou satellite health info";

    REGISTER_COMMAND_FACTORY(GetBeiDouHealthInfoForSV);


    GetBeiDouHealthInfoForSV::GetBeiDouHealthInfoForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouHealthInfoForSV::GetBeiDouHealthInfoForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetBeiDouHealthInfoForSVPtr GetBeiDouHealthInfoForSV::create(int svId)
    {
      return GetBeiDouHealthInfoForSVPtr(new GetBeiDouHealthInfoForSV(svId));
    }

    GetBeiDouHealthInfoForSVPtr GetBeiDouHealthInfoForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouHealthInfoForSV>(ptr);
    }

    bool GetBeiDouHealthInfoForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetBeiDouHealthInfoForSV::documentation() const { return Documentation; }


    int GetBeiDouHealthInfoForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouHealthInfoForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouHealthInfoForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouHealthInfoForSVResult
///
#include "gen/GetBeiDouHealthInfoForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouHealthInfoForSVResult::CmdName = "GetBeiDouHealthInfoForSVResult";
    const char* const GetBeiDouHealthInfoForSVResult::Documentation = "Result of GetBeiDouHealthInfoForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouHealthInfoForSVResult);


    GetBeiDouHealthInfoForSVResult::GetBeiDouHealthInfoForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouHealthInfoForSVResult::GetBeiDouHealthInfoForSVResult(CommandBasePtr relatedCommand, int svId, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetBeiDouHealthInfoForSVResultPtr GetBeiDouHealthInfoForSVResult::create(CommandBasePtr relatedCommand, int svId, int health)
    {
      return GetBeiDouHealthInfoForSVResultPtr(new GetBeiDouHealthInfoForSVResult(relatedCommand, svId, health));
    }

    GetBeiDouHealthInfoForSVResultPtr GetBeiDouHealthInfoForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouHealthInfoForSVResult>(ptr);
    }

    bool GetBeiDouHealthInfoForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetBeiDouHealthInfoForSVResult::documentation() const { return Documentation; }


    int GetBeiDouHealthInfoForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouHealthInfoForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouHealthInfoForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetBeiDouHealthInfoForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouAutonomousHealthForSV
///
#include "gen/SetBeiDouAutonomousHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouAutonomousHealthForSV::CmdName = "SetBeiDouAutonomousHealthForSV";
    const char* const SetBeiDouAutonomousHealthForSV::Documentation = "Set BeiDou satellite autonomous health";

    REGISTER_COMMAND_FACTORY(SetBeiDouAutonomousHealthForSV);


    SetBeiDouAutonomousHealthForSV::SetBeiDouAutonomousHealthForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouAutonomousHealthForSV::SetBeiDouAutonomousHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetBeiDouAutonomousHealthForSVPtr SetBeiDouAutonomousHealthForSV::create(int svId, bool health)
    {
      return SetBeiDouAutonomousHealthForSVPtr(new SetBeiDouAutonomousHealthForSV(svId, health));
    }

    SetBeiDouAutonomousHealthForSVPtr SetBeiDouAutonomousHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouAutonomousHealthForSV>(ptr);
    }

    bool SetBeiDouAutonomousHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetBeiDouAutonomousHealthForSV::documentation() const { return Documentation; }


    int SetBeiDouAutonomousHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouAutonomousHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouAutonomousHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetBeiDouAutonomousHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetBeiDouAutonomousHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouAutonomousHealthForSV
///
#include "gen/GetBeiDouAutonomousHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouAutonomousHealthForSV::CmdName = "GetBeiDouAutonomousHealthForSV";
    const char* const GetBeiDouAutonomousHealthForSV::Documentation = "Get BeiDou satellite autonomous health";

    REGISTER_COMMAND_FACTORY(GetBeiDouAutonomousHealthForSV);


    GetBeiDouAutonomousHealthForSV::GetBeiDouAutonomousHealthForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouAutonomousHealthForSV::GetBeiDouAutonomousHealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetBeiDouAutonomousHealthForSVPtr GetBeiDouAutonomousHealthForSV::create(int svId)
    {
      return GetBeiDouAutonomousHealthForSVPtr(new GetBeiDouAutonomousHealthForSV(svId));
    }

    GetBeiDouAutonomousHealthForSVPtr GetBeiDouAutonomousHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouAutonomousHealthForSV>(ptr);
    }

    bool GetBeiDouAutonomousHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetBeiDouAutonomousHealthForSV::documentation() const { return Documentation; }


    int GetBeiDouAutonomousHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouAutonomousHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouAutonomousHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouAutonomousHealthForSVResult
///
#include "gen/GetBeiDouAutonomousHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouAutonomousHealthForSVResult::CmdName = "GetBeiDouAutonomousHealthForSVResult";
    const char* const GetBeiDouAutonomousHealthForSVResult::Documentation = "Result of GetBeiDouAutonomousHealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouAutonomousHealthForSVResult);


    GetBeiDouAutonomousHealthForSVResult::GetBeiDouAutonomousHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouAutonomousHealthForSVResult::GetBeiDouAutonomousHealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetBeiDouAutonomousHealthForSVResultPtr GetBeiDouAutonomousHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetBeiDouAutonomousHealthForSVResultPtr(new GetBeiDouAutonomousHealthForSVResult(relatedCommand, svId, health));
    }

    GetBeiDouAutonomousHealthForSVResultPtr GetBeiDouAutonomousHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouAutonomousHealthForSVResult>(ptr);
    }

    bool GetBeiDouAutonomousHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetBeiDouAutonomousHealthForSVResult::documentation() const { return Documentation; }


    int GetBeiDouAutonomousHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouAutonomousHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouAutonomousHealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetBeiDouAutonomousHealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouCNavHealthInfoForSV
///
#include "gen/SetBeiDouCNavHealthInfoForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouCNavHealthInfoForSV::CmdName = "SetBeiDouCNavHealthInfoForSV";
    const char* const SetBeiDouCNavHealthInfoForSV::Documentation = "Set BeiDou CNav satellite health info";

    REGISTER_COMMAND_FACTORY(SetBeiDouCNavHealthInfoForSV);


    SetBeiDouCNavHealthInfoForSV::SetBeiDouCNavHealthInfoForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouCNavHealthInfoForSV::SetBeiDouCNavHealthInfoForSV(int svId, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetBeiDouCNavHealthInfoForSVPtr SetBeiDouCNavHealthInfoForSV::create(int svId, int health)
    {
      return SetBeiDouCNavHealthInfoForSVPtr(new SetBeiDouCNavHealthInfoForSV(svId, health));
    }

    SetBeiDouCNavHealthInfoForSVPtr SetBeiDouCNavHealthInfoForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouCNavHealthInfoForSV>(ptr);
    }

    bool SetBeiDouCNavHealthInfoForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetBeiDouCNavHealthInfoForSV::documentation() const { return Documentation; }


    int SetBeiDouCNavHealthInfoForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouCNavHealthInfoForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouCNavHealthInfoForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouCNavHealthInfoForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetBeiDouCNavHealthInfoForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNavHealthInfoForSV
///
#include "gen/GetBeiDouCNavHealthInfoForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNavHealthInfoForSV::CmdName = "GetBeiDouCNavHealthInfoForSV";
    const char* const GetBeiDouCNavHealthInfoForSV::Documentation = "Get BeiDou CNav satellite health info";

    REGISTER_COMMAND_FACTORY(GetBeiDouCNavHealthInfoForSV);


    GetBeiDouCNavHealthInfoForSV::GetBeiDouCNavHealthInfoForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouCNavHealthInfoForSV::GetBeiDouCNavHealthInfoForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetBeiDouCNavHealthInfoForSVPtr GetBeiDouCNavHealthInfoForSV::create(int svId)
    {
      return GetBeiDouCNavHealthInfoForSVPtr(new GetBeiDouCNavHealthInfoForSV(svId));
    }

    GetBeiDouCNavHealthInfoForSVPtr GetBeiDouCNavHealthInfoForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNavHealthInfoForSV>(ptr);
    }

    bool GetBeiDouCNavHealthInfoForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetBeiDouCNavHealthInfoForSV::documentation() const { return Documentation; }


    int GetBeiDouCNavHealthInfoForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouCNavHealthInfoForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouCNavHealthInfoForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNavHealthInfoForSVResult
///
#include "gen/GetBeiDouCNavHealthInfoForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNavHealthInfoForSVResult::CmdName = "GetBeiDouCNavHealthInfoForSVResult";
    const char* const GetBeiDouCNavHealthInfoForSVResult::Documentation = "Result of GetBeiDouCNavHealthInfoForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouCNavHealthInfoForSVResult);


    GetBeiDouCNavHealthInfoForSVResult::GetBeiDouCNavHealthInfoForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouCNavHealthInfoForSVResult::GetBeiDouCNavHealthInfoForSVResult(CommandBasePtr relatedCommand, int svId, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetBeiDouCNavHealthInfoForSVResultPtr GetBeiDouCNavHealthInfoForSVResult::create(CommandBasePtr relatedCommand, int svId, int health)
    {
      return GetBeiDouCNavHealthInfoForSVResultPtr(new GetBeiDouCNavHealthInfoForSVResult(relatedCommand, svId, health));
    }

    GetBeiDouCNavHealthInfoForSVResultPtr GetBeiDouCNavHealthInfoForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNavHealthInfoForSVResult>(ptr);
    }

    bool GetBeiDouCNavHealthInfoForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetBeiDouCNavHealthInfoForSVResult::documentation() const { return Documentation; }


    int GetBeiDouCNavHealthInfoForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouCNavHealthInfoForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouCNavHealthInfoForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetBeiDouCNavHealthInfoForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouHealthStatusForSV
///
#include "gen/SetBeiDouHealthStatusForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouHealthStatusForSV::CmdName = "SetBeiDouHealthStatusForSV";
    const char* const SetBeiDouHealthStatusForSV::Documentation = "Set BeiDou satellite health status";

    REGISTER_COMMAND_FACTORY(SetBeiDouHealthStatusForSV);


    SetBeiDouHealthStatusForSV::SetBeiDouHealthStatusForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouHealthStatusForSV::SetBeiDouHealthStatusForSV(int svId, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetBeiDouHealthStatusForSVPtr SetBeiDouHealthStatusForSV::create(int svId, int health)
    {
      return SetBeiDouHealthStatusForSVPtr(new SetBeiDouHealthStatusForSV(svId, health));
    }

    SetBeiDouHealthStatusForSVPtr SetBeiDouHealthStatusForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouHealthStatusForSV>(ptr);
    }

    bool SetBeiDouHealthStatusForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetBeiDouHealthStatusForSV::documentation() const { return Documentation; }


    int SetBeiDouHealthStatusForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouHealthStatusForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouHealthStatusForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouHealthStatusForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetBeiDouHealthStatusForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouHealthStatusForSV
///
#include "gen/GetBeiDouHealthStatusForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouHealthStatusForSV::CmdName = "GetBeiDouHealthStatusForSV";
    const char* const GetBeiDouHealthStatusForSV::Documentation = "Get BeiDou satellite health status";

    REGISTER_COMMAND_FACTORY(GetBeiDouHealthStatusForSV);


    GetBeiDouHealthStatusForSV::GetBeiDouHealthStatusForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouHealthStatusForSV::GetBeiDouHealthStatusForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetBeiDouHealthStatusForSVPtr GetBeiDouHealthStatusForSV::create(int svId)
    {
      return GetBeiDouHealthStatusForSVPtr(new GetBeiDouHealthStatusForSV(svId));
    }

    GetBeiDouHealthStatusForSVPtr GetBeiDouHealthStatusForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouHealthStatusForSV>(ptr);
    }

    bool GetBeiDouHealthStatusForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetBeiDouHealthStatusForSV::documentation() const { return Documentation; }


    int GetBeiDouHealthStatusForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouHealthStatusForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouHealthStatusForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouHealthStatusForSVResult
///
#include "gen/GetBeiDouHealthStatusForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouHealthStatusForSVResult::CmdName = "GetBeiDouHealthStatusForSVResult";
    const char* const GetBeiDouHealthStatusForSVResult::Documentation = "Result of GetBeiDouHealthStatusForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouHealthStatusForSVResult);


    GetBeiDouHealthStatusForSVResult::GetBeiDouHealthStatusForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouHealthStatusForSVResult::GetBeiDouHealthStatusForSVResult(CommandBasePtr relatedCommand, int svId, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetBeiDouHealthStatusForSVResultPtr GetBeiDouHealthStatusForSVResult::create(CommandBasePtr relatedCommand, int svId, int health)
    {
      return GetBeiDouHealthStatusForSVResultPtr(new GetBeiDouHealthStatusForSVResult(relatedCommand, svId, health));
    }

    GetBeiDouHealthStatusForSVResultPtr GetBeiDouHealthStatusForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouHealthStatusForSVResult>(ptr);
    }

    bool GetBeiDouHealthStatusForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetBeiDouHealthStatusForSVResult::documentation() const { return Documentation; }


    int GetBeiDouHealthStatusForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouHealthStatusForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouHealthStatusForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetBeiDouHealthStatusForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassEphemerisHealthFlagForSV
///
#include "gen/SetGlonassEphemerisHealthFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassEphemerisHealthFlagForSV::CmdName = "SetGlonassEphemerisHealthFlagForSV";
    const char* const SetGlonassEphemerisHealthFlagForSV::Documentation = "Set GLONASS satellite Ephemeris Health Flag Bn(ln)";

    REGISTER_COMMAND_FACTORY(SetGlonassEphemerisHealthFlagForSV);


    SetGlonassEphemerisHealthFlagForSV::SetGlonassEphemerisHealthFlagForSV()
      : CommandBase(CmdName)
    {}

    SetGlonassEphemerisHealthFlagForSV::SetGlonassEphemerisHealthFlagForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGlonassEphemerisHealthFlagForSVPtr SetGlonassEphemerisHealthFlagForSV::create(int svId, bool health)
    {
      return SetGlonassEphemerisHealthFlagForSVPtr(new SetGlonassEphemerisHealthFlagForSV(svId, health));
    }

    SetGlonassEphemerisHealthFlagForSVPtr SetGlonassEphemerisHealthFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassEphemerisHealthFlagForSV>(ptr);
    }

    bool SetGlonassEphemerisHealthFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGlonassEphemerisHealthFlagForSV::documentation() const { return Documentation; }


    int SetGlonassEphemerisHealthFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGlonassEphemerisHealthFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGlonassEphemerisHealthFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGlonassEphemerisHealthFlagForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGlonassEphemerisHealthFlagForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphemerisHealthFlagForSV
///
#include "gen/GetGlonassEphemerisHealthFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphemerisHealthFlagForSV::CmdName = "GetGlonassEphemerisHealthFlagForSV";
    const char* const GetGlonassEphemerisHealthFlagForSV::Documentation = "Get GLONASS satellite Ephemeris Health Flag Bn(ln)";

    REGISTER_COMMAND_FACTORY(GetGlonassEphemerisHealthFlagForSV);


    GetGlonassEphemerisHealthFlagForSV::GetGlonassEphemerisHealthFlagForSV()
      : CommandBase(CmdName)
    {}

    GetGlonassEphemerisHealthFlagForSV::GetGlonassEphemerisHealthFlagForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGlonassEphemerisHealthFlagForSVPtr GetGlonassEphemerisHealthFlagForSV::create(int svId)
    {
      return GetGlonassEphemerisHealthFlagForSVPtr(new GetGlonassEphemerisHealthFlagForSV(svId));
    }

    GetGlonassEphemerisHealthFlagForSVPtr GetGlonassEphemerisHealthFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphemerisHealthFlagForSV>(ptr);
    }

    bool GetGlonassEphemerisHealthFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGlonassEphemerisHealthFlagForSV::documentation() const { return Documentation; }


    int GetGlonassEphemerisHealthFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassEphemerisHealthFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassEphemerisHealthFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphemerisHealthFlagForSVResult
///
#include "gen/GetGlonassEphemerisHealthFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphemerisHealthFlagForSVResult::CmdName = "GetGlonassEphemerisHealthFlagForSVResult";
    const char* const GetGlonassEphemerisHealthFlagForSVResult::Documentation = "Result of GetGlonassEphemerisHealthFlagForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassEphemerisHealthFlagForSVResult);


    GetGlonassEphemerisHealthFlagForSVResult::GetGlonassEphemerisHealthFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetGlonassEphemerisHealthFlagForSVResult::GetGlonassEphemerisHealthFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGlonassEphemerisHealthFlagForSVResultPtr GetGlonassEphemerisHealthFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetGlonassEphemerisHealthFlagForSVResultPtr(new GetGlonassEphemerisHealthFlagForSVResult(relatedCommand, svId, health));
    }

    GetGlonassEphemerisHealthFlagForSVResultPtr GetGlonassEphemerisHealthFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphemerisHealthFlagForSVResult>(ptr);
    }

    bool GetGlonassEphemerisHealthFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGlonassEphemerisHealthFlagForSVResult::documentation() const { return Documentation; }


    int GetGlonassEphemerisHealthFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassEphemerisHealthFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGlonassEphemerisHealthFlagForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGlonassEphemerisHealthFlagForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassAlmanacUnhealthyFlagForSV
///
#include "gen/SetGlonassAlmanacUnhealthyFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassAlmanacUnhealthyFlagForSV::CmdName = "SetGlonassAlmanacUnhealthyFlagForSV";
    const char* const SetGlonassAlmanacUnhealthyFlagForSV::Documentation = "Set GLONASS satellite Almanac Unhealthy Flag Cn";

    REGISTER_COMMAND_FACTORY(SetGlonassAlmanacUnhealthyFlagForSV);


    SetGlonassAlmanacUnhealthyFlagForSV::SetGlonassAlmanacUnhealthyFlagForSV()
      : CommandBase(CmdName)
    {}

    SetGlonassAlmanacUnhealthyFlagForSV::SetGlonassAlmanacUnhealthyFlagForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetGlonassAlmanacUnhealthyFlagForSVPtr SetGlonassAlmanacUnhealthyFlagForSV::create(int svId, bool health)
    {
      return SetGlonassAlmanacUnhealthyFlagForSVPtr(new SetGlonassAlmanacUnhealthyFlagForSV(svId, health));
    }

    SetGlonassAlmanacUnhealthyFlagForSVPtr SetGlonassAlmanacUnhealthyFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassAlmanacUnhealthyFlagForSV>(ptr);
    }

    bool SetGlonassAlmanacUnhealthyFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGlonassAlmanacUnhealthyFlagForSV::documentation() const { return Documentation; }


    int SetGlonassAlmanacUnhealthyFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGlonassAlmanacUnhealthyFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGlonassAlmanacUnhealthyFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGlonassAlmanacUnhealthyFlagForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGlonassAlmanacUnhealthyFlagForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassAlmanacUnhealthyFlagForSV
///
#include "gen/GetGlonassAlmanacUnhealthyFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassAlmanacUnhealthyFlagForSV::CmdName = "GetGlonassAlmanacUnhealthyFlagForSV";
    const char* const GetGlonassAlmanacUnhealthyFlagForSV::Documentation = "Get GLONASS satellite Almanac Unhealthy Flag Cn";

    REGISTER_COMMAND_FACTORY(GetGlonassAlmanacUnhealthyFlagForSV);


    GetGlonassAlmanacUnhealthyFlagForSV::GetGlonassAlmanacUnhealthyFlagForSV()
      : CommandBase(CmdName)
    {}

    GetGlonassAlmanacUnhealthyFlagForSV::GetGlonassAlmanacUnhealthyFlagForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetGlonassAlmanacUnhealthyFlagForSVPtr GetGlonassAlmanacUnhealthyFlagForSV::create(int svId)
    {
      return GetGlonassAlmanacUnhealthyFlagForSVPtr(new GetGlonassAlmanacUnhealthyFlagForSV(svId));
    }

    GetGlonassAlmanacUnhealthyFlagForSVPtr GetGlonassAlmanacUnhealthyFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassAlmanacUnhealthyFlagForSV>(ptr);
    }

    bool GetGlonassAlmanacUnhealthyFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetGlonassAlmanacUnhealthyFlagForSV::documentation() const { return Documentation; }


    int GetGlonassAlmanacUnhealthyFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassAlmanacUnhealthyFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassAlmanacUnhealthyFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassAlmanacUnhealthyFlagForSVResult
///
#include "gen/GetGlonassAlmanacUnhealthyFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassAlmanacUnhealthyFlagForSVResult::CmdName = "GetGlonassAlmanacUnhealthyFlagForSVResult";
    const char* const GetGlonassAlmanacUnhealthyFlagForSVResult::Documentation = "Result of GetGlonassAlmanacUnhealthyFlagForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassAlmanacUnhealthyFlagForSVResult);


    GetGlonassAlmanacUnhealthyFlagForSVResult::GetGlonassAlmanacUnhealthyFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetGlonassAlmanacUnhealthyFlagForSVResult::GetGlonassAlmanacUnhealthyFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetGlonassAlmanacUnhealthyFlagForSVResultPtr GetGlonassAlmanacUnhealthyFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetGlonassAlmanacUnhealthyFlagForSVResultPtr(new GetGlonassAlmanacUnhealthyFlagForSVResult(relatedCommand, svId, health));
    }

    GetGlonassAlmanacUnhealthyFlagForSVResultPtr GetGlonassAlmanacUnhealthyFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassAlmanacUnhealthyFlagForSVResult>(ptr);
    }

    bool GetGlonassAlmanacUnhealthyFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGlonassAlmanacUnhealthyFlagForSVResult::documentation() const { return Documentation; }


    int GetGlonassAlmanacUnhealthyFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassAlmanacUnhealthyFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGlonassAlmanacUnhealthyFlagForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGlonassAlmanacUnhealthyFlagForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL1DataHealthForSV
///
#include "gen/SetQzssL1DataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL1DataHealthForSV::CmdName = "SetQzssL1DataHealthForSV";
    const char* const SetQzssL1DataHealthForSV::Documentation = "Set QZSS L1 C/A nav data health";

    REGISTER_COMMAND_FACTORY(SetQzssL1DataHealthForSV);


    SetQzssL1DataHealthForSV::SetQzssL1DataHealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL1DataHealthForSV::SetQzssL1DataHealthForSV(int svId, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssL1DataHealthForSVPtr SetQzssL1DataHealthForSV::create(int svId, int health)
    {
      return SetQzssL1DataHealthForSVPtr(new SetQzssL1DataHealthForSV(svId, health));
    }

    SetQzssL1DataHealthForSVPtr SetQzssL1DataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL1DataHealthForSV>(ptr);
    }

    bool SetQzssL1DataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssL1DataHealthForSV::documentation() const { return Documentation; }


    int SetQzssL1DataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL1DataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL1DataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssL1DataHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetQzssL1DataHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL1DataHealth
///
#include "gen/SetQzssSatelliteL1DataHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL1DataHealth::CmdName = "SetQzssSatelliteL1DataHealth";
    const char* const SetQzssSatelliteL1DataHealth::Documentation = "Please note the command SetQzssSatelliteL1DataHealth is deprecated since 21.3. You may use SetQzssL1DataHealthForSV.\n\nSet QZSS L1 C/A nav data health";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL1DataHealth);


    SetQzssSatelliteL1DataHealth::SetQzssSatelliteL1DataHealth()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL1DataHealth::SetQzssSatelliteL1DataHealth(int svId, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssSatelliteL1DataHealthPtr SetQzssSatelliteL1DataHealth::create(int svId, int health)
    {
      return SetQzssSatelliteL1DataHealthPtr(new SetQzssSatelliteL1DataHealth(svId, health));
    }

    SetQzssSatelliteL1DataHealthPtr SetQzssSatelliteL1DataHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL1DataHealth>(ptr);
    }

    bool SetQzssSatelliteL1DataHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssSatelliteL1DataHealth::documentation() const { return Documentation; }


    int SetQzssSatelliteL1DataHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL1DataHealth::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL1DataHealth::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssSatelliteL1DataHealth::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL1DataHealth::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1DataHealthForSV
///
#include "gen/GetQzssL1DataHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1DataHealthForSV::CmdName = "GetQzssL1DataHealthForSV";
    const char* const GetQzssL1DataHealthForSV::Documentation = "Get QZSS L1 C/A nav data health";

    REGISTER_COMMAND_FACTORY(GetQzssL1DataHealthForSV);


    GetQzssL1DataHealthForSV::GetQzssL1DataHealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL1DataHealthForSV::GetQzssL1DataHealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssL1DataHealthForSVPtr GetQzssL1DataHealthForSV::create(int svId)
    {
      return GetQzssL1DataHealthForSVPtr(new GetQzssL1DataHealthForSV(svId));
    }

    GetQzssL1DataHealthForSVPtr GetQzssL1DataHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1DataHealthForSV>(ptr);
    }

    bool GetQzssL1DataHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssL1DataHealthForSV::documentation() const { return Documentation; }


    int GetQzssL1DataHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL1DataHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1DataHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL1DataHealth
///
#include "gen/GetQzssSatelliteL1DataHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL1DataHealth::CmdName = "GetQzssSatelliteL1DataHealth";
    const char* const GetQzssSatelliteL1DataHealth::Documentation = "Please note the command GetQzssSatelliteL1DataHealth is deprecated since 21.3. You may use GetQzssL1DataHealthForSV.\n\nGet QZSS L1 C/A nav data health";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL1DataHealth);


    GetQzssSatelliteL1DataHealth::GetQzssSatelliteL1DataHealth()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL1DataHealth::GetQzssSatelliteL1DataHealth(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssSatelliteL1DataHealthPtr GetQzssSatelliteL1DataHealth::create(int svId)
    {
      return GetQzssSatelliteL1DataHealthPtr(new GetQzssSatelliteL1DataHealth(svId));
    }

    GetQzssSatelliteL1DataHealthPtr GetQzssSatelliteL1DataHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL1DataHealth>(ptr);
    }

    bool GetQzssSatelliteL1DataHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssSatelliteL1DataHealth::documentation() const { return Documentation; }


    int GetQzssSatelliteL1DataHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL1DataHealth::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL1DataHealth::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1DataHealthForSVResult
///
#include "gen/GetQzssL1DataHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1DataHealthForSVResult::CmdName = "GetQzssL1DataHealthForSVResult";
    const char* const GetQzssL1DataHealthForSVResult::Documentation = "Result of GetQzssL1DataHealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1DataHealthForSVResult);


    GetQzssL1DataHealthForSVResult::GetQzssL1DataHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1DataHealthForSVResult::GetQzssL1DataHealthForSVResult(CommandBasePtr relatedCommand, int svId, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetQzssL1DataHealthForSVResultPtr GetQzssL1DataHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, int health)
    {
      return GetQzssL1DataHealthForSVResultPtr(new GetQzssL1DataHealthForSVResult(relatedCommand, svId, health));
    }

    GetQzssL1DataHealthForSVResultPtr GetQzssL1DataHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1DataHealthForSVResult>(ptr);
    }

    bool GetQzssL1DataHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetQzssL1DataHealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL1DataHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1DataHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssL1DataHealthForSVResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetQzssL1DataHealthForSVResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL1HealthForSV
///
#include "gen/SetQzssL1HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL1HealthForSV::CmdName = "SetQzssL1HealthForSV";
    const char* const SetQzssL1HealthForSV::Documentation = "Set QZSS L1 health (Health of L1C/A signal)";

    REGISTER_COMMAND_FACTORY(SetQzssL1HealthForSV);


    SetQzssL1HealthForSV::SetQzssL1HealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL1HealthForSV::SetQzssL1HealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssL1HealthForSVPtr SetQzssL1HealthForSV::create(int svId, bool health)
    {
      return SetQzssL1HealthForSVPtr(new SetQzssL1HealthForSV(svId, health));
    }

    SetQzssL1HealthForSVPtr SetQzssL1HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL1HealthForSV>(ptr);
    }

    bool SetQzssL1HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssL1HealthForSV::documentation() const { return Documentation; }


    int SetQzssL1HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL1HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL1HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL1HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssL1HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL1Health
///
#include "gen/SetQzssSatelliteL1Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL1Health::CmdName = "SetQzssSatelliteL1Health";
    const char* const SetQzssSatelliteL1Health::Documentation = "Please note the command SetQzssSatelliteL1Health is deprecated since 21.3. You may use SetQzssL1HealthForSV.\n\nSet QZSS L1 health (Health of L1C/A signal)";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL1Health);


    SetQzssSatelliteL1Health::SetQzssSatelliteL1Health()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL1Health::SetQzssSatelliteL1Health(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssSatelliteL1HealthPtr SetQzssSatelliteL1Health::create(int svId, bool health)
    {
      return SetQzssSatelliteL1HealthPtr(new SetQzssSatelliteL1Health(svId, health));
    }

    SetQzssSatelliteL1HealthPtr SetQzssSatelliteL1Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL1Health>(ptr);
    }

    bool SetQzssSatelliteL1Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssSatelliteL1Health::documentation() const { return Documentation; }


    int SetQzssSatelliteL1Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL1Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL1Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteL1Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL1Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1HealthForSV
///
#include "gen/GetQzssL1HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1HealthForSV::CmdName = "GetQzssL1HealthForSV";
    const char* const GetQzssL1HealthForSV::Documentation = "Get QZSS L1 health (Health of L1C/A signal)";

    REGISTER_COMMAND_FACTORY(GetQzssL1HealthForSV);


    GetQzssL1HealthForSV::GetQzssL1HealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL1HealthForSV::GetQzssL1HealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssL1HealthForSVPtr GetQzssL1HealthForSV::create(int svId)
    {
      return GetQzssL1HealthForSVPtr(new GetQzssL1HealthForSV(svId));
    }

    GetQzssL1HealthForSVPtr GetQzssL1HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1HealthForSV>(ptr);
    }

    bool GetQzssL1HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssL1HealthForSV::documentation() const { return Documentation; }


    int GetQzssL1HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL1HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL1Health
///
#include "gen/GetQzssSatelliteL1Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL1Health::CmdName = "GetQzssSatelliteL1Health";
    const char* const GetQzssSatelliteL1Health::Documentation = "Please note the command GetQzssSatelliteL1Health is deprecated since 21.3. You may use GetQzssL1HealthForSV.\n\nGet QZSS L1 health (Health of L1C/A signal)";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL1Health);


    GetQzssSatelliteL1Health::GetQzssSatelliteL1Health()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL1Health::GetQzssSatelliteL1Health(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssSatelliteL1HealthPtr GetQzssSatelliteL1Health::create(int svId)
    {
      return GetQzssSatelliteL1HealthPtr(new GetQzssSatelliteL1Health(svId));
    }

    GetQzssSatelliteL1HealthPtr GetQzssSatelliteL1Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL1Health>(ptr);
    }

    bool GetQzssSatelliteL1Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssSatelliteL1Health::documentation() const { return Documentation; }


    int GetQzssSatelliteL1Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL1Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL1Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1HealthForSVResult
///
#include "gen/GetQzssL1HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1HealthForSVResult::CmdName = "GetQzssL1HealthForSVResult";
    const char* const GetQzssL1HealthForSVResult::Documentation = "Result of GetQzssL1HealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1HealthForSVResult);


    GetQzssL1HealthForSVResult::GetQzssL1HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1HealthForSVResult::GetQzssL1HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetQzssL1HealthForSVResultPtr GetQzssL1HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetQzssL1HealthForSVResultPtr(new GetQzssL1HealthForSVResult(relatedCommand, svId, health));
    }

    GetQzssL1HealthForSVResultPtr GetQzssL1HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1HealthForSVResult>(ptr);
    }

    bool GetQzssL1HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetQzssL1HealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL1HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL1HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetQzssL1HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL2HealthForSV
///
#include "gen/SetQzssL2HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL2HealthForSV::CmdName = "SetQzssL2HealthForSV";
    const char* const SetQzssL2HealthForSV::Documentation = "Set QZSS L2 health (Health of L2C signal)";

    REGISTER_COMMAND_FACTORY(SetQzssL2HealthForSV);


    SetQzssL2HealthForSV::SetQzssL2HealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL2HealthForSV::SetQzssL2HealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssL2HealthForSVPtr SetQzssL2HealthForSV::create(int svId, bool health)
    {
      return SetQzssL2HealthForSVPtr(new SetQzssL2HealthForSV(svId, health));
    }

    SetQzssL2HealthForSVPtr SetQzssL2HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL2HealthForSV>(ptr);
    }

    bool SetQzssL2HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssL2HealthForSV::documentation() const { return Documentation; }


    int SetQzssL2HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL2HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL2HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL2HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssL2HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL2Health
///
#include "gen/SetQzssSatelliteL2Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL2Health::CmdName = "SetQzssSatelliteL2Health";
    const char* const SetQzssSatelliteL2Health::Documentation = "Please note the command SetQzssSatelliteL2Health is deprecated since 21.3. You may use SetQzssL2HealthForSV.\n\nSet QZSS L2 health (Health of L2C signal)";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL2Health);


    SetQzssSatelliteL2Health::SetQzssSatelliteL2Health()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL2Health::SetQzssSatelliteL2Health(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssSatelliteL2HealthPtr SetQzssSatelliteL2Health::create(int svId, bool health)
    {
      return SetQzssSatelliteL2HealthPtr(new SetQzssSatelliteL2Health(svId, health));
    }

    SetQzssSatelliteL2HealthPtr SetQzssSatelliteL2Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL2Health>(ptr);
    }

    bool SetQzssSatelliteL2Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssSatelliteL2Health::documentation() const { return Documentation; }


    int SetQzssSatelliteL2Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL2Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL2Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteL2Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL2Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL2HealthForSV
///
#include "gen/GetQzssL2HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL2HealthForSV::CmdName = "GetQzssL2HealthForSV";
    const char* const GetQzssL2HealthForSV::Documentation = "Get QZSS L2 health (Health of L2C signal)";

    REGISTER_COMMAND_FACTORY(GetQzssL2HealthForSV);


    GetQzssL2HealthForSV::GetQzssL2HealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL2HealthForSV::GetQzssL2HealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssL2HealthForSVPtr GetQzssL2HealthForSV::create(int svId)
    {
      return GetQzssL2HealthForSVPtr(new GetQzssL2HealthForSV(svId));
    }

    GetQzssL2HealthForSVPtr GetQzssL2HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL2HealthForSV>(ptr);
    }

    bool GetQzssL2HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssL2HealthForSV::documentation() const { return Documentation; }


    int GetQzssL2HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL2HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL2HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL2Health
///
#include "gen/GetQzssSatelliteL2Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL2Health::CmdName = "GetQzssSatelliteL2Health";
    const char* const GetQzssSatelliteL2Health::Documentation = "Please note the command GetQzssSatelliteL2Health is deprecated since 21.3. You may use GetQzssL2HealthForSV.\n\nGet QZSS L2 health (Health of L2C signal)";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL2Health);


    GetQzssSatelliteL2Health::GetQzssSatelliteL2Health()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL2Health::GetQzssSatelliteL2Health(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssSatelliteL2HealthPtr GetQzssSatelliteL2Health::create(int svId)
    {
      return GetQzssSatelliteL2HealthPtr(new GetQzssSatelliteL2Health(svId));
    }

    GetQzssSatelliteL2HealthPtr GetQzssSatelliteL2Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL2Health>(ptr);
    }

    bool GetQzssSatelliteL2Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssSatelliteL2Health::documentation() const { return Documentation; }


    int GetQzssSatelliteL2Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL2Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL2Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL2HealthForSVResult
///
#include "gen/GetQzssL2HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL2HealthForSVResult::CmdName = "GetQzssL2HealthForSVResult";
    const char* const GetQzssL2HealthForSVResult::Documentation = "Result of GetQzssL2HealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL2HealthForSVResult);


    GetQzssL2HealthForSVResult::GetQzssL2HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL2HealthForSVResult::GetQzssL2HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetQzssL2HealthForSVResultPtr GetQzssL2HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetQzssL2HealthForSVResultPtr(new GetQzssL2HealthForSVResult(relatedCommand, svId, health));
    }

    GetQzssL2HealthForSVResultPtr GetQzssL2HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL2HealthForSVResult>(ptr);
    }

    bool GetQzssL2HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetQzssL2HealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL2HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL2HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL2HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetQzssL2HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL5HealthForSV
///
#include "gen/SetQzssL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL5HealthForSV::CmdName = "SetQzssL5HealthForSV";
    const char* const SetQzssL5HealthForSV::Documentation = "Set QZSS L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(SetQzssL5HealthForSV);


    SetQzssL5HealthForSV::SetQzssL5HealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL5HealthForSV::SetQzssL5HealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssL5HealthForSVPtr SetQzssL5HealthForSV::create(int svId, bool health)
    {
      return SetQzssL5HealthForSVPtr(new SetQzssL5HealthForSV(svId, health));
    }

    SetQzssL5HealthForSVPtr SetQzssL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL5HealthForSV>(ptr);
    }

    bool SetQzssL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssL5HealthForSV::documentation() const { return Documentation; }


    int SetQzssL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL5HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssL5HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL5Health
///
#include "gen/SetQzssSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL5Health::CmdName = "SetQzssSatelliteL5Health";
    const char* const SetQzssSatelliteL5Health::Documentation = "Please note the command SetQzssSatelliteL5Health is deprecated since 21.3. You may use SetQzssL5HealthForSV.\n\nSet QZSS L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL5Health);


    SetQzssSatelliteL5Health::SetQzssSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL5Health::SetQzssSatelliteL5Health(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssSatelliteL5HealthPtr SetQzssSatelliteL5Health::create(int svId, bool health)
    {
      return SetQzssSatelliteL5HealthPtr(new SetQzssSatelliteL5Health(svId, health));
    }

    SetQzssSatelliteL5HealthPtr SetQzssSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL5Health>(ptr);
    }

    bool SetQzssSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssSatelliteL5Health::documentation() const { return Documentation; }


    int SetQzssSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL5Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL5Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteL5Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL5Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL5HealthForSV
///
#include "gen/GetQzssL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL5HealthForSV::CmdName = "GetQzssL5HealthForSV";
    const char* const GetQzssL5HealthForSV::Documentation = "Get QZSS L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(GetQzssL5HealthForSV);


    GetQzssL5HealthForSV::GetQzssL5HealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL5HealthForSV::GetQzssL5HealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssL5HealthForSVPtr GetQzssL5HealthForSV::create(int svId)
    {
      return GetQzssL5HealthForSVPtr(new GetQzssL5HealthForSV(svId));
    }

    GetQzssL5HealthForSVPtr GetQzssL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL5HealthForSV>(ptr);
    }

    bool GetQzssL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssL5HealthForSV::documentation() const { return Documentation; }


    int GetQzssL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL5Health
///
#include "gen/GetQzssSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL5Health::CmdName = "GetQzssSatelliteL5Health";
    const char* const GetQzssSatelliteL5Health::Documentation = "Please note the command GetQzssSatelliteL5Health is deprecated since 21.3. You may use GetQzssL5HealthForSV.\n\nGet QZSS L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL5Health);


    GetQzssSatelliteL5Health::GetQzssSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL5Health::GetQzssSatelliteL5Health(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssSatelliteL5HealthPtr GetQzssSatelliteL5Health::create(int svId)
    {
      return GetQzssSatelliteL5HealthPtr(new GetQzssSatelliteL5Health(svId));
    }

    GetQzssSatelliteL5HealthPtr GetQzssSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL5Health>(ptr);
    }

    bool GetQzssSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssSatelliteL5Health::documentation() const { return Documentation; }


    int GetQzssSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL5Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL5Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL5HealthForSVResult
///
#include "gen/GetQzssL5HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL5HealthForSVResult::CmdName = "GetQzssL5HealthForSVResult";
    const char* const GetQzssL5HealthForSVResult::Documentation = "Result of GetQzssL5HealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL5HealthForSVResult);


    GetQzssL5HealthForSVResult::GetQzssL5HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL5HealthForSVResult::GetQzssL5HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetQzssL5HealthForSVResultPtr GetQzssL5HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetQzssL5HealthForSVResultPtr(new GetQzssL5HealthForSVResult(relatedCommand, svId, health));
    }

    GetQzssL5HealthForSVResultPtr GetQzssL5HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL5HealthForSVResult>(ptr);
    }

    bool GetQzssL5HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetQzssL5HealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL5HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL5HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL5HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetQzssL5HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL1cHealthForSV
///
#include "gen/SetQzssL1cHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL1cHealthForSV::CmdName = "SetQzssL1cHealthForSV";
    const char* const SetQzssL1cHealthForSV::Documentation = "Set QZSS L1C health (Health of L1C signal)";

    REGISTER_COMMAND_FACTORY(SetQzssL1cHealthForSV);


    SetQzssL1cHealthForSV::SetQzssL1cHealthForSV()
      : CommandBase(CmdName)
    {}

    SetQzssL1cHealthForSV::SetQzssL1cHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssL1cHealthForSVPtr SetQzssL1cHealthForSV::create(int svId, bool health)
    {
      return SetQzssL1cHealthForSVPtr(new SetQzssL1cHealthForSV(svId, health));
    }

    SetQzssL1cHealthForSVPtr SetQzssL1cHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL1cHealthForSV>(ptr);
    }

    bool SetQzssL1cHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssL1cHealthForSV::documentation() const { return Documentation; }


    int SetQzssL1cHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssL1cHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssL1cHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL1cHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssL1cHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteL1cHealth
///
#include "gen/SetQzssSatelliteL1cHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteL1cHealth::CmdName = "SetQzssSatelliteL1cHealth";
    const char* const SetQzssSatelliteL1cHealth::Documentation = "Please note the command SetQzssSatelliteL1cHealth is deprecated since 21.3. You may use SetQzssL1cHealthForSV.\n\nSet QZSS L1C health (Health of L1C signal)";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteL1cHealth);


    SetQzssSatelliteL1cHealth::SetQzssSatelliteL1cHealth()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteL1cHealth::SetQzssSatelliteL1cHealth(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetQzssSatelliteL1cHealthPtr SetQzssSatelliteL1cHealth::create(int svId, bool health)
    {
      return SetQzssSatelliteL1cHealthPtr(new SetQzssSatelliteL1cHealth(svId, health));
    }

    SetQzssSatelliteL1cHealthPtr SetQzssSatelliteL1cHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteL1cHealth>(ptr);
    }

    bool SetQzssSatelliteL1cHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetQzssSatelliteL1cHealth::documentation() const { return Documentation; }


    int SetQzssSatelliteL1cHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteL1cHealth::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteL1cHealth::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteL1cHealth::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetQzssSatelliteL1cHealth::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1cHealthForSV
///
#include "gen/GetQzssL1cHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1cHealthForSV::CmdName = "GetQzssL1cHealthForSV";
    const char* const GetQzssL1cHealthForSV::Documentation = "Get QZSS L1C health (Health of L1C signal)";

    REGISTER_COMMAND_FACTORY(GetQzssL1cHealthForSV);


    GetQzssL1cHealthForSV::GetQzssL1cHealthForSV()
      : CommandBase(CmdName)
    {}

    GetQzssL1cHealthForSV::GetQzssL1cHealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssL1cHealthForSVPtr GetQzssL1cHealthForSV::create(int svId)
    {
      return GetQzssL1cHealthForSVPtr(new GetQzssL1cHealthForSV(svId));
    }

    GetQzssL1cHealthForSVPtr GetQzssL1cHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1cHealthForSV>(ptr);
    }

    bool GetQzssL1cHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssL1cHealthForSV::documentation() const { return Documentation; }


    int GetQzssL1cHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssL1cHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1cHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteL1cHealth
///
#include "gen/GetQzssSatelliteL1cHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteL1cHealth::CmdName = "GetQzssSatelliteL1cHealth";
    const char* const GetQzssSatelliteL1cHealth::Documentation = "Please note the command GetQzssSatelliteL1cHealth is deprecated since 21.3. You may use GetQzssL1cHealthForSV.\n\nGet QZSS L1C health (Health of L1C signal)";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteL1cHealth);


    GetQzssSatelliteL1cHealth::GetQzssSatelliteL1cHealth()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteL1cHealth::GetQzssSatelliteL1cHealth(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssSatelliteL1cHealthPtr GetQzssSatelliteL1cHealth::create(int svId)
    {
      return GetQzssSatelliteL1cHealthPtr(new GetQzssSatelliteL1cHealth(svId));
    }

    GetQzssSatelliteL1cHealthPtr GetQzssSatelliteL1cHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteL1cHealth>(ptr);
    }

    bool GetQzssSatelliteL1cHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssSatelliteL1cHealth::documentation() const { return Documentation; }


    int GetQzssSatelliteL1cHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteL1cHealth::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteL1cHealth::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1cHealthForSVResult
///
#include "gen/GetQzssL1cHealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1cHealthForSVResult::CmdName = "GetQzssL1cHealthForSVResult";
    const char* const GetQzssL1cHealthForSVResult::Documentation = "Result of GetQzssL1cHealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1cHealthForSVResult);


    GetQzssL1cHealthForSVResult::GetQzssL1cHealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1cHealthForSVResult::GetQzssL1cHealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetQzssL1cHealthForSVResultPtr GetQzssL1cHealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetQzssL1cHealthForSVResultPtr(new GetQzssL1cHealthForSVResult(relatedCommand, svId, health));
    }

    GetQzssL1cHealthForSVResultPtr GetQzssL1cHealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1cHealthForSVResult>(ptr);
    }

    bool GetQzssL1cHealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetQzssL1cHealthForSVResult::documentation() const { return Documentation; }


    int GetQzssL1cHealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1cHealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL1cHealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetQzssL1cHealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssNavAlertFlagForSV
///
#include "gen/SetQzssNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssNavAlertFlagForSV::CmdName = "SetQzssNavAlertFlagForSV";
    const char* const SetQzssNavAlertFlagForSV::Documentation = "Set QZSS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetQzssNavAlertFlagForSV);


    SetQzssNavAlertFlagForSV::SetQzssNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    SetQzssNavAlertFlagForSV::SetQzssNavAlertFlagForSV(int svId, bool alert)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
    }


    SetQzssNavAlertFlagForSVPtr SetQzssNavAlertFlagForSV::create(int svId, bool alert)
    {
      return SetQzssNavAlertFlagForSVPtr(new SetQzssNavAlertFlagForSV(svId, alert));
    }

    SetQzssNavAlertFlagForSVPtr SetQzssNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssNavAlertFlagForSV>(ptr);
    }

    bool SetQzssNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string SetQzssNavAlertFlagForSV::documentation() const { return Documentation; }


    int SetQzssNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssNavAlertFlagForSV::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetQzssNavAlertFlagForSV::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatelliteNavAlertFlag
///
#include "gen/SetQzssSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatelliteNavAlertFlag::CmdName = "SetQzssSatelliteNavAlertFlag";
    const char* const SetQzssSatelliteNavAlertFlag::Documentation = "Please note the command SetQzssSatelliteNavAlertFlag is deprecated since 21.3. You may use SetQzssNavAlertFlagForSV.\n\nSet QZSS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetQzssSatelliteNavAlertFlag);


    SetQzssSatelliteNavAlertFlag::SetQzssSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    SetQzssSatelliteNavAlertFlag::SetQzssSatelliteNavAlertFlag(int svId, bool alert)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
    }


    SetQzssSatelliteNavAlertFlagPtr SetQzssSatelliteNavAlertFlag::create(int svId, bool alert)
    {
      return SetQzssSatelliteNavAlertFlagPtr(new SetQzssSatelliteNavAlertFlag(svId, alert));
    }

    SetQzssSatelliteNavAlertFlagPtr SetQzssSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatelliteNavAlertFlag>(ptr);
    }

    bool SetQzssSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string SetQzssSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int SetQzssSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetQzssSatelliteNavAlertFlag::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatelliteNavAlertFlag::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatelliteNavAlertFlag::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetQzssSatelliteNavAlertFlag::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssNavAlertFlagForSV
///
#include "gen/GetQzssNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssNavAlertFlagForSV::CmdName = "GetQzssNavAlertFlagForSV";
    const char* const GetQzssNavAlertFlagForSV::Documentation = "Get QZSS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetQzssNavAlertFlagForSV);


    GetQzssNavAlertFlagForSV::GetQzssNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    GetQzssNavAlertFlagForSV::GetQzssNavAlertFlagForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssNavAlertFlagForSVPtr GetQzssNavAlertFlagForSV::create(int svId)
    {
      return GetQzssNavAlertFlagForSVPtr(new GetQzssNavAlertFlagForSV(svId));
    }

    GetQzssNavAlertFlagForSVPtr GetQzssNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssNavAlertFlagForSV>(ptr);
    }

    bool GetQzssNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssNavAlertFlagForSV::documentation() const { return Documentation; }


    int GetQzssNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssSatelliteNavAlertFlag
///
#include "gen/GetQzssSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssSatelliteNavAlertFlag::CmdName = "GetQzssSatelliteNavAlertFlag";
    const char* const GetQzssSatelliteNavAlertFlag::Documentation = "Please note the command GetQzssSatelliteNavAlertFlag is deprecated since 21.3. You may use GetQzssNavAlertFlagForSV.\n\nGet QZSS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetQzssSatelliteNavAlertFlag);


    GetQzssSatelliteNavAlertFlag::GetQzssSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    GetQzssSatelliteNavAlertFlag::GetQzssSatelliteNavAlertFlag(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssSatelliteNavAlertFlagPtr GetQzssSatelliteNavAlertFlag::create(int svId)
    {
      return GetQzssSatelliteNavAlertFlagPtr(new GetQzssSatelliteNavAlertFlag(svId));
    }

    GetQzssSatelliteNavAlertFlagPtr GetQzssSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssSatelliteNavAlertFlag>(ptr);
    }

    bool GetQzssSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int GetQzssSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssSatelliteNavAlertFlag::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssSatelliteNavAlertFlag::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssNavAlertFlagForSVResult
///
#include "gen/GetQzssNavAlertFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssNavAlertFlagForSVResult::CmdName = "GetQzssNavAlertFlagForSVResult";
    const char* const GetQzssNavAlertFlagForSVResult::Documentation = "Result of GetQzssNavAlertFlagForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssNavAlertFlagForSVResult);


    GetQzssNavAlertFlagForSVResult::GetQzssNavAlertFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssNavAlertFlagForSVResult::GetQzssNavAlertFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool alert)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAlert(alert);
    }


    GetQzssNavAlertFlagForSVResultPtr GetQzssNavAlertFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool alert)
    {
      return GetQzssNavAlertFlagForSVResultPtr(new GetQzssNavAlertFlagForSVResult(relatedCommand, svId, alert));
    }

    GetQzssNavAlertFlagForSVResultPtr GetQzssNavAlertFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssNavAlertFlagForSVResult>(ptr);
    }

    bool GetQzssNavAlertFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string GetQzssNavAlertFlagForSVResult::documentation() const { return Documentation; }


    int GetQzssNavAlertFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssNavAlertFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssNavAlertFlagForSVResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetQzssNavAlertFlagForSVResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICL5HealthForSV
///
#include "gen/SetNavICL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICL5HealthForSV::CmdName = "SetNavICL5HealthForSV";
    const char* const SetNavICL5HealthForSV::Documentation = "Set NavIC L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(SetNavICL5HealthForSV);


    SetNavICL5HealthForSV::SetNavICL5HealthForSV()
      : CommandBase(CmdName)
    {}

    SetNavICL5HealthForSV::SetNavICL5HealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetNavICL5HealthForSVPtr SetNavICL5HealthForSV::create(int svId, bool health)
    {
      return SetNavICL5HealthForSVPtr(new SetNavICL5HealthForSV(svId, health));
    }

    SetNavICL5HealthForSVPtr SetNavICL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICL5HealthForSV>(ptr);
    }

    bool SetNavICL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetNavICL5HealthForSV::documentation() const { return Documentation; }


    int SetNavICL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetNavICL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetNavICL5HealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetNavICL5HealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICSatelliteL5Health
///
#include "gen/SetNavICSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICSatelliteL5Health::CmdName = "SetNavICSatelliteL5Health";
    const char* const SetNavICSatelliteL5Health::Documentation = "Please note the command SetNavICSatelliteL5Health is deprecated since 21.3. You may use SetNavICL5HealthForSV.\n\nSet NavIC L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(SetNavICSatelliteL5Health);


    SetNavICSatelliteL5Health::SetNavICSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    SetNavICSatelliteL5Health::SetNavICSatelliteL5Health(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetNavICSatelliteL5HealthPtr SetNavICSatelliteL5Health::create(int svId, bool health)
    {
      return SetNavICSatelliteL5HealthPtr(new SetNavICSatelliteL5Health(svId, health));
    }

    SetNavICSatelliteL5HealthPtr SetNavICSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICSatelliteL5Health>(ptr);
    }

    bool SetNavICSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetNavICSatelliteL5Health::documentation() const { return Documentation; }


    int SetNavICSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetNavICSatelliteL5Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICSatelliteL5Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetNavICSatelliteL5Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetNavICSatelliteL5Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICL5HealthForSV
///
#include "gen/GetNavICL5HealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICL5HealthForSV::CmdName = "GetNavICL5HealthForSV";
    const char* const GetNavICL5HealthForSV::Documentation = "Get NavIC L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(GetNavICL5HealthForSV);


    GetNavICL5HealthForSV::GetNavICL5HealthForSV()
      : CommandBase(CmdName)
    {}

    GetNavICL5HealthForSV::GetNavICL5HealthForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetNavICL5HealthForSVPtr GetNavICL5HealthForSV::create(int svId)
    {
      return GetNavICL5HealthForSVPtr(new GetNavICL5HealthForSV(svId));
    }

    GetNavICL5HealthForSVPtr GetNavICL5HealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICL5HealthForSV>(ptr);
    }

    bool GetNavICL5HealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetNavICL5HealthForSV::documentation() const { return Documentation; }


    int GetNavICL5HealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICL5HealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICL5HealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICSatelliteL5Health
///
#include "gen/GetNavICSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICSatelliteL5Health::CmdName = "GetNavICSatelliteL5Health";
    const char* const GetNavICSatelliteL5Health::Documentation = "Please note the command GetNavICSatelliteL5Health is deprecated since 21.3. You may use GetNavICL5HealthForSV.\n\nGet NavIC L5 health (Health of L5 signal)";

    REGISTER_COMMAND_FACTORY(GetNavICSatelliteL5Health);


    GetNavICSatelliteL5Health::GetNavICSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    GetNavICSatelliteL5Health::GetNavICSatelliteL5Health(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetNavICSatelliteL5HealthPtr GetNavICSatelliteL5Health::create(int svId)
    {
      return GetNavICSatelliteL5HealthPtr(new GetNavICSatelliteL5Health(svId));
    }

    GetNavICSatelliteL5HealthPtr GetNavICSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICSatelliteL5Health>(ptr);
    }

    bool GetNavICSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetNavICSatelliteL5Health::documentation() const { return Documentation; }


    int GetNavICSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICSatelliteL5Health::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICSatelliteL5Health::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICL5HealthForSVResult
///
#include "gen/GetNavICL5HealthForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICL5HealthForSVResult::CmdName = "GetNavICL5HealthForSVResult";
    const char* const GetNavICL5HealthForSVResult::Documentation = "Result of GetNavICL5HealthForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetNavICL5HealthForSVResult);


    GetNavICL5HealthForSVResult::GetNavICL5HealthForSVResult()
      : CommandResult(CmdName)
    {}

    GetNavICL5HealthForSVResult::GetNavICL5HealthForSVResult(CommandBasePtr relatedCommand, int svId, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setHealth(health);
    }


    GetNavICL5HealthForSVResultPtr GetNavICL5HealthForSVResult::create(CommandBasePtr relatedCommand, int svId, bool health)
    {
      return GetNavICL5HealthForSVResultPtr(new GetNavICL5HealthForSVResult(relatedCommand, svId, health));
    }

    GetNavICL5HealthForSVResultPtr GetNavICL5HealthForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICL5HealthForSVResult>(ptr);
    }

    bool GetNavICL5HealthForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetNavICL5HealthForSVResult::documentation() const { return Documentation; }


    int GetNavICL5HealthForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICL5HealthForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetNavICL5HealthForSVResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetNavICL5HealthForSVResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICNavAlertFlagForSV
///
#include "gen/SetNavICNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICNavAlertFlagForSV::CmdName = "SetNavICNavAlertFlagForSV";
    const char* const SetNavICNavAlertFlagForSV::Documentation = "Set NavIC NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetNavICNavAlertFlagForSV);


    SetNavICNavAlertFlagForSV::SetNavICNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    SetNavICNavAlertFlagForSV::SetNavICNavAlertFlagForSV(int svId, bool alert)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
    }


    SetNavICNavAlertFlagForSVPtr SetNavICNavAlertFlagForSV::create(int svId, bool alert)
    {
      return SetNavICNavAlertFlagForSVPtr(new SetNavICNavAlertFlagForSV(svId, alert));
    }

    SetNavICNavAlertFlagForSVPtr SetNavICNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICNavAlertFlagForSV>(ptr);
    }

    bool SetNavICNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string SetNavICNavAlertFlagForSV::documentation() const { return Documentation; }


    int SetNavICNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetNavICNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetNavICNavAlertFlagForSV::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetNavICNavAlertFlagForSV::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICSatelliteNavAlertFlag
///
#include "gen/SetNavICSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICSatelliteNavAlertFlag::CmdName = "SetNavICSatelliteNavAlertFlag";
    const char* const SetNavICSatelliteNavAlertFlag::Documentation = "Please note the command SetNavICSatelliteNavAlertFlag is deprecated since 21.3. You may use SetNavICNavAlertFlagForSV.\n\nSet NavIC NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetNavICSatelliteNavAlertFlag);


    SetNavICSatelliteNavAlertFlag::SetNavICSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    SetNavICSatelliteNavAlertFlag::SetNavICSatelliteNavAlertFlag(int svId, bool alert)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setAlert(alert);
    }


    SetNavICSatelliteNavAlertFlagPtr SetNavICSatelliteNavAlertFlag::create(int svId, bool alert)
    {
      return SetNavICSatelliteNavAlertFlagPtr(new SetNavICSatelliteNavAlertFlag(svId, alert));
    }

    SetNavICSatelliteNavAlertFlagPtr SetNavICSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICSatelliteNavAlertFlag>(ptr);
    }

    bool SetNavICSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string SetNavICSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int SetNavICSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetNavICSatelliteNavAlertFlag::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICSatelliteNavAlertFlag::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetNavICSatelliteNavAlertFlag::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetNavICSatelliteNavAlertFlag::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICNavAlertFlagForSV
///
#include "gen/GetNavICNavAlertFlagForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICNavAlertFlagForSV::CmdName = "GetNavICNavAlertFlagForSV";
    const char* const GetNavICNavAlertFlagForSV::Documentation = "Get NavIC NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetNavICNavAlertFlagForSV);


    GetNavICNavAlertFlagForSV::GetNavICNavAlertFlagForSV()
      : CommandBase(CmdName)
    {}

    GetNavICNavAlertFlagForSV::GetNavICNavAlertFlagForSV(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetNavICNavAlertFlagForSVPtr GetNavICNavAlertFlagForSV::create(int svId)
    {
      return GetNavICNavAlertFlagForSVPtr(new GetNavICNavAlertFlagForSV(svId));
    }

    GetNavICNavAlertFlagForSVPtr GetNavICNavAlertFlagForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICNavAlertFlagForSV>(ptr);
    }

    bool GetNavICNavAlertFlagForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetNavICNavAlertFlagForSV::documentation() const { return Documentation; }


    int GetNavICNavAlertFlagForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICNavAlertFlagForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICNavAlertFlagForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICSatelliteNavAlertFlag
///
#include "gen/GetNavICSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICSatelliteNavAlertFlag::CmdName = "GetNavICSatelliteNavAlertFlag";
    const char* const GetNavICSatelliteNavAlertFlag::Documentation = "Please note the command GetNavICSatelliteNavAlertFlag is deprecated since 21.3. You may use GetNavICNavAlertFlagForSV.\n\nGet NavIC NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetNavICSatelliteNavAlertFlag);


    GetNavICSatelliteNavAlertFlag::GetNavICSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    GetNavICSatelliteNavAlertFlag::GetNavICSatelliteNavAlertFlag(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetNavICSatelliteNavAlertFlagPtr GetNavICSatelliteNavAlertFlag::create(int svId)
    {
      return GetNavICSatelliteNavAlertFlagPtr(new GetNavICSatelliteNavAlertFlag(svId));
    }

    GetNavICSatelliteNavAlertFlagPtr GetNavICSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICSatelliteNavAlertFlag>(ptr);
    }

    bool GetNavICSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetNavICSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int GetNavICSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICSatelliteNavAlertFlag::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICSatelliteNavAlertFlag::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICNavAlertFlagForSVResult
///
#include "gen/GetNavICNavAlertFlagForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICNavAlertFlagForSVResult::CmdName = "GetNavICNavAlertFlagForSVResult";
    const char* const GetNavICNavAlertFlagForSVResult::Documentation = "Result of GetNavICNavAlertFlagForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetNavICNavAlertFlagForSVResult);


    GetNavICNavAlertFlagForSVResult::GetNavICNavAlertFlagForSVResult()
      : CommandResult(CmdName)
    {}

    GetNavICNavAlertFlagForSVResult::GetNavICNavAlertFlagForSVResult(CommandBasePtr relatedCommand, int svId, bool alert)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setAlert(alert);
    }


    GetNavICNavAlertFlagForSVResultPtr GetNavICNavAlertFlagForSVResult::create(CommandBasePtr relatedCommand, int svId, bool alert)
    {
      return GetNavICNavAlertFlagForSVResultPtr(new GetNavICNavAlertFlagForSVResult(relatedCommand, svId, alert));
    }

    GetNavICNavAlertFlagForSVResultPtr GetNavICNavAlertFlagForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICNavAlertFlagForSVResult>(ptr);
    }

    bool GetNavICNavAlertFlagForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string GetNavICNavAlertFlagForSVResult::documentation() const { return Documentation; }


    int GetNavICNavAlertFlagForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICNavAlertFlagForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetNavICNavAlertFlagForSVResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetNavICNavAlertFlagForSVResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPowerGlobalOffset
///
#include "gen/SetPowerGlobalOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPowerGlobalOffset::CmdName = "SetPowerGlobalOffset";
    const char* const SetPowerGlobalOffset::Documentation = "Set global power offset default value for all signals and all systems";

    REGISTER_COMMAND_FACTORY(SetPowerGlobalOffset);


    SetPowerGlobalOffset::SetPowerGlobalOffset()
      : CommandBase(CmdName)
    {}

    SetPowerGlobalOffset::SetPowerGlobalOffset(double offset)
      : CommandBase(CmdName)
    {

      setOffset(offset);
    }


    SetPowerGlobalOffsetPtr SetPowerGlobalOffset::create(double offset)
    {
      return SetPowerGlobalOffsetPtr(new SetPowerGlobalOffset(offset));
    }

    SetPowerGlobalOffsetPtr SetPowerGlobalOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPowerGlobalOffset>(ptr);
    }

    bool SetPowerGlobalOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPowerGlobalOffset::documentation() const { return Documentation; }


    int SetPowerGlobalOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetPowerGlobalOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPowerGlobalOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerGlobalOffset
///
#include "gen/GetPowerGlobalOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerGlobalOffset::CmdName = "GetPowerGlobalOffset";
    const char* const GetPowerGlobalOffset::Documentation = "Get global power offset default value for all signals and all systems";

    REGISTER_COMMAND_FACTORY(GetPowerGlobalOffset);


    GetPowerGlobalOffset::GetPowerGlobalOffset()
      : CommandBase(CmdName)
    {

    }


    GetPowerGlobalOffsetPtr GetPowerGlobalOffset::create()
    {
      return GetPowerGlobalOffsetPtr(new GetPowerGlobalOffset());
    }

    GetPowerGlobalOffsetPtr GetPowerGlobalOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerGlobalOffset>(ptr);
    }

    bool GetPowerGlobalOffset::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetPowerGlobalOffset::documentation() const { return Documentation; }


    int GetPowerGlobalOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetPowerGlobalOffsetResult
///
#include "gen/GetPowerGlobalOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerGlobalOffsetResult::CmdName = "GetPowerGlobalOffsetResult";
    const char* const GetPowerGlobalOffsetResult::Documentation = "Result of GetPowerGlobalOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetPowerGlobalOffsetResult);


    GetPowerGlobalOffsetResult::GetPowerGlobalOffsetResult()
      : CommandResult(CmdName)
    {}

    GetPowerGlobalOffsetResult::GetPowerGlobalOffsetResult(CommandBasePtr relatedCommand, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setOffset(offset);
    }


    GetPowerGlobalOffsetResultPtr GetPowerGlobalOffsetResult::create(CommandBasePtr relatedCommand, double offset)
    {
      return GetPowerGlobalOffsetResultPtr(new GetPowerGlobalOffsetResult(relatedCommand, offset));
    }

    GetPowerGlobalOffsetResultPtr GetPowerGlobalOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerGlobalOffsetResult>(ptr);
    }

    bool GetPowerGlobalOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPowerGlobalOffsetResult::documentation() const { return Documentation; }


    double GetPowerGlobalOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPowerGlobalOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPowerOffset
///
#include "gen/SetPowerOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPowerOffset::CmdName = "SetPowerOffset";
    const char* const SetPowerOffset::Documentation = "Set power offset default value for the signal given in argument";

    REGISTER_COMMAND_FACTORY(SetPowerOffset);


    SetPowerOffset::SetPowerOffset()
      : CommandBase(CmdName)
    {}

    SetPowerOffset::SetPowerOffset(const std::string& signal, double offset)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setOffset(offset);
    }


    SetPowerOffsetPtr SetPowerOffset::create(const std::string& signal, double offset)
    {
      return SetPowerOffsetPtr(new SetPowerOffset(signal, offset));
    }

    SetPowerOffsetPtr SetPowerOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPowerOffset>(ptr);
    }

    bool SetPowerOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPowerOffset::documentation() const { return Documentation; }


    int SetPowerOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetPowerOffset::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetPowerOffset::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPowerOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPowerOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerOffset
///
#include "gen/GetPowerOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerOffset::CmdName = "GetPowerOffset";
    const char* const GetPowerOffset::Documentation = "Get power offset default value for the signal given in argument";

    REGISTER_COMMAND_FACTORY(GetPowerOffset);


    GetPowerOffset::GetPowerOffset()
      : CommandBase(CmdName)
    {}

    GetPowerOffset::GetPowerOffset(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetPowerOffsetPtr GetPowerOffset::create(const std::string& signal)
    {
      return GetPowerOffsetPtr(new GetPowerOffset(signal));
    }

    GetPowerOffsetPtr GetPowerOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerOffset>(ptr);
    }

    bool GetPowerOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetPowerOffset::documentation() const { return Documentation; }


    int GetPowerOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPowerOffset::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPowerOffset::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerOffsetResult
///
#include "gen/GetPowerOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerOffsetResult::CmdName = "GetPowerOffsetResult";
    const char* const GetPowerOffsetResult::Documentation = "Result of GetPowerOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetPowerOffsetResult);


    GetPowerOffsetResult::GetPowerOffsetResult()
      : CommandResult(CmdName)
    {}

    GetPowerOffsetResult::GetPowerOffsetResult(CommandBasePtr relatedCommand, const std::string& signal, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setOffset(offset);
    }


    GetPowerOffsetResultPtr GetPowerOffsetResult::create(CommandBasePtr relatedCommand, const std::string& signal, double offset)
    {
      return GetPowerOffsetResultPtr(new GetPowerOffsetResult(relatedCommand, signal, offset));
    }

    GetPowerOffsetResultPtr GetPowerOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerOffsetResult>(ptr);
    }

    bool GetPowerOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPowerOffsetResult::documentation() const { return Documentation; }


    std::string GetPowerOffsetResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPowerOffsetResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPowerOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPowerSbasOffset
///
#include "gen/SetPowerSbasOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPowerSbasOffset::CmdName = "SetPowerSbasOffset";
    const char* const SetPowerSbasOffset::Documentation = "Set power offset default value for the SBAS Service Provider given in argument";

    REGISTER_COMMAND_FACTORY(SetPowerSbasOffset);


    SetPowerSbasOffset::SetPowerSbasOffset()
      : CommandBase(CmdName)
    {}

    SetPowerSbasOffset::SetPowerSbasOffset(const std::string& serviceProvider, double offset)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setOffset(offset);
    }


    SetPowerSbasOffsetPtr SetPowerSbasOffset::create(const std::string& serviceProvider, double offset)
    {
      return SetPowerSbasOffsetPtr(new SetPowerSbasOffset(serviceProvider, offset));
    }

    SetPowerSbasOffsetPtr SetPowerSbasOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPowerSbasOffset>(ptr);
    }

    bool SetPowerSbasOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPowerSbasOffset::documentation() const { return Documentation; }


    int SetPowerSbasOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetPowerSbasOffset::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void SetPowerSbasOffset::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPowerSbasOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPowerSbasOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerSbasOffset
///
#include "gen/GetPowerSbasOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerSbasOffset::CmdName = "GetPowerSbasOffset";
    const char* const GetPowerSbasOffset::Documentation = "Get power offset default value for the SBAS Service Provider given in argument";

    REGISTER_COMMAND_FACTORY(GetPowerSbasOffset);


    GetPowerSbasOffset::GetPowerSbasOffset()
      : CommandBase(CmdName)
    {}

    GetPowerSbasOffset::GetPowerSbasOffset(const std::string& serviceProvider)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
    }


    GetPowerSbasOffsetPtr GetPowerSbasOffset::create(const std::string& serviceProvider)
    {
      return GetPowerSbasOffsetPtr(new GetPowerSbasOffset(serviceProvider));
    }

    GetPowerSbasOffsetPtr GetPowerSbasOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerSbasOffset>(ptr);
    }

    bool GetPowerSbasOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetPowerSbasOffset::documentation() const { return Documentation; }


    int GetPowerSbasOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPowerSbasOffset::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetPowerSbasOffset::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPowerSbasOffsetResult
///
#include "gen/GetPowerSbasOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPowerSbasOffsetResult::CmdName = "GetPowerSbasOffsetResult";
    const char* const GetPowerSbasOffsetResult::Documentation = "Result of GetPowerSbasOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetPowerSbasOffsetResult);


    GetPowerSbasOffsetResult::GetPowerSbasOffsetResult()
      : CommandResult(CmdName)
    {}

    GetPowerSbasOffsetResult::GetPowerSbasOffsetResult(CommandBasePtr relatedCommand, const std::string& serviceProvider, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setServiceProvider(serviceProvider);
      setOffset(offset);
    }


    GetPowerSbasOffsetResultPtr GetPowerSbasOffsetResult::create(CommandBasePtr relatedCommand, const std::string& serviceProvider, double offset)
    {
      return GetPowerSbasOffsetResultPtr(new GetPowerSbasOffsetResult(relatedCommand, serviceProvider, offset));
    }

    GetPowerSbasOffsetResultPtr GetPowerSbasOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPowerSbasOffsetResult>(ptr);
    }

    bool GetPowerSbasOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPowerSbasOffsetResult::documentation() const { return Documentation; }


    std::string GetPowerSbasOffsetResult::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetPowerSbasOffsetResult::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPowerSbasOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPowerSbasOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModulationTarget
///
#include "gen/SetModulationTarget.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModulationTarget::CmdName = "SetModulationTarget";
    const char* const SetModulationTarget::Documentation = "Set a modulation target.\nIf Id is not set, or if new, a new target is added.\nFor setter : If the Id is already used, the corresponding target is updated.";

    REGISTER_COMMAND_FACTORY(SetModulationTarget);


    SetModulationTarget::SetModulationTarget()
      : CommandBase(CmdName)
    {}

    SetModulationTarget::SetModulationTarget(const std::string& type, const std::string& path, const std::string& address, bool clockIsExternal, const std::string& id)
      : CommandBase(CmdName)
    {

      setType(type);
      setPath(path);
      setAddress(address);
      setClockIsExternal(clockIsExternal);
      setId(id);
    }


    SetModulationTargetPtr SetModulationTarget::create(const std::string& type, const std::string& path, const std::string& address, bool clockIsExternal, const std::string& id)
    {
      return SetModulationTargetPtr(new SetModulationTarget(type, path, address, clockIsExternal, id));
    }

    SetModulationTargetPtr SetModulationTarget::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModulationTarget>(ptr);
    }

    bool SetModulationTarget::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<bool>::is_valid(m_values["ClockIsExternal"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModulationTarget::documentation() const { return Documentation; }


    int SetModulationTarget::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetModulationTarget::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetModulationTarget::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModulationTarget::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void SetModulationTarget::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModulationTarget::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void SetModulationTarget::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModulationTarget::clockIsExternal() const
    {
      return parse_json<bool>::parse(m_values["ClockIsExternal"]);
    }

    void SetModulationTarget::setClockIsExternal(bool clockIsExternal)
    {
      m_values.AddMember("ClockIsExternal", parse_json<bool>::format(clockIsExternal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModulationTarget::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModulationTarget::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTarget
///
#include "gen/GetModulationTarget.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTarget::CmdName = "GetModulationTarget";
    const char* const GetModulationTarget::Documentation = "Get a modulation target.\nIf Id is not set, or if new, a new target is added.\nFor setter : If the Id is already used, the corresponding target is updated.";

    REGISTER_COMMAND_FACTORY(GetModulationTarget);


    GetModulationTarget::GetModulationTarget()
      : CommandBase(CmdName)
    {}

    GetModulationTarget::GetModulationTarget(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetModulationTargetPtr GetModulationTarget::create(const std::string& id)
    {
      return GetModulationTargetPtr(new GetModulationTarget(id));
    }

    GetModulationTargetPtr GetModulationTarget::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTarget>(ptr);
    }

    bool GetModulationTarget::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetModulationTarget::documentation() const { return Documentation; }


    int GetModulationTarget::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetModulationTarget::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTarget::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetResult
///
#include "gen/GetModulationTargetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetResult::CmdName = "GetModulationTargetResult";
    const char* const GetModulationTargetResult::Documentation = "Result of GetModulationTarget";

    REGISTER_COMMAND_RESULT_FACTORY(GetModulationTargetResult);


    GetModulationTargetResult::GetModulationTargetResult()
      : CommandResult(CmdName)
    {}

    GetModulationTargetResult::GetModulationTargetResult(CommandBasePtr relatedCommand, const std::string& type, const std::string& path, const std::string& address, bool clockIsExternal, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setPath(path);
      setAddress(address);
      setClockIsExternal(clockIsExternal);
      setId(id);
    }


    GetModulationTargetResultPtr GetModulationTargetResult::create(CommandBasePtr relatedCommand, const std::string& type, const std::string& path, const std::string& address, bool clockIsExternal, const std::string& id)
    {
      return GetModulationTargetResultPtr(new GetModulationTargetResult(relatedCommand, type, path, address, clockIsExternal, id));
    }

    GetModulationTargetResultPtr GetModulationTargetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetResult>(ptr);
    }

    bool GetModulationTargetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<bool>::is_valid(m_values["ClockIsExternal"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetModulationTargetResult::documentation() const { return Documentation; }


    std::string GetModulationTargetResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetModulationTargetResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetResult::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void GetModulationTargetResult::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetResult::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void GetModulationTargetResult::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetModulationTargetResult::clockIsExternal() const
    {
      return parse_json<bool>::parse(m_values["ClockIsExternal"]);
    }

    void GetModulationTargetResult::setClockIsExternal(bool clockIsExternal)
    {
      m_values.AddMember("ClockIsExternal", parse_json<bool>::format(clockIsExternal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpu
///
#include "gen/SetGpu.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpu::CmdName = "SetGpu";
    const char* const SetGpu::Documentation = "Set the GPU associated with a RF output of a modulation target.";

    REGISTER_COMMAND_FACTORY(SetGpu);


    SetGpu::SetGpu()
      : CommandBase(CmdName)
    {}

    SetGpu::SetGpu(int gpuIdx, int output, const std::string& id)
      : CommandBase(CmdName)
    {

      setGpuIdx(gpuIdx);
      setOutput(output);
      setId(id);
    }


    SetGpuPtr SetGpu::create(int gpuIdx, int output, const std::string& id)
    {
      return SetGpuPtr(new SetGpu(gpuIdx, output, id));
    }

    SetGpuPtr SetGpu::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpu>(ptr);
    }

    bool SetGpu::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["GpuIdx"])
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetGpu::documentation() const { return Documentation; }


    int SetGpu::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpu::gpuIdx() const
    {
      return parse_json<int>::parse(m_values["GpuIdx"]);
    }

    void SetGpu::setGpuIdx(int gpuIdx)
    {
      m_values.AddMember("GpuIdx", parse_json<int>::format(gpuIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpu::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void SetGpu::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGpu::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetGpu::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpu
///
#include "gen/GetGpu.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpu::CmdName = "GetGpu";
    const char* const GetGpu::Documentation = "Get the GPU associated with a RF output of a modulation target.";

    REGISTER_COMMAND_FACTORY(GetGpu);


    GetGpu::GetGpu()
      : CommandBase(CmdName)
    {}

    GetGpu::GetGpu(int output, const std::string& id)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setId(id);
    }


    GetGpuPtr GetGpu::create(int output, const std::string& id)
    {
      return GetGpuPtr(new GetGpu(output, id));
    }

    GetGpuPtr GetGpu::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpu>(ptr);
    }

    bool GetGpu::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpu::documentation() const { return Documentation; }


    int GetGpu::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpu::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetGpu::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpu::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpu::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpuResult
///
#include "gen/GetGpuResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpuResult::CmdName = "GetGpuResult";
    const char* const GetGpuResult::Documentation = "Result of GetGpu";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpuResult);


    GetGpuResult::GetGpuResult()
      : CommandResult(CmdName)
    {}

    GetGpuResult::GetGpuResult(CommandBasePtr relatedCommand, int gpuIdx, int output, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setGpuIdx(gpuIdx);
      setOutput(output);
      setId(id);
    }


    GetGpuResultPtr GetGpuResult::create(CommandBasePtr relatedCommand, int gpuIdx, int output, const std::string& id)
    {
      return GetGpuResultPtr(new GetGpuResult(relatedCommand, gpuIdx, output, id));
    }

    GetGpuResultPtr GetGpuResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpuResult>(ptr);
    }

    bool GetGpuResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["GpuIdx"])
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpuResult::documentation() const { return Documentation; }


    int GetGpuResult::gpuIdx() const
    {
      return parse_json<int>::parse(m_values["GpuIdx"]);
    }

    void GetGpuResult::setGpuIdx(int gpuIdx)
    {
      m_values.AddMember("GpuIdx", parse_json<int>::format(gpuIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpuResult::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetGpuResult::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpuResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpuResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllModulationTargets
///
#include "gen/GetAllModulationTargets.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllModulationTargets::CmdName = "GetAllModulationTargets";
    const char* const GetAllModulationTargets::Documentation = "Get all the modulation targets IDs";

    REGISTER_COMMAND_FACTORY(GetAllModulationTargets);


    GetAllModulationTargets::GetAllModulationTargets()
      : CommandBase(CmdName)
    {

    }


    GetAllModulationTargetsPtr GetAllModulationTargets::create()
    {
      return GetAllModulationTargetsPtr(new GetAllModulationTargets());
    }

    GetAllModulationTargetsPtr GetAllModulationTargets::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllModulationTargets>(ptr);
    }

    bool GetAllModulationTargets::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAllModulationTargets::documentation() const { return Documentation; }


    int GetAllModulationTargets::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAllModulationTargetsResult
///
#include "gen/GetAllModulationTargetsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllModulationTargetsResult::CmdName = "GetAllModulationTargetsResult";
    const char* const GetAllModulationTargetsResult::Documentation = "Result of GetModulationTargets";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllModulationTargetsResult);


    GetAllModulationTargetsResult::GetAllModulationTargetsResult()
      : CommandResult(CmdName)
    {}

    GetAllModulationTargetsResult::GetAllModulationTargetsResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllModulationTargetsResultPtr GetAllModulationTargetsResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetAllModulationTargetsResultPtr(new GetAllModulationTargetsResult(relatedCommand, ids));
    }

    GetAllModulationTargetsResultPtr GetAllModulationTargetsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllModulationTargetsResult>(ptr);
    }

    bool GetAllModulationTargetsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllModulationTargetsResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllModulationTargetsResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllModulationTargetsResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModulationTarget
///
#include "gen/RemoveModulationTarget.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModulationTarget::CmdName = "RemoveModulationTarget";
    const char* const RemoveModulationTarget::Documentation = "Remove a modulation target.";

    REGISTER_COMMAND_FACTORY(RemoveModulationTarget);


    RemoveModulationTarget::RemoveModulationTarget()
      : CommandBase(CmdName)
    {}

    RemoveModulationTarget::RemoveModulationTarget(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModulationTargetPtr RemoveModulationTarget::create(const std::string& id)
    {
      return RemoveModulationTargetPtr(new RemoveModulationTarget(id));
    }

    RemoveModulationTargetPtr RemoveModulationTarget::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModulationTarget>(ptr);
    }

    bool RemoveModulationTarget::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModulationTarget::documentation() const { return Documentation; }


    int RemoveModulationTarget::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModulationTarget::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModulationTarget::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllModulationTargets
///
#include "gen/RemoveAllModulationTargets.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllModulationTargets::CmdName = "RemoveAllModulationTargets";
    const char* const RemoveAllModulationTargets::Documentation = "Remove all modulation targets.";

    REGISTER_COMMAND_FACTORY(RemoveAllModulationTargets);


    RemoveAllModulationTargets::RemoveAllModulationTargets()
      : CommandBase(CmdName)
    {

    }


    RemoveAllModulationTargetsPtr RemoveAllModulationTargets::create()
    {
      return RemoveAllModulationTargetsPtr(new RemoveAllModulationTargets());
    }

    RemoveAllModulationTargetsPtr RemoveAllModulationTargets::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllModulationTargets>(ptr);
    }

    bool RemoveAllModulationTargets::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllModulationTargets::documentation() const { return Documentation; }


    int RemoveAllModulationTargets::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of ChangeModulationTargetName
///
#include "gen/ChangeModulationTargetName.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeModulationTargetName::CmdName = "ChangeModulationTargetName";
    const char* const ChangeModulationTargetName::Documentation = "Change the modulation target name. The name is only used for display purpose.";

    REGISTER_COMMAND_FACTORY(ChangeModulationTargetName);


    ChangeModulationTargetName::ChangeModulationTargetName()
      : CommandBase(CmdName)
    {}

    ChangeModulationTargetName::ChangeModulationTargetName(const std::string& targetName, const std::string& id)
      : CommandBase(CmdName)
    {

      setTargetName(targetName);
      setId(id);
    }


    ChangeModulationTargetNamePtr ChangeModulationTargetName::create(const std::string& targetName, const std::string& id)
    {
      return ChangeModulationTargetNamePtr(new ChangeModulationTargetName(targetName, id));
    }

    ChangeModulationTargetNamePtr ChangeModulationTargetName::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeModulationTargetName>(ptr);
    }

    bool ChangeModulationTargetName::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TargetName"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ChangeModulationTargetName::documentation() const { return Documentation; }


    int ChangeModulationTargetName::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ChangeModulationTargetName::targetName() const
    {
      return parse_json<std::string>::parse(m_values["TargetName"]);
    }

    void ChangeModulationTargetName::setTargetName(const std::string& targetName)
    {
      m_values.AddMember("TargetName", parse_json<std::string>::format(targetName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetName::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeModulationTargetName::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeModulationTargetSignals
///
#include "gen/ChangeModulationTargetSignals.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeModulationTargetSignals::CmdName = "ChangeModulationTargetSignals";
    const char* const ChangeModulationTargetSignals::Documentation = "Set the signals for the specified target and output index.\nSkydel tries to keep the sampling rate as low as possible,\nbut it is possible to set constaints with MinRate and MaxRate.";

    REGISTER_COMMAND_FACTORY(ChangeModulationTargetSignals);


    ChangeModulationTargetSignals::ChangeModulationTargetSignals()
      : CommandBase(CmdName)
    {}

    ChangeModulationTargetSignals::ChangeModulationTargetSignals(int output, int minRate, int maxRate, const std::string& band, const std::string& signal, int gain, bool gaussianNoise, const std::string& id, const Sdx::optional<double>& centralFrequency)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setMinRate(minRate);
      setMaxRate(maxRate);
      setBand(band);
      setSignal(signal);
      setGain(gain);
      setGaussianNoise(gaussianNoise);
      setId(id);
      setCentralFrequency(centralFrequency);
    }


    ChangeModulationTargetSignalsPtr ChangeModulationTargetSignals::create(int output, int minRate, int maxRate, const std::string& band, const std::string& signal, int gain, bool gaussianNoise, const std::string& id, const Sdx::optional<double>& centralFrequency)
    {
      return ChangeModulationTargetSignalsPtr(new ChangeModulationTargetSignals(output, minRate, maxRate, band, signal, gain, gaussianNoise, id, centralFrequency));
    }

    ChangeModulationTargetSignalsPtr ChangeModulationTargetSignals::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeModulationTargetSignals>(ptr);
    }

    bool ChangeModulationTargetSignals::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<int>::is_valid(m_values["MinRate"])
          && parse_json<int>::is_valid(m_values["MaxRate"])
          && parse_json<std::string>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Gain"])
          && parse_json<bool>::is_valid(m_values["GaussianNoise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["CentralFrequency"])
        ;

    }

    std::string ChangeModulationTargetSignals::documentation() const { return Documentation; }


    int ChangeModulationTargetSignals::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ChangeModulationTargetSignals::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void ChangeModulationTargetSignals::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetSignals::minRate() const
    {
      return parse_json<int>::parse(m_values["MinRate"]);
    }

    void ChangeModulationTargetSignals::setMinRate(int minRate)
    {
      m_values.AddMember("MinRate", parse_json<int>::format(minRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetSignals::maxRate() const
    {
      return parse_json<int>::parse(m_values["MaxRate"]);
    }

    void ChangeModulationTargetSignals::setMaxRate(int maxRate)
    {
      m_values.AddMember("MaxRate", parse_json<int>::format(maxRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetSignals::band() const
    {
      return parse_json<std::string>::parse(m_values["Band"]);
    }

    void ChangeModulationTargetSignals::setBand(const std::string& band)
    {
      m_values.AddMember("Band", parse_json<std::string>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetSignals::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void ChangeModulationTargetSignals::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetSignals::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void ChangeModulationTargetSignals::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ChangeModulationTargetSignals::gaussianNoise() const
    {
      return parse_json<bool>::parse(m_values["GaussianNoise"]);
    }

    void ChangeModulationTargetSignals::setGaussianNoise(bool gaussianNoise)
    {
      m_values.AddMember("GaussianNoise", parse_json<bool>::format(gaussianNoise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetSignals::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeModulationTargetSignals::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> ChangeModulationTargetSignals::centralFrequency() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["CentralFrequency"]);
    }

    void ChangeModulationTargetSignals::setCentralFrequency(const Sdx::optional<double>& centralFrequency)
    {
      m_values.AddMember("CentralFrequency", parse_json<Sdx::optional<double>>::format(centralFrequency, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetSignals
///
#include "gen/GetModulationTargetSignals.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetSignals::CmdName = "GetModulationTargetSignals";
    const char* const GetModulationTargetSignals::Documentation = "Get the signals for the specified target and output index.\nSkydel tries to keep the sampling rate as low as possible,\nbut it is possible to set constaints with MinRate and MaxRate.";

    REGISTER_COMMAND_FACTORY(GetModulationTargetSignals);


    GetModulationTargetSignals::GetModulationTargetSignals()
      : CommandBase(CmdName)
    {}

    GetModulationTargetSignals::GetModulationTargetSignals(int output, const std::string& id)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setId(id);
    }


    GetModulationTargetSignalsPtr GetModulationTargetSignals::create(int output, const std::string& id)
    {
      return GetModulationTargetSignalsPtr(new GetModulationTargetSignals(output, id));
    }

    GetModulationTargetSignalsPtr GetModulationTargetSignals::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetSignals>(ptr);
    }

    bool GetModulationTargetSignals::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetModulationTargetSignals::documentation() const { return Documentation; }


    int GetModulationTargetSignals::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetModulationTargetSignals::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetModulationTargetSignals::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetSignals::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetSignals::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetSignalsResult
///
#include "gen/GetModulationTargetSignalsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetSignalsResult::CmdName = "GetModulationTargetSignalsResult";
    const char* const GetModulationTargetSignalsResult::Documentation = "Result of GetModulationTargetSignals";

    REGISTER_COMMAND_RESULT_FACTORY(GetModulationTargetSignalsResult);


    GetModulationTargetSignalsResult::GetModulationTargetSignalsResult()
      : CommandResult(CmdName)
    {}

    GetModulationTargetSignalsResult::GetModulationTargetSignalsResult(CommandBasePtr relatedCommand, int output, int minRate, int maxRate, const std::string& band, const std::string& signal, int gain, bool gaussianNoise, const std::string& id, const Sdx::optional<double>& centralFrequency)
      : CommandResult(CmdName, relatedCommand)
    {

      setOutput(output);
      setMinRate(minRate);
      setMaxRate(maxRate);
      setBand(band);
      setSignal(signal);
      setGain(gain);
      setGaussianNoise(gaussianNoise);
      setId(id);
      setCentralFrequency(centralFrequency);
    }


    GetModulationTargetSignalsResultPtr GetModulationTargetSignalsResult::create(CommandBasePtr relatedCommand, int output, int minRate, int maxRate, const std::string& band, const std::string& signal, int gain, bool gaussianNoise, const std::string& id, const Sdx::optional<double>& centralFrequency)
    {
      return GetModulationTargetSignalsResultPtr(new GetModulationTargetSignalsResult(relatedCommand, output, minRate, maxRate, band, signal, gain, gaussianNoise, id, centralFrequency));
    }

    GetModulationTargetSignalsResultPtr GetModulationTargetSignalsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetSignalsResult>(ptr);
    }

    bool GetModulationTargetSignalsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<int>::is_valid(m_values["MinRate"])
          && parse_json<int>::is_valid(m_values["MaxRate"])
          && parse_json<std::string>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Gain"])
          && parse_json<bool>::is_valid(m_values["GaussianNoise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["CentralFrequency"])
        ;

    }

    std::string GetModulationTargetSignalsResult::documentation() const { return Documentation; }


    int GetModulationTargetSignalsResult::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetModulationTargetSignalsResult::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetSignalsResult::minRate() const
    {
      return parse_json<int>::parse(m_values["MinRate"]);
    }

    void GetModulationTargetSignalsResult::setMinRate(int minRate)
    {
      m_values.AddMember("MinRate", parse_json<int>::format(minRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetSignalsResult::maxRate() const
    {
      return parse_json<int>::parse(m_values["MaxRate"]);
    }

    void GetModulationTargetSignalsResult::setMaxRate(int maxRate)
    {
      m_values.AddMember("MaxRate", parse_json<int>::format(maxRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetSignalsResult::band() const
    {
      return parse_json<std::string>::parse(m_values["Band"]);
    }

    void GetModulationTargetSignalsResult::setBand(const std::string& band)
    {
      m_values.AddMember("Band", parse_json<std::string>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetSignalsResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetModulationTargetSignalsResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetSignalsResult::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void GetModulationTargetSignalsResult::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetModulationTargetSignalsResult::gaussianNoise() const
    {
      return parse_json<bool>::parse(m_values["GaussianNoise"]);
    }

    void GetModulationTargetSignalsResult::setGaussianNoise(bool gaussianNoise)
    {
      m_values.AddMember("GaussianNoise", parse_json<bool>::format(gaussianNoise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetSignalsResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetSignalsResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetModulationTargetSignalsResult::centralFrequency() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["CentralFrequency"]);
    }

    void GetModulationTargetSignalsResult::setCentralFrequency(const Sdx::optional<double>& centralFrequency)
    {
      m_values.AddMember("CentralFrequency", parse_json<Sdx::optional<double>>::format(centralFrequency, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeModulationTargetInterference
///
#include "gen/ChangeModulationTargetInterference.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeModulationTargetInterference::CmdName = "ChangeModulationTargetInterference";
    const char* const ChangeModulationTargetInterference::Documentation = "Set the specified target and output index to a group of interferences.\nAn interference transmitter is mapped to a specific RF output by using the same Interference Group Number.\nSkydel tries to keep the sampling rate as low as possible,\nbut it is possible to set constaints with MinRate and MaxRate.";

    REGISTER_COMMAND_FACTORY(ChangeModulationTargetInterference);


    ChangeModulationTargetInterference::ChangeModulationTargetInterference()
      : CommandBase(CmdName)
    {}

    ChangeModulationTargetInterference::ChangeModulationTargetInterference(int output, int minRate, int maxRate, int group, double centralFreq, int gain, const std::string& id, const Sdx::optional<std::string>& signal)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setMinRate(minRate);
      setMaxRate(maxRate);
      setGroup(group);
      setCentralFreq(centralFreq);
      setGain(gain);
      setId(id);
      setSignal(signal);
    }


    ChangeModulationTargetInterferencePtr ChangeModulationTargetInterference::create(int output, int minRate, int maxRate, int group, double centralFreq, int gain, const std::string& id, const Sdx::optional<std::string>& signal)
    {
      return ChangeModulationTargetInterferencePtr(new ChangeModulationTargetInterference(output, minRate, maxRate, group, centralFreq, gain, id, signal));
    }

    ChangeModulationTargetInterferencePtr ChangeModulationTargetInterference::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeModulationTargetInterference>(ptr);
    }

    bool ChangeModulationTargetInterference::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<int>::is_valid(m_values["MinRate"])
          && parse_json<int>::is_valid(m_values["MaxRate"])
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<int>::is_valid(m_values["Gain"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Signal"])
        ;

    }

    std::string ChangeModulationTargetInterference::documentation() const { return Documentation; }


    int ChangeModulationTargetInterference::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ChangeModulationTargetInterference::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void ChangeModulationTargetInterference::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetInterference::minRate() const
    {
      return parse_json<int>::parse(m_values["MinRate"]);
    }

    void ChangeModulationTargetInterference::setMinRate(int minRate)
    {
      m_values.AddMember("MinRate", parse_json<int>::format(minRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetInterference::maxRate() const
    {
      return parse_json<int>::parse(m_values["MaxRate"]);
    }

    void ChangeModulationTargetInterference::setMaxRate(int maxRate)
    {
      m_values.AddMember("MaxRate", parse_json<int>::format(maxRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetInterference::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void ChangeModulationTargetInterference::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double ChangeModulationTargetInterference::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void ChangeModulationTargetInterference::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ChangeModulationTargetInterference::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void ChangeModulationTargetInterference::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationTargetInterference::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeModulationTargetInterference::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ChangeModulationTargetInterference::signal() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Signal"]);
    }

    void ChangeModulationTargetInterference::setSignal(const Sdx::optional<std::string>& signal)
    {
      m_values.AddMember("Signal", parse_json<Sdx::optional<std::string>>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetInterferences
///
#include "gen/GetModulationTargetInterferences.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetInterferences::CmdName = "GetModulationTargetInterferences";
    const char* const GetModulationTargetInterferences::Documentation = "Get the specified target and output index to a group of interferences.\nAn interference transmitter is mapped to a specific RF output by using the same Interference Group Number.\nSkydel tries to keep the sampling rate as low as possible,\nbut it is possible to set constaints with MinRate and MaxRate.";

    REGISTER_COMMAND_FACTORY(GetModulationTargetInterferences);


    GetModulationTargetInterferences::GetModulationTargetInterferences()
      : CommandBase(CmdName)
    {}

    GetModulationTargetInterferences::GetModulationTargetInterferences(int output, const std::string& id)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setId(id);
    }


    GetModulationTargetInterferencesPtr GetModulationTargetInterferences::create(int output, const std::string& id)
    {
      return GetModulationTargetInterferencesPtr(new GetModulationTargetInterferences(output, id));
    }

    GetModulationTargetInterferencesPtr GetModulationTargetInterferences::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetInterferences>(ptr);
    }

    bool GetModulationTargetInterferences::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetModulationTargetInterferences::documentation() const { return Documentation; }


    int GetModulationTargetInterferences::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetModulationTargetInterferences::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetModulationTargetInterferences::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetInterferences::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetInterferences::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetModulationTargetInterferencesResult
///
#include "gen/GetModulationTargetInterferencesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetModulationTargetInterferencesResult::CmdName = "GetModulationTargetInterferencesResult";
    const char* const GetModulationTargetInterferencesResult::Documentation = "Result of GetModulationTargetInterferences";

    REGISTER_COMMAND_RESULT_FACTORY(GetModulationTargetInterferencesResult);


    GetModulationTargetInterferencesResult::GetModulationTargetInterferencesResult()
      : CommandResult(CmdName)
    {}

    GetModulationTargetInterferencesResult::GetModulationTargetInterferencesResult(CommandBasePtr relatedCommand, int output, int minRate, int maxRate, int group, double centralFreq, int gain, const std::string& id, const Sdx::optional<std::string>& signal)
      : CommandResult(CmdName, relatedCommand)
    {

      setOutput(output);
      setMinRate(minRate);
      setMaxRate(maxRate);
      setGroup(group);
      setCentralFreq(centralFreq);
      setGain(gain);
      setId(id);
      setSignal(signal);
    }


    GetModulationTargetInterferencesResultPtr GetModulationTargetInterferencesResult::create(CommandBasePtr relatedCommand, int output, int minRate, int maxRate, int group, double centralFreq, int gain, const std::string& id, const Sdx::optional<std::string>& signal)
    {
      return GetModulationTargetInterferencesResultPtr(new GetModulationTargetInterferencesResult(relatedCommand, output, minRate, maxRate, group, centralFreq, gain, id, signal));
    }

    GetModulationTargetInterferencesResultPtr GetModulationTargetInterferencesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetModulationTargetInterferencesResult>(ptr);
    }

    bool GetModulationTargetInterferencesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<int>::is_valid(m_values["MinRate"])
          && parse_json<int>::is_valid(m_values["MaxRate"])
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<int>::is_valid(m_values["Gain"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetModulationTargetInterferencesResult::documentation() const { return Documentation; }


    int GetModulationTargetInterferencesResult::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void GetModulationTargetInterferencesResult::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetInterferencesResult::minRate() const
    {
      return parse_json<int>::parse(m_values["MinRate"]);
    }

    void GetModulationTargetInterferencesResult::setMinRate(int minRate)
    {
      m_values.AddMember("MinRate", parse_json<int>::format(minRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetInterferencesResult::maxRate() const
    {
      return parse_json<int>::parse(m_values["MaxRate"]);
    }

    void GetModulationTargetInterferencesResult::setMaxRate(int maxRate)
    {
      m_values.AddMember("MaxRate", parse_json<int>::format(maxRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetInterferencesResult::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void GetModulationTargetInterferencesResult::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetModulationTargetInterferencesResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetModulationTargetInterferencesResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetModulationTargetInterferencesResult::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void GetModulationTargetInterferencesResult::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetModulationTargetInterferencesResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetModulationTargetInterferencesResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetModulationTargetInterferencesResult::signal() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Signal"]);
    }

    void GetModulationTargetInterferencesResult::setSignal(const Sdx::optional<std::string>& signal)
    {
      m_values.AddMember("Signal", parse_json<Sdx::optional<std::string>>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeModulationAnechoicTargetInterference
///
#include "gen/ChangeModulationAnechoicTargetInterference.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeModulationAnechoicTargetInterference::CmdName = "ChangeModulationAnechoicTargetInterference";
    const char* const ChangeModulationAnechoicTargetInterference::Documentation = "Assign an output to a specific interference group. This command works only\nfor Anechoic Chamber target.";

    REGISTER_COMMAND_FACTORY(ChangeModulationAnechoicTargetInterference);


    ChangeModulationAnechoicTargetInterference::ChangeModulationAnechoicTargetInterference()
      : CommandBase(CmdName)
    {}

    ChangeModulationAnechoicTargetInterference::ChangeModulationAnechoicTargetInterference(int group, const std::string& output, double centralFreq)
      : CommandBase(CmdName)
    {

      setGroup(group);
      setOutput(output);
      setCentralFreq(centralFreq);
    }


    ChangeModulationAnechoicTargetInterferencePtr ChangeModulationAnechoicTargetInterference::create(int group, const std::string& output, double centralFreq)
    {
      return ChangeModulationAnechoicTargetInterferencePtr(new ChangeModulationAnechoicTargetInterference(group, output, centralFreq));
    }

    ChangeModulationAnechoicTargetInterferencePtr ChangeModulationAnechoicTargetInterference::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeModulationAnechoicTargetInterference>(ptr);
    }

    bool ChangeModulationAnechoicTargetInterference::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<std::string>::is_valid(m_values["Output"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
        ;

    }

    std::string ChangeModulationAnechoicTargetInterference::documentation() const { return Documentation; }


    int ChangeModulationAnechoicTargetInterference::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ChangeModulationAnechoicTargetInterference::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void ChangeModulationAnechoicTargetInterference::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeModulationAnechoicTargetInterference::output() const
    {
      return parse_json<std::string>::parse(m_values["Output"]);
    }

    void ChangeModulationAnechoicTargetInterference::setOutput(const std::string& output)
    {
      m_values.AddMember("Output", parse_json<std::string>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double ChangeModulationAnechoicTargetInterference::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void ChangeModulationAnechoicTargetInterference::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModulationAnechoicTargetInterference
///
#include "gen/RemoveModulationAnechoicTargetInterference.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModulationAnechoicTargetInterference::CmdName = "RemoveModulationAnechoicTargetInterference";
    const char* const RemoveModulationAnechoicTargetInterference::Documentation = "Remove output assignation. This command works only for Anechoic Chamber\ntarget.";

    REGISTER_COMMAND_FACTORY(RemoveModulationAnechoicTargetInterference);


    RemoveModulationAnechoicTargetInterference::RemoveModulationAnechoicTargetInterference()
      : CommandBase(CmdName)
    {}

    RemoveModulationAnechoicTargetInterference::RemoveModulationAnechoicTargetInterference(int group)
      : CommandBase(CmdName)
    {

      setGroup(group);
    }


    RemoveModulationAnechoicTargetInterferencePtr RemoveModulationAnechoicTargetInterference::create(int group)
    {
      return RemoveModulationAnechoicTargetInterferencePtr(new RemoveModulationAnechoicTargetInterference(group));
    }

    RemoveModulationAnechoicTargetInterferencePtr RemoveModulationAnechoicTargetInterference::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModulationAnechoicTargetInterference>(ptr);
    }

    bool RemoveModulationAnechoicTargetInterference::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Group"])
        ;

    }

    std::string RemoveModulationAnechoicTargetInterference::documentation() const { return Documentation; }


    int RemoveModulationAnechoicTargetInterference::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int RemoveModulationAnechoicTargetInterference::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void RemoveModulationAnechoicTargetInterference::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetRfGain
///
#include "gen/SetRfGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetRfGain::CmdName = "SetRfGain";
    const char* const SetRfGain::Documentation = "USE AT YOUR OWN RISKS. Set the RF Gain of the SDR";

    REGISTER_COMMAND_FACTORY(SetRfGain);


    SetRfGain::SetRfGain()
      : CommandBase(CmdName)
    {}

    SetRfGain::SetRfGain(int output, double gain)
      : CommandBase(CmdName)
    {

      setOutput(output);
      setGain(gain);
    }


    SetRfGainPtr SetRfGain::create(int output, double gain)
    {
      return SetRfGainPtr(new SetRfGain(output, gain));
    }

    SetRfGainPtr SetRfGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetRfGain>(ptr);
    }

    bool SetRfGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Output"])
          && parse_json<double>::is_valid(m_values["Gain"])
        ;

    }

    std::string SetRfGain::documentation() const { return Documentation; }


    int SetRfGain::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetRfGain::output() const
    {
      return parse_json<int>::parse(m_values["Output"]);
    }

    void SetRfGain::setOutput(int output)
    {
      m_values.AddMember("Output", parse_json<int>::format(output, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetRfGain::gain() const
    {
      return parse_json<double>::parse(m_values["Gain"]);
    }

    void SetRfGain::setGain(double gain)
    {
      m_values.AddMember("Gain", parse_json<double>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportConstellationParameters
///
#include "gen/ImportConstellationParameters.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportConstellationParameters::CmdName = "ImportConstellationParameters";
    const char* const ImportConstellationParameters::Documentation = "Import navigation message file for the specified constellation. This could be Rinex, SEM or YUMA file for GPS. Only Rinex for the others.";

    REGISTER_COMMAND_FACTORY(ImportConstellationParameters);


    ImportConstellationParameters::ImportConstellationParameters()
      : CommandBase(CmdName)
    {}

    ImportConstellationParameters::ImportConstellationParameters(const std::string& system, const std::string& path, const Sdx::optional<int>& rollover)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPath(path);
      setRollover(rollover);
    }


    ImportConstellationParametersPtr ImportConstellationParameters::create(const std::string& system, const std::string& path, const Sdx::optional<int>& rollover)
    {
      return ImportConstellationParametersPtr(new ImportConstellationParameters(system, path, rollover));
    }

    ImportConstellationParametersPtr ImportConstellationParameters::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportConstellationParameters>(ptr);
    }

    bool ImportConstellationParameters::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Rollover"])
        ;

    }

    std::string ImportConstellationParameters::documentation() const { return Documentation; }


    int ImportConstellationParameters::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportConstellationParameters::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ImportConstellationParameters::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportConstellationParameters::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportConstellationParameters::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> ImportConstellationParameters::rollover() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Rollover"]);
    }

    void ImportConstellationParameters::setRollover(const Sdx::optional<int>& rollover)
    {
      m_values.AddMember("Rollover", parse_json<Sdx::optional<int>>::format(rollover, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportIonoParameters
///
#include "gen/ImportIonoParameters.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportIonoParameters::CmdName = "ImportIonoParameters";
    const char* const ImportIonoParameters::Documentation = "Import ionospheric parameters from a Rinex file.";

    REGISTER_COMMAND_FACTORY(ImportIonoParameters);


    ImportIonoParameters::ImportIonoParameters()
      : CommandBase(CmdName)
    {}

    ImportIonoParameters::ImportIonoParameters(const std::string& path, const Sdx::optional<std::string>& type)
      : CommandBase(CmdName)
    {

      setPath(path);
      setType(type);
    }


    ImportIonoParametersPtr ImportIonoParameters::create(const std::string& path, const Sdx::optional<std::string>& type)
    {
      return ImportIonoParametersPtr(new ImportIonoParameters(path, type));
    }

    ImportIonoParametersPtr ImportIonoParameters::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportIonoParameters>(ptr);
    }

    bool ImportIonoParameters::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Type"])
        ;

    }

    std::string ImportIonoParameters::documentation() const { return Documentation; }


    int ImportIonoParameters::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportIonoParameters::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportIonoParameters::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ImportIonoParameters::type() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Type"]);
    }

    void ImportIonoParameters::setType(const Sdx::optional<std::string>& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::optional<std::string>>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportGlonassAlmanac
///
#include "gen/ImportGlonassAlmanac.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportGlonassAlmanac::CmdName = "ImportGlonassAlmanac";
    const char* const ImportGlonassAlmanac::Documentation = "Import GLONASS almanac file";

    REGISTER_COMMAND_FACTORY(ImportGlonassAlmanac);


    ImportGlonassAlmanac::ImportGlonassAlmanac()
      : CommandBase(CmdName)
    {}

    ImportGlonassAlmanac::ImportGlonassAlmanac(const std::string& path)
      : CommandBase(CmdName)
    {

      setPath(path);
    }


    ImportGlonassAlmanacPtr ImportGlonassAlmanac::create(const std::string& path)
    {
      return ImportGlonassAlmanacPtr(new ImportGlonassAlmanac(path));
    }

    ImportGlonassAlmanacPtr ImportGlonassAlmanac::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportGlonassAlmanac>(ptr);
    }

    bool ImportGlonassAlmanac::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportGlonassAlmanac::documentation() const { return Documentation; }


    int ImportGlonassAlmanac::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportGlonassAlmanac::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportGlonassAlmanac::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportNmeaTrack
///
#include "gen/ImportNmeaTrack.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportNmeaTrack::CmdName = "ImportNmeaTrack";
    const char* const ImportNmeaTrack::Documentation = "Import NMEA track file";

    REGISTER_COMMAND_FACTORY(ImportNmeaTrack);


    ImportNmeaTrack::ImportNmeaTrack()
      : CommandBase(CmdName)
    {}

    ImportNmeaTrack::ImportNmeaTrack(const std::string& path)
      : CommandBase(CmdName)
    {

      setPath(path);
    }


    ImportNmeaTrackPtr ImportNmeaTrack::create(const std::string& path)
    {
      return ImportNmeaTrackPtr(new ImportNmeaTrack(path));
    }

    ImportNmeaTrackPtr ImportNmeaTrack::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportNmeaTrack>(ptr);
    }

    bool ImportNmeaTrack::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportNmeaTrack::documentation() const { return Documentation; }


    int ImportNmeaTrack::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportNmeaTrack::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportNmeaTrack::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearVehiculeTrajectory
///
#include "gen/ClearVehiculeTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearVehiculeTrajectory::CmdName = "ClearVehiculeTrajectory";
    const char* const ClearVehiculeTrajectory::Documentation = "Clear NMEA trajectory file";

    REGISTER_COMMAND_FACTORY(ClearVehiculeTrajectory);


    ClearVehiculeTrajectory::ClearVehiculeTrajectory()
      : CommandBase(CmdName)
    {

    }


    ClearVehiculeTrajectoryPtr ClearVehiculeTrajectory::create()
    {
      return ClearVehiculeTrajectoryPtr(new ClearVehiculeTrajectory());
    }

    ClearVehiculeTrajectoryPtr ClearVehiculeTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearVehiculeTrajectory>(ptr);
    }

    bool ClearVehiculeTrajectory::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearVehiculeTrajectory::documentation() const { return Documentation; }


    int ClearVehiculeTrajectory::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of SetDefaultVehicleAntennaModel
///
#include "gen/SetDefaultVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetDefaultVehicleAntennaModel::CmdName = "SetDefaultVehicleAntennaModel";
    const char* const SetDefaultVehicleAntennaModel::Documentation = "Set the default vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(SetDefaultVehicleAntennaModel);


    SetDefaultVehicleAntennaModel::SetDefaultVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    SetDefaultVehicleAntennaModel::SetDefaultVehicleAntennaModel(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    SetDefaultVehicleAntennaModelPtr SetDefaultVehicleAntennaModel::create(const std::string& name)
    {
      return SetDefaultVehicleAntennaModelPtr(new SetDefaultVehicleAntennaModel(name));
    }

    SetDefaultVehicleAntennaModelPtr SetDefaultVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetDefaultVehicleAntennaModel>(ptr);
    }

    bool SetDefaultVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string SetDefaultVehicleAntennaModel::documentation() const { return Documentation; }


    int SetDefaultVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetDefaultVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void SetDefaultVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetDefaultVehicleAntennaModel
///
#include "gen/GetDefaultVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDefaultVehicleAntennaModel::CmdName = "GetDefaultVehicleAntennaModel";
    const char* const GetDefaultVehicleAntennaModel::Documentation = "Get the default vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(GetDefaultVehicleAntennaModel);


    GetDefaultVehicleAntennaModel::GetDefaultVehicleAntennaModel()
      : CommandBase(CmdName)
    {

    }


    GetDefaultVehicleAntennaModelPtr GetDefaultVehicleAntennaModel::create()
    {
      return GetDefaultVehicleAntennaModelPtr(new GetDefaultVehicleAntennaModel());
    }

    GetDefaultVehicleAntennaModelPtr GetDefaultVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDefaultVehicleAntennaModel>(ptr);
    }

    bool GetDefaultVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetDefaultVehicleAntennaModel::documentation() const { return Documentation; }


    int GetDefaultVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetDefaultVehicleAntennaModelResult
///
#include "gen/GetDefaultVehicleAntennaModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDefaultVehicleAntennaModelResult::CmdName = "GetDefaultVehicleAntennaModelResult";
    const char* const GetDefaultVehicleAntennaModelResult::Documentation = "Result of GetDefaultVehicleAntennaModel";

    REGISTER_COMMAND_RESULT_FACTORY(GetDefaultVehicleAntennaModelResult);


    GetDefaultVehicleAntennaModelResult::GetDefaultVehicleAntennaModelResult()
      : CommandResult(CmdName)
    {}

    GetDefaultVehicleAntennaModelResult::GetDefaultVehicleAntennaModelResult(CommandBasePtr relatedCommand, const std::string& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setName(name);
    }


    GetDefaultVehicleAntennaModelResultPtr GetDefaultVehicleAntennaModelResult::create(CommandBasePtr relatedCommand, const std::string& name)
    {
      return GetDefaultVehicleAntennaModelResultPtr(new GetDefaultVehicleAntennaModelResult(relatedCommand, name));
    }

    GetDefaultVehicleAntennaModelResultPtr GetDefaultVehicleAntennaModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDefaultVehicleAntennaModelResult>(ptr);
    }

    bool GetDefaultVehicleAntennaModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string GetDefaultVehicleAntennaModelResult::documentation() const { return Documentation; }


    std::string GetDefaultVehicleAntennaModelResult::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void GetDefaultVehicleAntennaModelResult::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllVehicleAntennaNames
///
#include "gen/GetAllVehicleAntennaNames.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllVehicleAntennaNames::CmdName = "GetAllVehicleAntennaNames";
    const char* const GetAllVehicleAntennaNames::Documentation = "Get a list of all vehicle antenna names";

    REGISTER_COMMAND_FACTORY(GetAllVehicleAntennaNames);


    GetAllVehicleAntennaNames::GetAllVehicleAntennaNames()
      : CommandBase(CmdName)
    {

    }


    GetAllVehicleAntennaNamesPtr GetAllVehicleAntennaNames::create()
    {
      return GetAllVehicleAntennaNamesPtr(new GetAllVehicleAntennaNames());
    }

    GetAllVehicleAntennaNamesPtr GetAllVehicleAntennaNames::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllVehicleAntennaNames>(ptr);
    }

    bool GetAllVehicleAntennaNames::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAllVehicleAntennaNames::documentation() const { return Documentation; }


    int GetAllVehicleAntennaNames::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAllVehicleAntennaNamesResult
///
#include "gen/GetAllVehicleAntennaNamesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllVehicleAntennaNamesResult::CmdName = "GetAllVehicleAntennaNamesResult";
    const char* const GetAllVehicleAntennaNamesResult::Documentation = "Result of GetAllVehicleAntennaNames";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllVehicleAntennaNamesResult);


    GetAllVehicleAntennaNamesResult::GetAllVehicleAntennaNamesResult()
      : CommandResult(CmdName)
    {}

    GetAllVehicleAntennaNamesResult::GetAllVehicleAntennaNamesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& antennaNames)
      : CommandResult(CmdName, relatedCommand)
    {

      setAntennaNames(antennaNames);
    }


    GetAllVehicleAntennaNamesResultPtr GetAllVehicleAntennaNamesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& antennaNames)
    {
      return GetAllVehicleAntennaNamesResultPtr(new GetAllVehicleAntennaNamesResult(relatedCommand, antennaNames));
    }

    GetAllVehicleAntennaNamesResultPtr GetAllVehicleAntennaNamesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllVehicleAntennaNamesResult>(ptr);
    }

    bool GetAllVehicleAntennaNamesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaNames"])
        ;

    }

    std::string GetAllVehicleAntennaNamesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllVehicleAntennaNamesResult::antennaNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaNames"]);
    }

    void GetAllVehicleAntennaNamesResult::setAntennaNames(const std::vector<std::string>& antennaNames)
    {
      m_values.AddMember("AntennaNames", parse_json<std::vector<std::string>>::format(antennaNames, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaGain
///
#include "gen/SetVehicleAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaGain::CmdName = "SetVehicleAntennaGain";
    const char* const SetVehicleAntennaGain::Documentation = "Set Vehicle gain antenna pattern. If no name is specified, the command is aplied to Basic vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaGain);


    SetVehicleAntennaGain::SetVehicleAntennaGain()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaGain::SetVehicleAntennaGain(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setGain(gain);
      setType(type);
      setBand(band);
      setName(name);
    }


    SetVehicleAntennaGainPtr SetVehicleAntennaGain::create(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return SetVehicleAntennaGainPtr(new SetVehicleAntennaGain(gain, type, band, name));
    }

    SetVehicleAntennaGainPtr SetVehicleAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaGain>(ptr);
    }

    bool SetVehicleAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaGain::documentation() const { return Documentation; }


    int SetVehicleAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetVehicleAntennaGain::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void SetVehicleAntennaGain::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetVehicleAntennaGain::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetVehicleAntennaGain::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetVehicleAntennaGain::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetVehicleAntennaGain::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaGain::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaGain::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaGain
///
#include "gen/GetVehicleAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaGain::CmdName = "GetVehicleAntennaGain";
    const char* const GetVehicleAntennaGain::Documentation = "Get Vehicle gain antenna pattern. If no name is specified, the command is aplied to Basic vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(GetVehicleAntennaGain);


    GetVehicleAntennaGain::GetVehicleAntennaGain()
      : CommandBase(CmdName)
    {}

    GetVehicleAntennaGain::GetVehicleAntennaGain(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setBand(band);
      setName(name);
    }


    GetVehicleAntennaGainPtr GetVehicleAntennaGain::create(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return GetVehicleAntennaGainPtr(new GetVehicleAntennaGain(band, name));
    }

    GetVehicleAntennaGainPtr GetVehicleAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaGain>(ptr);
    }

    bool GetVehicleAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaGain::documentation() const { return Documentation; }


    int GetVehicleAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetVehicleAntennaGain::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleAntennaGain::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaGain::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaGain::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaGainResult
///
#include "gen/GetVehicleAntennaGainResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaGainResult::CmdName = "GetVehicleAntennaGainResult";
    const char* const GetVehicleAntennaGainResult::Documentation = "Result of GetVehicleAntennaGain";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleAntennaGainResult);


    GetVehicleAntennaGainResult::GetVehicleAntennaGainResult()
      : CommandResult(CmdName)
    {}

    GetVehicleAntennaGainResult::GetVehicleAntennaGainResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
      setType(type);
      setBand(band);
      setName(name);
    }


    GetVehicleAntennaGainResultPtr GetVehicleAntennaGainResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return GetVehicleAntennaGainResultPtr(new GetVehicleAntennaGainResult(relatedCommand, gain, type, band, name));
    }

    GetVehicleAntennaGainResultPtr GetVehicleAntennaGainResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaGainResult>(ptr);
    }

    bool GetVehicleAntennaGainResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaGainResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetVehicleAntennaGainResult::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void GetVehicleAntennaGainResult::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaGainResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetVehicleAntennaGainResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand GetVehicleAntennaGainResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleAntennaGainResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaGainResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaGainResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaPhaseOffset
///
#include "gen/SetVehicleAntennaPhaseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaPhaseOffset::CmdName = "SetVehicleAntennaPhaseOffset";
    const char* const SetVehicleAntennaPhaseOffset::Documentation = "Set Vehicle phase offset antenna pattern. If no name is specified, the command is aplied to Basic Vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaPhaseOffset);


    SetVehicleAntennaPhaseOffset::SetVehicleAntennaPhaseOffset()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaPhaseOffset::SetVehicleAntennaPhaseOffset(const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setPhaseOffset(phaseOffset);
      setType(type);
      setBand(band);
      setName(name);
    }


    SetVehicleAntennaPhaseOffsetPtr SetVehicleAntennaPhaseOffset::create(const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return SetVehicleAntennaPhaseOffsetPtr(new SetVehicleAntennaPhaseOffset(phaseOffset, type, band, name));
    }

    SetVehicleAntennaPhaseOffsetPtr SetVehicleAntennaPhaseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaPhaseOffset>(ptr);
    }

    bool SetVehicleAntennaPhaseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffset"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaPhaseOffset::documentation() const { return Documentation; }


    int SetVehicleAntennaPhaseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetVehicleAntennaPhaseOffset::phaseOffset() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffset"]);
    }

    void SetVehicleAntennaPhaseOffset::setPhaseOffset(const std::vector<std::vector<double>>& phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<std::vector<std::vector<double>>>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetVehicleAntennaPhaseOffset::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetVehicleAntennaPhaseOffset::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetVehicleAntennaPhaseOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetVehicleAntennaPhaseOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaPhaseOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaPhaseOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaPhaseOffset
///
#include "gen/GetVehicleAntennaPhaseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaPhaseOffset::CmdName = "GetVehicleAntennaPhaseOffset";
    const char* const GetVehicleAntennaPhaseOffset::Documentation = "Get Vehicle phase offset antenna pattern. If no name is specified, the command is aplied to Basic Vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(GetVehicleAntennaPhaseOffset);


    GetVehicleAntennaPhaseOffset::GetVehicleAntennaPhaseOffset()
      : CommandBase(CmdName)
    {}

    GetVehicleAntennaPhaseOffset::GetVehicleAntennaPhaseOffset(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setBand(band);
      setName(name);
    }


    GetVehicleAntennaPhaseOffsetPtr GetVehicleAntennaPhaseOffset::create(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return GetVehicleAntennaPhaseOffsetPtr(new GetVehicleAntennaPhaseOffset(band, name));
    }

    GetVehicleAntennaPhaseOffsetPtr GetVehicleAntennaPhaseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaPhaseOffset>(ptr);
    }

    bool GetVehicleAntennaPhaseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaPhaseOffset::documentation() const { return Documentation; }


    int GetVehicleAntennaPhaseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetVehicleAntennaPhaseOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleAntennaPhaseOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaPhaseOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaPhaseOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaPhaseOffsetResult
///
#include "gen/GetVehicleAntennaPhaseOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaPhaseOffsetResult::CmdName = "GetVehicleAntennaPhaseOffsetResult";
    const char* const GetVehicleAntennaPhaseOffsetResult::Documentation = "Result of GetVehicleAntennaPhaseOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleAntennaPhaseOffsetResult);


    GetVehicleAntennaPhaseOffsetResult::GetVehicleAntennaPhaseOffsetResult()
      : CommandResult(CmdName)
    {}

    GetVehicleAntennaPhaseOffsetResult::GetVehicleAntennaPhaseOffsetResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setPhaseOffset(phaseOffset);
      setType(type);
      setBand(band);
      setName(name);
    }


    GetVehicleAntennaPhaseOffsetResultPtr GetVehicleAntennaPhaseOffsetResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return GetVehicleAntennaPhaseOffsetResultPtr(new GetVehicleAntennaPhaseOffsetResult(relatedCommand, phaseOffset, type, band, name));
    }

    GetVehicleAntennaPhaseOffsetResultPtr GetVehicleAntennaPhaseOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaPhaseOffsetResult>(ptr);
    }

    bool GetVehicleAntennaPhaseOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffset"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaPhaseOffsetResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetVehicleAntennaPhaseOffsetResult::phaseOffset() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffset"]);
    }

    void GetVehicleAntennaPhaseOffsetResult::setPhaseOffset(const std::vector<std::vector<double>>& phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<std::vector<std::vector<double>>>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaPhaseOffsetResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetVehicleAntennaPhaseOffsetResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand GetVehicleAntennaPhaseOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleAntennaPhaseOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaPhaseOffsetResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaPhaseOffsetResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaGainCSV
///
#include "gen/SetVehicleAntennaGainCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaGainCSV::CmdName = "SetVehicleAntennaGainCSV";
    const char* const SetVehicleAntennaGainCSV::Documentation = "Set vehicle gain antenna pattern from a CSV file. If no name is specified, the command is aplied to Basic vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaGainCSV);


    SetVehicleAntennaGainCSV::SetVehicleAntennaGainCSV()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaGainCSV::SetVehicleAntennaGainCSV(const std::string& filePath, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setType(type);
      setBand(band);
      setName(name);
    }


    SetVehicleAntennaGainCSVPtr SetVehicleAntennaGainCSV::create(const std::string& filePath, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return SetVehicleAntennaGainCSVPtr(new SetVehicleAntennaGainCSV(filePath, type, band, name));
    }

    SetVehicleAntennaGainCSVPtr SetVehicleAntennaGainCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaGainCSV>(ptr);
    }

    bool SetVehicleAntennaGainCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaGainCSV::documentation() const { return Documentation; }


    int SetVehicleAntennaGainCSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleAntennaGainCSV::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void SetVehicleAntennaGainCSV::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetVehicleAntennaGainCSV::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetVehicleAntennaGainCSV::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetVehicleAntennaGainCSV::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetVehicleAntennaGainCSV::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaGainCSV::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaGainCSV::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaPhaseOffsetCSV
///
#include "gen/SetVehicleAntennaPhaseOffsetCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaPhaseOffsetCSV::CmdName = "SetVehicleAntennaPhaseOffsetCSV";
    const char* const SetVehicleAntennaPhaseOffsetCSV::Documentation = "Set vehicle phase offset antenna pattern from a CSV file. If no name is specified, the command is aplied to Basic vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaPhaseOffsetCSV);


    SetVehicleAntennaPhaseOffsetCSV::SetVehicleAntennaPhaseOffsetCSV()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaPhaseOffsetCSV::SetVehicleAntennaPhaseOffsetCSV(const std::string& filePath, const Sdx::AntennaPatternFileType& fileFormat, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setFileFormat(fileFormat);
      setType(type);
      setBand(band);
      setName(name);
    }


    SetVehicleAntennaPhaseOffsetCSVPtr SetVehicleAntennaPhaseOffsetCSV::create(const std::string& filePath, const Sdx::AntennaPatternFileType& fileFormat, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const Sdx::optional<std::string>& name)
    {
      return SetVehicleAntennaPhaseOffsetCSVPtr(new SetVehicleAntennaPhaseOffsetCSV(filePath, fileFormat, type, band, name));
    }

    SetVehicleAntennaPhaseOffsetCSVPtr SetVehicleAntennaPhaseOffsetCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaPhaseOffsetCSV>(ptr);
    }

    bool SetVehicleAntennaPhaseOffsetCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<Sdx::AntennaPatternFileType>::is_valid(m_values["FileFormat"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaPhaseOffsetCSV::documentation() const { return Documentation; }


    int SetVehicleAntennaPhaseOffsetCSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleAntennaPhaseOffsetCSV::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternFileType SetVehicleAntennaPhaseOffsetCSV::fileFormat() const
    {
      return parse_json<Sdx::AntennaPatternFileType>::parse(m_values["FileFormat"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setFileFormat(const Sdx::AntennaPatternFileType& fileFormat)
    {
      m_values.AddMember("FileFormat", parse_json<Sdx::AntennaPatternFileType>::format(fileFormat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetVehicleAntennaPhaseOffsetCSV::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetVehicleAntennaPhaseOffsetCSV::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaPhaseOffsetCSV::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaPhaseOffsetCSV::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddVehicleGainPatternOffset
///
#include "gen/AddVehicleGainPatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddVehicleGainPatternOffset::CmdName = "AddVehicleGainPatternOffset";
    const char* const AddVehicleGainPatternOffset::Documentation = "Add an offset (in db) for all values of the pattern.";

    REGISTER_COMMAND_FACTORY(AddVehicleGainPatternOffset);


    AddVehicleGainPatternOffset::AddVehicleGainPatternOffset()
      : CommandBase(CmdName)
    {}

    AddVehicleGainPatternOffset::AddVehicleGainPatternOffset(const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    AddVehicleGainPatternOffsetPtr AddVehicleGainPatternOffset::create(const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return AddVehicleGainPatternOffsetPtr(new AddVehicleGainPatternOffset(band, offset, antennaName));
    }

    AddVehicleGainPatternOffsetPtr AddVehicleGainPatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddVehicleGainPatternOffset>(ptr);
    }

    bool AddVehicleGainPatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string AddVehicleGainPatternOffset::documentation() const { return Documentation; }


    int AddVehicleGainPatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand AddVehicleGainPatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void AddVehicleGainPatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddVehicleGainPatternOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void AddVehicleGainPatternOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> AddVehicleGainPatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void AddVehicleGainPatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleGainPatternOffset
///
#include "gen/GetVehicleGainPatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleGainPatternOffset::CmdName = "GetVehicleGainPatternOffset";
    const char* const GetVehicleGainPatternOffset::Documentation = "Get the offset (in dB) for the antenna gain pattern of the band.";

    REGISTER_COMMAND_FACTORY(GetVehicleGainPatternOffset);


    GetVehicleGainPatternOffset::GetVehicleGainPatternOffset()
      : CommandBase(CmdName)
    {}

    GetVehicleGainPatternOffset::GetVehicleGainPatternOffset(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setAntennaName(antennaName);
    }


    GetVehicleGainPatternOffsetPtr GetVehicleGainPatternOffset::create(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& antennaName)
    {
      return GetVehicleGainPatternOffsetPtr(new GetVehicleGainPatternOffset(band, antennaName));
    }

    GetVehicleGainPatternOffsetPtr GetVehicleGainPatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleGainPatternOffset>(ptr);
    }

    bool GetVehicleGainPatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetVehicleGainPatternOffset::documentation() const { return Documentation; }


    int GetVehicleGainPatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetVehicleGainPatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleGainPatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleGainPatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetVehicleGainPatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleGainPatternOffsetResult
///
#include "gen/GetVehicleGainPatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleGainPatternOffsetResult::CmdName = "GetVehicleGainPatternOffsetResult";
    const char* const GetVehicleGainPatternOffsetResult::Documentation = "Result of GetVehicleGainPatternOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleGainPatternOffsetResult);


    GetVehicleGainPatternOffsetResult::GetVehicleGainPatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetVehicleGainPatternOffsetResult::GetVehicleGainPatternOffsetResult(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    GetVehicleGainPatternOffsetResultPtr GetVehicleGainPatternOffsetResult::create(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return GetVehicleGainPatternOffsetResultPtr(new GetVehicleGainPatternOffsetResult(relatedCommand, band, offset, antennaName));
    }

    GetVehicleGainPatternOffsetResultPtr GetVehicleGainPatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleGainPatternOffsetResult>(ptr);
    }

    bool GetVehicleGainPatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetVehicleGainPatternOffsetResult::documentation() const { return Documentation; }


    Sdx::GNSSBand GetVehicleGainPatternOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehicleGainPatternOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleGainPatternOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetVehicleGainPatternOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleGainPatternOffsetResult::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetVehicleGainPatternOffsetResult::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddVehiclePhasePatternOffset
///
#include "gen/AddVehiclePhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddVehiclePhasePatternOffset::CmdName = "AddVehiclePhasePatternOffset";
    const char* const AddVehiclePhasePatternOffset::Documentation = "Add an offset (in rad) for all values of the phase pattern.";

    REGISTER_COMMAND_FACTORY(AddVehiclePhasePatternOffset);


    AddVehiclePhasePatternOffset::AddVehiclePhasePatternOffset()
      : CommandBase(CmdName)
    {}

    AddVehiclePhasePatternOffset::AddVehiclePhasePatternOffset(const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    AddVehiclePhasePatternOffsetPtr AddVehiclePhasePatternOffset::create(const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return AddVehiclePhasePatternOffsetPtr(new AddVehiclePhasePatternOffset(band, offset, antennaName));
    }

    AddVehiclePhasePatternOffsetPtr AddVehiclePhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddVehiclePhasePatternOffset>(ptr);
    }

    bool AddVehiclePhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string AddVehiclePhasePatternOffset::documentation() const { return Documentation; }


    int AddVehiclePhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand AddVehiclePhasePatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void AddVehiclePhasePatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddVehiclePhasePatternOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void AddVehiclePhasePatternOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> AddVehiclePhasePatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void AddVehiclePhasePatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehiclePhasePatternOffset
///
#include "gen/GetVehiclePhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehiclePhasePatternOffset::CmdName = "GetVehiclePhasePatternOffset";
    const char* const GetVehiclePhasePatternOffset::Documentation = "Get the offset (in rad) for the antenna phase pattern of the band.";

    REGISTER_COMMAND_FACTORY(GetVehiclePhasePatternOffset);


    GetVehiclePhasePatternOffset::GetVehiclePhasePatternOffset()
      : CommandBase(CmdName)
    {}

    GetVehiclePhasePatternOffset::GetVehiclePhasePatternOffset(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setAntennaName(antennaName);
    }


    GetVehiclePhasePatternOffsetPtr GetVehiclePhasePatternOffset::create(const Sdx::GNSSBand& band, const Sdx::optional<std::string>& antennaName)
    {
      return GetVehiclePhasePatternOffsetPtr(new GetVehiclePhasePatternOffset(band, antennaName));
    }

    GetVehiclePhasePatternOffsetPtr GetVehiclePhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehiclePhasePatternOffset>(ptr);
    }

    bool GetVehiclePhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetVehiclePhasePatternOffset::documentation() const { return Documentation; }


    int GetVehiclePhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetVehiclePhasePatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehiclePhasePatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehiclePhasePatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetVehiclePhasePatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehiclePhasePatternOffsetResult
///
#include "gen/GetVehiclePhasePatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehiclePhasePatternOffsetResult::CmdName = "GetVehiclePhasePatternOffsetResult";
    const char* const GetVehiclePhasePatternOffsetResult::Documentation = "Result of GetVehiclePhasePatternOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehiclePhasePatternOffsetResult);


    GetVehiclePhasePatternOffsetResult::GetVehiclePhasePatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetVehiclePhasePatternOffsetResult::GetVehiclePhasePatternOffsetResult(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    GetVehiclePhasePatternOffsetResultPtr GetVehiclePhasePatternOffsetResult::create(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return GetVehiclePhasePatternOffsetResultPtr(new GetVehiclePhasePatternOffsetResult(relatedCommand, band, offset, antennaName));
    }

    GetVehiclePhasePatternOffsetResultPtr GetVehiclePhasePatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehiclePhasePatternOffsetResult>(ptr);
    }

    bool GetVehiclePhasePatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetVehiclePhasePatternOffsetResult::documentation() const { return Documentation; }


    Sdx::GNSSBand GetVehiclePhasePatternOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetVehiclePhasePatternOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehiclePhasePatternOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetVehiclePhasePatternOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehiclePhasePatternOffsetResult::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetVehiclePhasePatternOffsetResult::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleAntennaOffset
///
#include "gen/SetVehicleAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleAntennaOffset::CmdName = "SetVehicleAntennaOffset";
    const char* const SetVehicleAntennaOffset::Documentation = "Set antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the vehicle trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(SetVehicleAntennaOffset);


    SetVehicleAntennaOffset::SetVehicleAntennaOffset()
      : CommandBase(CmdName)
    {}

    SetVehicleAntennaOffset::SetVehicleAntennaOffset(double x, double y, double z, double yaw, double pitch, double roll, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setName(name);
    }


    SetVehicleAntennaOffsetPtr SetVehicleAntennaOffset::create(double x, double y, double z, double yaw, double pitch, double roll, const Sdx::optional<std::string>& name)
    {
      return SetVehicleAntennaOffsetPtr(new SetVehicleAntennaOffset(x, y, z, yaw, pitch, roll, name));
    }

    SetVehicleAntennaOffsetPtr SetVehicleAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleAntennaOffset>(ptr);
    }

    bool SetVehicleAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetVehicleAntennaOffset::documentation() const { return Documentation; }


    int SetVehicleAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetVehicleAntennaOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetVehicleAntennaOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetVehicleAntennaOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetVehicleAntennaOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetVehicleAntennaOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetVehicleAntennaOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleAntennaOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetVehicleAntennaOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetVehicleAntennaOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetVehicleAntennaOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaOffset
///
#include "gen/GetVehicleAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaOffset::CmdName = "GetVehicleAntennaOffset";
    const char* const GetVehicleAntennaOffset::Documentation = "Get the vehicle antenna offset infos. If no name is specified, the default vehicle antenna is get.";

    REGISTER_COMMAND_FACTORY(GetVehicleAntennaOffset);


    GetVehicleAntennaOffset::GetVehicleAntennaOffset(const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    GetVehicleAntennaOffsetPtr GetVehicleAntennaOffset::create(const Sdx::optional<std::string>& name)
    {
      return GetVehicleAntennaOffsetPtr(new GetVehicleAntennaOffset(name));
    }

    GetVehicleAntennaOffsetPtr GetVehicleAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaOffset>(ptr);
    }

    bool GetVehicleAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaOffset::documentation() const { return Documentation; }


    int GetVehicleAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::optional<std::string> GetVehicleAntennaOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaOffsetResult
///
#include "gen/GetVehicleAntennaOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaOffsetResult::CmdName = "GetVehicleAntennaOffsetResult";
    const char* const GetVehicleAntennaOffsetResult::Documentation = "Result of GetVehicleAntennaOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleAntennaOffsetResult);


    GetVehicleAntennaOffsetResult::GetVehicleAntennaOffsetResult()
      : CommandResult(CmdName)
    {}

    GetVehicleAntennaOffsetResult::GetVehicleAntennaOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setName(name);
    }


    GetVehicleAntennaOffsetResultPtr GetVehicleAntennaOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const Sdx::optional<std::string>& name)
    {
      return GetVehicleAntennaOffsetResultPtr(new GetVehicleAntennaOffsetResult(relatedCommand, x, y, z, yaw, pitch, roll, name));
    }

    GetVehicleAntennaOffsetResultPtr GetVehicleAntennaOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaOffsetResult>(ptr);
    }

    bool GetVehicleAntennaOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaOffsetResult::documentation() const { return Documentation; }


    double GetVehicleAntennaOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetVehicleAntennaOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetVehicleAntennaOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetVehicleAntennaOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetVehicleAntennaOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetVehicleAntennaOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetVehicleAntennaOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetVehicleAntennaOffsetResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaOffsetResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddEmptyVehicleAntennaModel
///
#include "gen/AddEmptyVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddEmptyVehicleAntennaModel::CmdName = "AddEmptyVehicleAntennaModel";
    const char* const AddEmptyVehicleAntennaModel::Documentation = "Create an empty vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(AddEmptyVehicleAntennaModel);


    AddEmptyVehicleAntennaModel::AddEmptyVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    AddEmptyVehicleAntennaModel::AddEmptyVehicleAntennaModel(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    AddEmptyVehicleAntennaModelPtr AddEmptyVehicleAntennaModel::create(const std::string& name)
    {
      return AddEmptyVehicleAntennaModelPtr(new AddEmptyVehicleAntennaModel(name));
    }

    AddEmptyVehicleAntennaModelPtr AddEmptyVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddEmptyVehicleAntennaModel>(ptr);
    }

    bool AddEmptyVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string AddEmptyVehicleAntennaModel::documentation() const { return Documentation; }


    int AddEmptyVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddEmptyVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void AddEmptyVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of DeleteVehicleAntennaModel
///
#include "gen/DeleteVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const DeleteVehicleAntennaModel::CmdName = "DeleteVehicleAntennaModel";
    const char* const DeleteVehicleAntennaModel::Documentation = "Delete a vehicle antenna model. The default vehicle antenna model can't be deleted.";

    REGISTER_COMMAND_FACTORY(DeleteVehicleAntennaModel);


    DeleteVehicleAntennaModel::DeleteVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    DeleteVehicleAntennaModel::DeleteVehicleAntennaModel(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    DeleteVehicleAntennaModelPtr DeleteVehicleAntennaModel::create(const std::string& name)
    {
      return DeleteVehicleAntennaModelPtr(new DeleteVehicleAntennaModel(name));
    }

    DeleteVehicleAntennaModelPtr DeleteVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<DeleteVehicleAntennaModel>(ptr);
    }

    bool DeleteVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string DeleteVehicleAntennaModel::documentation() const { return Documentation; }


    int DeleteVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string DeleteVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void DeleteVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RenameVehicleAntennaModel
///
#include "gen/RenameVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RenameVehicleAntennaModel::CmdName = "RenameVehicleAntennaModel";
    const char* const RenameVehicleAntennaModel::Documentation = "Rename a vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(RenameVehicleAntennaModel);


    RenameVehicleAntennaModel::RenameVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    RenameVehicleAntennaModel::RenameVehicleAntennaModel(const std::string& name, const std::string& newName)
      : CommandBase(CmdName)
    {

      setName(name);
      setNewName(newName);
    }


    RenameVehicleAntennaModelPtr RenameVehicleAntennaModel::create(const std::string& name, const std::string& newName)
    {
      return RenameVehicleAntennaModelPtr(new RenameVehicleAntennaModel(name, newName));
    }

    RenameVehicleAntennaModelPtr RenameVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RenameVehicleAntennaModel>(ptr);
    }

    bool RenameVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["NewName"])
        ;

    }

    std::string RenameVehicleAntennaModel::documentation() const { return Documentation; }


    int RenameVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RenameVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void RenameVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameVehicleAntennaModel::newName() const
    {
      return parse_json<std::string>::parse(m_values["NewName"]);
    }

    void RenameVehicleAntennaModel::setNewName(const std::string& newName)
    {
      m_values.AddMember("NewName", parse_json<std::string>::format(newName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CopyVehicleAntennaModel
///
#include "gen/CopyVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CopyVehicleAntennaModel::CmdName = "CopyVehicleAntennaModel";
    const char* const CopyVehicleAntennaModel::Documentation = "Copy a vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(CopyVehicleAntennaModel);


    CopyVehicleAntennaModel::CopyVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    CopyVehicleAntennaModel::CopyVehicleAntennaModel(const std::string& name, const std::string& copyName)
      : CommandBase(CmdName)
    {

      setName(name);
      setCopyName(copyName);
    }


    CopyVehicleAntennaModelPtr CopyVehicleAntennaModel::create(const std::string& name, const std::string& copyName)
    {
      return CopyVehicleAntennaModelPtr(new CopyVehicleAntennaModel(name, copyName));
    }

    CopyVehicleAntennaModelPtr CopyVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CopyVehicleAntennaModel>(ptr);
    }

    bool CopyVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["CopyName"])
        ;

    }

    std::string CopyVehicleAntennaModel::documentation() const { return Documentation; }


    int CopyVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string CopyVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void CopyVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string CopyVehicleAntennaModel::copyName() const
    {
      return parse_json<std::string>::parse(m_values["CopyName"]);
    }

    void CopyVehicleAntennaModel::setCopyName(const std::string& copyName)
    {
      m_values.AddMember("CopyName", parse_json<std::string>::format(copyName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaModel
///
#include "gen/GetVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaModel::CmdName = "GetVehicleAntennaModel";
    const char* const GetVehicleAntennaModel::Documentation = "Get all infos about this antenna model.";

    REGISTER_COMMAND_FACTORY(GetVehicleAntennaModel);


    GetVehicleAntennaModel::GetVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    GetVehicleAntennaModel::GetVehicleAntennaModel(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    GetVehicleAntennaModelPtr GetVehicleAntennaModel::create(const std::string& name)
    {
      return GetVehicleAntennaModelPtr(new GetVehicleAntennaModel(name));
    }

    GetVehicleAntennaModelPtr GetVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaModel>(ptr);
    }

    bool GetVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaModel::documentation() const { return Documentation; }


    int GetVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetVehicleAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleAntennaModelResult
///
#include "gen/GetVehicleAntennaModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleAntennaModelResult::CmdName = "GetVehicleAntennaModelResult";
    const char* const GetVehicleAntennaModelResult::Documentation = "Result of GetVehicleAntennaModel";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleAntennaModelResult);


    GetVehicleAntennaModelResult::GetVehicleAntennaModelResult()
      : CommandResult(CmdName)
    {}

    GetVehicleAntennaModelResult::GetVehicleAntennaModelResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gainL1, const Sdx::AntennaPatternType& gainTypeL1, double gainOffsetL1, const std::vector<std::vector<double>>& gainL2, const Sdx::AntennaPatternType& gainTypeL2, double gainOffsetL2, const std::vector<std::vector<double>>& gainL5, const Sdx::AntennaPatternType& gainTypeL5, double gainOffsetL5, const std::vector<std::vector<double>>& gainE6, const Sdx::AntennaPatternType& gainTypeE6, double gainOffsetE6, const std::vector<std::vector<double>>& phaseOffsetL1, const Sdx::AntennaPatternType& phaseOffsetTypeL1, double phasePatternOffsetL1, const std::vector<std::vector<double>>& phaseOffsetL2, const Sdx::AntennaPatternType& phaseOffsetTypeL2, double phasePatternOffsetL2, const std::vector<std::vector<double>>& phaseOffsetL5, const Sdx::AntennaPatternType& phaseOffsetTypeL5, double phasePatternOffsetL5, const std::vector<std::vector<double>>& phaseOffsetE6, const Sdx::AntennaPatternType& phaseOffsetTypeE6, double phasePatternOffsetE6, double x, double y, double z, double yaw, double pitch, double roll, const std::string& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setGainL1(gainL1);
      setGainTypeL1(gainTypeL1);
      setGainOffsetL1(gainOffsetL1);
      setGainL2(gainL2);
      setGainTypeL2(gainTypeL2);
      setGainOffsetL2(gainOffsetL2);
      setGainL5(gainL5);
      setGainTypeL5(gainTypeL5);
      setGainOffsetL5(gainOffsetL5);
      setGainE6(gainE6);
      setGainTypeE6(gainTypeE6);
      setGainOffsetE6(gainOffsetE6);
      setPhaseOffsetL1(phaseOffsetL1);
      setPhaseOffsetTypeL1(phaseOffsetTypeL1);
      setPhasePatternOffsetL1(phasePatternOffsetL1);
      setPhaseOffsetL2(phaseOffsetL2);
      setPhaseOffsetTypeL2(phaseOffsetTypeL2);
      setPhasePatternOffsetL2(phasePatternOffsetL2);
      setPhaseOffsetL5(phaseOffsetL5);
      setPhaseOffsetTypeL5(phaseOffsetTypeL5);
      setPhasePatternOffsetL5(phasePatternOffsetL5);
      setPhaseOffsetE6(phaseOffsetE6);
      setPhaseOffsetTypeE6(phaseOffsetTypeE6);
      setPhasePatternOffsetE6(phasePatternOffsetE6);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setName(name);
    }


    GetVehicleAntennaModelResultPtr GetVehicleAntennaModelResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gainL1, const Sdx::AntennaPatternType& gainTypeL1, double gainOffsetL1, const std::vector<std::vector<double>>& gainL2, const Sdx::AntennaPatternType& gainTypeL2, double gainOffsetL2, const std::vector<std::vector<double>>& gainL5, const Sdx::AntennaPatternType& gainTypeL5, double gainOffsetL5, const std::vector<std::vector<double>>& gainE6, const Sdx::AntennaPatternType& gainTypeE6, double gainOffsetE6, const std::vector<std::vector<double>>& phaseOffsetL1, const Sdx::AntennaPatternType& phaseOffsetTypeL1, double phasePatternOffsetL1, const std::vector<std::vector<double>>& phaseOffsetL2, const Sdx::AntennaPatternType& phaseOffsetTypeL2, double phasePatternOffsetL2, const std::vector<std::vector<double>>& phaseOffsetL5, const Sdx::AntennaPatternType& phaseOffsetTypeL5, double phasePatternOffsetL5, const std::vector<std::vector<double>>& phaseOffsetE6, const Sdx::AntennaPatternType& phaseOffsetTypeE6, double phasePatternOffsetE6, double x, double y, double z, double yaw, double pitch, double roll, const std::string& name)
    {
      return GetVehicleAntennaModelResultPtr(new GetVehicleAntennaModelResult(relatedCommand, gainL1, gainTypeL1, gainOffsetL1, gainL2, gainTypeL2, gainOffsetL2, gainL5, gainTypeL5, gainOffsetL5, gainE6, gainTypeE6, gainOffsetE6, phaseOffsetL1, phaseOffsetTypeL1, phasePatternOffsetL1, phaseOffsetL2, phaseOffsetTypeL2, phasePatternOffsetL2, phaseOffsetL5, phaseOffsetTypeL5, phasePatternOffsetL5, phaseOffsetE6, phaseOffsetTypeE6, phasePatternOffsetE6, x, y, z, yaw, pitch, roll, name));
    }

    GetVehicleAntennaModelResultPtr GetVehicleAntennaModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleAntennaModelResult>(ptr);
    }

    bool GetVehicleAntennaModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["GainL1"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["GainTypeL1"])
          && parse_json<double>::is_valid(m_values["GainOffsetL1"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["GainL2"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["GainTypeL2"])
          && parse_json<double>::is_valid(m_values["GainOffsetL2"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["GainL5"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["GainTypeL5"])
          && parse_json<double>::is_valid(m_values["GainOffsetL5"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["GainE6"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["GainTypeE6"])
          && parse_json<double>::is_valid(m_values["GainOffsetE6"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffsetL1"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["PhaseOffsetTypeL1"])
          && parse_json<double>::is_valid(m_values["PhasePatternOffsetL1"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffsetL2"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["PhaseOffsetTypeL2"])
          && parse_json<double>::is_valid(m_values["PhasePatternOffsetL2"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffsetL5"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["PhaseOffsetTypeL5"])
          && parse_json<double>::is_valid(m_values["PhasePatternOffsetL5"])
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffsetE6"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["PhaseOffsetTypeE6"])
          && parse_json<double>::is_valid(m_values["PhasePatternOffsetE6"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string GetVehicleAntennaModelResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetVehicleAntennaModelResult::gainL1() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["GainL1"]);
    }

    void GetVehicleAntennaModelResult::setGainL1(const std::vector<std::vector<double>>& gainL1)
    {
      m_values.AddMember("GainL1", parse_json<std::vector<std::vector<double>>>::format(gainL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::gainTypeL1() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["GainTypeL1"]);
    }

    void GetVehicleAntennaModelResult::setGainTypeL1(const Sdx::AntennaPatternType& gainTypeL1)
    {
      m_values.AddMember("GainTypeL1", parse_json<Sdx::AntennaPatternType>::format(gainTypeL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::gainOffsetL1() const
    {
      return parse_json<double>::parse(m_values["GainOffsetL1"]);
    }

    void GetVehicleAntennaModelResult::setGainOffsetL1(double gainOffsetL1)
    {
      m_values.AddMember("GainOffsetL1", parse_json<double>::format(gainOffsetL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::gainL2() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["GainL2"]);
    }

    void GetVehicleAntennaModelResult::setGainL2(const std::vector<std::vector<double>>& gainL2)
    {
      m_values.AddMember("GainL2", parse_json<std::vector<std::vector<double>>>::format(gainL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::gainTypeL2() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["GainTypeL2"]);
    }

    void GetVehicleAntennaModelResult::setGainTypeL2(const Sdx::AntennaPatternType& gainTypeL2)
    {
      m_values.AddMember("GainTypeL2", parse_json<Sdx::AntennaPatternType>::format(gainTypeL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::gainOffsetL2() const
    {
      return parse_json<double>::parse(m_values["GainOffsetL2"]);
    }

    void GetVehicleAntennaModelResult::setGainOffsetL2(double gainOffsetL2)
    {
      m_values.AddMember("GainOffsetL2", parse_json<double>::format(gainOffsetL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::gainL5() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["GainL5"]);
    }

    void GetVehicleAntennaModelResult::setGainL5(const std::vector<std::vector<double>>& gainL5)
    {
      m_values.AddMember("GainL5", parse_json<std::vector<std::vector<double>>>::format(gainL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::gainTypeL5() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["GainTypeL5"]);
    }

    void GetVehicleAntennaModelResult::setGainTypeL5(const Sdx::AntennaPatternType& gainTypeL5)
    {
      m_values.AddMember("GainTypeL5", parse_json<Sdx::AntennaPatternType>::format(gainTypeL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::gainOffsetL5() const
    {
      return parse_json<double>::parse(m_values["GainOffsetL5"]);
    }

    void GetVehicleAntennaModelResult::setGainOffsetL5(double gainOffsetL5)
    {
      m_values.AddMember("GainOffsetL5", parse_json<double>::format(gainOffsetL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::gainE6() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["GainE6"]);
    }

    void GetVehicleAntennaModelResult::setGainE6(const std::vector<std::vector<double>>& gainE6)
    {
      m_values.AddMember("GainE6", parse_json<std::vector<std::vector<double>>>::format(gainE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::gainTypeE6() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["GainTypeE6"]);
    }

    void GetVehicleAntennaModelResult::setGainTypeE6(const Sdx::AntennaPatternType& gainTypeE6)
    {
      m_values.AddMember("GainTypeE6", parse_json<Sdx::AntennaPatternType>::format(gainTypeE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::gainOffsetE6() const
    {
      return parse_json<double>::parse(m_values["GainOffsetE6"]);
    }

    void GetVehicleAntennaModelResult::setGainOffsetE6(double gainOffsetE6)
    {
      m_values.AddMember("GainOffsetE6", parse_json<double>::format(gainOffsetE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::phaseOffsetL1() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffsetL1"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetL1(const std::vector<std::vector<double>>& phaseOffsetL1)
    {
      m_values.AddMember("PhaseOffsetL1", parse_json<std::vector<std::vector<double>>>::format(phaseOffsetL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::phaseOffsetTypeL1() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["PhaseOffsetTypeL1"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetTypeL1(const Sdx::AntennaPatternType& phaseOffsetTypeL1)
    {
      m_values.AddMember("PhaseOffsetTypeL1", parse_json<Sdx::AntennaPatternType>::format(phaseOffsetTypeL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::phasePatternOffsetL1() const
    {
      return parse_json<double>::parse(m_values["PhasePatternOffsetL1"]);
    }

    void GetVehicleAntennaModelResult::setPhasePatternOffsetL1(double phasePatternOffsetL1)
    {
      m_values.AddMember("PhasePatternOffsetL1", parse_json<double>::format(phasePatternOffsetL1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::phaseOffsetL2() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffsetL2"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetL2(const std::vector<std::vector<double>>& phaseOffsetL2)
    {
      m_values.AddMember("PhaseOffsetL2", parse_json<std::vector<std::vector<double>>>::format(phaseOffsetL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::phaseOffsetTypeL2() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["PhaseOffsetTypeL2"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetTypeL2(const Sdx::AntennaPatternType& phaseOffsetTypeL2)
    {
      m_values.AddMember("PhaseOffsetTypeL2", parse_json<Sdx::AntennaPatternType>::format(phaseOffsetTypeL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::phasePatternOffsetL2() const
    {
      return parse_json<double>::parse(m_values["PhasePatternOffsetL2"]);
    }

    void GetVehicleAntennaModelResult::setPhasePatternOffsetL2(double phasePatternOffsetL2)
    {
      m_values.AddMember("PhasePatternOffsetL2", parse_json<double>::format(phasePatternOffsetL2, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::phaseOffsetL5() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffsetL5"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetL5(const std::vector<std::vector<double>>& phaseOffsetL5)
    {
      m_values.AddMember("PhaseOffsetL5", parse_json<std::vector<std::vector<double>>>::format(phaseOffsetL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::phaseOffsetTypeL5() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["PhaseOffsetTypeL5"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetTypeL5(const Sdx::AntennaPatternType& phaseOffsetTypeL5)
    {
      m_values.AddMember("PhaseOffsetTypeL5", parse_json<Sdx::AntennaPatternType>::format(phaseOffsetTypeL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::phasePatternOffsetL5() const
    {
      return parse_json<double>::parse(m_values["PhasePatternOffsetL5"]);
    }

    void GetVehicleAntennaModelResult::setPhasePatternOffsetL5(double phasePatternOffsetL5)
    {
      m_values.AddMember("PhasePatternOffsetL5", parse_json<double>::format(phasePatternOffsetL5, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<double>> GetVehicleAntennaModelResult::phaseOffsetE6() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffsetE6"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetE6(const std::vector<std::vector<double>>& phaseOffsetE6)
    {
      m_values.AddMember("PhaseOffsetE6", parse_json<std::vector<std::vector<double>>>::format(phaseOffsetE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetVehicleAntennaModelResult::phaseOffsetTypeE6() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["PhaseOffsetTypeE6"]);
    }

    void GetVehicleAntennaModelResult::setPhaseOffsetTypeE6(const Sdx::AntennaPatternType& phaseOffsetTypeE6)
    {
      m_values.AddMember("PhaseOffsetTypeE6", parse_json<Sdx::AntennaPatternType>::format(phaseOffsetTypeE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::phasePatternOffsetE6() const
    {
      return parse_json<double>::parse(m_values["PhasePatternOffsetE6"]);
    }

    void GetVehicleAntennaModelResult::setPhasePatternOffsetE6(double phasePatternOffsetE6)
    {
      m_values.AddMember("PhasePatternOffsetE6", parse_json<double>::format(phasePatternOffsetE6, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetVehicleAntennaModelResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetVehicleAntennaModelResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetVehicleAntennaModelResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetVehicleAntennaModelResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetVehicleAntennaModelResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleAntennaModelResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetVehicleAntennaModelResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetVehicleAntennaModelResult::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void GetVehicleAntennaModelResult::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportVehicleAntennaModel
///
#include "gen/ImportVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportVehicleAntennaModel::CmdName = "ImportVehicleAntennaModel";
    const char* const ImportVehicleAntennaModel::Documentation = "Import a vehicle antenna model from a XML file.";

    REGISTER_COMMAND_FACTORY(ImportVehicleAntennaModel);


    ImportVehicleAntennaModel::ImportVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    ImportVehicleAntennaModel::ImportVehicleAntennaModel(const std::string& filePath)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
    }


    ImportVehicleAntennaModelPtr ImportVehicleAntennaModel::create(const std::string& filePath)
    {
      return ImportVehicleAntennaModelPtr(new ImportVehicleAntennaModel(filePath));
    }

    ImportVehicleAntennaModelPtr ImportVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportVehicleAntennaModel>(ptr);
    }

    bool ImportVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
        ;

    }

    std::string ImportVehicleAntennaModel::documentation() const { return Documentation; }


    int ImportVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportVehicleAntennaModel::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void ImportVehicleAntennaModel::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportVehicleAntennaModel
///
#include "gen/ExportVehicleAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportVehicleAntennaModel::CmdName = "ExportVehicleAntennaModel";
    const char* const ExportVehicleAntennaModel::Documentation = "Export a vehicle antenna model in a XML file.";

    REGISTER_COMMAND_FACTORY(ExportVehicleAntennaModel);


    ExportVehicleAntennaModel::ExportVehicleAntennaModel()
      : CommandBase(CmdName)
    {}

    ExportVehicleAntennaModel::ExportVehicleAntennaModel(const std::string& antennaName, const std::string& filePath, bool overwriting)
      : CommandBase(CmdName)
    {

      setAntennaName(antennaName);
      setFilePath(filePath);
      setOverwriting(overwriting);
    }


    ExportVehicleAntennaModelPtr ExportVehicleAntennaModel::create(const std::string& antennaName, const std::string& filePath, bool overwriting)
    {
      return ExportVehicleAntennaModelPtr(new ExportVehicleAntennaModel(antennaName, filePath, overwriting));
    }

    ExportVehicleAntennaModelPtr ExportVehicleAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportVehicleAntennaModel>(ptr);
    }

    bool ExportVehicleAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["AntennaName"])
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
        ;

    }

    std::string ExportVehicleAntennaModel::documentation() const { return Documentation; }


    int ExportVehicleAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ExportVehicleAntennaModel::antennaName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaName"]);
    }

    void ExportVehicleAntennaModel::setAntennaName(const std::string& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<std::string>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportVehicleAntennaModel::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void ExportVehicleAntennaModel::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ExportVehicleAntennaModel::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportVehicleAntennaModel::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAntennaChange
///
#include "gen/SetAntennaChange.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAntennaChange::CmdName = "SetAntennaChange";
    const char* const SetAntennaChange::Documentation = "Add/edit an antenna change.";

    REGISTER_COMMAND_FACTORY(SetAntennaChange);


    SetAntennaChange::SetAntennaChange()
      : CommandBase(CmdName)
    {}

    SetAntennaChange::SetAntennaChange(double startTime, const std::string& antenna, const std::string& id)
      : CommandBase(CmdName)
    {

      setStartTime(startTime);
      setAntenna(antenna);
      setId(id);
    }


    SetAntennaChangePtr SetAntennaChange::create(double startTime, const std::string& antenna, const std::string& id)
    {
      return SetAntennaChangePtr(new SetAntennaChange(startTime, antenna, id));
    }

    SetAntennaChangePtr SetAntennaChange::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAntennaChange>(ptr);
    }

    bool SetAntennaChange::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["StartTime"])
          && parse_json<std::string>::is_valid(m_values["Antenna"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetAntennaChange::documentation() const { return Documentation; }


    int SetAntennaChange::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetAntennaChange::startTime() const
    {
      return parse_json<double>::parse(m_values["StartTime"]);
    }

    void SetAntennaChange::setStartTime(double startTime)
    {
      m_values.AddMember("StartTime", parse_json<double>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetAntennaChange::antenna() const
    {
      return parse_json<std::string>::parse(m_values["Antenna"]);
    }

    void SetAntennaChange::setAntenna(const std::string& antenna)
    {
      m_values.AddMember("Antenna", parse_json<std::string>::format(antenna, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetAntennaChange::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetAntennaChange::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAntennaChange
///
#include "gen/GetAntennaChange.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAntennaChange::CmdName = "GetAntennaChange";
    const char* const GetAntennaChange::Documentation = "Get an antenna change.";

    REGISTER_COMMAND_FACTORY(GetAntennaChange);


    GetAntennaChange::GetAntennaChange()
      : CommandBase(CmdName)
    {}

    GetAntennaChange::GetAntennaChange(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetAntennaChangePtr GetAntennaChange::create(const std::string& id)
    {
      return GetAntennaChangePtr(new GetAntennaChange(id));
    }

    GetAntennaChangePtr GetAntennaChange::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAntennaChange>(ptr);
    }

    bool GetAntennaChange::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetAntennaChange::documentation() const { return Documentation; }


    int GetAntennaChange::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAntennaChange::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetAntennaChange::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAntennaChangeResult
///
#include "gen/GetAntennaChangeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAntennaChangeResult::CmdName = "GetAntennaChangeResult";
    const char* const GetAntennaChangeResult::Documentation = "Result of GetAntennaChange";

    REGISTER_COMMAND_RESULT_FACTORY(GetAntennaChangeResult);


    GetAntennaChangeResult::GetAntennaChangeResult()
      : CommandResult(CmdName)
    {}

    GetAntennaChangeResult::GetAntennaChangeResult(CommandBasePtr relatedCommand, double startTime, const std::string& antenna, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setStartTime(startTime);
      setAntenna(antenna);
      setId(id);
    }


    GetAntennaChangeResultPtr GetAntennaChangeResult::create(CommandBasePtr relatedCommand, double startTime, const std::string& antenna, const std::string& id)
    {
      return GetAntennaChangeResultPtr(new GetAntennaChangeResult(relatedCommand, startTime, antenna, id));
    }

    GetAntennaChangeResultPtr GetAntennaChangeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAntennaChangeResult>(ptr);
    }

    bool GetAntennaChangeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["StartTime"])
          && parse_json<std::string>::is_valid(m_values["Antenna"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetAntennaChangeResult::documentation() const { return Documentation; }


    double GetAntennaChangeResult::startTime() const
    {
      return parse_json<double>::parse(m_values["StartTime"]);
    }

    void GetAntennaChangeResult::setStartTime(double startTime)
    {
      m_values.AddMember("StartTime", parse_json<double>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetAntennaChangeResult::antenna() const
    {
      return parse_json<std::string>::parse(m_values["Antenna"]);
    }

    void GetAntennaChangeResult::setAntenna(const std::string& antenna)
    {
      m_values.AddMember("Antenna", parse_json<std::string>::format(antenna, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetAntennaChangeResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetAntennaChangeResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAntennaChange
///
#include "gen/RemoveAntennaChange.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAntennaChange::CmdName = "RemoveAntennaChange";
    const char* const RemoveAntennaChange::Documentation = "Removes an antenna change.";

    REGISTER_COMMAND_FACTORY(RemoveAntennaChange);


    RemoveAntennaChange::RemoveAntennaChange()
      : CommandBase(CmdName)
    {}

    RemoveAntennaChange::RemoveAntennaChange(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveAntennaChangePtr RemoveAntennaChange::create(const std::string& id)
    {
      return RemoveAntennaChangePtr(new RemoveAntennaChange(id));
    }

    RemoveAntennaChangePtr RemoveAntennaChange::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAntennaChange>(ptr);
    }

    bool RemoveAntennaChange::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveAntennaChange::documentation() const { return Documentation; }


    int RemoveAntennaChange::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAntennaChange::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveAntennaChange::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllAntennaChanges
///
#include "gen/ClearAllAntennaChanges.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllAntennaChanges::CmdName = "ClearAllAntennaChanges";
    const char* const ClearAllAntennaChanges::Documentation = "Clear all antenna changes.";

    REGISTER_COMMAND_FACTORY(ClearAllAntennaChanges);


    ClearAllAntennaChanges::ClearAllAntennaChanges()
      : CommandBase(CmdName)
    {

    }


    ClearAllAntennaChangesPtr ClearAllAntennaChanges::create()
    {
      return ClearAllAntennaChangesPtr(new ClearAllAntennaChanges());
    }

    ClearAllAntennaChangesPtr ClearAllAntennaChanges::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllAntennaChanges>(ptr);
    }

    bool ClearAllAntennaChanges::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllAntennaChanges::documentation() const { return Documentation; }


    int ClearAllAntennaChanges::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of SetWFAntennaOffset
///
#include "gen/SetWFAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaOffset::CmdName = "SetWFAntennaOffset";
    const char* const SetWFAntennaOffset::Documentation = "Set WF antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the vehicle trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(SetWFAntennaOffset);


    SetWFAntennaOffset::SetWFAntennaOffset()
      : CommandBase(CmdName)
    {}

    SetWFAntennaOffset::SetWFAntennaOffset(double x, double y, double z, double yaw, double pitch, double roll)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    SetWFAntennaOffsetPtr SetWFAntennaOffset::create(double x, double y, double z, double yaw, double pitch, double roll)
    {
      return SetWFAntennaOffsetPtr(new SetWFAntennaOffset(x, y, z, yaw, pitch, roll));
    }

    SetWFAntennaOffsetPtr SetWFAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaOffset>(ptr);
    }

    bool SetWFAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string SetWFAntennaOffset::documentation() const { return Documentation; }


    int SetWFAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetWFAntennaOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetWFAntennaOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetWFAntennaOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetWFAntennaOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetWFAntennaOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetWFAntennaOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetWFAntennaOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaOffset
///
#include "gen/GetWFAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaOffset::CmdName = "GetWFAntennaOffset";
    const char* const GetWFAntennaOffset::Documentation = "Get the WF antenna offset infos.";

    REGISTER_COMMAND_FACTORY(GetWFAntennaOffset);


    GetWFAntennaOffset::GetWFAntennaOffset()
      : CommandBase(CmdName)
    {

    }


    GetWFAntennaOffsetPtr GetWFAntennaOffset::create()
    {
      return GetWFAntennaOffsetPtr(new GetWFAntennaOffset());
    }

    GetWFAntennaOffsetPtr GetWFAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaOffset>(ptr);
    }

    bool GetWFAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetWFAntennaOffset::documentation() const { return Documentation; }


    int GetWFAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetWFAntennaOffsetResult
///
#include "gen/GetWFAntennaOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaOffsetResult::CmdName = "GetWFAntennaOffsetResult";
    const char* const GetWFAntennaOffsetResult::Documentation = "Result of GetWFAntennaOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaOffsetResult);


    GetWFAntennaOffsetResult::GetWFAntennaOffsetResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaOffsetResult::GetWFAntennaOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    GetWFAntennaOffsetResultPtr GetWFAntennaOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll)
    {
      return GetWFAntennaOffsetResultPtr(new GetWFAntennaOffsetResult(relatedCommand, x, y, z, yaw, pitch, roll));
    }

    GetWFAntennaOffsetResultPtr GetWFAntennaOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaOffsetResult>(ptr);
    }

    bool GetWFAntennaOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string GetWFAntennaOffsetResult::documentation() const { return Documentation; }


    double GetWFAntennaOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetWFAntennaOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetWFAntennaOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetWFAntennaOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetWFAntennaOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetWFAntennaOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetWFAntennaOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaElementOffset
///
#include "gen/SetWFAntennaElementOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaElementOffset::CmdName = "SetWFAntennaElementOffset";
    const char* const SetWFAntennaElementOffset::Documentation = "Set WF antenna offset and orientation relative to CRPA Antenna frame for the specified element index.";

    REGISTER_COMMAND_FACTORY(SetWFAntennaElementOffset);


    SetWFAntennaElementOffset::SetWFAntennaElementOffset()
      : CommandBase(CmdName)
    {}

    SetWFAntennaElementOffset::SetWFAntennaElementOffset(double x, double y, double z, double yaw, double pitch, double roll, int element)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setElement(element);
    }


    SetWFAntennaElementOffsetPtr SetWFAntennaElementOffset::create(double x, double y, double z, double yaw, double pitch, double roll, int element)
    {
      return SetWFAntennaElementOffsetPtr(new SetWFAntennaElementOffset(x, y, z, yaw, pitch, roll, element));
    }

    SetWFAntennaElementOffsetPtr SetWFAntennaElementOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaElementOffset>(ptr);
    }

    bool SetWFAntennaElementOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string SetWFAntennaElementOffset::documentation() const { return Documentation; }


    int SetWFAntennaElementOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetWFAntennaElementOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetWFAntennaElementOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetWFAntennaElementOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetWFAntennaElementOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetWFAntennaElementOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetWFAntennaElementOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetWFAntennaElementOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetWFAntennaElementOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetWFAntennaElementOffset::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void SetWFAntennaElementOffset::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementOffset
///
#include "gen/GetWFAntennaElementOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementOffset::CmdName = "GetWFAntennaElementOffset";
    const char* const GetWFAntennaElementOffset::Documentation = "Get the WF antenna offset infos for this element.";

    REGISTER_COMMAND_FACTORY(GetWFAntennaElementOffset);


    GetWFAntennaElementOffset::GetWFAntennaElementOffset()
      : CommandBase(CmdName)
    {}

    GetWFAntennaElementOffset::GetWFAntennaElementOffset(int element)
      : CommandBase(CmdName)
    {

      setElement(element);
    }


    GetWFAntennaElementOffsetPtr GetWFAntennaElementOffset::create(int element)
    {
      return GetWFAntennaElementOffsetPtr(new GetWFAntennaElementOffset(element));
    }

    GetWFAntennaElementOffsetPtr GetWFAntennaElementOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementOffset>(ptr);
    }

    bool GetWFAntennaElementOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementOffset::documentation() const { return Documentation; }


    int GetWFAntennaElementOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetWFAntennaElementOffset::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementOffset::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementOffsetResult
///
#include "gen/GetWFAntennaElementOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementOffsetResult::CmdName = "GetWFAntennaElementOffsetResult";
    const char* const GetWFAntennaElementOffsetResult::Documentation = "Result of GetWFAntennaElementOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaElementOffsetResult);


    GetWFAntennaElementOffsetResult::GetWFAntennaElementOffsetResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaElementOffsetResult::GetWFAntennaElementOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, int element)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setElement(element);
    }


    GetWFAntennaElementOffsetResultPtr GetWFAntennaElementOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, int element)
    {
      return GetWFAntennaElementOffsetResultPtr(new GetWFAntennaElementOffsetResult(relatedCommand, x, y, z, yaw, pitch, roll, element));
    }

    GetWFAntennaElementOffsetResultPtr GetWFAntennaElementOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementOffsetResult>(ptr);
    }

    bool GetWFAntennaElementOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementOffsetResult::documentation() const { return Documentation; }


    double GetWFAntennaElementOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetWFAntennaElementOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetWFAntennaElementOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetWFAntennaElementOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetWFAntennaElementOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetWFAntennaElementOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetWFAntennaElementOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetWFAntennaElementOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetWFAntennaElementOffsetResult::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementOffsetResult::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaElementModel
///
#include "gen/SetWFAntennaElementModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaElementModel::CmdName = "SetWFAntennaElementModel";
    const char* const SetWFAntennaElementModel::Documentation = "Set WF Antenna model for this element";

    REGISTER_COMMAND_FACTORY(SetWFAntennaElementModel);


    SetWFAntennaElementModel::SetWFAntennaElementModel()
      : CommandBase(CmdName)
    {}

    SetWFAntennaElementModel::SetWFAntennaElementModel(const std::string& antennaModelName, int element)
      : CommandBase(CmdName)
    {

      setAntennaModelName(antennaModelName);
      setElement(element);
    }


    SetWFAntennaElementModelPtr SetWFAntennaElementModel::create(const std::string& antennaModelName, int element)
    {
      return SetWFAntennaElementModelPtr(new SetWFAntennaElementModel(antennaModelName, element));
    }

    SetWFAntennaElementModelPtr SetWFAntennaElementModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaElementModel>(ptr);
    }

    bool SetWFAntennaElementModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string SetWFAntennaElementModel::documentation() const { return Documentation; }


    int SetWFAntennaElementModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetWFAntennaElementModel::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void SetWFAntennaElementModel::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetWFAntennaElementModel::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void SetWFAntennaElementModel::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementModel
///
#include "gen/GetWFAntennaElementModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementModel::CmdName = "GetWFAntennaElementModel";
    const char* const GetWFAntennaElementModel::Documentation = "Get WF Antenna model for this element";

    REGISTER_COMMAND_FACTORY(GetWFAntennaElementModel);


    GetWFAntennaElementModel::GetWFAntennaElementModel()
      : CommandBase(CmdName)
    {}

    GetWFAntennaElementModel::GetWFAntennaElementModel(int element)
      : CommandBase(CmdName)
    {

      setElement(element);
    }


    GetWFAntennaElementModelPtr GetWFAntennaElementModel::create(int element)
    {
      return GetWFAntennaElementModelPtr(new GetWFAntennaElementModel(element));
    }

    GetWFAntennaElementModelPtr GetWFAntennaElementModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementModel>(ptr);
    }

    bool GetWFAntennaElementModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementModel::documentation() const { return Documentation; }


    int GetWFAntennaElementModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetWFAntennaElementModel::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementModel::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementModelResult
///
#include "gen/GetWFAntennaElementModelResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementModelResult::CmdName = "GetWFAntennaElementModelResult";
    const char* const GetWFAntennaElementModelResult::Documentation = "Result of GetWFAntennaElementModel";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaElementModelResult);


    GetWFAntennaElementModelResult::GetWFAntennaElementModelResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaElementModelResult::GetWFAntennaElementModelResult(CommandBasePtr relatedCommand, const std::string& antennaModelName, int element)
      : CommandResult(CmdName, relatedCommand)
    {

      setAntennaModelName(antennaModelName);
      setElement(element);
    }


    GetWFAntennaElementModelResultPtr GetWFAntennaElementModelResult::create(CommandBasePtr relatedCommand, const std::string& antennaModelName, int element)
    {
      return GetWFAntennaElementModelResultPtr(new GetWFAntennaElementModelResult(relatedCommand, antennaModelName, element));
    }

    GetWFAntennaElementModelResultPtr GetWFAntennaElementModelResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementModelResult>(ptr);
    }

    bool GetWFAntennaElementModelResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementModelResult::documentation() const { return Documentation; }


    std::string GetWFAntennaElementModelResult::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void GetWFAntennaElementModelResult::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetWFAntennaElementModelResult::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementModelResult::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaElementPhasePatternOffset
///
#include "gen/SetWFAntennaElementPhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaElementPhasePatternOffset::CmdName = "SetWFAntennaElementPhasePatternOffset";
    const char* const SetWFAntennaElementPhasePatternOffset::Documentation = "Set WF Antenna phase pattern offset (in rad) for this element";

    REGISTER_COMMAND_FACTORY(SetWFAntennaElementPhasePatternOffset);


    SetWFAntennaElementPhasePatternOffset::SetWFAntennaElementPhasePatternOffset()
      : CommandBase(CmdName)
    {}

    SetWFAntennaElementPhasePatternOffset::SetWFAntennaElementPhasePatternOffset(double phaseOffset, int element)
      : CommandBase(CmdName)
    {

      setPhaseOffset(phaseOffset);
      setElement(element);
    }


    SetWFAntennaElementPhasePatternOffsetPtr SetWFAntennaElementPhasePatternOffset::create(double phaseOffset, int element)
    {
      return SetWFAntennaElementPhasePatternOffsetPtr(new SetWFAntennaElementPhasePatternOffset(phaseOffset, element));
    }

    SetWFAntennaElementPhasePatternOffsetPtr SetWFAntennaElementPhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaElementPhasePatternOffset>(ptr);
    }

    bool SetWFAntennaElementPhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["PhaseOffset"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string SetWFAntennaElementPhasePatternOffset::documentation() const { return Documentation; }


    int SetWFAntennaElementPhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetWFAntennaElementPhasePatternOffset::phaseOffset() const
    {
      return parse_json<double>::parse(m_values["PhaseOffset"]);
    }

    void SetWFAntennaElementPhasePatternOffset::setPhaseOffset(double phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<double>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetWFAntennaElementPhasePatternOffset::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void SetWFAntennaElementPhasePatternOffset::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementPhasePatternOffset
///
#include "gen/GetWFAntennaElementPhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementPhasePatternOffset::CmdName = "GetWFAntennaElementPhasePatternOffset";
    const char* const GetWFAntennaElementPhasePatternOffset::Documentation = "Get WF Antenna phase pattern offset (in rad) for this element";

    REGISTER_COMMAND_FACTORY(GetWFAntennaElementPhasePatternOffset);


    GetWFAntennaElementPhasePatternOffset::GetWFAntennaElementPhasePatternOffset()
      : CommandBase(CmdName)
    {}

    GetWFAntennaElementPhasePatternOffset::GetWFAntennaElementPhasePatternOffset(int element)
      : CommandBase(CmdName)
    {

      setElement(element);
    }


    GetWFAntennaElementPhasePatternOffsetPtr GetWFAntennaElementPhasePatternOffset::create(int element)
    {
      return GetWFAntennaElementPhasePatternOffsetPtr(new GetWFAntennaElementPhasePatternOffset(element));
    }

    GetWFAntennaElementPhasePatternOffsetPtr GetWFAntennaElementPhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementPhasePatternOffset>(ptr);
    }

    bool GetWFAntennaElementPhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementPhasePatternOffset::documentation() const { return Documentation; }


    int GetWFAntennaElementPhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetWFAntennaElementPhasePatternOffset::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementPhasePatternOffset::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaElementPhasePatternOffsetResult
///
#include "gen/GetWFAntennaElementPhasePatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaElementPhasePatternOffsetResult::CmdName = "GetWFAntennaElementPhasePatternOffsetResult";
    const char* const GetWFAntennaElementPhasePatternOffsetResult::Documentation = "Result of GetWFAntennaElementPhasePatternOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaElementPhasePatternOffsetResult);


    GetWFAntennaElementPhasePatternOffsetResult::GetWFAntennaElementPhasePatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaElementPhasePatternOffsetResult::GetWFAntennaElementPhasePatternOffsetResult(CommandBasePtr relatedCommand, double phaseOffset, int element)
      : CommandResult(CmdName, relatedCommand)
    {

      setPhaseOffset(phaseOffset);
      setElement(element);
    }


    GetWFAntennaElementPhasePatternOffsetResultPtr GetWFAntennaElementPhasePatternOffsetResult::create(CommandBasePtr relatedCommand, double phaseOffset, int element)
    {
      return GetWFAntennaElementPhasePatternOffsetResultPtr(new GetWFAntennaElementPhasePatternOffsetResult(relatedCommand, phaseOffset, element));
    }

    GetWFAntennaElementPhasePatternOffsetResultPtr GetWFAntennaElementPhasePatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaElementPhasePatternOffsetResult>(ptr);
    }

    bool GetWFAntennaElementPhasePatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["PhaseOffset"])
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string GetWFAntennaElementPhasePatternOffsetResult::documentation() const { return Documentation; }


    double GetWFAntennaElementPhasePatternOffsetResult::phaseOffset() const
    {
      return parse_json<double>::parse(m_values["PhaseOffset"]);
    }

    void GetWFAntennaElementPhasePatternOffsetResult::setPhaseOffset(double phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<double>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetWFAntennaElementPhasePatternOffsetResult::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void GetWFAntennaElementPhasePatternOffsetResult::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaElementEnabled
///
#include "gen/SetWFAntennaElementEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaElementEnabled::CmdName = "SetWFAntennaElementEnabled";
    const char* const SetWFAntennaElementEnabled::Documentation = "Set WF antenna element enabled or disabled. A disabled antenna element is not simulated at all.";

    REGISTER_COMMAND_FACTORY(SetWFAntennaElementEnabled);


    SetWFAntennaElementEnabled::SetWFAntennaElementEnabled()
      : CommandBase(CmdName)
    {}

    SetWFAntennaElementEnabled::SetWFAntennaElementEnabled(int element, bool enabled)
      : CommandBase(CmdName)
    {

      setElement(element);
      setEnabled(enabled);
    }


    SetWFAntennaElementEnabledPtr SetWFAntennaElementEnabled::create(int element, bool enabled)
    {
      return SetWFAntennaElementEnabledPtr(new SetWFAntennaElementEnabled(element, enabled));
    }

    SetWFAntennaElementEnabledPtr SetWFAntennaElementEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaElementEnabled>(ptr);
    }

    bool SetWFAntennaElementEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string SetWFAntennaElementEnabled::documentation() const { return Documentation; }


    int SetWFAntennaElementEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetWFAntennaElementEnabled::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void SetWFAntennaElementEnabled::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetWFAntennaElementEnabled::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetWFAntennaElementEnabled::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsWFAntennaElementEnabled
///
#include "gen/IsWFAntennaElementEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsWFAntennaElementEnabled::CmdName = "IsWFAntennaElementEnabled";
    const char* const IsWFAntennaElementEnabled::Documentation = "Get whether an antenna element is enabled or disabled.";

    REGISTER_COMMAND_FACTORY(IsWFAntennaElementEnabled);


    IsWFAntennaElementEnabled::IsWFAntennaElementEnabled()
      : CommandBase(CmdName)
    {}

    IsWFAntennaElementEnabled::IsWFAntennaElementEnabled(int element)
      : CommandBase(CmdName)
    {

      setElement(element);
    }


    IsWFAntennaElementEnabledPtr IsWFAntennaElementEnabled::create(int element)
    {
      return IsWFAntennaElementEnabledPtr(new IsWFAntennaElementEnabled(element));
    }

    IsWFAntennaElementEnabledPtr IsWFAntennaElementEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsWFAntennaElementEnabled>(ptr);
    }

    bool IsWFAntennaElementEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
        ;

    }

    std::string IsWFAntennaElementEnabled::documentation() const { return Documentation; }


    int IsWFAntennaElementEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int IsWFAntennaElementEnabled::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void IsWFAntennaElementEnabled::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsWFAntennaElementEnabledResult
///
#include "gen/IsWFAntennaElementEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsWFAntennaElementEnabledResult::CmdName = "IsWFAntennaElementEnabledResult";
    const char* const IsWFAntennaElementEnabledResult::Documentation = "Result of IsWFAntennaElementEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsWFAntennaElementEnabledResult);


    IsWFAntennaElementEnabledResult::IsWFAntennaElementEnabledResult()
      : CommandResult(CmdName)
    {}

    IsWFAntennaElementEnabledResult::IsWFAntennaElementEnabledResult(CommandBasePtr relatedCommand, int element, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setElement(element);
      setEnabled(enabled);
    }


    IsWFAntennaElementEnabledResultPtr IsWFAntennaElementEnabledResult::create(CommandBasePtr relatedCommand, int element, bool enabled)
    {
      return IsWFAntennaElementEnabledResultPtr(new IsWFAntennaElementEnabledResult(relatedCommand, element, enabled));
    }

    IsWFAntennaElementEnabledResultPtr IsWFAntennaElementEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsWFAntennaElementEnabledResult>(ptr);
    }

    bool IsWFAntennaElementEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Element"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsWFAntennaElementEnabledResult::documentation() const { return Documentation; }


    int IsWFAntennaElementEnabledResult::element() const
    {
      return parse_json<int>::parse(m_values["Element"]);
    }

    void IsWFAntennaElementEnabledResult::setElement(int element)
    {
      m_values.AddMember("Element", parse_json<int>::format(element, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsWFAntennaElementEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsWFAntennaElementEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSVAntennaNames
///
#include "gen/GetAllSVAntennaNames.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSVAntennaNames::CmdName = "GetAllSVAntennaNames";
    const char* const GetAllSVAntennaNames::Documentation = "Get a list of all space vehicle antenna names.";

    REGISTER_COMMAND_FACTORY(GetAllSVAntennaNames);


    GetAllSVAntennaNames::GetAllSVAntennaNames()
      : CommandBase(CmdName)
    {}

    GetAllSVAntennaNames::GetAllSVAntennaNames(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetAllSVAntennaNamesPtr GetAllSVAntennaNames::create(const std::string& system)
    {
      return GetAllSVAntennaNamesPtr(new GetAllSVAntennaNames(system));
    }

    GetAllSVAntennaNamesPtr GetAllSVAntennaNames::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSVAntennaNames>(ptr);
    }

    bool GetAllSVAntennaNames::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetAllSVAntennaNames::documentation() const { return Documentation; }


    int GetAllSVAntennaNames::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSVAntennaNames::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSVAntennaNames::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSVAntennaNamesResult
///
#include "gen/GetAllSVAntennaNamesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSVAntennaNamesResult::CmdName = "GetAllSVAntennaNamesResult";
    const char* const GetAllSVAntennaNamesResult::Documentation = "Result of GetAllSVNames";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllSVAntennaNamesResult);


    GetAllSVAntennaNamesResult::GetAllSVAntennaNamesResult()
      : CommandResult(CmdName)
    {}

    GetAllSVAntennaNamesResult::GetAllSVAntennaNamesResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<std::string>& antennaNames)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setAntennaNames(antennaNames);
    }


    GetAllSVAntennaNamesResultPtr GetAllSVAntennaNamesResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<std::string>& antennaNames)
    {
      return GetAllSVAntennaNamesResultPtr(new GetAllSVAntennaNamesResult(relatedCommand, system, antennaNames));
    }

    GetAllSVAntennaNamesResultPtr GetAllSVAntennaNamesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSVAntennaNamesResult>(ptr);
    }

    bool GetAllSVAntennaNamesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaNames"])
        ;

    }

    std::string GetAllSVAntennaNamesResult::documentation() const { return Documentation; }


    std::string GetAllSVAntennaNamesResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSVAntennaNamesResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetAllSVAntennaNamesResult::antennaNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaNames"]);
    }

    void GetAllSVAntennaNamesResult::setAntennaNames(const std::vector<std::string>& antennaNames)
    {
      m_values.AddMember("AntennaNames", parse_json<std::vector<std::string>>::format(antennaNames, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddSVGainPatternOffset
///
#include "gen/AddSVGainPatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddSVGainPatternOffset::CmdName = "AddSVGainPatternOffset";
    const char* const AddSVGainPatternOffset::Documentation = "Add an offset (in dB) for all values of the pattern.";

    REGISTER_COMMAND_FACTORY(AddSVGainPatternOffset);


    AddSVGainPatternOffset::AddSVGainPatternOffset()
      : CommandBase(CmdName)
    {}

    AddSVGainPatternOffset::AddSVGainPatternOffset(const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    AddSVGainPatternOffsetPtr AddSVGainPatternOffset::create(const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return AddSVGainPatternOffsetPtr(new AddSVGainPatternOffset(band, system, offset, antennaName));
    }

    AddSVGainPatternOffsetPtr AddSVGainPatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddSVGainPatternOffset>(ptr);
    }

    bool AddSVGainPatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string AddSVGainPatternOffset::documentation() const { return Documentation; }


    int AddSVGainPatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand AddSVGainPatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void AddSVGainPatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddSVGainPatternOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void AddSVGainPatternOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddSVGainPatternOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void AddSVGainPatternOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> AddSVGainPatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void AddSVGainPatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVGainPatternOffset
///
#include "gen/GetSVGainPatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVGainPatternOffset::CmdName = "GetSVGainPatternOffset";
    const char* const GetSVGainPatternOffset::Documentation = "Get the offset (in dB) for the antenna gain pattern of the band.";

    REGISTER_COMMAND_FACTORY(GetSVGainPatternOffset);


    GetSVGainPatternOffset::GetSVGainPatternOffset()
      : CommandBase(CmdName)
    {}

    GetSVGainPatternOffset::GetSVGainPatternOffset(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setAntennaName(antennaName);
    }


    GetSVGainPatternOffsetPtr GetSVGainPatternOffset::create(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& antennaName)
    {
      return GetSVGainPatternOffsetPtr(new GetSVGainPatternOffset(band, system, antennaName));
    }

    GetSVGainPatternOffsetPtr GetSVGainPatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVGainPatternOffset>(ptr);
    }

    bool GetSVGainPatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetSVGainPatternOffset::documentation() const { return Documentation; }


    int GetSVGainPatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetSVGainPatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVGainPatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVGainPatternOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVGainPatternOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVGainPatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetSVGainPatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVGainPatternOffsetResult
///
#include "gen/GetSVGainPatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVGainPatternOffsetResult::CmdName = "GetSVGainPatternOffsetResult";
    const char* const GetSVGainPatternOffsetResult::Documentation = "Result of GetSVGainPatternOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVGainPatternOffsetResult);


    GetSVGainPatternOffsetResult::GetSVGainPatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSVGainPatternOffsetResult::GetSVGainPatternOffsetResult(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setSystem(system);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    GetSVGainPatternOffsetResultPtr GetSVGainPatternOffsetResult::create(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return GetSVGainPatternOffsetResultPtr(new GetSVGainPatternOffsetResult(relatedCommand, band, system, offset, antennaName));
    }

    GetSVGainPatternOffsetResultPtr GetSVGainPatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVGainPatternOffsetResult>(ptr);
    }

    bool GetSVGainPatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetSVGainPatternOffsetResult::documentation() const { return Documentation; }


    Sdx::GNSSBand GetSVGainPatternOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVGainPatternOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVGainPatternOffsetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVGainPatternOffsetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSVGainPatternOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetSVGainPatternOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVGainPatternOffsetResult::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetSVGainPatternOffsetResult::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddSVPhasePatternOffset
///
#include "gen/AddSVPhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddSVPhasePatternOffset::CmdName = "AddSVPhasePatternOffset";
    const char* const AddSVPhasePatternOffset::Documentation = "Add an offset (in rad) for all values of the phase pattern.";

    REGISTER_COMMAND_FACTORY(AddSVPhasePatternOffset);


    AddSVPhasePatternOffset::AddSVPhasePatternOffset()
      : CommandBase(CmdName)
    {}

    AddSVPhasePatternOffset::AddSVPhasePatternOffset(const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    AddSVPhasePatternOffsetPtr AddSVPhasePatternOffset::create(const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return AddSVPhasePatternOffsetPtr(new AddSVPhasePatternOffset(band, system, offset, antennaName));
    }

    AddSVPhasePatternOffsetPtr AddSVPhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddSVPhasePatternOffset>(ptr);
    }

    bool AddSVPhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string AddSVPhasePatternOffset::documentation() const { return Documentation; }


    int AddSVPhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand AddSVPhasePatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void AddSVPhasePatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddSVPhasePatternOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void AddSVPhasePatternOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddSVPhasePatternOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void AddSVPhasePatternOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> AddSVPhasePatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void AddSVPhasePatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVPhasePatternOffset
///
#include "gen/GetSVPhasePatternOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVPhasePatternOffset::CmdName = "GetSVPhasePatternOffset";
    const char* const GetSVPhasePatternOffset::Documentation = "Get the offset (in rad) for the antenna phase pattern of the band.";

    REGISTER_COMMAND_FACTORY(GetSVPhasePatternOffset);


    GetSVPhasePatternOffset::GetSVPhasePatternOffset()
      : CommandBase(CmdName)
    {}

    GetSVPhasePatternOffset::GetSVPhasePatternOffset(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& antennaName)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setAntennaName(antennaName);
    }


    GetSVPhasePatternOffsetPtr GetSVPhasePatternOffset::create(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& antennaName)
    {
      return GetSVPhasePatternOffsetPtr(new GetSVPhasePatternOffset(band, system, antennaName));
    }

    GetSVPhasePatternOffsetPtr GetSVPhasePatternOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVPhasePatternOffset>(ptr);
    }

    bool GetSVPhasePatternOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetSVPhasePatternOffset::documentation() const { return Documentation; }


    int GetSVPhasePatternOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetSVPhasePatternOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVPhasePatternOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVPhasePatternOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVPhasePatternOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVPhasePatternOffset::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetSVPhasePatternOffset::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVPhasePatternOffsetResult
///
#include "gen/GetSVPhasePatternOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVPhasePatternOffsetResult::CmdName = "GetSVPhasePatternOffsetResult";
    const char* const GetSVPhasePatternOffsetResult::Documentation = "Result of GetSVPhasePatternOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVPhasePatternOffsetResult);


    GetSVPhasePatternOffsetResult::GetSVPhasePatternOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSVPhasePatternOffsetResult::GetSVPhasePatternOffsetResult(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setSystem(system);
      setOffset(offset);
      setAntennaName(antennaName);
    }


    GetSVPhasePatternOffsetResultPtr GetSVPhasePatternOffsetResult::create(CommandBasePtr relatedCommand, const Sdx::GNSSBand& band, const std::string& system, double offset, const Sdx::optional<std::string>& antennaName)
    {
      return GetSVPhasePatternOffsetResultPtr(new GetSVPhasePatternOffsetResult(relatedCommand, band, system, offset, antennaName));
    }

    GetSVPhasePatternOffsetResultPtr GetSVPhasePatternOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVPhasePatternOffsetResult>(ptr);
    }

    bool GetSVPhasePatternOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["AntennaName"])
        ;

    }

    std::string GetSVPhasePatternOffsetResult::documentation() const { return Documentation; }


    Sdx::GNSSBand GetSVPhasePatternOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVPhasePatternOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVPhasePatternOffsetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVPhasePatternOffsetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSVPhasePatternOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetSVPhasePatternOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVPhasePatternOffsetResult::antennaName() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["AntennaName"]);
    }

    void GetSVPhasePatternOffsetResult::setAntennaName(const Sdx::optional<std::string>& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<Sdx::optional<std::string>>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaGain
///
#include "gen/SetSVAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaGain::CmdName = "SetSVAntennaGain";
    const char* const SetSVAntennaGain::Documentation = "Set space vehicle gain antenna pattern. If no name is specified, the command is aplied to Basic SV Antenna.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaGain);


    SetSVAntennaGain::SetSVAntennaGain()
      : CommandBase(CmdName)
    {}

    SetSVAntennaGain::SetSVAntennaGain(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setGain(gain);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    SetSVAntennaGainPtr SetSVAntennaGain::create(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return SetSVAntennaGainPtr(new SetSVAntennaGain(gain, type, band, system, name));
    }

    SetSVAntennaGainPtr SetSVAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaGain>(ptr);
    }

    bool SetSVAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetSVAntennaGain::documentation() const { return Documentation; }


    int SetSVAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetSVAntennaGain::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void SetSVAntennaGain::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSVAntennaGain::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSVAntennaGain::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetSVAntennaGain::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetSVAntennaGain::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaGain::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaGain::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetSVAntennaGain::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetSVAntennaGain::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaGain
///
#include "gen/GetSVAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaGain::CmdName = "GetSVAntennaGain";
    const char* const GetSVAntennaGain::Documentation = "Get space vehicle gain antenna pattern. If no name is specified, the command is aplied to Basic SV Antenna.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaGain);


    GetSVAntennaGain::GetSVAntennaGain()
      : CommandBase(CmdName)
    {}

    GetSVAntennaGain::GetSVAntennaGain(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setName(name);
    }


    GetSVAntennaGainPtr GetSVAntennaGain::create(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return GetSVAntennaGainPtr(new GetSVAntennaGain(band, system, name));
    }

    GetSVAntennaGainPtr GetSVAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaGain>(ptr);
    }

    bool GetSVAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetSVAntennaGain::documentation() const { return Documentation; }


    int GetSVAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetSVAntennaGain::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVAntennaGain::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaGain::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaGain::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVAntennaGain::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetSVAntennaGain::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaGainResult
///
#include "gen/GetSVAntennaGainResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaGainResult::CmdName = "GetSVAntennaGainResult";
    const char* const GetSVAntennaGainResult::Documentation = "Result of GetSVAntennaGain";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaGainResult);


    GetSVAntennaGainResult::GetSVAntennaGainResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaGainResult::GetSVAntennaGainResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    GetSVAntennaGainResultPtr GetSVAntennaGainResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return GetSVAntennaGainResultPtr(new GetSVAntennaGainResult(relatedCommand, gain, type, band, system, name));
    }

    GetSVAntennaGainResultPtr GetSVAntennaGainResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaGainResult>(ptr);
    }

    bool GetSVAntennaGainResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetSVAntennaGainResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetSVAntennaGainResult::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void GetSVAntennaGainResult::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetSVAntennaGainResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetSVAntennaGainResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand GetSVAntennaGainResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVAntennaGainResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaGainResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaGainResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVAntennaGainResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetSVAntennaGainResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaPhaseOffset
///
#include "gen/SetSVAntennaPhaseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaPhaseOffset::CmdName = "SetSVAntennaPhaseOffset";
    const char* const SetSVAntennaPhaseOffset::Documentation = "Set space vehicle phase offset antenna pattern. If no name is specified, the command is aplied to Basic Vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaPhaseOffset);


    SetSVAntennaPhaseOffset::SetSVAntennaPhaseOffset()
      : CommandBase(CmdName)
    {}

    SetSVAntennaPhaseOffset::SetSVAntennaPhaseOffset(const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setPhaseOffset(phaseOffset);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    SetSVAntennaPhaseOffsetPtr SetSVAntennaPhaseOffset::create(const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return SetSVAntennaPhaseOffsetPtr(new SetSVAntennaPhaseOffset(phaseOffset, type, band, system, name));
    }

    SetSVAntennaPhaseOffsetPtr SetSVAntennaPhaseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaPhaseOffset>(ptr);
    }

    bool SetSVAntennaPhaseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffset"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetSVAntennaPhaseOffset::documentation() const { return Documentation; }


    int SetSVAntennaPhaseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetSVAntennaPhaseOffset::phaseOffset() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffset"]);
    }

    void SetSVAntennaPhaseOffset::setPhaseOffset(const std::vector<std::vector<double>>& phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<std::vector<std::vector<double>>>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSVAntennaPhaseOffset::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSVAntennaPhaseOffset::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetSVAntennaPhaseOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetSVAntennaPhaseOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaPhaseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaPhaseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetSVAntennaPhaseOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetSVAntennaPhaseOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaPhaseOffset
///
#include "gen/GetSVAntennaPhaseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaPhaseOffset::CmdName = "GetSVAntennaPhaseOffset";
    const char* const GetSVAntennaPhaseOffset::Documentation = "Get space vehicle phase offset antenna pattern. If no name is specified, the command is aplied to Basic Vehicle Antenna.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaPhaseOffset);


    GetSVAntennaPhaseOffset::GetSVAntennaPhaseOffset()
      : CommandBase(CmdName)
    {}

    GetSVAntennaPhaseOffset::GetSVAntennaPhaseOffset(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setBand(band);
      setSystem(system);
      setName(name);
    }


    GetSVAntennaPhaseOffsetPtr GetSVAntennaPhaseOffset::create(const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return GetSVAntennaPhaseOffsetPtr(new GetSVAntennaPhaseOffset(band, system, name));
    }

    GetSVAntennaPhaseOffsetPtr GetSVAntennaPhaseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaPhaseOffset>(ptr);
    }

    bool GetSVAntennaPhaseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetSVAntennaPhaseOffset::documentation() const { return Documentation; }


    int GetSVAntennaPhaseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::GNSSBand GetSVAntennaPhaseOffset::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVAntennaPhaseOffset::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaPhaseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaPhaseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVAntennaPhaseOffset::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetSVAntennaPhaseOffset::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaPhaseOffsetResult
///
#include "gen/GetSVAntennaPhaseOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaPhaseOffsetResult::CmdName = "GetSVAntennaPhaseOffsetResult";
    const char* const GetSVAntennaPhaseOffsetResult::Documentation = "Result of GetSVAntennaPhaseOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaPhaseOffsetResult);


    GetSVAntennaPhaseOffsetResult::GetSVAntennaPhaseOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaPhaseOffsetResult::GetSVAntennaPhaseOffsetResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandResult(CmdName, relatedCommand)
    {

      setPhaseOffset(phaseOffset);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    GetSVAntennaPhaseOffsetResultPtr GetSVAntennaPhaseOffsetResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& phaseOffset, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return GetSVAntennaPhaseOffsetResultPtr(new GetSVAntennaPhaseOffsetResult(relatedCommand, phaseOffset, type, band, system, name));
    }

    GetSVAntennaPhaseOffsetResultPtr GetSVAntennaPhaseOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaPhaseOffsetResult>(ptr);
    }

    bool GetSVAntennaPhaseOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["PhaseOffset"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string GetSVAntennaPhaseOffsetResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetSVAntennaPhaseOffsetResult::phaseOffset() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["PhaseOffset"]);
    }

    void GetSVAntennaPhaseOffsetResult::setPhaseOffset(const std::vector<std::vector<double>>& phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<std::vector<std::vector<double>>>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetSVAntennaPhaseOffsetResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetSVAntennaPhaseOffsetResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand GetSVAntennaPhaseOffsetResult::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void GetSVAntennaPhaseOffsetResult::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaPhaseOffsetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaPhaseOffsetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetSVAntennaPhaseOffsetResult::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void GetSVAntennaPhaseOffsetResult::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaGainCSV
///
#include "gen/SetSVAntennaGainCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaGainCSV::CmdName = "SetSVAntennaGainCSV";
    const char* const SetSVAntennaGainCSV::Documentation = "Set space vehicle gain antenna pattern from a CSV file. If no name is specified, the command is aplied to Basic SV Antenna.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaGainCSV);


    SetSVAntennaGainCSV::SetSVAntennaGainCSV()
      : CommandBase(CmdName)
    {}

    SetSVAntennaGainCSV::SetSVAntennaGainCSV(const std::string& filePath, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    SetSVAntennaGainCSVPtr SetSVAntennaGainCSV::create(const std::string& filePath, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return SetSVAntennaGainCSVPtr(new SetSVAntennaGainCSV(filePath, type, band, system, name));
    }

    SetSVAntennaGainCSVPtr SetSVAntennaGainCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaGainCSV>(ptr);
    }

    bool SetSVAntennaGainCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetSVAntennaGainCSV::documentation() const { return Documentation; }


    int SetSVAntennaGainCSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVAntennaGainCSV::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void SetSVAntennaGainCSV::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSVAntennaGainCSV::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSVAntennaGainCSV::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetSVAntennaGainCSV::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetSVAntennaGainCSV::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaGainCSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaGainCSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetSVAntennaGainCSV::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetSVAntennaGainCSV::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaPhaseOffsetCSV
///
#include "gen/SetSVAntennaPhaseOffsetCSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaPhaseOffsetCSV::CmdName = "SetSVAntennaPhaseOffsetCSV";
    const char* const SetSVAntennaPhaseOffsetCSV::Documentation = "Set space vehicle phase offset antenna pattern from a CSV file. If no name is specified, the command is aplied to Basic SV Antenna.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaPhaseOffsetCSV);


    SetSVAntennaPhaseOffsetCSV::SetSVAntennaPhaseOffsetCSV()
      : CommandBase(CmdName)
    {}

    SetSVAntennaPhaseOffsetCSV::SetSVAntennaPhaseOffsetCSV(const std::string& filePath, const Sdx::AntennaPatternFileType& fileFormat, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setFileFormat(fileFormat);
      setType(type);
      setBand(band);
      setSystem(system);
      setName(name);
    }


    SetSVAntennaPhaseOffsetCSVPtr SetSVAntennaPhaseOffsetCSV::create(const std::string& filePath, const Sdx::AntennaPatternFileType& fileFormat, const Sdx::AntennaPatternType& type, const Sdx::GNSSBand& band, const std::string& system, const Sdx::optional<std::string>& name)
    {
      return SetSVAntennaPhaseOffsetCSVPtr(new SetSVAntennaPhaseOffsetCSV(filePath, fileFormat, type, band, system, name));
    }

    SetSVAntennaPhaseOffsetCSVPtr SetSVAntennaPhaseOffsetCSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaPhaseOffsetCSV>(ptr);
    }

    bool SetSVAntennaPhaseOffsetCSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<Sdx::AntennaPatternFileType>::is_valid(m_values["FileFormat"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<Sdx::GNSSBand>::is_valid(m_values["Band"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["Name"])
        ;

    }

    std::string SetSVAntennaPhaseOffsetCSV::documentation() const { return Documentation; }


    int SetSVAntennaPhaseOffsetCSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVAntennaPhaseOffsetCSV::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternFileType SetSVAntennaPhaseOffsetCSV::fileFormat() const
    {
      return parse_json<Sdx::AntennaPatternFileType>::parse(m_values["FileFormat"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setFileFormat(const Sdx::AntennaPatternFileType& fileFormat)
    {
      m_values.AddMember("FileFormat", parse_json<Sdx::AntennaPatternFileType>::format(fileFormat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSVAntennaPhaseOffsetCSV::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GNSSBand SetSVAntennaPhaseOffsetCSV::band() const
    {
      return parse_json<Sdx::GNSSBand>::parse(m_values["Band"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setBand(const Sdx::GNSSBand& band)
    {
      m_values.AddMember("Band", parse_json<Sdx::GNSSBand>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaPhaseOffsetCSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetSVAntennaPhaseOffsetCSV::name() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["Name"]);
    }

    void SetSVAntennaPhaseOffsetCSV::setName(const Sdx::optional<std::string>& name)
    {
      m_values.AddMember("Name", parse_json<Sdx::optional<std::string>>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddEmptySVAntennaModel
///
#include "gen/AddEmptySVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddEmptySVAntennaModel::CmdName = "AddEmptySVAntennaModel";
    const char* const AddEmptySVAntennaModel::Documentation = "Create an empty space vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(AddEmptySVAntennaModel);


    AddEmptySVAntennaModel::AddEmptySVAntennaModel()
      : CommandBase(CmdName)
    {}

    AddEmptySVAntennaModel::AddEmptySVAntennaModel(const std::string& name, const std::string& system)
      : CommandBase(CmdName)
    {

      setName(name);
      setSystem(system);
    }


    AddEmptySVAntennaModelPtr AddEmptySVAntennaModel::create(const std::string& name, const std::string& system)
    {
      return AddEmptySVAntennaModelPtr(new AddEmptySVAntennaModel(name, system));
    }

    AddEmptySVAntennaModelPtr AddEmptySVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddEmptySVAntennaModel>(ptr);
    }

    bool AddEmptySVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string AddEmptySVAntennaModel::documentation() const { return Documentation; }


    int AddEmptySVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddEmptySVAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void AddEmptySVAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddEmptySVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void AddEmptySVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of DeleteSVAntennaModel
///
#include "gen/DeleteSVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const DeleteSVAntennaModel::CmdName = "DeleteSVAntennaModel";
    const char* const DeleteSVAntennaModel::Documentation = "Delete a space vehicle antenna model. The default SV antenna model can't be deleted.";

    REGISTER_COMMAND_FACTORY(DeleteSVAntennaModel);


    DeleteSVAntennaModel::DeleteSVAntennaModel()
      : CommandBase(CmdName)
    {}

    DeleteSVAntennaModel::DeleteSVAntennaModel(const std::string& name, const std::string& system)
      : CommandBase(CmdName)
    {

      setName(name);
      setSystem(system);
    }


    DeleteSVAntennaModelPtr DeleteSVAntennaModel::create(const std::string& name, const std::string& system)
    {
      return DeleteSVAntennaModelPtr(new DeleteSVAntennaModel(name, system));
    }

    DeleteSVAntennaModelPtr DeleteSVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<DeleteSVAntennaModel>(ptr);
    }

    bool DeleteSVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string DeleteSVAntennaModel::documentation() const { return Documentation; }


    int DeleteSVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string DeleteSVAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void DeleteSVAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string DeleteSVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void DeleteSVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RenameSVAntennaModel
///
#include "gen/RenameSVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RenameSVAntennaModel::CmdName = "RenameSVAntennaModel";
    const char* const RenameSVAntennaModel::Documentation = "Rename a space vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(RenameSVAntennaModel);


    RenameSVAntennaModel::RenameSVAntennaModel()
      : CommandBase(CmdName)
    {}

    RenameSVAntennaModel::RenameSVAntennaModel(const std::string& name, const std::string& newName, const std::string& system)
      : CommandBase(CmdName)
    {

      setName(name);
      setNewName(newName);
      setSystem(system);
    }


    RenameSVAntennaModelPtr RenameSVAntennaModel::create(const std::string& name, const std::string& newName, const std::string& system)
    {
      return RenameSVAntennaModelPtr(new RenameSVAntennaModel(name, newName, system));
    }

    RenameSVAntennaModelPtr RenameSVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RenameSVAntennaModel>(ptr);
    }

    bool RenameSVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["NewName"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RenameSVAntennaModel::documentation() const { return Documentation; }


    int RenameSVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RenameSVAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void RenameSVAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameSVAntennaModel::newName() const
    {
      return parse_json<std::string>::parse(m_values["NewName"]);
    }

    void RenameSVAntennaModel::setNewName(const std::string& newName)
    {
      m_values.AddMember("NewName", parse_json<std::string>::format(newName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameSVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RenameSVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CopySVAntennaModel
///
#include "gen/CopySVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CopySVAntennaModel::CmdName = "CopySVAntennaModel";
    const char* const CopySVAntennaModel::Documentation = "Copy a space vehicle antenna model.";

    REGISTER_COMMAND_FACTORY(CopySVAntennaModel);


    CopySVAntennaModel::CopySVAntennaModel()
      : CommandBase(CmdName)
    {}

    CopySVAntennaModel::CopySVAntennaModel(const std::string& name, const std::string& copyName, const std::string& system)
      : CommandBase(CmdName)
    {

      setName(name);
      setCopyName(copyName);
      setSystem(system);
    }


    CopySVAntennaModelPtr CopySVAntennaModel::create(const std::string& name, const std::string& copyName, const std::string& system)
    {
      return CopySVAntennaModelPtr(new CopySVAntennaModel(name, copyName, system));
    }

    CopySVAntennaModelPtr CopySVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CopySVAntennaModel>(ptr);
    }

    bool CopySVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["CopyName"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string CopySVAntennaModel::documentation() const { return Documentation; }


    int CopySVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string CopySVAntennaModel::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void CopySVAntennaModel::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string CopySVAntennaModel::copyName() const
    {
      return parse_json<std::string>::parse(m_values["CopyName"]);
    }

    void CopySVAntennaModel::setCopyName(const std::string& copyName)
    {
      m_values.AddMember("CopyName", parse_json<std::string>::format(copyName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string CopySVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void CopySVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportSVAntennaModel
///
#include "gen/ImportSVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportSVAntennaModel::CmdName = "ImportSVAntennaModel";
    const char* const ImportSVAntennaModel::Documentation = "Import a space vehicle antenna model from a XML file.";

    REGISTER_COMMAND_FACTORY(ImportSVAntennaModel);


    ImportSVAntennaModel::ImportSVAntennaModel()
      : CommandBase(CmdName)
    {}

    ImportSVAntennaModel::ImportSVAntennaModel(const std::string& filePath, const std::string& system)
      : CommandBase(CmdName)
    {

      setFilePath(filePath);
      setSystem(system);
    }


    ImportSVAntennaModelPtr ImportSVAntennaModel::create(const std::string& filePath, const std::string& system)
    {
      return ImportSVAntennaModelPtr(new ImportSVAntennaModel(filePath, system));
    }

    ImportSVAntennaModelPtr ImportSVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportSVAntennaModel>(ptr);
    }

    bool ImportSVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string ImportSVAntennaModel::documentation() const { return Documentation; }


    int ImportSVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportSVAntennaModel::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void ImportSVAntennaModel::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportSVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ImportSVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportSVAntennaModel
///
#include "gen/ExportSVAntennaModel.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportSVAntennaModel::CmdName = "ExportSVAntennaModel";
    const char* const ExportSVAntennaModel::Documentation = "Export a space vehicle antenna model in a XML file.";

    REGISTER_COMMAND_FACTORY(ExportSVAntennaModel);


    ExportSVAntennaModel::ExportSVAntennaModel()
      : CommandBase(CmdName)
    {}

    ExportSVAntennaModel::ExportSVAntennaModel(const std::string& antennaName, const std::string& system, const std::string& filePath, bool overwriting)
      : CommandBase(CmdName)
    {

      setAntennaName(antennaName);
      setSystem(system);
      setFilePath(filePath);
      setOverwriting(overwriting);
    }


    ExportSVAntennaModelPtr ExportSVAntennaModel::create(const std::string& antennaName, const std::string& system, const std::string& filePath, bool overwriting)
    {
      return ExportSVAntennaModelPtr(new ExportSVAntennaModel(antennaName, system, filePath, overwriting));
    }

    ExportSVAntennaModelPtr ExportSVAntennaModel::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportSVAntennaModel>(ptr);
    }

    bool ExportSVAntennaModel::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["AntennaName"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["FilePath"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
        ;

    }

    std::string ExportSVAntennaModel::documentation() const { return Documentation; }


    int ExportSVAntennaModel::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ExportSVAntennaModel::antennaName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaName"]);
    }

    void ExportSVAntennaModel::setAntennaName(const std::string& antennaName)
    {
      m_values.AddMember("AntennaName", parse_json<std::string>::format(antennaName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportSVAntennaModel::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ExportSVAntennaModel::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportSVAntennaModel::filePath() const
    {
      return parse_json<std::string>::parse(m_values["FilePath"]);
    }

    void ExportSVAntennaModel::setFilePath(const std::string& filePath)
    {
      m_values.AddMember("FilePath", parse_json<std::string>::format(filePath, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ExportSVAntennaModel::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportSVAntennaModel::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaModelForSV
///
#include "gen/SetSVAntennaModelForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaModelForSV::CmdName = "SetSVAntennaModelForSV";
    const char* const SetSVAntennaModelForSV::Documentation = "Set the antenna model used by the SV.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaModelForSV);


    SetSVAntennaModelForSV::SetSVAntennaModelForSV()
      : CommandBase(CmdName)
    {}

    SetSVAntennaModelForSV::SetSVAntennaModelForSV(const std::string& system, int svId, const std::string& antennaModelName)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setAntennaModelName(antennaModelName);
    }


    SetSVAntennaModelForSVPtr SetSVAntennaModelForSV::create(const std::string& system, int svId, const std::string& antennaModelName)
    {
      return SetSVAntennaModelForSVPtr(new SetSVAntennaModelForSV(system, svId, antennaModelName));
    }

    SetSVAntennaModelForSVPtr SetSVAntennaModelForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaModelForSV>(ptr);
    }

    bool SetSVAntennaModelForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
        ;

    }

    std::string SetSVAntennaModelForSV::documentation() const { return Documentation; }


    int SetSVAntennaModelForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVAntennaModelForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaModelForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSVAntennaModelForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSVAntennaModelForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaModelForSV::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void SetSVAntennaModelForSV::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForSV
///
#include "gen/GetSVAntennaModelForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForSV::CmdName = "GetSVAntennaModelForSV";
    const char* const GetSVAntennaModelForSV::Documentation = "Get the antenna model used by the SV.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaModelForSV);


    GetSVAntennaModelForSV::GetSVAntennaModelForSV()
      : CommandBase(CmdName)
    {}

    GetSVAntennaModelForSV::GetSVAntennaModelForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetSVAntennaModelForSVPtr GetSVAntennaModelForSV::create(const std::string& system, int svId)
    {
      return GetSVAntennaModelForSVPtr(new GetSVAntennaModelForSV(system, svId));
    }

    GetSVAntennaModelForSVPtr GetSVAntennaModelForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForSV>(ptr);
    }

    bool GetSVAntennaModelForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetSVAntennaModelForSV::documentation() const { return Documentation; }


    int GetSVAntennaModelForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSVAntennaModelForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVAntennaModelForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSVAntennaModelForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForSVResult
///
#include "gen/GetSVAntennaModelForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForSVResult::CmdName = "GetSVAntennaModelForSVResult";
    const char* const GetSVAntennaModelForSVResult::Documentation = "Result of GetSVAntennaModelForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaModelForSVResult);


    GetSVAntennaModelForSVResult::GetSVAntennaModelForSVResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaModelForSVResult::GetSVAntennaModelForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::string& antennaModelName)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setAntennaModelName(antennaModelName);
    }


    GetSVAntennaModelForSVResultPtr GetSVAntennaModelForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::string& antennaModelName)
    {
      return GetSVAntennaModelForSVResultPtr(new GetSVAntennaModelForSVResult(relatedCommand, system, svId, antennaModelName));
    }

    GetSVAntennaModelForSVResultPtr GetSVAntennaModelForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForSVResult>(ptr);
    }

    bool GetSVAntennaModelForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
        ;

    }

    std::string GetSVAntennaModelForSVResult::documentation() const { return Documentation; }


    std::string GetSVAntennaModelForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVAntennaModelForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSVAntennaModelForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaModelForSVResult::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void GetSVAntennaModelForSVResult::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaModelForEachSV
///
#include "gen/SetSVAntennaModelForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaModelForEachSV::CmdName = "SetSVAntennaModelForEachSV";
    const char* const SetSVAntennaModelForEachSV::Documentation = "Set the antenna model for all satellites.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaModelForEachSV);


    SetSVAntennaModelForEachSV::SetSVAntennaModelForEachSV()
      : CommandBase(CmdName)
    {}

    SetSVAntennaModelForEachSV::SetSVAntennaModelForEachSV(const std::string& system, const std::vector<std::string>& antennaModelNames)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setAntennaModelNames(antennaModelNames);
    }


    SetSVAntennaModelForEachSVPtr SetSVAntennaModelForEachSV::create(const std::string& system, const std::vector<std::string>& antennaModelNames)
    {
      return SetSVAntennaModelForEachSVPtr(new SetSVAntennaModelForEachSV(system, antennaModelNames));
    }

    SetSVAntennaModelForEachSVPtr SetSVAntennaModelForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaModelForEachSV>(ptr);
    }

    bool SetSVAntennaModelForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaModelNames"])
        ;

    }

    std::string SetSVAntennaModelForEachSV::documentation() const { return Documentation; }


    int SetSVAntennaModelForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVAntennaModelForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaModelForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> SetSVAntennaModelForEachSV::antennaModelNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaModelNames"]);
    }

    void SetSVAntennaModelForEachSV::setAntennaModelNames(const std::vector<std::string>& antennaModelNames)
    {
      m_values.AddMember("AntennaModelNames", parse_json<std::vector<std::string>>::format(antennaModelNames, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForEachSV
///
#include "gen/GetSVAntennaModelForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForEachSV::CmdName = "GetSVAntennaModelForEachSV";
    const char* const GetSVAntennaModelForEachSV::Documentation = "Get the antenna model for all satellites.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaModelForEachSV);


    GetSVAntennaModelForEachSV::GetSVAntennaModelForEachSV()
      : CommandBase(CmdName)
    {}

    GetSVAntennaModelForEachSV::GetSVAntennaModelForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetSVAntennaModelForEachSVPtr GetSVAntennaModelForEachSV::create(const std::string& system)
    {
      return GetSVAntennaModelForEachSVPtr(new GetSVAntennaModelForEachSV(system));
    }

    GetSVAntennaModelForEachSVPtr GetSVAntennaModelForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForEachSV>(ptr);
    }

    bool GetSVAntennaModelForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetSVAntennaModelForEachSV::documentation() const { return Documentation; }


    int GetSVAntennaModelForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSVAntennaModelForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForEachSVResult
///
#include "gen/GetSVAntennaModelForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForEachSVResult::CmdName = "GetSVAntennaModelForEachSVResult";
    const char* const GetSVAntennaModelForEachSVResult::Documentation = "Result of GetSVAntennaModelForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaModelForEachSVResult);


    GetSVAntennaModelForEachSVResult::GetSVAntennaModelForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaModelForEachSVResult::GetSVAntennaModelForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<std::string>& antennaModelNames)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setAntennaModelNames(antennaModelNames);
    }


    GetSVAntennaModelForEachSVResultPtr GetSVAntennaModelForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<std::string>& antennaModelNames)
    {
      return GetSVAntennaModelForEachSVResultPtr(new GetSVAntennaModelForEachSVResult(relatedCommand, system, antennaModelNames));
    }

    GetSVAntennaModelForEachSVResultPtr GetSVAntennaModelForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForEachSVResult>(ptr);
    }

    bool GetSVAntennaModelForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaModelNames"])
        ;

    }

    std::string GetSVAntennaModelForEachSVResult::documentation() const { return Documentation; }


    std::string GetSVAntennaModelForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetSVAntennaModelForEachSVResult::antennaModelNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaModelNames"]);
    }

    void GetSVAntennaModelForEachSVResult::setAntennaModelNames(const std::vector<std::string>& antennaModelNames)
    {
      m_values.AddMember("AntennaModelNames", parse_json<std::vector<std::string>>::format(antennaModelNames, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVType
///
#include "gen/SetSVType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVType::CmdName = "SetSVType";
    const char* const SetSVType::Documentation = "Set the type of a SV.\nSatellite SV ID accepted values (0 for all SVs):\nQZSS 1..10";

    REGISTER_COMMAND_FACTORY(SetSVType);


    SetSVType::SetSVType()
      : CommandBase(CmdName)
    {}

    SetSVType::SetSVType(const std::string& system, int svId, const std::string& svType)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setSvType(svType);
    }


    SetSVTypePtr SetSVType::create(const std::string& system, int svId, const std::string& svType)
    {
      return SetSVTypePtr(new SetSVType(system, svId, svType));
    }

    SetSVTypePtr SetSVType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVType>(ptr);
    }

    bool SetSVType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["SvType"])
        ;

    }

    std::string SetSVType::documentation() const { return Documentation; }


    int SetSVType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSVType::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVType::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSVType::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSVType::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVType::svType() const
    {
      return parse_json<std::string>::parse(m_values["SvType"]);
    }

    void SetSVType::setSvType(const std::string& svType)
    {
      m_values.AddMember("SvType", parse_json<std::string>::format(svType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVType
///
#include "gen/GetSVType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVType::CmdName = "GetSVType";
    const char* const GetSVType::Documentation = "Get the type of a SV.\nSatellite SV ID accepted values:\nQZSS 1..10";

    REGISTER_COMMAND_FACTORY(GetSVType);


    GetSVType::GetSVType()
      : CommandBase(CmdName)
    {}

    GetSVType::GetSVType(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetSVTypePtr GetSVType::create(const std::string& system, int svId)
    {
      return GetSVTypePtr(new GetSVType(system, svId));
    }

    GetSVTypePtr GetSVType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVType>(ptr);
    }

    bool GetSVType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetSVType::documentation() const { return Documentation; }


    int GetSVType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSVType::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVType::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVType::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSVType::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVTypeResult
///
#include "gen/GetSVTypeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVTypeResult::CmdName = "GetSVTypeResult";
    const char* const GetSVTypeResult::Documentation = "Result of GetSVType";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVTypeResult);


    GetSVTypeResult::GetSVTypeResult()
      : CommandResult(CmdName)
    {}

    GetSVTypeResult::GetSVTypeResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::string& svType)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setSvType(svType);
    }


    GetSVTypeResultPtr GetSVTypeResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::string& svType)
    {
      return GetSVTypeResultPtr(new GetSVTypeResult(relatedCommand, system, svId, svType));
    }

    GetSVTypeResultPtr GetSVTypeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVTypeResult>(ptr);
    }

    bool GetSVTypeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["SvType"])
        ;

    }

    std::string GetSVTypeResult::documentation() const { return Documentation; }


    std::string GetSVTypeResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVTypeResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVTypeResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSVTypeResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVTypeResult::svType() const
    {
      return parse_json<std::string>::parse(m_values["SvType"]);
    }

    void GetSVTypeResult::setSvType(const std::string& svType)
    {
      m_values.AddMember("SvType", parse_json<std::string>::format(svType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetTransmittedPrnForSV
///
#include "gen/SetTransmittedPrnForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetTransmittedPrnForSV::CmdName = "SetTransmittedPrnForSV";
    const char* const SetTransmittedPrnForSV::Documentation = "Set the PRNs transmitted by the SV ID for these signals.";

    REGISTER_COMMAND_FACTORY(SetTransmittedPrnForSV);


    SetTransmittedPrnForSV::SetTransmittedPrnForSV()
      : CommandBase(CmdName)
    {}

    SetTransmittedPrnForSV::SetTransmittedPrnForSV(int svId, const std::map<std::string, int>& signalPrnDict)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSignalPrnDict(signalPrnDict);
    }


    SetTransmittedPrnForSVPtr SetTransmittedPrnForSV::create(int svId, const std::map<std::string, int>& signalPrnDict)
    {
      return SetTransmittedPrnForSVPtr(new SetTransmittedPrnForSV(svId, signalPrnDict));
    }

    SetTransmittedPrnForSVPtr SetTransmittedPrnForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetTransmittedPrnForSV>(ptr);
    }

    bool SetTransmittedPrnForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, int>>::is_valid(m_values["SignalPrnDict"])
        ;

    }

    std::string SetTransmittedPrnForSV::documentation() const { return Documentation; }


    int SetTransmittedPrnForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetTransmittedPrnForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetTransmittedPrnForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, int> SetTransmittedPrnForSV::signalPrnDict() const
    {
      return parse_json<std::map<std::string, int>>::parse(m_values["SignalPrnDict"]);
    }

    void SetTransmittedPrnForSV::setSignalPrnDict(const std::map<std::string, int>& signalPrnDict)
    {
      m_values.AddMember("SignalPrnDict", parse_json<std::map<std::string, int>>::format(signalPrnDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetTransmittedPrnForSV
///
#include "gen/GetTransmittedPrnForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetTransmittedPrnForSV::CmdName = "GetTransmittedPrnForSV";
    const char* const GetTransmittedPrnForSV::Documentation = "Get the PRNs transmitted by the SV ID for these signals.";

    REGISTER_COMMAND_FACTORY(GetTransmittedPrnForSV);


    GetTransmittedPrnForSV::GetTransmittedPrnForSV()
      : CommandBase(CmdName)
    {}

    GetTransmittedPrnForSV::GetTransmittedPrnForSV(int svId, const std::vector<std::string>& signalArray)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSignalArray(signalArray);
    }


    GetTransmittedPrnForSVPtr GetTransmittedPrnForSV::create(int svId, const std::vector<std::string>& signalArray)
    {
      return GetTransmittedPrnForSVPtr(new GetTransmittedPrnForSV(svId, signalArray));
    }

    GetTransmittedPrnForSVPtr GetTransmittedPrnForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetTransmittedPrnForSV>(ptr);
    }

    bool GetTransmittedPrnForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
        ;

    }

    std::string GetTransmittedPrnForSV::documentation() const { return Documentation; }


    int GetTransmittedPrnForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetTransmittedPrnForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetTransmittedPrnForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetTransmittedPrnForSV::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetTransmittedPrnForSV::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetTransmittedPrnForSVResult
///
#include "gen/GetTransmittedPrnForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetTransmittedPrnForSVResult::CmdName = "GetTransmittedPrnForSVResult";
    const char* const GetTransmittedPrnForSVResult::Documentation = "Result of GetTransmittedPrnForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetTransmittedPrnForSVResult);


    GetTransmittedPrnForSVResult::GetTransmittedPrnForSVResult()
      : CommandResult(CmdName)
    {}

    GetTransmittedPrnForSVResult::GetTransmittedPrnForSVResult(CommandBasePtr relatedCommand, int svId, const std::map<std::string, int>& signalPrnDict)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setSignalPrnDict(signalPrnDict);
    }


    GetTransmittedPrnForSVResultPtr GetTransmittedPrnForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::map<std::string, int>& signalPrnDict)
    {
      return GetTransmittedPrnForSVResultPtr(new GetTransmittedPrnForSVResult(relatedCommand, svId, signalPrnDict));
    }

    GetTransmittedPrnForSVResultPtr GetTransmittedPrnForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetTransmittedPrnForSVResult>(ptr);
    }

    bool GetTransmittedPrnForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, int>>::is_valid(m_values["SignalPrnDict"])
        ;

    }

    std::string GetTransmittedPrnForSVResult::documentation() const { return Documentation; }


    int GetTransmittedPrnForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetTransmittedPrnForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, int> GetTransmittedPrnForSVResult::signalPrnDict() const
    {
      return parse_json<std::map<std::string, int>>::parse(m_values["SignalPrnDict"]);
    }

    void GetTransmittedPrnForSVResult::setSignalPrnDict(const std::map<std::string, int>& signalPrnDict)
    {
      m_values.AddMember("SignalPrnDict", parse_json<std::map<std::string, int>>::format(signalPrnDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPrnOfSVID
///
#include "gen/SetPrnOfSVID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPrnOfSVID::CmdName = "SetPrnOfSVID";
    const char* const SetPrnOfSVID::Documentation = "Set the PRN transmitted by the SV ID for this signal.";

    REGISTER_COMMAND_FACTORY(SetPrnOfSVID);


    SetPrnOfSVID::SetPrnOfSVID()
      : CommandBase(CmdName)
    {}

    SetPrnOfSVID::SetPrnOfSVID(const std::string& signal, int svId, int prn)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
      setPrn(prn);
    }


    SetPrnOfSVIDPtr SetPrnOfSVID::create(const std::string& signal, int svId, int prn)
    {
      return SetPrnOfSVIDPtr(new SetPrnOfSVID(signal, svId, prn));
    }

    SetPrnOfSVIDPtr SetPrnOfSVID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPrnOfSVID>(ptr);
    }

    bool SetPrnOfSVID::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string SetPrnOfSVID::documentation() const { return Documentation; }


    int SetPrnOfSVID::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPrnOfSVID::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetPrnOfSVID::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPrnOfSVID::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPrnOfSVID::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPrnOfSVID::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetPrnOfSVID::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnOfSVID
///
#include "gen/GetPrnOfSVID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnOfSVID::CmdName = "GetPrnOfSVID";
    const char* const GetPrnOfSVID::Documentation = "Get the PRN transmitted by the SV ID for this signal.";

    REGISTER_COMMAND_FACTORY(GetPrnOfSVID);


    GetPrnOfSVID::GetPrnOfSVID()
      : CommandBase(CmdName)
    {}

    GetPrnOfSVID::GetPrnOfSVID(const std::string& signal, int svId)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
    }


    GetPrnOfSVIDPtr GetPrnOfSVID::create(const std::string& signal, int svId)
    {
      return GetPrnOfSVIDPtr(new GetPrnOfSVID(signal, svId));
    }

    GetPrnOfSVIDPtr GetPrnOfSVID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnOfSVID>(ptr);
    }

    bool GetPrnOfSVID::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetPrnOfSVID::documentation() const { return Documentation; }


    int GetPrnOfSVID::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPrnOfSVID::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPrnOfSVID::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPrnOfSVID::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPrnOfSVID::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnOfSVIDResult
///
#include "gen/GetPrnOfSVIDResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnOfSVIDResult::CmdName = "GetPrnOfSVIDResult";
    const char* const GetPrnOfSVIDResult::Documentation = "Result of GetPrnOfSVID";

    REGISTER_COMMAND_RESULT_FACTORY(GetPrnOfSVIDResult);


    GetPrnOfSVIDResult::GetPrnOfSVIDResult()
      : CommandResult(CmdName)
    {}

    GetPrnOfSVIDResult::GetPrnOfSVIDResult(CommandBasePtr relatedCommand, const std::string& signal, int svId, int prn)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setSvId(svId);
      setPrn(prn);
    }


    GetPrnOfSVIDResultPtr GetPrnOfSVIDResult::create(CommandBasePtr relatedCommand, const std::string& signal, int svId, int prn)
    {
      return GetPrnOfSVIDResultPtr(new GetPrnOfSVIDResult(relatedCommand, signal, svId, prn));
    }

    GetPrnOfSVIDResultPtr GetPrnOfSVIDResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnOfSVIDResult>(ptr);
    }

    bool GetPrnOfSVIDResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetPrnOfSVIDResult::documentation() const { return Documentation; }


    std::string GetPrnOfSVIDResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPrnOfSVIDResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPrnOfSVIDResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPrnOfSVIDResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPrnOfSVIDResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetPrnOfSVIDResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPrnForEachSV
///
#include "gen/SetPrnForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPrnForEachSV::CmdName = "SetPrnForEachSV";
    const char* const SetPrnForEachSV::Documentation = "Set the PRN for each satellite for specified signals.";

    REGISTER_COMMAND_FACTORY(SetPrnForEachSV);


    SetPrnForEachSV::SetPrnForEachSV()
      : CommandBase(CmdName)
    {}

    SetPrnForEachSV::SetPrnForEachSV(const std::string& signal, const std::vector<int>& prn)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setPrn(prn);
    }


    SetPrnForEachSVPtr SetPrnForEachSV::create(const std::string& signal, const std::vector<int>& prn)
    {
      return SetPrnForEachSVPtr(new SetPrnForEachSV(signal, prn));
    }

    SetPrnForEachSVPtr SetPrnForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPrnForEachSV>(ptr);
    }

    bool SetPrnForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<int>>::is_valid(m_values["Prn"])
        ;

    }

    std::string SetPrnForEachSV::documentation() const { return Documentation; }


    int SetPrnForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPrnForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetPrnForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetPrnForEachSV::prn() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Prn"]);
    }

    void SetPrnForEachSV::setPrn(const std::vector<int>& prn)
    {
      m_values.AddMember("Prn", parse_json<std::vector<int>>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnForEachSV
///
#include "gen/GetPrnForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnForEachSV::CmdName = "GetPrnForEachSV";
    const char* const GetPrnForEachSV::Documentation = "Get the PRN for each satellite for specified signals.";

    REGISTER_COMMAND_FACTORY(GetPrnForEachSV);


    GetPrnForEachSV::GetPrnForEachSV()
      : CommandBase(CmdName)
    {}

    GetPrnForEachSV::GetPrnForEachSV(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetPrnForEachSVPtr GetPrnForEachSV::create(const std::string& signal)
    {
      return GetPrnForEachSVPtr(new GetPrnForEachSV(signal));
    }

    GetPrnForEachSVPtr GetPrnForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnForEachSV>(ptr);
    }

    bool GetPrnForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetPrnForEachSV::documentation() const { return Documentation; }


    int GetPrnForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPrnForEachSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPrnForEachSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnForEachSVResult
///
#include "gen/GetPrnForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnForEachSVResult::CmdName = "GetPrnForEachSVResult";
    const char* const GetPrnForEachSVResult::Documentation = "Result of GetPrnForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetPrnForEachSVResult);


    GetPrnForEachSVResult::GetPrnForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetPrnForEachSVResult::GetPrnForEachSVResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<int>& prn)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setPrn(prn);
    }


    GetPrnForEachSVResultPtr GetPrnForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<int>& prn)
    {
      return GetPrnForEachSVResultPtr(new GetPrnForEachSVResult(relatedCommand, signal, prn));
    }

    GetPrnForEachSVResultPtr GetPrnForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnForEachSVResult>(ptr);
    }

    bool GetPrnForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<int>>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetPrnForEachSVResult::documentation() const { return Documentation; }


    std::string GetPrnForEachSVResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPrnForEachSVResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetPrnForEachSVResult::prn() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Prn"]);
    }

    void GetPrnForEachSVResult::setPrn(const std::vector<int>& prn)
    {
      m_values.AddMember("Prn", parse_json<std::vector<int>>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetToDefaultPrn
///
#include "gen/ResetToDefaultPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetToDefaultPrn::CmdName = "ResetToDefaultPrn";
    const char* const ResetToDefaultPrn::Documentation = "Reset the PRNs of all satellites in specified system, for all signals.";

    REGISTER_COMMAND_FACTORY(ResetToDefaultPrn);


    ResetToDefaultPrn::ResetToDefaultPrn()
      : CommandBase(CmdName)
    {}

    ResetToDefaultPrn::ResetToDefaultPrn(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    ResetToDefaultPrnPtr ResetToDefaultPrn::create(const std::string& system)
    {
      return ResetToDefaultPrnPtr(new ResetToDefaultPrn(system));
    }

    ResetToDefaultPrnPtr ResetToDefaultPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetToDefaultPrn>(ptr);
    }

    bool ResetToDefaultPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string ResetToDefaultPrn::documentation() const { return Documentation; }


    int ResetToDefaultPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ResetToDefaultPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ResetToDefaultPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableTrajectorySmoothing
///
#include "gen/EnableTrajectorySmoothing.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableTrajectorySmoothing::CmdName = "EnableTrajectorySmoothing";
    const char* const EnableTrajectorySmoothing::Documentation = "Set trajectory smoothing for Track or Route enabled or disabled";

    REGISTER_COMMAND_FACTORY(EnableTrajectorySmoothing);


    EnableTrajectorySmoothing::EnableTrajectorySmoothing()
      : CommandBase(CmdName)
    {}

    EnableTrajectorySmoothing::EnableTrajectorySmoothing(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableTrajectorySmoothingPtr EnableTrajectorySmoothing::create(bool enabled)
    {
      return EnableTrajectorySmoothingPtr(new EnableTrajectorySmoothing(enabled));
    }

    EnableTrajectorySmoothingPtr EnableTrajectorySmoothing::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableTrajectorySmoothing>(ptr);
    }

    bool EnableTrajectorySmoothing::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableTrajectorySmoothing::documentation() const { return Documentation; }


    int EnableTrajectorySmoothing::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableTrajectorySmoothing::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableTrajectorySmoothing::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsTrajectorySmoothingEnabled
///
#include "gen/IsTrajectorySmoothingEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTrajectorySmoothingEnabled::CmdName = "IsTrajectorySmoothingEnabled";
    const char* const IsTrajectorySmoothingEnabled::Documentation = "Get trajectory smoothing for Track or Route enabled or disabled";

    REGISTER_COMMAND_FACTORY(IsTrajectorySmoothingEnabled);


    IsTrajectorySmoothingEnabled::IsTrajectorySmoothingEnabled()
      : CommandBase(CmdName)
    {

    }


    IsTrajectorySmoothingEnabledPtr IsTrajectorySmoothingEnabled::create()
    {
      return IsTrajectorySmoothingEnabledPtr(new IsTrajectorySmoothingEnabled());
    }

    IsTrajectorySmoothingEnabledPtr IsTrajectorySmoothingEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTrajectorySmoothingEnabled>(ptr);
    }

    bool IsTrajectorySmoothingEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsTrajectorySmoothingEnabled::documentation() const { return Documentation; }


    int IsTrajectorySmoothingEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsTrajectorySmoothingEnabledResult
///
#include "gen/IsTrajectorySmoothingEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTrajectorySmoothingEnabledResult::CmdName = "IsTrajectorySmoothingEnabledResult";
    const char* const IsTrajectorySmoothingEnabledResult::Documentation = "Result of IsTrajectorySmoothingEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsTrajectorySmoothingEnabledResult);


    IsTrajectorySmoothingEnabledResult::IsTrajectorySmoothingEnabledResult()
      : CommandResult(CmdName)
    {}

    IsTrajectorySmoothingEnabledResult::IsTrajectorySmoothingEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsTrajectorySmoothingEnabledResultPtr IsTrajectorySmoothingEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsTrajectorySmoothingEnabledResultPtr(new IsTrajectorySmoothingEnabledResult(relatedCommand, enabled));
    }

    IsTrajectorySmoothingEnabledResultPtr IsTrajectorySmoothingEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTrajectorySmoothingEnabledResult>(ptr);
    }

    bool IsTrajectorySmoothingEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsTrajectorySmoothingEnabledResult::documentation() const { return Documentation; }


    bool IsTrajectorySmoothingEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsTrajectorySmoothingEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSimulationStopAtTrajectoryEnd
///
#include "gen/EnableSimulationStopAtTrajectoryEnd.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSimulationStopAtTrajectoryEnd::CmdName = "EnableSimulationStopAtTrajectoryEnd";
    const char* const EnableSimulationStopAtTrajectoryEnd::Documentation = "Set simulation automatic stop when the vehicle reaches trajectory end enabled or disabled. Only effective with Tracks and Routes";

    REGISTER_COMMAND_FACTORY(EnableSimulationStopAtTrajectoryEnd);


    EnableSimulationStopAtTrajectoryEnd::EnableSimulationStopAtTrajectoryEnd()
      : CommandBase(CmdName)
    {}

    EnableSimulationStopAtTrajectoryEnd::EnableSimulationStopAtTrajectoryEnd(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    EnableSimulationStopAtTrajectoryEndPtr EnableSimulationStopAtTrajectoryEnd::create(bool enabled)
    {
      return EnableSimulationStopAtTrajectoryEndPtr(new EnableSimulationStopAtTrajectoryEnd(enabled));
    }

    EnableSimulationStopAtTrajectoryEndPtr EnableSimulationStopAtTrajectoryEnd::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSimulationStopAtTrajectoryEnd>(ptr);
    }

    bool EnableSimulationStopAtTrajectoryEnd::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSimulationStopAtTrajectoryEnd::documentation() const { return Documentation; }


    int EnableSimulationStopAtTrajectoryEnd::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableSimulationStopAtTrajectoryEnd::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSimulationStopAtTrajectoryEnd::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSimulationStopAtTrajectoryEndEnabled
///
#include "gen/IsSimulationStopAtTrajectoryEndEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSimulationStopAtTrajectoryEndEnabled::CmdName = "IsSimulationStopAtTrajectoryEndEnabled";
    const char* const IsSimulationStopAtTrajectoryEndEnabled::Documentation = "Get simulation automatic stop when the vehicle reaches trajectory end enabled or disabled. Only effective with Tracks and Routes";

    REGISTER_COMMAND_FACTORY(IsSimulationStopAtTrajectoryEndEnabled);


    IsSimulationStopAtTrajectoryEndEnabled::IsSimulationStopAtTrajectoryEndEnabled()
      : CommandBase(CmdName)
    {

    }


    IsSimulationStopAtTrajectoryEndEnabledPtr IsSimulationStopAtTrajectoryEndEnabled::create()
    {
      return IsSimulationStopAtTrajectoryEndEnabledPtr(new IsSimulationStopAtTrajectoryEndEnabled());
    }

    IsSimulationStopAtTrajectoryEndEnabledPtr IsSimulationStopAtTrajectoryEndEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSimulationStopAtTrajectoryEndEnabled>(ptr);
    }

    bool IsSimulationStopAtTrajectoryEndEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsSimulationStopAtTrajectoryEndEnabled::documentation() const { return Documentation; }


    int IsSimulationStopAtTrajectoryEndEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsSimulationStopAtTrajectoryEndEnabledResult
///
#include "gen/IsSimulationStopAtTrajectoryEndEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSimulationStopAtTrajectoryEndEnabledResult::CmdName = "IsSimulationStopAtTrajectoryEndEnabledResult";
    const char* const IsSimulationStopAtTrajectoryEndEnabledResult::Documentation = "Result of IsSimulationStopAtTrajectoryEndEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsSimulationStopAtTrajectoryEndEnabledResult);


    IsSimulationStopAtTrajectoryEndEnabledResult::IsSimulationStopAtTrajectoryEndEnabledResult()
      : CommandResult(CmdName)
    {}

    IsSimulationStopAtTrajectoryEndEnabledResult::IsSimulationStopAtTrajectoryEndEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsSimulationStopAtTrajectoryEndEnabledResultPtr IsSimulationStopAtTrajectoryEndEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsSimulationStopAtTrajectoryEndEnabledResultPtr(new IsSimulationStopAtTrajectoryEndEnabledResult(relatedCommand, enabled));
    }

    IsSimulationStopAtTrajectoryEndEnabledResultPtr IsSimulationStopAtTrajectoryEndEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSimulationStopAtTrajectoryEndEnabledResult>(ptr);
    }

    bool IsSimulationStopAtTrajectoryEndEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSimulationStopAtTrajectoryEndEnabledResult::documentation() const { return Documentation; }


    bool IsSimulationStopAtTrajectoryEndEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSimulationStopAtTrajectoryEndEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ForceAttitudeToZero
///
#include "gen/ForceAttitudeToZero.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ForceAttitudeToZero::CmdName = "ForceAttitudeToZero";
    const char* const ForceAttitudeToZero::Documentation = "Set force vehicle yaw, pitch and roll to zero enabled or disabled";

    REGISTER_COMMAND_FACTORY(ForceAttitudeToZero);


    ForceAttitudeToZero::ForceAttitudeToZero()
      : CommandBase(CmdName)
    {}

    ForceAttitudeToZero::ForceAttitudeToZero(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    ForceAttitudeToZeroPtr ForceAttitudeToZero::create(bool enabled)
    {
      return ForceAttitudeToZeroPtr(new ForceAttitudeToZero(enabled));
    }

    ForceAttitudeToZeroPtr ForceAttitudeToZero::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ForceAttitudeToZero>(ptr);
    }

    bool ForceAttitudeToZero::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string ForceAttitudeToZero::documentation() const { return Documentation; }


    int ForceAttitudeToZero::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ForceAttitudeToZero::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void ForceAttitudeToZero::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsAttitudeToZeroForced
///
#include "gen/IsAttitudeToZeroForced.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsAttitudeToZeroForced::CmdName = "IsAttitudeToZeroForced";
    const char* const IsAttitudeToZeroForced::Documentation = "Get force vehicle yaw, pitch and roll to zero enabled or disabled";

    REGISTER_COMMAND_FACTORY(IsAttitudeToZeroForced);


    IsAttitudeToZeroForced::IsAttitudeToZeroForced()
      : CommandBase(CmdName)
    {

    }


    IsAttitudeToZeroForcedPtr IsAttitudeToZeroForced::create()
    {
      return IsAttitudeToZeroForcedPtr(new IsAttitudeToZeroForced());
    }

    IsAttitudeToZeroForcedPtr IsAttitudeToZeroForced::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsAttitudeToZeroForced>(ptr);
    }

    bool IsAttitudeToZeroForced::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsAttitudeToZeroForced::documentation() const { return Documentation; }


    int IsAttitudeToZeroForced::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsAttitudeToZeroForcedResult
///
#include "gen/IsAttitudeToZeroForcedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsAttitudeToZeroForcedResult::CmdName = "IsAttitudeToZeroForcedResult";
    const char* const IsAttitudeToZeroForcedResult::Documentation = "Result of IsAttitudeToZeroForced";

    REGISTER_COMMAND_RESULT_FACTORY(IsAttitudeToZeroForcedResult);


    IsAttitudeToZeroForcedResult::IsAttitudeToZeroForcedResult()
      : CommandResult(CmdName)
    {}

    IsAttitudeToZeroForcedResult::IsAttitudeToZeroForcedResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsAttitudeToZeroForcedResultPtr IsAttitudeToZeroForcedResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsAttitudeToZeroForcedResultPtr(new IsAttitudeToZeroForcedResult(relatedCommand, enabled));
    }

    IsAttitudeToZeroForcedResultPtr IsAttitudeToZeroForcedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsAttitudeToZeroForcedResult>(ptr);
    }

    bool IsAttitudeToZeroForcedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsAttitudeToZeroForcedResult::documentation() const { return Documentation; }


    bool IsAttitudeToZeroForcedResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsAttitudeToZeroForcedResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectory
///
#include "gen/SetVehicleTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectory::CmdName = "SetVehicleTrajectory";
    const char* const SetVehicleTrajectory::Documentation = "Set vehicle trajectory type";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectory);


    SetVehicleTrajectory::SetVehicleTrajectory()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectory::SetVehicleTrajectory(const std::string& type)
      : CommandBase(CmdName)
    {

      setType(type);
    }


    SetVehicleTrajectoryPtr SetVehicleTrajectory::create(const std::string& type)
    {
      return SetVehicleTrajectoryPtr(new SetVehicleTrajectory(type));
    }

    SetVehicleTrajectoryPtr SetVehicleTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectory>(ptr);
    }

    bool SetVehicleTrajectory::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string SetVehicleTrajectory::documentation() const { return Documentation; }


    int SetVehicleTrajectory::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectory::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectory::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectory
///
#include "gen/GetVehicleTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectory::CmdName = "GetVehicleTrajectory";
    const char* const GetVehicleTrajectory::Documentation = "Get vehicle trajectory type";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectory);


    GetVehicleTrajectory::GetVehicleTrajectory()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryPtr GetVehicleTrajectory::create()
    {
      return GetVehicleTrajectoryPtr(new GetVehicleTrajectory());
    }

    GetVehicleTrajectoryPtr GetVehicleTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectory>(ptr);
    }

    bool GetVehicleTrajectory::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectory::documentation() const { return Documentation; }


    int GetVehicleTrajectory::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryResult
///
#include "gen/GetVehicleTrajectoryResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryResult::CmdName = "GetVehicleTrajectoryResult";
    const char* const GetVehicleTrajectoryResult::Documentation = "Result of GetVehicleTrajectory";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryResult);


    GetVehicleTrajectoryResult::GetVehicleTrajectoryResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryResult::GetVehicleTrajectoryResult(CommandBasePtr relatedCommand, const std::string& type)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
    }


    GetVehicleTrajectoryResultPtr GetVehicleTrajectoryResult::create(CommandBasePtr relatedCommand, const std::string& type)
    {
      return GetVehicleTrajectoryResultPtr(new GetVehicleTrajectoryResult(relatedCommand, type));
    }

    GetVehicleTrajectoryResultPtr GetVehicleTrajectoryResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryResult>(ptr);
    }

    bool GetVehicleTrajectoryResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string GetVehicleTrajectoryResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleType
///
#include "gen/SetVehicleType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleType::CmdName = "SetVehicleType";
    const char* const SetVehicleType::Documentation = "Set vehicle type for Route Trajectory";

    REGISTER_COMMAND_FACTORY(SetVehicleType);


    SetVehicleType::SetVehicleType()
      : CommandBase(CmdName)
    {}

    SetVehicleType::SetVehicleType(const std::string& type)
      : CommandBase(CmdName)
    {

      setType(type);
    }


    SetVehicleTypePtr SetVehicleType::create(const std::string& type)
    {
      return SetVehicleTypePtr(new SetVehicleType(type));
    }

    SetVehicleTypePtr SetVehicleType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleType>(ptr);
    }

    bool SetVehicleType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string SetVehicleType::documentation() const { return Documentation; }


    int SetVehicleType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleType::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleType::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BeginTrackDefinition
///
#include "gen/BeginTrackDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BeginTrackDefinition::CmdName = "BeginTrackDefinition";
    const char* const BeginTrackDefinition::Documentation = "Begins a new track definition. Actual track remains unchanged until\nEndTrackDefinition command is sent and successful. After this command, the\nclient must push time and position pairs to form a complete track. Once all the\npositions are sent, the client must send the command EndTrackDefinition.";

    REGISTER_COMMAND_FACTORY(BeginTrackDefinition);


    BeginTrackDefinition::BeginTrackDefinition()
      : CommandBase(CmdName)
    {

    }


    BeginTrackDefinitionPtr BeginTrackDefinition::create()
    {
      return BeginTrackDefinitionPtr(new BeginTrackDefinition());
    }

    BeginTrackDefinitionPtr BeginTrackDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BeginTrackDefinition>(ptr);
    }

    bool BeginTrackDefinition::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string BeginTrackDefinition::documentation() const { return Documentation; }


    int BeginTrackDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of PushTrackEcef
///
#include "gen/PushTrackEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushTrackEcef::CmdName = "PushTrackEcef";
    const char* const PushTrackEcef::Documentation = "Push a track ecef node. Must be called after BeginTrackDefinition and before EndTrackDefinition.";

    REGISTER_COMMAND_FACTORY(PushTrackEcef);


    PushTrackEcef::PushTrackEcef()
      : CommandBase(CmdName)
    {}

    PushTrackEcef::PushTrackEcef(int time, double x, double y, double z)
      : CommandBase(CmdName)
    {

      setTime(time);
      setX(x);
      setY(y);
      setZ(z);
    }


    PushTrackEcefPtr PushTrackEcef::create(int time, double x, double y, double z)
    {
      return PushTrackEcefPtr(new PushTrackEcef(time, x, y, z));
    }

    PushTrackEcefPtr PushTrackEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushTrackEcef>(ptr);
    }

    bool PushTrackEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
        ;

    }

    std::string PushTrackEcef::documentation() const { return Documentation; }


    int PushTrackEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int PushTrackEcef::time() const
    {
      return parse_json<int>::parse(m_values["Time"]);
    }

    void PushTrackEcef::setTime(int time)
    {
      m_values.AddMember("Time", parse_json<int>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushTrackEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushTrackEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushTrackEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of PushTrackEcefNed
///
#include "gen/PushTrackEcefNed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushTrackEcefNed::CmdName = "PushTrackEcefNed";
    const char* const PushTrackEcefNed::Documentation = "Push a track ecef and ned attitude node. Must be called after BeginTrackDefinition and before EndTrackDefinition.";

    REGISTER_COMMAND_FACTORY(PushTrackEcefNed);


    PushTrackEcefNed::PushTrackEcefNed()
      : CommandBase(CmdName)
    {}

    PushTrackEcefNed::PushTrackEcefNed(int time, double x, double y, double z, double yaw, double pitch, double roll)
      : CommandBase(CmdName)
    {

      setTime(time);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    PushTrackEcefNedPtr PushTrackEcefNed::create(int time, double x, double y, double z, double yaw, double pitch, double roll)
    {
      return PushTrackEcefNedPtr(new PushTrackEcefNed(time, x, y, z, yaw, pitch, roll));
    }

    PushTrackEcefNedPtr PushTrackEcefNed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushTrackEcefNed>(ptr);
    }

    bool PushTrackEcefNed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string PushTrackEcefNed::documentation() const { return Documentation; }


    int PushTrackEcefNed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int PushTrackEcefNed::time() const
    {
      return parse_json<int>::parse(m_values["Time"]);
    }

    void PushTrackEcefNed::setTime(int time)
    {
      m_values.AddMember("Time", parse_json<int>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushTrackEcefNed::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushTrackEcefNed::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushTrackEcefNed::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void PushTrackEcefNed::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void PushTrackEcefNed::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushTrackEcefNed::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void PushTrackEcefNed::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EndTrackDefinition
///
#include "gen/EndTrackDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndTrackDefinition::CmdName = "EndTrackDefinition";
    const char* const EndTrackDefinition::Documentation = "This command completes the track started with BeginTrackDefinition command. If\nthe track is accepted, the current track in the configuration is replaced with\nthis new track. If the track is not accepted, the current track in the config\nremains unchanged.";

    REGISTER_COMMAND_FACTORY(EndTrackDefinition);


    EndTrackDefinition::EndTrackDefinition()
      : CommandBase(CmdName)
    {

    }


    EndTrackDefinitionPtr EndTrackDefinition::create()
    {
      return EndTrackDefinitionPtr(new EndTrackDefinition());
    }

    EndTrackDefinitionPtr EndTrackDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndTrackDefinition>(ptr);
    }

    bool EndTrackDefinition::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string EndTrackDefinition::documentation() const { return Documentation; }


    int EndTrackDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of EndTrackDefinitionResult
///
#include "gen/EndTrackDefinitionResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndTrackDefinitionResult::CmdName = "EndTrackDefinitionResult";
    const char* const EndTrackDefinitionResult::Documentation = "EndTrackDefinition Result with created track informations.";

    REGISTER_COMMAND_RESULT_FACTORY(EndTrackDefinitionResult);


    EndTrackDefinitionResult::EndTrackDefinitionResult()
      : CommandResult(CmdName)
    {}

    EndTrackDefinitionResult::EndTrackDefinitionResult(CommandBasePtr relatedCommand, int count)
      : CommandResult(CmdName, relatedCommand)
    {

      setCount(count);
    }


    EndTrackDefinitionResultPtr EndTrackDefinitionResult::create(CommandBasePtr relatedCommand, int count)
    {
      return EndTrackDefinitionResultPtr(new EndTrackDefinitionResult(relatedCommand, count));
    }

    EndTrackDefinitionResultPtr EndTrackDefinitionResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndTrackDefinitionResult>(ptr);
    }

    bool EndTrackDefinitionResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Count"])
        ;

    }

    std::string EndTrackDefinitionResult::documentation() const { return Documentation; }


    int EndTrackDefinitionResult::count() const
    {
      return parse_json<int>::parse(m_values["Count"]);
    }

    void EndTrackDefinitionResult::setCount(int count)
    {
      m_values.AddMember("Count", parse_json<int>::format(count, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BeginRouteDefinition
///
#include "gen/BeginRouteDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BeginRouteDefinition::CmdName = "BeginRouteDefinition";
    const char* const BeginRouteDefinition::Documentation = "Begins a new route definition. Actual route remains unchanged until\nEndRouteDefinition command is sent and successful. After this command, the\nclient must push time and position pairs to form a complete route. Once all the\npositions are sent, the client must send the command EndRouteDefinition.";

    REGISTER_COMMAND_FACTORY(BeginRouteDefinition);


    BeginRouteDefinition::BeginRouteDefinition()
      : CommandBase(CmdName)
    {

    }


    BeginRouteDefinitionPtr BeginRouteDefinition::create()
    {
      return BeginRouteDefinitionPtr(new BeginRouteDefinition());
    }

    BeginRouteDefinitionPtr BeginRouteDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BeginRouteDefinition>(ptr);
    }

    bool BeginRouteDefinition::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string BeginRouteDefinition::documentation() const { return Documentation; }


    int BeginRouteDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of PushRouteEcef
///
#include "gen/PushRouteEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushRouteEcef::CmdName = "PushRouteEcef";
    const char* const PushRouteEcef::Documentation = "Push a route ecef node with speed. Must be called after BeginRouteDefinition and before EndRouteDefinition.";

    REGISTER_COMMAND_FACTORY(PushRouteEcef);


    PushRouteEcef::PushRouteEcef()
      : CommandBase(CmdName)
    {}

    PushRouteEcef::PushRouteEcef(double speed, double x, double y, double z)
      : CommandBase(CmdName)
    {

      setSpeed(speed);
      setX(x);
      setY(y);
      setZ(z);
    }


    PushRouteEcefPtr PushRouteEcef::create(double speed, double x, double y, double z)
    {
      return PushRouteEcefPtr(new PushRouteEcef(speed, x, y, z));
    }

    PushRouteEcefPtr PushRouteEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushRouteEcef>(ptr);
    }

    bool PushRouteEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
        ;

    }

    std::string PushRouteEcef::documentation() const { return Documentation; }


    int PushRouteEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double PushRouteEcef::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void PushRouteEcef::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushRouteEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushRouteEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushRouteEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushRouteEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushRouteEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushRouteEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EndRouteDefinition
///
#include "gen/EndRouteDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndRouteDefinition::CmdName = "EndRouteDefinition";
    const char* const EndRouteDefinition::Documentation = "This command completes the route started with BeginRouteDefinition command. If\nthe route is accepted, the current route in the configuration is replaced with\nthis new route. If the route is not accepted, the current route in the config\nremains unchanged.";

    REGISTER_COMMAND_FACTORY(EndRouteDefinition);


    EndRouteDefinition::EndRouteDefinition()
      : CommandBase(CmdName)
    {

    }


    EndRouteDefinitionPtr EndRouteDefinition::create()
    {
      return EndRouteDefinitionPtr(new EndRouteDefinition());
    }

    EndRouteDefinitionPtr EndRouteDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndRouteDefinition>(ptr);
    }

    bool EndRouteDefinition::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string EndRouteDefinition::documentation() const { return Documentation; }


    int EndRouteDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of EndRouteDefinitionResult
///
#include "gen/EndRouteDefinitionResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndRouteDefinitionResult::CmdName = "EndRouteDefinitionResult";
    const char* const EndRouteDefinitionResult::Documentation = "EndRouteDefinition Result with created route informations.";

    REGISTER_COMMAND_RESULT_FACTORY(EndRouteDefinitionResult);


    EndRouteDefinitionResult::EndRouteDefinitionResult()
      : CommandResult(CmdName)
    {}

    EndRouteDefinitionResult::EndRouteDefinitionResult(CommandBasePtr relatedCommand, int count)
      : CommandResult(CmdName, relatedCommand)
    {

      setCount(count);
    }


    EndRouteDefinitionResultPtr EndRouteDefinitionResult::create(CommandBasePtr relatedCommand, int count)
    {
      return EndRouteDefinitionResultPtr(new EndRouteDefinitionResult(relatedCommand, count));
    }

    EndRouteDefinitionResultPtr EndRouteDefinitionResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndRouteDefinitionResult>(ptr);
    }

    bool EndRouteDefinitionResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Count"])
        ;

    }

    std::string EndRouteDefinitionResult::documentation() const { return Documentation; }


    int EndRouteDefinitionResult::count() const
    {
      return parse_json<int>::parse(m_values["Count"]);
    }

    void EndRouteDefinitionResult::setCount(int count)
    {
      m_values.AddMember("Count", parse_json<int>::format(count, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectoryFix
///
#include "gen/SetVehicleTrajectoryFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectoryFix::CmdName = "SetVehicleTrajectoryFix";
    const char* const SetVehicleTrajectoryFix::Documentation = "Set vehicle static position and orientation";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectoryFix);


    SetVehicleTrajectoryFix::SetVehicleTrajectoryFix()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectoryFix::SetVehicleTrajectoryFix(const std::string& type, double lat, double lon, double alt, double yaw, double pitch, double roll)
      : CommandBase(CmdName)
    {

      setType(type);
      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    SetVehicleTrajectoryFixPtr SetVehicleTrajectoryFix::create(const std::string& type, double lat, double lon, double alt, double yaw, double pitch, double roll)
    {
      return SetVehicleTrajectoryFixPtr(new SetVehicleTrajectoryFix(type, lat, lon, alt, yaw, pitch, roll));
    }

    SetVehicleTrajectoryFixPtr SetVehicleTrajectoryFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectoryFix>(ptr);
    }

    bool SetVehicleTrajectoryFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string SetVehicleTrajectoryFix::documentation() const { return Documentation; }


    int SetVehicleTrajectoryFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectoryFix::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectoryFix::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetVehicleTrajectoryFix::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetVehicleTrajectoryFix::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetVehicleTrajectoryFix::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetVehicleTrajectoryFix::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetVehicleTrajectoryFix::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFix::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetVehicleTrajectoryFix::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectoryFix
///
#include "gen/GetVehicleTrajectoryFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryFix::CmdName = "GetVehicleTrajectoryFix";
    const char* const GetVehicleTrajectoryFix::Documentation = "Get vehicle static position and orientation";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectoryFix);


    GetVehicleTrajectoryFix::GetVehicleTrajectoryFix()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryFixPtr GetVehicleTrajectoryFix::create()
    {
      return GetVehicleTrajectoryFixPtr(new GetVehicleTrajectoryFix());
    }

    GetVehicleTrajectoryFixPtr GetVehicleTrajectoryFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryFix>(ptr);
    }

    bool GetVehicleTrajectoryFix::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectoryFix::documentation() const { return Documentation; }


    int GetVehicleTrajectoryFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryFixResult
///
#include "gen/GetVehicleTrajectoryFixResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryFixResult::CmdName = "GetVehicleTrajectoryFixResult";
    const char* const GetVehicleTrajectoryFixResult::Documentation = "Result of GetVehicleTrajectoryFix";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryFixResult);


    GetVehicleTrajectoryFixResult::GetVehicleTrajectoryFixResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryFixResult::GetVehicleTrajectoryFixResult(CommandBasePtr relatedCommand, const std::string& type, double lat, double lon, double alt, double yaw, double pitch, double roll)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    GetVehicleTrajectoryFixResultPtr GetVehicleTrajectoryFixResult::create(CommandBasePtr relatedCommand, const std::string& type, double lat, double lon, double alt, double yaw, double pitch, double roll)
    {
      return GetVehicleTrajectoryFixResultPtr(new GetVehicleTrajectoryFixResult(relatedCommand, type, lat, lon, alt, yaw, pitch, roll));
    }

    GetVehicleTrajectoryFixResultPtr GetVehicleTrajectoryFixResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryFixResult>(ptr);
    }

    bool GetVehicleTrajectoryFixResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string GetVehicleTrajectoryFixResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryFixResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryFixResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetVehicleTrajectoryFixResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetVehicleTrajectoryFixResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetVehicleTrajectoryFixResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetVehicleTrajectoryFixResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetVehicleTrajectoryFixResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetVehicleTrajectoryFixResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectoryFixEcef
///
#include "gen/SetVehicleTrajectoryFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectoryFixEcef::CmdName = "SetVehicleTrajectoryFixEcef";
    const char* const SetVehicleTrajectoryFixEcef::Documentation = "Set vehicle static position and orientation";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectoryFixEcef);


    SetVehicleTrajectoryFixEcef::SetVehicleTrajectoryFixEcef()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectoryFixEcef::SetVehicleTrajectoryFixEcef(const std::string& type, double x, double y, double z, double yaw, double pitch, double roll)
      : CommandBase(CmdName)
    {

      setType(type);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    SetVehicleTrajectoryFixEcefPtr SetVehicleTrajectoryFixEcef::create(const std::string& type, double x, double y, double z, double yaw, double pitch, double roll)
    {
      return SetVehicleTrajectoryFixEcefPtr(new SetVehicleTrajectoryFixEcef(type, x, y, z, yaw, pitch, roll));
    }

    SetVehicleTrajectoryFixEcefPtr SetVehicleTrajectoryFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectoryFixEcef>(ptr);
    }

    bool SetVehicleTrajectoryFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string SetVehicleTrajectoryFixEcef::documentation() const { return Documentation; }


    int SetVehicleTrajectoryFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectoryFixEcef::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectoryFixEcef::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetVehicleTrajectoryFixEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetVehicleTrajectoryFixEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetVehicleTrajectoryFixEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetVehicleTrajectoryFixEcef::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetVehicleTrajectoryFixEcef::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryFixEcef::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetVehicleTrajectoryFixEcef::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectoryFixEcef
///
#include "gen/GetVehicleTrajectoryFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryFixEcef::CmdName = "GetVehicleTrajectoryFixEcef";
    const char* const GetVehicleTrajectoryFixEcef::Documentation = "Get vehicle static position and orientation";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectoryFixEcef);


    GetVehicleTrajectoryFixEcef::GetVehicleTrajectoryFixEcef()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryFixEcefPtr GetVehicleTrajectoryFixEcef::create()
    {
      return GetVehicleTrajectoryFixEcefPtr(new GetVehicleTrajectoryFixEcef());
    }

    GetVehicleTrajectoryFixEcefPtr GetVehicleTrajectoryFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryFixEcef>(ptr);
    }

    bool GetVehicleTrajectoryFixEcef::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectoryFixEcef::documentation() const { return Documentation; }


    int GetVehicleTrajectoryFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryFixEcefResult
///
#include "gen/GetVehicleTrajectoryFixEcefResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryFixEcefResult::CmdName = "GetVehicleTrajectoryFixEcefResult";
    const char* const GetVehicleTrajectoryFixEcefResult::Documentation = "Result of GetVehicleTrajectoryFixEcef";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryFixEcefResult);


    GetVehicleTrajectoryFixEcefResult::GetVehicleTrajectoryFixEcefResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryFixEcefResult::GetVehicleTrajectoryFixEcefResult(CommandBasePtr relatedCommand, const std::string& type, double x, double y, double z, double yaw, double pitch, double roll)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
    }


    GetVehicleTrajectoryFixEcefResultPtr GetVehicleTrajectoryFixEcefResult::create(CommandBasePtr relatedCommand, const std::string& type, double x, double y, double z, double yaw, double pitch, double roll)
    {
      return GetVehicleTrajectoryFixEcefResultPtr(new GetVehicleTrajectoryFixEcefResult(relatedCommand, type, x, y, z, yaw, pitch, roll));
    }

    GetVehicleTrajectoryFixEcefResultPtr GetVehicleTrajectoryFixEcefResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryFixEcefResult>(ptr);
    }

    bool GetVehicleTrajectoryFixEcefResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
        ;

    }

    std::string GetVehicleTrajectoryFixEcefResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryFixEcefResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryFixEcefResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetVehicleTrajectoryFixEcefResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectoryCircular
///
#include "gen/SetVehicleTrajectoryCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectoryCircular::CmdName = "SetVehicleTrajectoryCircular";
    const char* const SetVehicleTrajectoryCircular::Documentation = "Set vehicle circular trajectory";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectoryCircular);


    SetVehicleTrajectoryCircular::SetVehicleTrajectoryCircular()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectoryCircular::SetVehicleTrajectoryCircular(const std::string& type, double lat, double lon, double alt, double radius, double speed, bool clockwise, const Sdx::optional<double>& originAngle)
      : CommandBase(CmdName)
    {

      setType(type);
      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setOriginAngle(originAngle);
    }


    SetVehicleTrajectoryCircularPtr SetVehicleTrajectoryCircular::create(const std::string& type, double lat, double lon, double alt, double radius, double speed, bool clockwise, const Sdx::optional<double>& originAngle)
    {
      return SetVehicleTrajectoryCircularPtr(new SetVehicleTrajectoryCircular(type, lat, lon, alt, radius, speed, clockwise, originAngle));
    }

    SetVehicleTrajectoryCircularPtr SetVehicleTrajectoryCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectoryCircular>(ptr);
    }

    bool SetVehicleTrajectoryCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string SetVehicleTrajectoryCircular::documentation() const { return Documentation; }


    int SetVehicleTrajectoryCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectoryCircular::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectoryCircular::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetVehicleTrajectoryCircular::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetVehicleTrajectoryCircular::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetVehicleTrajectoryCircular::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void SetVehicleTrajectoryCircular::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryCircular::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void SetVehicleTrajectoryCircular::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetVehicleTrajectoryCircular::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void SetVehicleTrajectoryCircular::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> SetVehicleTrajectoryCircular::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void SetVehicleTrajectoryCircular::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectoryCircular
///
#include "gen/GetVehicleTrajectoryCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryCircular::CmdName = "GetVehicleTrajectoryCircular";
    const char* const GetVehicleTrajectoryCircular::Documentation = "Get vehicle circular trajectory";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectoryCircular);


    GetVehicleTrajectoryCircular::GetVehicleTrajectoryCircular()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryCircularPtr GetVehicleTrajectoryCircular::create()
    {
      return GetVehicleTrajectoryCircularPtr(new GetVehicleTrajectoryCircular());
    }

    GetVehicleTrajectoryCircularPtr GetVehicleTrajectoryCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryCircular>(ptr);
    }

    bool GetVehicleTrajectoryCircular::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectoryCircular::documentation() const { return Documentation; }


    int GetVehicleTrajectoryCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryCircularResult
///
#include "gen/GetVehicleTrajectoryCircularResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryCircularResult::CmdName = "GetVehicleTrajectoryCircularResult";
    const char* const GetVehicleTrajectoryCircularResult::Documentation = "Result of GetVehicleTrajectoryCircular";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryCircularResult);


    GetVehicleTrajectoryCircularResult::GetVehicleTrajectoryCircularResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryCircularResult::GetVehicleTrajectoryCircularResult(CommandBasePtr relatedCommand, const std::string& type, double lat, double lon, double alt, double radius, double speed, bool clockwise, const Sdx::optional<double>& originAngle)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setOriginAngle(originAngle);
    }


    GetVehicleTrajectoryCircularResultPtr GetVehicleTrajectoryCircularResult::create(CommandBasePtr relatedCommand, const std::string& type, double lat, double lon, double alt, double radius, double speed, bool clockwise, const Sdx::optional<double>& originAngle)
    {
      return GetVehicleTrajectoryCircularResultPtr(new GetVehicleTrajectoryCircularResult(relatedCommand, type, lat, lon, alt, radius, speed, clockwise, originAngle));
    }

    GetVehicleTrajectoryCircularResultPtr GetVehicleTrajectoryCircularResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryCircularResult>(ptr);
    }

    bool GetVehicleTrajectoryCircularResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string GetVehicleTrajectoryCircularResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryCircularResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryCircularResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetVehicleTrajectoryCircularResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetVehicleTrajectoryCircularResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetVehicleTrajectoryCircularResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void GetVehicleTrajectoryCircularResult::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryCircularResult::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void GetVehicleTrajectoryCircularResult::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetVehicleTrajectoryCircularResult::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void GetVehicleTrajectoryCircularResult::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetVehicleTrajectoryCircularResult::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void GetVehicleTrajectoryCircularResult::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetVehicleTrajectoryOrbit
///
#include "gen/SetVehicleTrajectoryOrbit.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetVehicleTrajectoryOrbit::CmdName = "SetVehicleTrajectoryOrbit";
    const char* const SetVehicleTrajectoryOrbit::Documentation = "Set earth-orbiting spacecraft trajectory.";

    REGISTER_COMMAND_FACTORY(SetVehicleTrajectoryOrbit);


    SetVehicleTrajectoryOrbit::SetVehicleTrajectoryOrbit()
      : CommandBase(CmdName)
    {}

    SetVehicleTrajectoryOrbit::SetVehicleTrajectoryOrbit(const std::string& type, const Sdx::DateTime& reference, double semiMajorAxis, double inclination, double rightAscension, double eccentricity, double meanAnomaly, double argumentOfPerigee)
      : CommandBase(CmdName)
    {

      setType(type);
      setReference(reference);
      setSemiMajorAxis(semiMajorAxis);
      setInclination(inclination);
      setRightAscension(rightAscension);
      setEccentricity(eccentricity);
      setMeanAnomaly(meanAnomaly);
      setArgumentOfPerigee(argumentOfPerigee);
    }


    SetVehicleTrajectoryOrbitPtr SetVehicleTrajectoryOrbit::create(const std::string& type, const Sdx::DateTime& reference, double semiMajorAxis, double inclination, double rightAscension, double eccentricity, double meanAnomaly, double argumentOfPerigee)
    {
      return SetVehicleTrajectoryOrbitPtr(new SetVehicleTrajectoryOrbit(type, reference, semiMajorAxis, inclination, rightAscension, eccentricity, meanAnomaly, argumentOfPerigee));
    }

    SetVehicleTrajectoryOrbitPtr SetVehicleTrajectoryOrbit::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetVehicleTrajectoryOrbit>(ptr);
    }

    bool SetVehicleTrajectoryOrbit::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Reference"])
          && parse_json<double>::is_valid(m_values["SemiMajorAxis"])
          && parse_json<double>::is_valid(m_values["Inclination"])
          && parse_json<double>::is_valid(m_values["RightAscension"])
          && parse_json<double>::is_valid(m_values["Eccentricity"])
          && parse_json<double>::is_valid(m_values["MeanAnomaly"])
          && parse_json<double>::is_valid(m_values["ArgumentOfPerigee"])
        ;

    }

    std::string SetVehicleTrajectoryOrbit::documentation() const { return Documentation; }


    int SetVehicleTrajectoryOrbit::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetVehicleTrajectoryOrbit::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetVehicleTrajectoryOrbit::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetVehicleTrajectoryOrbit::reference() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Reference"]);
    }

    void SetVehicleTrajectoryOrbit::setReference(const Sdx::DateTime& reference)
    {
      m_values.AddMember("Reference", parse_json<Sdx::DateTime>::format(reference, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::semiMajorAxis() const
    {
      return parse_json<double>::parse(m_values["SemiMajorAxis"]);
    }

    void SetVehicleTrajectoryOrbit::setSemiMajorAxis(double semiMajorAxis)
    {
      m_values.AddMember("SemiMajorAxis", parse_json<double>::format(semiMajorAxis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::inclination() const
    {
      return parse_json<double>::parse(m_values["Inclination"]);
    }

    void SetVehicleTrajectoryOrbit::setInclination(double inclination)
    {
      m_values.AddMember("Inclination", parse_json<double>::format(inclination, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::rightAscension() const
    {
      return parse_json<double>::parse(m_values["RightAscension"]);
    }

    void SetVehicleTrajectoryOrbit::setRightAscension(double rightAscension)
    {
      m_values.AddMember("RightAscension", parse_json<double>::format(rightAscension, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::eccentricity() const
    {
      return parse_json<double>::parse(m_values["Eccentricity"]);
    }

    void SetVehicleTrajectoryOrbit::setEccentricity(double eccentricity)
    {
      m_values.AddMember("Eccentricity", parse_json<double>::format(eccentricity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::meanAnomaly() const
    {
      return parse_json<double>::parse(m_values["MeanAnomaly"]);
    }

    void SetVehicleTrajectoryOrbit::setMeanAnomaly(double meanAnomaly)
    {
      m_values.AddMember("MeanAnomaly", parse_json<double>::format(meanAnomaly, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetVehicleTrajectoryOrbit::argumentOfPerigee() const
    {
      return parse_json<double>::parse(m_values["ArgumentOfPerigee"]);
    }

    void SetVehicleTrajectoryOrbit::setArgumentOfPerigee(double argumentOfPerigee)
    {
      m_values.AddMember("ArgumentOfPerigee", parse_json<double>::format(argumentOfPerigee, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVehicleTrajectoryOrbit
///
#include "gen/GetVehicleTrajectoryOrbit.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryOrbit::CmdName = "GetVehicleTrajectoryOrbit";
    const char* const GetVehicleTrajectoryOrbit::Documentation = "Get earth-orbiting spacecraft trajectory.";

    REGISTER_COMMAND_FACTORY(GetVehicleTrajectoryOrbit);


    GetVehicleTrajectoryOrbit::GetVehicleTrajectoryOrbit()
      : CommandBase(CmdName)
    {

    }


    GetVehicleTrajectoryOrbitPtr GetVehicleTrajectoryOrbit::create()
    {
      return GetVehicleTrajectoryOrbitPtr(new GetVehicleTrajectoryOrbit());
    }

    GetVehicleTrajectoryOrbitPtr GetVehicleTrajectoryOrbit::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryOrbit>(ptr);
    }

    bool GetVehicleTrajectoryOrbit::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetVehicleTrajectoryOrbit::documentation() const { return Documentation; }


    int GetVehicleTrajectoryOrbit::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetVehicleTrajectoryOrbitResult
///
#include "gen/GetVehicleTrajectoryOrbitResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVehicleTrajectoryOrbitResult::CmdName = "GetVehicleTrajectoryOrbitResult";
    const char* const GetVehicleTrajectoryOrbitResult::Documentation = "Result of GetVehicleTrajectoryOrbit";

    REGISTER_COMMAND_RESULT_FACTORY(GetVehicleTrajectoryOrbitResult);


    GetVehicleTrajectoryOrbitResult::GetVehicleTrajectoryOrbitResult()
      : CommandResult(CmdName)
    {}

    GetVehicleTrajectoryOrbitResult::GetVehicleTrajectoryOrbitResult(CommandBasePtr relatedCommand, const std::string& type, const Sdx::DateTime& reference, double semiMajorAxis, double inclination, double rightAscension, double eccentricity, double meanAnomaly, double argumentOfPerigee)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setReference(reference);
      setSemiMajorAxis(semiMajorAxis);
      setInclination(inclination);
      setRightAscension(rightAscension);
      setEccentricity(eccentricity);
      setMeanAnomaly(meanAnomaly);
      setArgumentOfPerigee(argumentOfPerigee);
    }


    GetVehicleTrajectoryOrbitResultPtr GetVehicleTrajectoryOrbitResult::create(CommandBasePtr relatedCommand, const std::string& type, const Sdx::DateTime& reference, double semiMajorAxis, double inclination, double rightAscension, double eccentricity, double meanAnomaly, double argumentOfPerigee)
    {
      return GetVehicleTrajectoryOrbitResultPtr(new GetVehicleTrajectoryOrbitResult(relatedCommand, type, reference, semiMajorAxis, inclination, rightAscension, eccentricity, meanAnomaly, argumentOfPerigee));
    }

    GetVehicleTrajectoryOrbitResultPtr GetVehicleTrajectoryOrbitResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVehicleTrajectoryOrbitResult>(ptr);
    }

    bool GetVehicleTrajectoryOrbitResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Reference"])
          && parse_json<double>::is_valid(m_values["SemiMajorAxis"])
          && parse_json<double>::is_valid(m_values["Inclination"])
          && parse_json<double>::is_valid(m_values["RightAscension"])
          && parse_json<double>::is_valid(m_values["Eccentricity"])
          && parse_json<double>::is_valid(m_values["MeanAnomaly"])
          && parse_json<double>::is_valid(m_values["ArgumentOfPerigee"])
        ;

    }

    std::string GetVehicleTrajectoryOrbitResult::documentation() const { return Documentation; }


    std::string GetVehicleTrajectoryOrbitResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetVehicleTrajectoryOrbitResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime GetVehicleTrajectoryOrbitResult::reference() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Reference"]);
    }

    void GetVehicleTrajectoryOrbitResult::setReference(const Sdx::DateTime& reference)
    {
      m_values.AddMember("Reference", parse_json<Sdx::DateTime>::format(reference, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::semiMajorAxis() const
    {
      return parse_json<double>::parse(m_values["SemiMajorAxis"]);
    }

    void GetVehicleTrajectoryOrbitResult::setSemiMajorAxis(double semiMajorAxis)
    {
      m_values.AddMember("SemiMajorAxis", parse_json<double>::format(semiMajorAxis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::inclination() const
    {
      return parse_json<double>::parse(m_values["Inclination"]);
    }

    void GetVehicleTrajectoryOrbitResult::setInclination(double inclination)
    {
      m_values.AddMember("Inclination", parse_json<double>::format(inclination, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::rightAscension() const
    {
      return parse_json<double>::parse(m_values["RightAscension"]);
    }

    void GetVehicleTrajectoryOrbitResult::setRightAscension(double rightAscension)
    {
      m_values.AddMember("RightAscension", parse_json<double>::format(rightAscension, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::eccentricity() const
    {
      return parse_json<double>::parse(m_values["Eccentricity"]);
    }

    void GetVehicleTrajectoryOrbitResult::setEccentricity(double eccentricity)
    {
      m_values.AddMember("Eccentricity", parse_json<double>::format(eccentricity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::meanAnomaly() const
    {
      return parse_json<double>::parse(m_values["MeanAnomaly"]);
    }

    void GetVehicleTrajectoryOrbitResult::setMeanAnomaly(double meanAnomaly)
    {
      m_values.AddMember("MeanAnomaly", parse_json<double>::format(meanAnomaly, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetVehicleTrajectoryOrbitResult::argumentOfPerigee() const
    {
      return parse_json<double>::parse(m_values["ArgumentOfPerigee"]);
    }

    void GetVehicleTrajectoryOrbitResult::setArgumentOfPerigee(double argumentOfPerigee)
    {
      m_values.AddMember("ArgumentOfPerigee", parse_json<double>::format(argumentOfPerigee, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetHilPort
///
#include "gen/GetHilPort.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetHilPort::CmdName = "GetHilPort";
    const char* const GetHilPort::Documentation = "Get Hardware in the loop trajectory server port. Returns HilPortResult.";

    REGISTER_COMMAND_FACTORY(GetHilPort);


    GetHilPort::GetHilPort()
      : CommandBase(CmdName)
    {

    }


    GetHilPortPtr GetHilPort::create()
    {
      return GetHilPortPtr(new GetHilPort());
    }

    GetHilPortPtr GetHilPort::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetHilPort>(ptr);
    }

    bool GetHilPort::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetHilPort::documentation() const { return Documentation; }


    int GetHilPort::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of HilPortResult
///
#include "gen/HilPortResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const HilPortResult::CmdName = "HilPortResult";
    const char* const HilPortResult::Documentation = "Hardware in the loop server port.";

    REGISTER_COMMAND_RESULT_FACTORY(HilPortResult);


    HilPortResult::HilPortResult()
      : CommandResult(CmdName)
    {}

    HilPortResult::HilPortResult(CommandBasePtr relatedCommand, int port)
      : CommandResult(CmdName, relatedCommand)
    {

      setPort(port);
    }


    HilPortResultPtr HilPortResult::create(CommandBasePtr relatedCommand, int port)
    {
      return HilPortResultPtr(new HilPortResult(relatedCommand, port));
    }

    HilPortResultPtr HilPortResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<HilPortResult>(ptr);
    }

    bool HilPortResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Port"])
        ;

    }

    std::string HilPortResult::documentation() const { return Documentation; }


    int HilPortResult::port() const
    {
      return parse_json<int>::parse(m_values["Port"]);
    }

    void HilPortResult::setPort(int port)
    {
      m_values.AddMember("Port", parse_json<int>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetLastHilWarning
///
#include "gen/GetLastHilWarning.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLastHilWarning::CmdName = "GetLastHilWarning";
    const char* const GetLastHilWarning::Documentation = "Get last Hardware in the loop trajectory server warning message. Returns HilWarningResult.";

    REGISTER_COMMAND_FACTORY(GetLastHilWarning);


    GetLastHilWarning::GetLastHilWarning()
      : CommandBase(CmdName)
    {

    }


    GetLastHilWarningPtr GetLastHilWarning::create()
    {
      return GetLastHilWarningPtr(new GetLastHilWarning());
    }

    GetLastHilWarningPtr GetLastHilWarning::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLastHilWarning>(ptr);
    }

    bool GetLastHilWarning::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLastHilWarning::documentation() const { return Documentation; }


    int GetLastHilWarning::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of ResetHilWarning
///
#include "gen/ResetHilWarning.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetHilWarning::CmdName = "ResetHilWarning";
    const char* const ResetHilWarning::Documentation = "Reset Hardware in the loop trajectory server warning message.";

    REGISTER_COMMAND_FACTORY(ResetHilWarning);


    ResetHilWarning::ResetHilWarning()
      : CommandBase(CmdName)
    {

    }


    ResetHilWarningPtr ResetHilWarning::create()
    {
      return ResetHilWarningPtr(new ResetHilWarning());
    }

    ResetHilWarningPtr ResetHilWarning::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetHilWarning>(ptr);
    }

    bool ResetHilWarning::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ResetHilWarning::documentation() const { return Documentation; }


    int ResetHilWarning::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of HilWarningResult
///
#include "gen/HilWarningResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const HilWarningResult::CmdName = "HilWarningResult";
    const char* const HilWarningResult::Documentation = "Hardware in the loop server warning result ";

    REGISTER_COMMAND_RESULT_FACTORY(HilWarningResult);


    HilWarningResult::HilWarningResult()
      : CommandResult(CmdName)
    {}

    HilWarningResult::HilWarningResult(CommandBasePtr relatedCommand, bool isExtrapolated, int extrapolationTime)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsExtrapolated(isExtrapolated);
      setExtrapolationTime(extrapolationTime);
    }


    HilWarningResultPtr HilWarningResult::create(CommandBasePtr relatedCommand, bool isExtrapolated, int extrapolationTime)
    {
      return HilWarningResultPtr(new HilWarningResult(relatedCommand, isExtrapolated, extrapolationTime));
    }

    HilWarningResultPtr HilWarningResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<HilWarningResult>(ptr);
    }

    bool HilWarningResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsExtrapolated"])
          && parse_json<int>::is_valid(m_values["ExtrapolationTime"])
        ;

    }

    std::string HilWarningResult::documentation() const { return Documentation; }


    bool HilWarningResult::isExtrapolated() const
    {
      return parse_json<bool>::parse(m_values["IsExtrapolated"]);
    }

    void HilWarningResult::setIsExtrapolated(bool isExtrapolated)
    {
      m_values.AddMember("IsExtrapolated", parse_json<bool>::format(isExtrapolated, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int HilWarningResult::extrapolationTime() const
    {
      return parse_json<int>::parse(m_values["ExtrapolationTime"]);
    }

    void HilWarningResult::setExtrapolationTime(int extrapolationTime)
    {
      m_values.AddMember("ExtrapolationTime", parse_json<int>::format(extrapolationTime, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetEphemerisReferenceTimeForSV
///
#include "gen/SetEphemerisReferenceTimeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetEphemerisReferenceTimeForSV::CmdName = "SetEphemerisReferenceTimeForSV";
    const char* const SetEphemerisReferenceTimeForSV::Documentation = "Set the ephemeris reference time for the specified constellation.";

    REGISTER_COMMAND_FACTORY(SetEphemerisReferenceTimeForSV);


    SetEphemerisReferenceTimeForSV::SetEphemerisReferenceTimeForSV()
      : CommandBase(CmdName)
    {}

    SetEphemerisReferenceTimeForSV::SetEphemerisReferenceTimeForSV(const std::string& system, int svId, const Sdx::DateTime& time)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setTime(time);
    }


    SetEphemerisReferenceTimeForSVPtr SetEphemerisReferenceTimeForSV::create(const std::string& system, int svId, const Sdx::DateTime& time)
    {
      return SetEphemerisReferenceTimeForSVPtr(new SetEphemerisReferenceTimeForSV(system, svId, time));
    }

    SetEphemerisReferenceTimeForSVPtr SetEphemerisReferenceTimeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetEphemerisReferenceTimeForSV>(ptr);
    }

    bool SetEphemerisReferenceTimeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string SetEphemerisReferenceTimeForSV::documentation() const { return Documentation; }


    int SetEphemerisReferenceTimeForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetEphemerisReferenceTimeForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetEphemerisReferenceTimeForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetEphemerisReferenceTimeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetEphemerisReferenceTimeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetEphemerisReferenceTimeForSV::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void SetEphemerisReferenceTimeForSV::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetEphemerisReferenceTime
///
#include "gen/SetEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetEphemerisReferenceTime::CmdName = "SetEphemerisReferenceTime";
    const char* const SetEphemerisReferenceTime::Documentation = "Please note the command SetEphemerisReferenceTime is deprecated since 21.3. You may use SetEphemerisReferenceTimeForSV.\n\nSet the ephemeris reference time for the specified constellation.";

    REGISTER_COMMAND_FACTORY(SetEphemerisReferenceTime);


    SetEphemerisReferenceTime::SetEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    SetEphemerisReferenceTime::SetEphemerisReferenceTime(const std::string& system, int svId, const Sdx::DateTime& time)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setTime(time);
    }


    SetEphemerisReferenceTimePtr SetEphemerisReferenceTime::create(const std::string& system, int svId, const Sdx::DateTime& time)
    {
      return SetEphemerisReferenceTimePtr(new SetEphemerisReferenceTime(system, svId, time));
    }

    SetEphemerisReferenceTimePtr SetEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetEphemerisReferenceTime>(ptr);
    }

    bool SetEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string SetEphemerisReferenceTime::documentation() const { return Documentation; }


    int SetEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetEphemerisReferenceTime::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetEphemerisReferenceTime::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetEphemerisReferenceTime::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetEphemerisReferenceTime::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetEphemerisReferenceTime::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void SetEphemerisReferenceTime::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisReferenceTimeForSV
///
#include "gen/GetEphemerisReferenceTimeForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisReferenceTimeForSV::CmdName = "GetEphemerisReferenceTimeForSV";
    const char* const GetEphemerisReferenceTimeForSV::Documentation = "Get the ephemeris reference time for the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetEphemerisReferenceTimeForSV);


    GetEphemerisReferenceTimeForSV::GetEphemerisReferenceTimeForSV()
      : CommandBase(CmdName)
    {}

    GetEphemerisReferenceTimeForSV::GetEphemerisReferenceTimeForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetEphemerisReferenceTimeForSVPtr GetEphemerisReferenceTimeForSV::create(const std::string& system, int svId)
    {
      return GetEphemerisReferenceTimeForSVPtr(new GetEphemerisReferenceTimeForSV(system, svId));
    }

    GetEphemerisReferenceTimeForSVPtr GetEphemerisReferenceTimeForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisReferenceTimeForSV>(ptr);
    }

    bool GetEphemerisReferenceTimeForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetEphemerisReferenceTimeForSV::documentation() const { return Documentation; }


    int GetEphemerisReferenceTimeForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetEphemerisReferenceTimeForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisReferenceTimeForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisReferenceTimeForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisReferenceTimeForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisReferenceTime
///
#include "gen/GetEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisReferenceTime::CmdName = "GetEphemerisReferenceTime";
    const char* const GetEphemerisReferenceTime::Documentation = "Please note the command GetEphemerisReferenceTime is deprecated since 21.3. You may use GetEphemerisReferenceTimeForSV.\n\nGet the ephemeris reference time for the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetEphemerisReferenceTime);


    GetEphemerisReferenceTime::GetEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    GetEphemerisReferenceTime::GetEphemerisReferenceTime(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetEphemerisReferenceTimePtr GetEphemerisReferenceTime::create(const std::string& system, int svId)
    {
      return GetEphemerisReferenceTimePtr(new GetEphemerisReferenceTime(system, svId));
    }

    GetEphemerisReferenceTimePtr GetEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisReferenceTime>(ptr);
    }

    bool GetEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetEphemerisReferenceTime::documentation() const { return Documentation; }


    int GetEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetEphemerisReferenceTime::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisReferenceTime::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisReferenceTime::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisReferenceTime::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisReferenceTimeForSVResult
///
#include "gen/GetEphemerisReferenceTimeForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisReferenceTimeForSVResult::CmdName = "GetEphemerisReferenceTimeForSVResult";
    const char* const GetEphemerisReferenceTimeForSVResult::Documentation = "Result of GetEphemerisReferenceTimeForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetEphemerisReferenceTimeForSVResult);


    GetEphemerisReferenceTimeForSVResult::GetEphemerisReferenceTimeForSVResult()
      : CommandResult(CmdName)
    {}

    GetEphemerisReferenceTimeForSVResult::GetEphemerisReferenceTimeForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::DateTime& time)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setTime(time);
    }


    GetEphemerisReferenceTimeForSVResultPtr GetEphemerisReferenceTimeForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::DateTime& time)
    {
      return GetEphemerisReferenceTimeForSVResultPtr(new GetEphemerisReferenceTimeForSVResult(relatedCommand, system, svId, time));
    }

    GetEphemerisReferenceTimeForSVResultPtr GetEphemerisReferenceTimeForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisReferenceTimeForSVResult>(ptr);
    }

    bool GetEphemerisReferenceTimeForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string GetEphemerisReferenceTimeForSVResult::documentation() const { return Documentation; }


    std::string GetEphemerisReferenceTimeForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisReferenceTimeForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisReferenceTimeForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisReferenceTimeForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime GetEphemerisReferenceTimeForSVResult::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void GetEphemerisReferenceTimeForSVResult::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphDoubleParamForSV
///
#include "gen/SetGpsEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphDoubleParamForSV::CmdName = "SetGpsEphDoubleParamForSV";
    const char* const SetGpsEphDoubleParamForSV::Documentation = "Set various parameters in the GPS ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"IscL1Ca\"         sec\n  \"IscL2C\"          sec\n  \"IscL5I5\"         sec\n  \"IscL5Q5\"         sec\n  \"IscL1CP\"         sec\n  \"IscL1CD\"         sec";

    REGISTER_COMMAND_FACTORY(SetGpsEphDoubleParamForSV);


    SetGpsEphDoubleParamForSV::SetGpsEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetGpsEphDoubleParamForSV::SetGpsEphDoubleParamForSV(int svId, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetGpsEphDoubleParamForSVPtr SetGpsEphDoubleParamForSV::create(int svId, const std::string& paramName, double val)
    {
      return SetGpsEphDoubleParamForSVPtr(new SetGpsEphDoubleParamForSV(svId, paramName, val));
    }

    SetGpsEphDoubleParamForSVPtr SetGpsEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphDoubleParamForSV>(ptr);
    }

    bool SetGpsEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGpsEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetGpsEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGpsEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGpsEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetGpsEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphDoubleParamForSV
///
#include "gen/GetGpsEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphDoubleParamForSV::CmdName = "GetGpsEphDoubleParamForSV";
    const char* const GetGpsEphDoubleParamForSV::Documentation = "Get various parameters in the GPS ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"IscL1Ca\"         sec\n  \"IscL2C\"          sec\n  \"IscL5I5\"         sec\n  \"IscL5Q5\"         sec\n  \"IscL1CP\"         sec\n  \"IscL1CD\"         sec";

    REGISTER_COMMAND_FACTORY(GetGpsEphDoubleParamForSV);


    GetGpsEphDoubleParamForSV::GetGpsEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetGpsEphDoubleParamForSV::GetGpsEphDoubleParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetGpsEphDoubleParamForSVPtr GetGpsEphDoubleParamForSV::create(int svId, const std::string& paramName)
    {
      return GetGpsEphDoubleParamForSVPtr(new GetGpsEphDoubleParamForSV(svId, paramName));
    }

    GetGpsEphDoubleParamForSVPtr GetGpsEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphDoubleParamForSV>(ptr);
    }

    bool GetGpsEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGpsEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetGpsEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphDoubleParamForSVResult
///
#include "gen/GetGpsEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphDoubleParamForSVResult::CmdName = "GetGpsEphDoubleParamForSVResult";
    const char* const GetGpsEphDoubleParamForSVResult::Documentation = "Result of GetGpsEphDoubleParamForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphDoubleParamForSVResult);


    GetGpsEphDoubleParamForSVResult::GetGpsEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphDoubleParamForSVResult::GetGpsEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetGpsEphDoubleParamForSVResultPtr GetGpsEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
    {
      return GetGpsEphDoubleParamForSVResultPtr(new GetGpsEphDoubleParamForSVResult(relatedCommand, svId, paramName, val));
    }

    GetGpsEphDoubleParamForSVResultPtr GetGpsEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphDoubleParamForSVResult>(ptr);
    }

    bool GetGpsEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGpsEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetGpsEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGpsEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetGpsEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoEphDoubleParamForSV
///
#include "gen/SetGalileoEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoEphDoubleParamForSV::CmdName = "SetGalileoEphDoubleParamForSV";
    const char* const SetGalileoEphDoubleParamForSV::Documentation = "Set various parameters in the Galileo ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"BgdE1E5a\"        ns\n  \"BgdE1E5b\"        ns";

    REGISTER_COMMAND_FACTORY(SetGalileoEphDoubleParamForSV);


    SetGalileoEphDoubleParamForSV::SetGalileoEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoEphDoubleParamForSV::SetGalileoEphDoubleParamForSV(int svId, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetGalileoEphDoubleParamForSVPtr SetGalileoEphDoubleParamForSV::create(int svId, const std::string& paramName, double val)
    {
      return SetGalileoEphDoubleParamForSVPtr(new SetGalileoEphDoubleParamForSV(svId, paramName, val));
    }

    SetGalileoEphDoubleParamForSVPtr SetGalileoEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoEphDoubleParamForSV>(ptr);
    }

    bool SetGalileoEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGalileoEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetGalileoEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGalileoEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGalileoEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGalileoEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGalileoEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetGalileoEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphDoubleParamForSV
///
#include "gen/GetGalileoEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphDoubleParamForSV::CmdName = "GetGalileoEphDoubleParamForSV";
    const char* const GetGalileoEphDoubleParamForSV::Documentation = "Get various parameters in the Galileo ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"BgdE1E5a\"        ns\n  \"BgdE1E5b\"        ns";

    REGISTER_COMMAND_FACTORY(GetGalileoEphDoubleParamForSV);


    GetGalileoEphDoubleParamForSV::GetGalileoEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetGalileoEphDoubleParamForSV::GetGalileoEphDoubleParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetGalileoEphDoubleParamForSVPtr GetGalileoEphDoubleParamForSV::create(int svId, const std::string& paramName)
    {
      return GetGalileoEphDoubleParamForSVPtr(new GetGalileoEphDoubleParamForSV(svId, paramName));
    }

    GetGalileoEphDoubleParamForSVPtr GetGalileoEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphDoubleParamForSV>(ptr);
    }

    bool GetGalileoEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGalileoEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetGalileoEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphDoubleParamForSVResult
///
#include "gen/GetGalileoEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphDoubleParamForSVResult::CmdName = "GetGalileoEphDoubleParamForSVResult";
    const char* const GetGalileoEphDoubleParamForSVResult::Documentation = "Result of GetGalileoEphDoubleParamForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoEphDoubleParamForSVResult);


    GetGalileoEphDoubleParamForSVResult::GetGalileoEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetGalileoEphDoubleParamForSVResult::GetGalileoEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetGalileoEphDoubleParamForSVResultPtr GetGalileoEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
    {
      return GetGalileoEphDoubleParamForSVResultPtr(new GetGalileoEphDoubleParamForSVResult(relatedCommand, svId, paramName, val));
    }

    GetGalileoEphDoubleParamForSVResultPtr GetGalileoEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphDoubleParamForSVResult>(ptr);
    }

    bool GetGalileoEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGalileoEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetGalileoEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGalileoEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGalileoEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetGalileoEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphDoubleParamForSV
///
#include "gen/SetBeiDouEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphDoubleParamForSV::CmdName = "SetBeiDouEphDoubleParamForSV";
    const char* const SetBeiDouEphDoubleParamForSV::Documentation = "Set various parameters in the BeiDou ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd1\"            sec\n  \"Tgd2\"            sec\n  \"TgdB1Cp\"         sec\n  \"TgdB2Ap\"         sec";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphDoubleParamForSV);


    SetBeiDouEphDoubleParamForSV::SetBeiDouEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphDoubleParamForSV::SetBeiDouEphDoubleParamForSV(int svId, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetBeiDouEphDoubleParamForSVPtr SetBeiDouEphDoubleParamForSV::create(int svId, const std::string& paramName, double val)
    {
      return SetBeiDouEphDoubleParamForSVPtr(new SetBeiDouEphDoubleParamForSV(svId, paramName, val));
    }

    SetBeiDouEphDoubleParamForSVPtr SetBeiDouEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphDoubleParamForSV>(ptr);
    }

    bool SetBeiDouEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetBeiDouEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetBeiDouEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetBeiDouEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetBeiDouEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetBeiDouEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetBeiDouEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphDoubleParamForSV
///
#include "gen/GetBeiDouEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphDoubleParamForSV::CmdName = "GetBeiDouEphDoubleParamForSV";
    const char* const GetBeiDouEphDoubleParamForSV::Documentation = "Get various parameters in the BeiDou ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd1\"            sec\n  \"Tgd2\"            sec\n  \"TgdB1Cp\"         sec\n  \"TgdB2Ap\"         sec";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphDoubleParamForSV);


    GetBeiDouEphDoubleParamForSV::GetBeiDouEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphDoubleParamForSV::GetBeiDouEphDoubleParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetBeiDouEphDoubleParamForSVPtr GetBeiDouEphDoubleParamForSV::create(int svId, const std::string& paramName)
    {
      return GetBeiDouEphDoubleParamForSVPtr(new GetBeiDouEphDoubleParamForSV(svId, paramName));
    }

    GetBeiDouEphDoubleParamForSVPtr GetBeiDouEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphDoubleParamForSV>(ptr);
    }

    bool GetBeiDouEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetBeiDouEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetBeiDouEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphDoubleParamForSVResult
///
#include "gen/GetBeiDouEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphDoubleParamForSVResult::CmdName = "GetBeiDouEphDoubleParamForSVResult";
    const char* const GetBeiDouEphDoubleParamForSVResult::Documentation = "Result of GetBeiDouEphDoubleParamForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphDoubleParamForSVResult);


    GetBeiDouEphDoubleParamForSVResult::GetBeiDouEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphDoubleParamForSVResult::GetBeiDouEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetBeiDouEphDoubleParamForSVResultPtr GetBeiDouEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
    {
      return GetBeiDouEphDoubleParamForSVResultPtr(new GetBeiDouEphDoubleParamForSVResult(relatedCommand, svId, paramName, val));
    }

    GetBeiDouEphDoubleParamForSVResultPtr GetBeiDouEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphDoubleParamForSVResult>(ptr);
    }

    bool GetBeiDouEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetBeiDouEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetBeiDouEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetBeiDouEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetBeiDouEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassEphDoubleParamForSV
///
#include "gen/SetGlonassEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassEphDoubleParamForSV::CmdName = "SetGlonassEphDoubleParamForSV";
    const char* const SetGlonassEphDoubleParamForSV::Documentation = "Set various parameters for GLONASS\n\n  ParamName       Unit               Range          Description\n  \"TauC\"          sec                +/- 1          GLONASS time scale correction to UTC(SU) time\n  \"TauGps\"        day                +/- 1.9x10^-3  Correction to GPS time relative to GLONASS time\n  \"TauN\"          sec                +/- 1.9x10^-3  Coarse value of satellite time correction to GLONASS time\n  \"TLambda\"       sec                0..44100       Time of the first ascending node passage\n  \"Lambda\"        semicircle         +/- 1          Longitude of the first ascending node\n  \"DeltaI\"        semicircle         +/- 0.067      Correction to the mean value of inclination\n  \"Omega\"         semicircle         +/- 1          Argument of perigee\n  \"Eccentricity\"  -                  0..0.03        Eccentricity\n  \"DeltaT\"        sec/orb. period    +/- 3.6x10^3   Correction to the mean value of Draconian period\n  \"DeltaTRate\"    sec/orb. period^2  +/- 2^-8       Rate of change of Draconian period";

    REGISTER_COMMAND_FACTORY(SetGlonassEphDoubleParamForSV);


    SetGlonassEphDoubleParamForSV::SetGlonassEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetGlonassEphDoubleParamForSV::SetGlonassEphDoubleParamForSV(int svId, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetGlonassEphDoubleParamForSVPtr SetGlonassEphDoubleParamForSV::create(int svId, const std::string& paramName, double val)
    {
      return SetGlonassEphDoubleParamForSVPtr(new SetGlonassEphDoubleParamForSV(svId, paramName, val));
    }

    SetGlonassEphDoubleParamForSVPtr SetGlonassEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassEphDoubleParamForSV>(ptr);
    }

    bool SetGlonassEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGlonassEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetGlonassEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGlonassEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGlonassEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGlonassEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGlonassEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGlonassEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetGlonassEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphDoubleParamForSV
///
#include "gen/GetGlonassEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphDoubleParamForSV::CmdName = "GetGlonassEphDoubleParamForSV";
    const char* const GetGlonassEphDoubleParamForSV::Documentation = "Get various parameters for GLONASS\n\n  ParamName       Unit               Range          Description\n  \"TauC\"          sec                +/- 1          GLONASS time scale correction to UTC(SU) time\n  \"TauGps\"        day                +/- 1.9x10^-3  Correction to GPS time relative to GLONASS time\n  \"TauN\"          sec                +/- 1.9x10^-3  Coarse value of satellite time correction to GLONASS time\n  \"TLambda\"       sec                0..44100       Time of the first ascending node passage\n  \"Lambda\"        semicircle         +/- 1          Longitude of the first ascending node\n  \"DeltaI\"        semicircle         +/- 0.067      Correction to the mean value of inclination\n  \"Omega\"         semicircle         +/- 1          Argument of perigee\n  \"Eccentricity\"  -                  0..0.03        Eccentricity\n  \"DeltaT\"        sec/orb. period    +/- 3.6x10^3   Correction to the mean value of Draconian period\n  \"DeltaTRate\"    sec/orb. period^2  +/- 2^-8       Rate of change of Draconian period";

    REGISTER_COMMAND_FACTORY(GetGlonassEphDoubleParamForSV);


    GetGlonassEphDoubleParamForSV::GetGlonassEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetGlonassEphDoubleParamForSV::GetGlonassEphDoubleParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetGlonassEphDoubleParamForSVPtr GetGlonassEphDoubleParamForSV::create(int svId, const std::string& paramName)
    {
      return GetGlonassEphDoubleParamForSVPtr(new GetGlonassEphDoubleParamForSV(svId, paramName));
    }

    GetGlonassEphDoubleParamForSVPtr GetGlonassEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphDoubleParamForSV>(ptr);
    }

    bool GetGlonassEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGlonassEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetGlonassEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGlonassEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphDoubleParamForSVResult
///
#include "gen/GetGlonassEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphDoubleParamForSVResult::CmdName = "GetGlonassEphDoubleParamForSVResult";
    const char* const GetGlonassEphDoubleParamForSVResult::Documentation = "Result of GetGlonassEphDoubleParamForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassEphDoubleParamForSVResult);


    GetGlonassEphDoubleParamForSVResult::GetGlonassEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetGlonassEphDoubleParamForSVResult::GetGlonassEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetGlonassEphDoubleParamForSVResultPtr GetGlonassEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
    {
      return GetGlonassEphDoubleParamForSVResultPtr(new GetGlonassEphDoubleParamForSVResult(relatedCommand, svId, paramName, val));
    }

    GetGlonassEphDoubleParamForSVResultPtr GetGlonassEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphDoubleParamForSVResult>(ptr);
    }

    bool GetGlonassEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGlonassEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetGlonassEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGlonassEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGlonassEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGlonassEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetGlonassEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphDoubleParamForSV
///
#include "gen/SetQzssEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphDoubleParamForSV::CmdName = "SetQzssEphDoubleParamForSV";
    const char* const SetQzssEphDoubleParamForSV::Documentation = "Set various parameters in the QZSS ephemeris.";

    REGISTER_COMMAND_FACTORY(SetQzssEphDoubleParamForSV);


    SetQzssEphDoubleParamForSV::SetQzssEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetQzssEphDoubleParamForSV::SetQzssEphDoubleParamForSV(int svId, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetQzssEphDoubleParamForSVPtr SetQzssEphDoubleParamForSV::create(int svId, const std::string& paramName, double val)
    {
      return SetQzssEphDoubleParamForSVPtr(new SetQzssEphDoubleParamForSV(svId, paramName, val));
    }

    SetQzssEphDoubleParamForSVPtr SetQzssEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphDoubleParamForSV>(ptr);
    }

    bool SetQzssEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetQzssEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetQzssEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetQzssEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphemerisDoubleParam
///
#include "gen/SetQzssEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphemerisDoubleParam::CmdName = "SetQzssEphemerisDoubleParam";
    const char* const SetQzssEphemerisDoubleParam::Documentation = "Please note the command SetQzssEphemerisDoubleParam is deprecated since 21.3. You may use SetQzssEphDoubleParamForSV.\n\nSet various parameters in the QZSS ephemeris.";

    REGISTER_COMMAND_FACTORY(SetQzssEphemerisDoubleParam);


    SetQzssEphemerisDoubleParam::SetQzssEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    SetQzssEphemerisDoubleParam::SetQzssEphemerisDoubleParam(int svId, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetQzssEphemerisDoubleParamPtr SetQzssEphemerisDoubleParam::create(int svId, const std::string& paramName, double val)
    {
      return SetQzssEphemerisDoubleParamPtr(new SetQzssEphemerisDoubleParam(svId, paramName, val));
    }

    SetQzssEphemerisDoubleParamPtr SetQzssEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphemerisDoubleParam>(ptr);
    }

    bool SetQzssEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetQzssEphemerisDoubleParam::documentation() const { return Documentation; }


    int SetQzssEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssEphemerisDoubleParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssEphemerisDoubleParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssEphemerisDoubleParam::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetQzssEphemerisDoubleParam::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphDoubleParamForSV
///
#include "gen/GetQzssEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphDoubleParamForSV::CmdName = "GetQzssEphDoubleParamForSV";
    const char* const GetQzssEphDoubleParamForSV::Documentation = "Get various parameters in the QZSS ephemeris.";

    REGISTER_COMMAND_FACTORY(GetQzssEphDoubleParamForSV);


    GetQzssEphDoubleParamForSV::GetQzssEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetQzssEphDoubleParamForSV::GetQzssEphDoubleParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetQzssEphDoubleParamForSVPtr GetQzssEphDoubleParamForSV::create(int svId, const std::string& paramName)
    {
      return GetQzssEphDoubleParamForSVPtr(new GetQzssEphDoubleParamForSV(svId, paramName));
    }

    GetQzssEphDoubleParamForSVPtr GetQzssEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphDoubleParamForSV>(ptr);
    }

    bool GetQzssEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetQzssEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetQzssEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisDoubleParam
///
#include "gen/GetQzssEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisDoubleParam::CmdName = "GetQzssEphemerisDoubleParam";
    const char* const GetQzssEphemerisDoubleParam::Documentation = "Please note the command GetQzssEphemerisDoubleParam is deprecated since 21.3. You may use GetQzssEphDoubleParamForSV.\n\nGet various parameters in the QZSS ephemeris.";

    REGISTER_COMMAND_FACTORY(GetQzssEphemerisDoubleParam);


    GetQzssEphemerisDoubleParam::GetQzssEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    GetQzssEphemerisDoubleParam::GetQzssEphemerisDoubleParam(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetQzssEphemerisDoubleParamPtr GetQzssEphemerisDoubleParam::create(int svId, const std::string& paramName)
    {
      return GetQzssEphemerisDoubleParamPtr(new GetQzssEphemerisDoubleParam(svId, paramName));
    }

    GetQzssEphemerisDoubleParamPtr GetQzssEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisDoubleParam>(ptr);
    }

    bool GetQzssEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetQzssEphemerisDoubleParam::documentation() const { return Documentation; }


    int GetQzssEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssEphemerisDoubleParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphemerisDoubleParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphDoubleParamForSVResult
///
#include "gen/GetQzssEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphDoubleParamForSVResult::CmdName = "GetQzssEphDoubleParamForSVResult";
    const char* const GetQzssEphDoubleParamForSVResult::Documentation = "Result of GetQzssEphDoubleParamForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssEphDoubleParamForSVResult);


    GetQzssEphDoubleParamForSVResult::GetQzssEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssEphDoubleParamForSVResult::GetQzssEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetQzssEphDoubleParamForSVResultPtr GetQzssEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
    {
      return GetQzssEphDoubleParamForSVResultPtr(new GetQzssEphDoubleParamForSVResult(relatedCommand, svId, paramName, val));
    }

    GetQzssEphDoubleParamForSVResultPtr GetQzssEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphDoubleParamForSVResult>(ptr);
    }

    bool GetQzssEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetQzssEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetQzssEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetQzssEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICEphDoubleParamForSV
///
#include "gen/SetNavICEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICEphDoubleParamForSV::CmdName = "SetNavICEphDoubleParamForSV";
    const char* const SetNavICEphDoubleParamForSV::Documentation = "Set various parameters in the NavIC ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec";

    REGISTER_COMMAND_FACTORY(SetNavICEphDoubleParamForSV);


    SetNavICEphDoubleParamForSV::SetNavICEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    SetNavICEphDoubleParamForSV::SetNavICEphDoubleParamForSV(int svId, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetNavICEphDoubleParamForSVPtr SetNavICEphDoubleParamForSV::create(int svId, const std::string& paramName, double val)
    {
      return SetNavICEphDoubleParamForSVPtr(new SetNavICEphDoubleParamForSV(svId, paramName, val));
    }

    SetNavICEphDoubleParamForSVPtr SetNavICEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICEphDoubleParamForSV>(ptr);
    }

    bool SetNavICEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetNavICEphDoubleParamForSV::documentation() const { return Documentation; }


    int SetNavICEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetNavICEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetNavICEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetNavICEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetNavICEphDoubleParamForSV::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetNavICEphDoubleParamForSV::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICEphemerisDoubleParam
///
#include "gen/SetNavICEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICEphemerisDoubleParam::CmdName = "SetNavICEphemerisDoubleParam";
    const char* const SetNavICEphemerisDoubleParam::Documentation = "Please note the command SetNavICEphemerisDoubleParam is deprecated since 21.3. You may use SetNavICEphDoubleParamForSV.\n\nSet various parameters in the NavIC ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec";

    REGISTER_COMMAND_FACTORY(SetNavICEphemerisDoubleParam);


    SetNavICEphemerisDoubleParam::SetNavICEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    SetNavICEphemerisDoubleParam::SetNavICEphemerisDoubleParam(int svId, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetNavICEphemerisDoubleParamPtr SetNavICEphemerisDoubleParam::create(int svId, const std::string& paramName, double val)
    {
      return SetNavICEphemerisDoubleParamPtr(new SetNavICEphemerisDoubleParam(svId, paramName, val));
    }

    SetNavICEphemerisDoubleParamPtr SetNavICEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICEphemerisDoubleParam>(ptr);
    }

    bool SetNavICEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetNavICEphemerisDoubleParam::documentation() const { return Documentation; }


    int SetNavICEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetNavICEphemerisDoubleParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICEphemerisDoubleParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetNavICEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetNavICEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetNavICEphemerisDoubleParam::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetNavICEphemerisDoubleParam::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphDoubleParamForSV
///
#include "gen/GetNavICEphDoubleParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphDoubleParamForSV::CmdName = "GetNavICEphDoubleParamForSV";
    const char* const GetNavICEphDoubleParamForSV::Documentation = "Get various parameters in the NavIC ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec";

    REGISTER_COMMAND_FACTORY(GetNavICEphDoubleParamForSV);


    GetNavICEphDoubleParamForSV::GetNavICEphDoubleParamForSV()
      : CommandBase(CmdName)
    {}

    GetNavICEphDoubleParamForSV::GetNavICEphDoubleParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetNavICEphDoubleParamForSVPtr GetNavICEphDoubleParamForSV::create(int svId, const std::string& paramName)
    {
      return GetNavICEphDoubleParamForSVPtr(new GetNavICEphDoubleParamForSV(svId, paramName));
    }

    GetNavICEphDoubleParamForSVPtr GetNavICEphDoubleParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphDoubleParamForSV>(ptr);
    }

    bool GetNavICEphDoubleParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetNavICEphDoubleParamForSV::documentation() const { return Documentation; }


    int GetNavICEphDoubleParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICEphDoubleParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICEphDoubleParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetNavICEphDoubleParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphDoubleParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphemerisDoubleParam
///
#include "gen/GetNavICEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphemerisDoubleParam::CmdName = "GetNavICEphemerisDoubleParam";
    const char* const GetNavICEphemerisDoubleParam::Documentation = "Please note the command GetNavICEphemerisDoubleParam is deprecated since 21.3. You may use GetNavICEphDoubleParamForSV.\n\nGet various parameters in the NavIC ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec";

    REGISTER_COMMAND_FACTORY(GetNavICEphemerisDoubleParam);


    GetNavICEphemerisDoubleParam::GetNavICEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    GetNavICEphemerisDoubleParam::GetNavICEphemerisDoubleParam(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetNavICEphemerisDoubleParamPtr GetNavICEphemerisDoubleParam::create(int svId, const std::string& paramName)
    {
      return GetNavICEphemerisDoubleParamPtr(new GetNavICEphemerisDoubleParam(svId, paramName));
    }

    GetNavICEphemerisDoubleParamPtr GetNavICEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphemerisDoubleParam>(ptr);
    }

    bool GetNavICEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetNavICEphemerisDoubleParam::documentation() const { return Documentation; }


    int GetNavICEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetNavICEphemerisDoubleParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICEphemerisDoubleParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetNavICEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphDoubleParamForSVResult
///
#include "gen/GetNavICEphDoubleParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphDoubleParamForSVResult::CmdName = "GetNavICEphDoubleParamForSVResult";
    const char* const GetNavICEphDoubleParamForSVResult::Documentation = "Result of GetNavICEphDoubleParamForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetNavICEphDoubleParamForSVResult);


    GetNavICEphDoubleParamForSVResult::GetNavICEphDoubleParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetNavICEphDoubleParamForSVResult::GetNavICEphDoubleParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetNavICEphDoubleParamForSVResultPtr GetNavICEphDoubleParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, double val)
    {
      return GetNavICEphDoubleParamForSVResultPtr(new GetNavICEphDoubleParamForSVResult(relatedCommand, svId, paramName, val));
    }

    GetNavICEphDoubleParamForSVResultPtr GetNavICEphDoubleParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphDoubleParamForSVResult>(ptr);
    }

    bool GetNavICEphDoubleParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetNavICEphDoubleParamForSVResult::documentation() const { return Documentation; }


    int GetNavICEphDoubleParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICEphDoubleParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetNavICEphDoubleParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphDoubleParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetNavICEphDoubleParamForSVResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetNavICEphDoubleParamForSVResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphDoubleParamForEachSV
///
#include "gen/SetGpsEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphDoubleParamForEachSV::CmdName = "SetGpsEphDoubleParamForEachSV";
    const char* const SetGpsEphDoubleParamForEachSV::Documentation = "Set GPS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGpsEphDoubleParamForEachSV);


    SetGpsEphDoubleParamForEachSV::SetGpsEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetGpsEphDoubleParamForEachSV::SetGpsEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGpsEphDoubleParamForEachSVPtr SetGpsEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetGpsEphDoubleParamForEachSVPtr(new SetGpsEphDoubleParamForEachSV(paramName, val));
    }

    SetGpsEphDoubleParamForEachSVPtr SetGpsEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphDoubleParamForEachSV>(ptr);
    }

    bool SetGpsEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGpsEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetGpsEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGpsEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGpsEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphemerisDoubleParams
///
#include "gen/SetGpsEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphemerisDoubleParams::CmdName = "SetGpsEphemerisDoubleParams";
    const char* const SetGpsEphemerisDoubleParams::Documentation = "Please note the command SetGpsEphemerisDoubleParams is deprecated since 21.3. You may use SetGpsEphDoubleParamForEachSV.\n\nSet GPS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGpsEphemerisDoubleParams);


    SetGpsEphemerisDoubleParams::SetGpsEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetGpsEphemerisDoubleParams::SetGpsEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGpsEphemerisDoubleParamsPtr SetGpsEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetGpsEphemerisDoubleParamsPtr(new SetGpsEphemerisDoubleParams(paramName, val));
    }

    SetGpsEphemerisDoubleParamsPtr SetGpsEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphemerisDoubleParams>(ptr);
    }

    bool SetGpsEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGpsEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetGpsEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGpsEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGpsEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphDoubleParamForEachSV
///
#include "gen/GetGpsEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphDoubleParamForEachSV::CmdName = "GetGpsEphDoubleParamForEachSV";
    const char* const GetGpsEphDoubleParamForEachSV::Documentation = "Get GPS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGpsEphDoubleParamForEachSV);


    GetGpsEphDoubleParamForEachSV::GetGpsEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetGpsEphDoubleParamForEachSV::GetGpsEphDoubleParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGpsEphDoubleParamForEachSVPtr GetGpsEphDoubleParamForEachSV::create(const std::string& paramName)
    {
      return GetGpsEphDoubleParamForEachSVPtr(new GetGpsEphDoubleParamForEachSV(paramName));
    }

    GetGpsEphDoubleParamForEachSVPtr GetGpsEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphDoubleParamForEachSV>(ptr);
    }

    bool GetGpsEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGpsEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetGpsEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisDoubleParams
///
#include "gen/GetGpsEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisDoubleParams::CmdName = "GetGpsEphemerisDoubleParams";
    const char* const GetGpsEphemerisDoubleParams::Documentation = "Please note the command GetGpsEphemerisDoubleParams is deprecated since 21.3. You may use GetGpsEphDoubleParamForEachSV.\n\nGet GPS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGpsEphemerisDoubleParams);


    GetGpsEphemerisDoubleParams::GetGpsEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetGpsEphemerisDoubleParams::GetGpsEphemerisDoubleParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGpsEphemerisDoubleParamsPtr GetGpsEphemerisDoubleParams::create(const std::string& paramName)
    {
      return GetGpsEphemerisDoubleParamsPtr(new GetGpsEphemerisDoubleParams(paramName));
    }

    GetGpsEphemerisDoubleParamsPtr GetGpsEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisDoubleParams>(ptr);
    }

    bool GetGpsEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGpsEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetGpsEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphDoubleParamForEachSVResult
///
#include "gen/GetGpsEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphDoubleParamForEachSVResult::CmdName = "GetGpsEphDoubleParamForEachSVResult";
    const char* const GetGpsEphDoubleParamForEachSVResult::Documentation = "Result of GetGpsEphDoubleParamForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphDoubleParamForEachSVResult);


    GetGpsEphDoubleParamForEachSVResult::GetGpsEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphDoubleParamForEachSVResult::GetGpsEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetGpsEphDoubleParamForEachSVResultPtr GetGpsEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
    {
      return GetGpsEphDoubleParamForEachSVResultPtr(new GetGpsEphDoubleParamForEachSVResult(relatedCommand, paramName, val));
    }

    GetGpsEphDoubleParamForEachSVResultPtr GetGpsEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetGpsEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGpsEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetGpsEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGpsEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetGpsEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoEphDoubleParamForEachSV
///
#include "gen/SetGalileoEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoEphDoubleParamForEachSV::CmdName = "SetGalileoEphDoubleParamForEachSV";
    const char* const SetGalileoEphDoubleParamForEachSV::Documentation = "Set Galileo ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGalileoEphDoubleParamForEachSV);


    SetGalileoEphDoubleParamForEachSV::SetGalileoEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetGalileoEphDoubleParamForEachSV::SetGalileoEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGalileoEphDoubleParamForEachSVPtr SetGalileoEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetGalileoEphDoubleParamForEachSVPtr(new SetGalileoEphDoubleParamForEachSV(paramName, val));
    }

    SetGalileoEphDoubleParamForEachSVPtr SetGalileoEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoEphDoubleParamForEachSV>(ptr);
    }

    bool SetGalileoEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGalileoEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetGalileoEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGalileoEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGalileoEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGalileoEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGalileoEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoEphemerisDoubleParams
///
#include "gen/SetGalileoEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoEphemerisDoubleParams::CmdName = "SetGalileoEphemerisDoubleParams";
    const char* const SetGalileoEphemerisDoubleParams::Documentation = "Please note the command SetGalileoEphemerisDoubleParams is deprecated since 21.3. You may use SetGalileoEphDoubleParamForEachSV.\n\nSet Galileo ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGalileoEphemerisDoubleParams);


    SetGalileoEphemerisDoubleParams::SetGalileoEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetGalileoEphemerisDoubleParams::SetGalileoEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGalileoEphemerisDoubleParamsPtr SetGalileoEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetGalileoEphemerisDoubleParamsPtr(new SetGalileoEphemerisDoubleParams(paramName, val));
    }

    SetGalileoEphemerisDoubleParamsPtr SetGalileoEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoEphemerisDoubleParams>(ptr);
    }

    bool SetGalileoEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGalileoEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetGalileoEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGalileoEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGalileoEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGalileoEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGalileoEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphDoubleParamForEachSV
///
#include "gen/GetGalileoEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphDoubleParamForEachSV::CmdName = "GetGalileoEphDoubleParamForEachSV";
    const char* const GetGalileoEphDoubleParamForEachSV::Documentation = "Get Galileo ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGalileoEphDoubleParamForEachSV);


    GetGalileoEphDoubleParamForEachSV::GetGalileoEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetGalileoEphDoubleParamForEachSV::GetGalileoEphDoubleParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGalileoEphDoubleParamForEachSVPtr GetGalileoEphDoubleParamForEachSV::create(const std::string& paramName)
    {
      return GetGalileoEphDoubleParamForEachSVPtr(new GetGalileoEphDoubleParamForEachSV(paramName));
    }

    GetGalileoEphDoubleParamForEachSVPtr GetGalileoEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphDoubleParamForEachSV>(ptr);
    }

    bool GetGalileoEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGalileoEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetGalileoEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGalileoEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphemerisDoubleParams
///
#include "gen/GetGalileoEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphemerisDoubleParams::CmdName = "GetGalileoEphemerisDoubleParams";
    const char* const GetGalileoEphemerisDoubleParams::Documentation = "Please note the command GetGalileoEphemerisDoubleParams is deprecated since 21.3. You may use GetGalileoEphDoubleParamForEachSV.\n\nGet Galileo ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGalileoEphemerisDoubleParams);


    GetGalileoEphemerisDoubleParams::GetGalileoEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetGalileoEphemerisDoubleParams::GetGalileoEphemerisDoubleParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGalileoEphemerisDoubleParamsPtr GetGalileoEphemerisDoubleParams::create(const std::string& paramName)
    {
      return GetGalileoEphemerisDoubleParamsPtr(new GetGalileoEphemerisDoubleParams(paramName));
    }

    GetGalileoEphemerisDoubleParamsPtr GetGalileoEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphemerisDoubleParams>(ptr);
    }

    bool GetGalileoEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGalileoEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetGalileoEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGalileoEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphDoubleParamForEachSVResult
///
#include "gen/GetGalileoEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphDoubleParamForEachSVResult::CmdName = "GetGalileoEphDoubleParamForEachSVResult";
    const char* const GetGalileoEphDoubleParamForEachSVResult::Documentation = "Result of GetGalileoEphDoubleParamForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoEphDoubleParamForEachSVResult);


    GetGalileoEphDoubleParamForEachSVResult::GetGalileoEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGalileoEphDoubleParamForEachSVResult::GetGalileoEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetGalileoEphDoubleParamForEachSVResultPtr GetGalileoEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
    {
      return GetGalileoEphDoubleParamForEachSVResultPtr(new GetGalileoEphDoubleParamForEachSVResult(relatedCommand, paramName, val));
    }

    GetGalileoEphDoubleParamForEachSVResultPtr GetGalileoEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetGalileoEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGalileoEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetGalileoEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGalileoEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetGalileoEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphDoubleParamForEachSV
///
#include "gen/SetBeiDouEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphDoubleParamForEachSV::CmdName = "SetBeiDouEphDoubleParamForEachSV";
    const char* const SetBeiDouEphDoubleParamForEachSV::Documentation = "Set BeiDou ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphDoubleParamForEachSV);


    SetBeiDouEphDoubleParamForEachSV::SetBeiDouEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphDoubleParamForEachSV::SetBeiDouEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetBeiDouEphDoubleParamForEachSVPtr SetBeiDouEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetBeiDouEphDoubleParamForEachSVPtr(new SetBeiDouEphDoubleParamForEachSV(paramName, val));
    }

    SetBeiDouEphDoubleParamForEachSVPtr SetBeiDouEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphDoubleParamForEachSV>(ptr);
    }

    bool SetBeiDouEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetBeiDouEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetBeiDouEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetBeiDouEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetBeiDouEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetBeiDouEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphemerisDoubleParams
///
#include "gen/SetBeiDouEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphemerisDoubleParams::CmdName = "SetBeiDouEphemerisDoubleParams";
    const char* const SetBeiDouEphemerisDoubleParams::Documentation = "Please note the command SetBeiDouEphemerisDoubleParams is deprecated since 21.3. You may use SetBeiDouEphDoubleParamForEachSV.\n\nSet BeiDou ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphemerisDoubleParams);


    SetBeiDouEphemerisDoubleParams::SetBeiDouEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphemerisDoubleParams::SetBeiDouEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetBeiDouEphemerisDoubleParamsPtr SetBeiDouEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetBeiDouEphemerisDoubleParamsPtr(new SetBeiDouEphemerisDoubleParams(paramName, val));
    }

    SetBeiDouEphemerisDoubleParamsPtr SetBeiDouEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphemerisDoubleParams>(ptr);
    }

    bool SetBeiDouEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetBeiDouEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetBeiDouEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetBeiDouEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetBeiDouEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetBeiDouEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphDoubleParamForEachSV
///
#include "gen/GetBeiDouEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphDoubleParamForEachSV::CmdName = "GetBeiDouEphDoubleParamForEachSV";
    const char* const GetBeiDouEphDoubleParamForEachSV::Documentation = "Get BeiDou ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphDoubleParamForEachSV);


    GetBeiDouEphDoubleParamForEachSV::GetBeiDouEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphDoubleParamForEachSV::GetBeiDouEphDoubleParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetBeiDouEphDoubleParamForEachSVPtr GetBeiDouEphDoubleParamForEachSV::create(const std::string& paramName)
    {
      return GetBeiDouEphDoubleParamForEachSVPtr(new GetBeiDouEphDoubleParamForEachSV(paramName));
    }

    GetBeiDouEphDoubleParamForEachSVPtr GetBeiDouEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphDoubleParamForEachSV>(ptr);
    }

    bool GetBeiDouEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetBeiDouEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetBeiDouEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisDoubleParams
///
#include "gen/GetBeiDouEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisDoubleParams::CmdName = "GetBeiDouEphemerisDoubleParams";
    const char* const GetBeiDouEphemerisDoubleParams::Documentation = "Please note the command GetBeiDouEphemerisDoubleParams is deprecated since 21.3. You may use GetBeiDouEphDoubleParamForEachSV.\n\nGet BeiDou ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphemerisDoubleParams);


    GetBeiDouEphemerisDoubleParams::GetBeiDouEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphemerisDoubleParams::GetBeiDouEphemerisDoubleParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetBeiDouEphemerisDoubleParamsPtr GetBeiDouEphemerisDoubleParams::create(const std::string& paramName)
    {
      return GetBeiDouEphemerisDoubleParamsPtr(new GetBeiDouEphemerisDoubleParams(paramName));
    }

    GetBeiDouEphemerisDoubleParamsPtr GetBeiDouEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisDoubleParams>(ptr);
    }

    bool GetBeiDouEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetBeiDouEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetBeiDouEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphDoubleParamForEachSVResult
///
#include "gen/GetBeiDouEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphDoubleParamForEachSVResult::CmdName = "GetBeiDouEphDoubleParamForEachSVResult";
    const char* const GetBeiDouEphDoubleParamForEachSVResult::Documentation = "Result of GetBeiDouEphDoubleParamForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphDoubleParamForEachSVResult);


    GetBeiDouEphDoubleParamForEachSVResult::GetBeiDouEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphDoubleParamForEachSVResult::GetBeiDouEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetBeiDouEphDoubleParamForEachSVResultPtr GetBeiDouEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
    {
      return GetBeiDouEphDoubleParamForEachSVResultPtr(new GetBeiDouEphDoubleParamForEachSVResult(relatedCommand, paramName, val));
    }

    GetBeiDouEphDoubleParamForEachSVResultPtr GetBeiDouEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetBeiDouEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetBeiDouEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetBeiDouEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetBeiDouEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetBeiDouEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassEphDoubleParamForEachSV
///
#include "gen/SetGlonassEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassEphDoubleParamForEachSV::CmdName = "SetGlonassEphDoubleParamForEachSV";
    const char* const SetGlonassEphDoubleParamForEachSV::Documentation = "Set GLONASS parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGlonassEphDoubleParamForEachSV);


    SetGlonassEphDoubleParamForEachSV::SetGlonassEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetGlonassEphDoubleParamForEachSV::SetGlonassEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGlonassEphDoubleParamForEachSVPtr SetGlonassEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetGlonassEphDoubleParamForEachSVPtr(new SetGlonassEphDoubleParamForEachSV(paramName, val));
    }

    SetGlonassEphDoubleParamForEachSVPtr SetGlonassEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassEphDoubleParamForEachSV>(ptr);
    }

    bool SetGlonassEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGlonassEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetGlonassEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGlonassEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGlonassEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGlonassEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGlonassEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassDoubleParams
///
#include "gen/SetGlonassDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassDoubleParams::CmdName = "SetGlonassDoubleParams";
    const char* const SetGlonassDoubleParams::Documentation = "Please note the command SetGlonassDoubleParams is deprecated since 21.3. You may use SetGlonassEphDoubleParamForEachSV.\n\nSet GLONASS parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGlonassDoubleParams);


    SetGlonassDoubleParams::SetGlonassDoubleParams()
      : CommandBase(CmdName)
    {}

    SetGlonassDoubleParams::SetGlonassDoubleParams(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGlonassDoubleParamsPtr SetGlonassDoubleParams::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetGlonassDoubleParamsPtr(new SetGlonassDoubleParams(paramName, val));
    }

    SetGlonassDoubleParamsPtr SetGlonassDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassDoubleParams>(ptr);
    }

    bool SetGlonassDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGlonassDoubleParams::documentation() const { return Documentation; }


    int SetGlonassDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGlonassDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGlonassDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGlonassDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetGlonassDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphDoubleParamForEachSV
///
#include "gen/GetGlonassEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphDoubleParamForEachSV::CmdName = "GetGlonassEphDoubleParamForEachSV";
    const char* const GetGlonassEphDoubleParamForEachSV::Documentation = "Get GLONASS parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGlonassEphDoubleParamForEachSV);


    GetGlonassEphDoubleParamForEachSV::GetGlonassEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetGlonassEphDoubleParamForEachSV::GetGlonassEphDoubleParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGlonassEphDoubleParamForEachSVPtr GetGlonassEphDoubleParamForEachSV::create(const std::string& paramName)
    {
      return GetGlonassEphDoubleParamForEachSVPtr(new GetGlonassEphDoubleParamForEachSV(paramName));
    }

    GetGlonassEphDoubleParamForEachSVPtr GetGlonassEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphDoubleParamForEachSV>(ptr);
    }

    bool GetGlonassEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGlonassEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetGlonassEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGlonassEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassDoubleParams
///
#include "gen/GetGlonassDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassDoubleParams::CmdName = "GetGlonassDoubleParams";
    const char* const GetGlonassDoubleParams::Documentation = "Please note the command GetGlonassDoubleParams is deprecated since 21.3. You may use GetGlonassEphDoubleParamForEachSV.\n\nGet GLONASS parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGlonassDoubleParams);


    GetGlonassDoubleParams::GetGlonassDoubleParams()
      : CommandBase(CmdName)
    {}

    GetGlonassDoubleParams::GetGlonassDoubleParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGlonassDoubleParamsPtr GetGlonassDoubleParams::create(const std::string& paramName)
    {
      return GetGlonassDoubleParamsPtr(new GetGlonassDoubleParams(paramName));
    }

    GetGlonassDoubleParamsPtr GetGlonassDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassDoubleParams>(ptr);
    }

    bool GetGlonassDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGlonassDoubleParams::documentation() const { return Documentation; }


    int GetGlonassDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGlonassDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassEphDoubleParamForEachSVResult
///
#include "gen/GetGlonassEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassEphDoubleParamForEachSVResult::CmdName = "GetGlonassEphDoubleParamForEachSVResult";
    const char* const GetGlonassEphDoubleParamForEachSVResult::Documentation = "Result of GetGlonassEphDoubleParamForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassEphDoubleParamForEachSVResult);


    GetGlonassEphDoubleParamForEachSVResult::GetGlonassEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGlonassEphDoubleParamForEachSVResult::GetGlonassEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetGlonassEphDoubleParamForEachSVResultPtr GetGlonassEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
    {
      return GetGlonassEphDoubleParamForEachSVResultPtr(new GetGlonassEphDoubleParamForEachSVResult(relatedCommand, paramName, val));
    }

    GetGlonassEphDoubleParamForEachSVResultPtr GetGlonassEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetGlonassEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGlonassEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetGlonassEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGlonassEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetGlonassEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphDoubleParamForEachSV
///
#include "gen/SetQzssEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphDoubleParamForEachSV::CmdName = "SetQzssEphDoubleParamForEachSV";
    const char* const SetQzssEphDoubleParamForEachSV::Documentation = "Set QZSS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetQzssEphDoubleParamForEachSV);


    SetQzssEphDoubleParamForEachSV::SetQzssEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetQzssEphDoubleParamForEachSV::SetQzssEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetQzssEphDoubleParamForEachSVPtr SetQzssEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetQzssEphDoubleParamForEachSVPtr(new SetQzssEphDoubleParamForEachSV(paramName, val));
    }

    SetQzssEphDoubleParamForEachSVPtr SetQzssEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphDoubleParamForEachSV>(ptr);
    }

    bool SetQzssEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetQzssEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetQzssEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetQzssEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetQzssEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphemerisDoubleParams
///
#include "gen/SetQzssEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphemerisDoubleParams::CmdName = "SetQzssEphemerisDoubleParams";
    const char* const SetQzssEphemerisDoubleParams::Documentation = "Please note the command SetQzssEphemerisDoubleParams is deprecated since 21.3. You may use SetQzssEphDoubleParamForEachSV.\n\nSet QZSS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetQzssEphemerisDoubleParams);


    SetQzssEphemerisDoubleParams::SetQzssEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetQzssEphemerisDoubleParams::SetQzssEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetQzssEphemerisDoubleParamsPtr SetQzssEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetQzssEphemerisDoubleParamsPtr(new SetQzssEphemerisDoubleParams(paramName, val));
    }

    SetQzssEphemerisDoubleParamsPtr SetQzssEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphemerisDoubleParams>(ptr);
    }

    bool SetQzssEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetQzssEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetQzssEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetQzssEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetQzssEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphDoubleParamForEachSV
///
#include "gen/GetQzssEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphDoubleParamForEachSV::CmdName = "GetQzssEphDoubleParamForEachSV";
    const char* const GetQzssEphDoubleParamForEachSV::Documentation = "Get QZSS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetQzssEphDoubleParamForEachSV);


    GetQzssEphDoubleParamForEachSV::GetQzssEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetQzssEphDoubleParamForEachSV::GetQzssEphDoubleParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetQzssEphDoubleParamForEachSVPtr GetQzssEphDoubleParamForEachSV::create(const std::string& paramName)
    {
      return GetQzssEphDoubleParamForEachSVPtr(new GetQzssEphDoubleParamForEachSV(paramName));
    }

    GetQzssEphDoubleParamForEachSVPtr GetQzssEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphDoubleParamForEachSV>(ptr);
    }

    bool GetQzssEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetQzssEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetQzssEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisDoubleParams
///
#include "gen/GetQzssEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisDoubleParams::CmdName = "GetQzssEphemerisDoubleParams";
    const char* const GetQzssEphemerisDoubleParams::Documentation = "Please note the command GetQzssEphemerisDoubleParams is deprecated since 21.3. You may use GetQzssEphDoubleParamForEachSV.\n\nGet QZSS ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetQzssEphemerisDoubleParams);


    GetQzssEphemerisDoubleParams::GetQzssEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetQzssEphemerisDoubleParams::GetQzssEphemerisDoubleParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetQzssEphemerisDoubleParamsPtr GetQzssEphemerisDoubleParams::create(const std::string& paramName)
    {
      return GetQzssEphemerisDoubleParamsPtr(new GetQzssEphemerisDoubleParams(paramName));
    }

    GetQzssEphemerisDoubleParamsPtr GetQzssEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisDoubleParams>(ptr);
    }

    bool GetQzssEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetQzssEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetQzssEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphDoubleParamForEachSVResult
///
#include "gen/GetQzssEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphDoubleParamForEachSVResult::CmdName = "GetQzssEphDoubleParamForEachSVResult";
    const char* const GetQzssEphDoubleParamForEachSVResult::Documentation = "Result of GetQzssEphDoubleParamForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssEphDoubleParamForEachSVResult);


    GetQzssEphDoubleParamForEachSVResult::GetQzssEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssEphDoubleParamForEachSVResult::GetQzssEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetQzssEphDoubleParamForEachSVResultPtr GetQzssEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
    {
      return GetQzssEphDoubleParamForEachSVResultPtr(new GetQzssEphDoubleParamForEachSVResult(relatedCommand, paramName, val));
    }

    GetQzssEphDoubleParamForEachSVResultPtr GetQzssEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetQzssEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetQzssEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetQzssEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetQzssEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetQzssEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICEphDoubleParamForEachSV
///
#include "gen/SetNavICEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICEphDoubleParamForEachSV::CmdName = "SetNavICEphDoubleParamForEachSV";
    const char* const SetNavICEphDoubleParamForEachSV::Documentation = "Set NavIC ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetNavICEphDoubleParamForEachSV);


    SetNavICEphDoubleParamForEachSV::SetNavICEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetNavICEphDoubleParamForEachSV::SetNavICEphDoubleParamForEachSV(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetNavICEphDoubleParamForEachSVPtr SetNavICEphDoubleParamForEachSV::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetNavICEphDoubleParamForEachSVPtr(new SetNavICEphDoubleParamForEachSV(paramName, val));
    }

    SetNavICEphDoubleParamForEachSVPtr SetNavICEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICEphDoubleParamForEachSV>(ptr);
    }

    bool SetNavICEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetNavICEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int SetNavICEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetNavICEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetNavICEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetNavICEphDoubleParamForEachSV::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetNavICEphDoubleParamForEachSV::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICEphemerisDoubleParams
///
#include "gen/SetNavICEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICEphemerisDoubleParams::CmdName = "SetNavICEphemerisDoubleParams";
    const char* const SetNavICEphemerisDoubleParams::Documentation = "Please note the command SetNavICEphemerisDoubleParams is deprecated since 21.3. You may use SetNavICEphDoubleParamForEachSV.\n\nSet NavIC ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetNavICEphemerisDoubleParams);


    SetNavICEphemerisDoubleParams::SetNavICEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    SetNavICEphemerisDoubleParams::SetNavICEphemerisDoubleParams(const std::string& paramName, const std::vector<double>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetNavICEphemerisDoubleParamsPtr SetNavICEphemerisDoubleParams::create(const std::string& paramName, const std::vector<double>& val)
    {
      return SetNavICEphemerisDoubleParamsPtr(new SetNavICEphemerisDoubleParams(paramName, val));
    }

    SetNavICEphemerisDoubleParamsPtr SetNavICEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICEphemerisDoubleParams>(ptr);
    }

    bool SetNavICEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetNavICEphemerisDoubleParams::documentation() const { return Documentation; }


    int SetNavICEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetNavICEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetNavICEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetNavICEphemerisDoubleParams::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void SetNavICEphemerisDoubleParams::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphDoubleParamForEachSV
///
#include "gen/GetNavICEphDoubleParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphDoubleParamForEachSV::CmdName = "GetNavICEphDoubleParamForEachSV";
    const char* const GetNavICEphDoubleParamForEachSV::Documentation = "Get NavIC ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetNavICEphDoubleParamForEachSV);


    GetNavICEphDoubleParamForEachSV::GetNavICEphDoubleParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetNavICEphDoubleParamForEachSV::GetNavICEphDoubleParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetNavICEphDoubleParamForEachSVPtr GetNavICEphDoubleParamForEachSV::create(const std::string& paramName)
    {
      return GetNavICEphDoubleParamForEachSVPtr(new GetNavICEphDoubleParamForEachSV(paramName));
    }

    GetNavICEphDoubleParamForEachSVPtr GetNavICEphDoubleParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphDoubleParamForEachSV>(ptr);
    }

    bool GetNavICEphDoubleParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetNavICEphDoubleParamForEachSV::documentation() const { return Documentation; }


    int GetNavICEphDoubleParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetNavICEphDoubleParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphDoubleParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphemerisDoubleParams
///
#include "gen/GetNavICEphemerisDoubleParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphemerisDoubleParams::CmdName = "GetNavICEphemerisDoubleParams";
    const char* const GetNavICEphemerisDoubleParams::Documentation = "Please note the command GetNavICEphemerisDoubleParams is deprecated since 21.3. You may use GetNavICEphDoubleParamForEachSV.\n\nGet NavIC ephemeris parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetNavICEphemerisDoubleParams);


    GetNavICEphemerisDoubleParams::GetNavICEphemerisDoubleParams()
      : CommandBase(CmdName)
    {}

    GetNavICEphemerisDoubleParams::GetNavICEphemerisDoubleParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetNavICEphemerisDoubleParamsPtr GetNavICEphemerisDoubleParams::create(const std::string& paramName)
    {
      return GetNavICEphemerisDoubleParamsPtr(new GetNavICEphemerisDoubleParams(paramName));
    }

    GetNavICEphemerisDoubleParamsPtr GetNavICEphemerisDoubleParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphemerisDoubleParams>(ptr);
    }

    bool GetNavICEphemerisDoubleParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetNavICEphemerisDoubleParams::documentation() const { return Documentation; }


    int GetNavICEphemerisDoubleParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetNavICEphemerisDoubleParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphemerisDoubleParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICEphDoubleParamForEachSVResult
///
#include "gen/GetNavICEphDoubleParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICEphDoubleParamForEachSVResult::CmdName = "GetNavICEphDoubleParamForEachSVResult";
    const char* const GetNavICEphDoubleParamForEachSVResult::Documentation = "Result of GetNavICEphDoubleParamForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetNavICEphDoubleParamForEachSVResult);


    GetNavICEphDoubleParamForEachSVResult::GetNavICEphDoubleParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetNavICEphDoubleParamForEachSVResult::GetNavICEphDoubleParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetNavICEphDoubleParamForEachSVResultPtr GetNavICEphDoubleParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<double>& val)
    {
      return GetNavICEphDoubleParamForEachSVResultPtr(new GetNavICEphDoubleParamForEachSVResult(relatedCommand, paramName, val));
    }

    GetNavICEphDoubleParamForEachSVResultPtr GetNavICEphDoubleParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICEphDoubleParamForEachSVResult>(ptr);
    }

    bool GetNavICEphDoubleParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<double>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetNavICEphDoubleParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetNavICEphDoubleParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetNavICEphDoubleParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetNavICEphDoubleParamForEachSVResult::val() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Val"]);
    }

    void GetNavICEphDoubleParamForEachSVResult::setVal(const std::vector<double>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<double>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphBoolParamForSV
///
#include "gen/SetGpsEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphBoolParamForSV::CmdName = "SetGpsEphBoolParamForSV";
    const char* const SetGpsEphBoolParamForSV::Documentation = "Set various boolean parameters in the GPS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(SetGpsEphBoolParamForSV);


    SetGpsEphBoolParamForSV::SetGpsEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    SetGpsEphBoolParamForSV::SetGpsEphBoolParamForSV(int svId, const std::string& paramName, bool val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetGpsEphBoolParamForSVPtr SetGpsEphBoolParamForSV::create(int svId, const std::string& paramName, bool val)
    {
      return SetGpsEphBoolParamForSVPtr(new SetGpsEphBoolParamForSV(svId, paramName, val));
    }

    SetGpsEphBoolParamForSVPtr SetGpsEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphBoolParamForSV>(ptr);
    }

    bool SetGpsEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGpsEphBoolParamForSV::documentation() const { return Documentation; }


    int SetGpsEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGpsEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsEphBoolParamForSV::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetGpsEphBoolParamForSV::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphBoolParamForSV
///
#include "gen/GetGpsEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphBoolParamForSV::CmdName = "GetGpsEphBoolParamForSV";
    const char* const GetGpsEphBoolParamForSV::Documentation = "Get various boolean parameters in the GPS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(GetGpsEphBoolParamForSV);


    GetGpsEphBoolParamForSV::GetGpsEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    GetGpsEphBoolParamForSV::GetGpsEphBoolParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetGpsEphBoolParamForSVPtr GetGpsEphBoolParamForSV::create(int svId, const std::string& paramName)
    {
      return GetGpsEphBoolParamForSVPtr(new GetGpsEphBoolParamForSV(svId, paramName));
    }

    GetGpsEphBoolParamForSVPtr GetGpsEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphBoolParamForSV>(ptr);
    }

    bool GetGpsEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGpsEphBoolParamForSV::documentation() const { return Documentation; }


    int GetGpsEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphBoolParamForSVResult
///
#include "gen/GetGpsEphBoolParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphBoolParamForSVResult::CmdName = "GetGpsEphBoolParamForSVResult";
    const char* const GetGpsEphBoolParamForSVResult::Documentation = "Result of GetGpsEphBoolParamForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphBoolParamForSVResult);


    GetGpsEphBoolParamForSVResult::GetGpsEphBoolParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphBoolParamForSVResult::GetGpsEphBoolParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetGpsEphBoolParamForSVResultPtr GetGpsEphBoolParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val)
    {
      return GetGpsEphBoolParamForSVResultPtr(new GetGpsEphBoolParamForSVResult(relatedCommand, svId, paramName, val));
    }

    GetGpsEphBoolParamForSVResultPtr GetGpsEphBoolParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphBoolParamForSVResult>(ptr);
    }

    bool GetGpsEphBoolParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGpsEphBoolParamForSVResult::documentation() const { return Documentation; }


    int GetGpsEphBoolParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetGpsEphBoolParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphBoolParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphBoolParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsEphBoolParamForSVResult::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void GetGpsEphBoolParamForSVResult::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphBoolParamForEachSV
///
#include "gen/SetGpsEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphBoolParamForEachSV::CmdName = "SetGpsEphBoolParamForEachSV";
    const char* const SetGpsEphBoolParamForEachSV::Documentation = "Set GPS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGpsEphBoolParamForEachSV);


    SetGpsEphBoolParamForEachSV::SetGpsEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetGpsEphBoolParamForEachSV::SetGpsEphBoolParamForEachSV(const std::string& paramName, const std::vector<bool>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGpsEphBoolParamForEachSVPtr SetGpsEphBoolParamForEachSV::create(const std::string& paramName, const std::vector<bool>& val)
    {
      return SetGpsEphBoolParamForEachSVPtr(new SetGpsEphBoolParamForEachSV(paramName, val));
    }

    SetGpsEphBoolParamForEachSVPtr SetGpsEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphBoolParamForEachSV>(ptr);
    }

    bool SetGpsEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGpsEphBoolParamForEachSV::documentation() const { return Documentation; }


    int SetGpsEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetGpsEphBoolParamForEachSV::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetGpsEphBoolParamForEachSV::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphemerisBoolParams
///
#include "gen/SetGpsEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphemerisBoolParams::CmdName = "SetGpsEphemerisBoolParams";
    const char* const SetGpsEphemerisBoolParams::Documentation = "Please note the command SetGpsEphemerisBoolParams is deprecated since 21.3. You may use SetGpsEphBoolParamForEachSV.\n\nSet GPS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetGpsEphemerisBoolParams);


    SetGpsEphemerisBoolParams::SetGpsEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    SetGpsEphemerisBoolParams::SetGpsEphemerisBoolParams(const std::string& paramName, const std::vector<bool>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetGpsEphemerisBoolParamsPtr SetGpsEphemerisBoolParams::create(const std::string& paramName, const std::vector<bool>& val)
    {
      return SetGpsEphemerisBoolParamsPtr(new SetGpsEphemerisBoolParams(paramName, val));
    }

    SetGpsEphemerisBoolParamsPtr SetGpsEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphemerisBoolParams>(ptr);
    }

    bool SetGpsEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGpsEphemerisBoolParams::documentation() const { return Documentation; }


    int SetGpsEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetGpsEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetGpsEphemerisBoolParams::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetGpsEphemerisBoolParams::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphBoolParamForEachSV
///
#include "gen/GetGpsEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphBoolParamForEachSV::CmdName = "GetGpsEphBoolParamForEachSV";
    const char* const GetGpsEphBoolParamForEachSV::Documentation = "Get GPS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGpsEphBoolParamForEachSV);


    GetGpsEphBoolParamForEachSV::GetGpsEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetGpsEphBoolParamForEachSV::GetGpsEphBoolParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGpsEphBoolParamForEachSVPtr GetGpsEphBoolParamForEachSV::create(const std::string& paramName)
    {
      return GetGpsEphBoolParamForEachSVPtr(new GetGpsEphBoolParamForEachSV(paramName));
    }

    GetGpsEphBoolParamForEachSVPtr GetGpsEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphBoolParamForEachSV>(ptr);
    }

    bool GetGpsEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGpsEphBoolParamForEachSV::documentation() const { return Documentation; }


    int GetGpsEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisBoolParams
///
#include "gen/GetGpsEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisBoolParams::CmdName = "GetGpsEphemerisBoolParams";
    const char* const GetGpsEphemerisBoolParams::Documentation = "Please note the command GetGpsEphemerisBoolParams is deprecated since 21.3. You may use GetGpsEphBoolParamForEachSV.\n\nGet GPS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetGpsEphemerisBoolParams);


    GetGpsEphemerisBoolParams::GetGpsEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    GetGpsEphemerisBoolParams::GetGpsEphemerisBoolParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetGpsEphemerisBoolParamsPtr GetGpsEphemerisBoolParams::create(const std::string& paramName)
    {
      return GetGpsEphemerisBoolParamsPtr(new GetGpsEphemerisBoolParams(paramName));
    }

    GetGpsEphemerisBoolParamsPtr GetGpsEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisBoolParams>(ptr);
    }

    bool GetGpsEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGpsEphemerisBoolParams::documentation() const { return Documentation; }


    int GetGpsEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphBoolParamForEachSVResult
///
#include "gen/GetGpsEphBoolParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphBoolParamForEachSVResult::CmdName = "GetGpsEphBoolParamForEachSVResult";
    const char* const GetGpsEphBoolParamForEachSVResult::Documentation = "Result of GetGpsEphBoolParamForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphBoolParamForEachSVResult);


    GetGpsEphBoolParamForEachSVResult::GetGpsEphBoolParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphBoolParamForEachSVResult::GetGpsEphBoolParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetGpsEphBoolParamForEachSVResultPtr GetGpsEphBoolParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val)
    {
      return GetGpsEphBoolParamForEachSVResultPtr(new GetGpsEphBoolParamForEachSVResult(relatedCommand, paramName, val));
    }

    GetGpsEphBoolParamForEachSVResultPtr GetGpsEphBoolParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphBoolParamForEachSVResult>(ptr);
    }

    bool GetGpsEphBoolParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGpsEphBoolParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetGpsEphBoolParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphBoolParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetGpsEphBoolParamForEachSVResult::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void GetGpsEphBoolParamForEachSVResult::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphBoolParamForSV
///
#include "gen/SetBeiDouEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphBoolParamForSV::CmdName = "SetBeiDouEphBoolParamForSV";
    const char* const SetBeiDouEphBoolParamForSV::Documentation = "Set various boolean parameters in the BeiDou ephemeris\n\n  ParamName\n\"IscB1CdAvailable\"\n\"IscB2adAvailable\"";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphBoolParamForSV);


    SetBeiDouEphBoolParamForSV::SetBeiDouEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphBoolParamForSV::SetBeiDouEphBoolParamForSV(int svId, const std::string& paramName, bool val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetBeiDouEphBoolParamForSVPtr SetBeiDouEphBoolParamForSV::create(int svId, const std::string& paramName, bool val)
    {
      return SetBeiDouEphBoolParamForSVPtr(new SetBeiDouEphBoolParamForSV(svId, paramName, val));
    }

    SetBeiDouEphBoolParamForSVPtr SetBeiDouEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphBoolParamForSV>(ptr);
    }

    bool SetBeiDouEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string SetBeiDouEphBoolParamForSV::documentation() const { return Documentation; }


    int SetBeiDouEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetBeiDouEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetBeiDouEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetBeiDouEphBoolParamForSV::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetBeiDouEphBoolParamForSV::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphBoolParamForSV
///
#include "gen/GetBeiDouEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphBoolParamForSV::CmdName = "GetBeiDouEphBoolParamForSV";
    const char* const GetBeiDouEphBoolParamForSV::Documentation = "Get various boolean parameters in the BeiDou ephemeris\n\n  ParamName\n\"IscB1CdAvailable\"\n\"IscB2adAvailable\"";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphBoolParamForSV);


    GetBeiDouEphBoolParamForSV::GetBeiDouEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphBoolParamForSV::GetBeiDouEphBoolParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetBeiDouEphBoolParamForSVPtr GetBeiDouEphBoolParamForSV::create(int svId, const std::string& paramName)
    {
      return GetBeiDouEphBoolParamForSVPtr(new GetBeiDouEphBoolParamForSV(svId, paramName));
    }

    GetBeiDouEphBoolParamForSVPtr GetBeiDouEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphBoolParamForSV>(ptr);
    }

    bool GetBeiDouEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetBeiDouEphBoolParamForSV::documentation() const { return Documentation; }


    int GetBeiDouEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphBoolParamForSVResult
///
#include "gen/GetBeiDouEphBoolParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphBoolParamForSVResult::CmdName = "GetBeiDouEphBoolParamForSVResult";
    const char* const GetBeiDouEphBoolParamForSVResult::Documentation = "Result of GetBeiDouEphBoolParamForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphBoolParamForSVResult);


    GetBeiDouEphBoolParamForSVResult::GetBeiDouEphBoolParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphBoolParamForSVResult::GetBeiDouEphBoolParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetBeiDouEphBoolParamForSVResultPtr GetBeiDouEphBoolParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val)
    {
      return GetBeiDouEphBoolParamForSVResultPtr(new GetBeiDouEphBoolParamForSVResult(relatedCommand, svId, paramName, val));
    }

    GetBeiDouEphBoolParamForSVResultPtr GetBeiDouEphBoolParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphBoolParamForSVResult>(ptr);
    }

    bool GetBeiDouEphBoolParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string GetBeiDouEphBoolParamForSVResult::documentation() const { return Documentation; }


    int GetBeiDouEphBoolParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetBeiDouEphBoolParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphBoolParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphBoolParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouEphBoolParamForSVResult::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void GetBeiDouEphBoolParamForSVResult::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphBoolParamForEachSV
///
#include "gen/SetBeiDouEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphBoolParamForEachSV::CmdName = "SetBeiDouEphBoolParamForEachSV";
    const char* const SetBeiDouEphBoolParamForEachSV::Documentation = "Set BeiDou ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphBoolParamForEachSV);


    SetBeiDouEphBoolParamForEachSV::SetBeiDouEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphBoolParamForEachSV::SetBeiDouEphBoolParamForEachSV(const std::string& paramName, const std::vector<bool>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetBeiDouEphBoolParamForEachSVPtr SetBeiDouEphBoolParamForEachSV::create(const std::string& paramName, const std::vector<bool>& val)
    {
      return SetBeiDouEphBoolParamForEachSVPtr(new SetBeiDouEphBoolParamForEachSV(paramName, val));
    }

    SetBeiDouEphBoolParamForEachSVPtr SetBeiDouEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphBoolParamForEachSV>(ptr);
    }

    bool SetBeiDouEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetBeiDouEphBoolParamForEachSV::documentation() const { return Documentation; }


    int SetBeiDouEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetBeiDouEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetBeiDouEphBoolParamForEachSV::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetBeiDouEphBoolParamForEachSV::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphemerisBoolParams
///
#include "gen/SetBeiDouEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphemerisBoolParams::CmdName = "SetBeiDouEphemerisBoolParams";
    const char* const SetBeiDouEphemerisBoolParams::Documentation = "Please note the command SetBeiDouEphemerisBoolParams is deprecated since 21.3. You may use SetBeiDouEphBoolParamForEachSV.\n\nSet BeiDou ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphemerisBoolParams);


    SetBeiDouEphemerisBoolParams::SetBeiDouEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphemerisBoolParams::SetBeiDouEphemerisBoolParams(const std::string& paramName, const std::vector<bool>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetBeiDouEphemerisBoolParamsPtr SetBeiDouEphemerisBoolParams::create(const std::string& paramName, const std::vector<bool>& val)
    {
      return SetBeiDouEphemerisBoolParamsPtr(new SetBeiDouEphemerisBoolParams(paramName, val));
    }

    SetBeiDouEphemerisBoolParamsPtr SetBeiDouEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphemerisBoolParams>(ptr);
    }

    bool SetBeiDouEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetBeiDouEphemerisBoolParams::documentation() const { return Documentation; }


    int SetBeiDouEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetBeiDouEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetBeiDouEphemerisBoolParams::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetBeiDouEphemerisBoolParams::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphBoolParamForEachSV
///
#include "gen/GetBeiDouEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphBoolParamForEachSV::CmdName = "GetBeiDouEphBoolParamForEachSV";
    const char* const GetBeiDouEphBoolParamForEachSV::Documentation = "Get BeiDou ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphBoolParamForEachSV);


    GetBeiDouEphBoolParamForEachSV::GetBeiDouEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphBoolParamForEachSV::GetBeiDouEphBoolParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetBeiDouEphBoolParamForEachSVPtr GetBeiDouEphBoolParamForEachSV::create(const std::string& paramName)
    {
      return GetBeiDouEphBoolParamForEachSVPtr(new GetBeiDouEphBoolParamForEachSV(paramName));
    }

    GetBeiDouEphBoolParamForEachSVPtr GetBeiDouEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphBoolParamForEachSV>(ptr);
    }

    bool GetBeiDouEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetBeiDouEphBoolParamForEachSV::documentation() const { return Documentation; }


    int GetBeiDouEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisBoolParams
///
#include "gen/GetBeiDouEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisBoolParams::CmdName = "GetBeiDouEphemerisBoolParams";
    const char* const GetBeiDouEphemerisBoolParams::Documentation = "Please note the command GetBeiDouEphemerisBoolParams is deprecated since 21.3. You may use GetBeiDouEphBoolParamForEachSV.\n\nGet BeiDou ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphemerisBoolParams);


    GetBeiDouEphemerisBoolParams::GetBeiDouEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphemerisBoolParams::GetBeiDouEphemerisBoolParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetBeiDouEphemerisBoolParamsPtr GetBeiDouEphemerisBoolParams::create(const std::string& paramName)
    {
      return GetBeiDouEphemerisBoolParamsPtr(new GetBeiDouEphemerisBoolParams(paramName));
    }

    GetBeiDouEphemerisBoolParamsPtr GetBeiDouEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisBoolParams>(ptr);
    }

    bool GetBeiDouEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetBeiDouEphemerisBoolParams::documentation() const { return Documentation; }


    int GetBeiDouEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphBoolParamForEachSVResult
///
#include "gen/GetBeiDouEphBoolParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphBoolParamForEachSVResult::CmdName = "GetBeiDouEphBoolParamForEachSVResult";
    const char* const GetBeiDouEphBoolParamForEachSVResult::Documentation = "Result of GetBeiDouEphBoolParamForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphBoolParamForEachSVResult);


    GetBeiDouEphBoolParamForEachSVResult::GetBeiDouEphBoolParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphBoolParamForEachSVResult::GetBeiDouEphBoolParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetBeiDouEphBoolParamForEachSVResultPtr GetBeiDouEphBoolParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val)
    {
      return GetBeiDouEphBoolParamForEachSVResultPtr(new GetBeiDouEphBoolParamForEachSVResult(relatedCommand, paramName, val));
    }

    GetBeiDouEphBoolParamForEachSVResultPtr GetBeiDouEphBoolParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphBoolParamForEachSVResult>(ptr);
    }

    bool GetBeiDouEphBoolParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetBeiDouEphBoolParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetBeiDouEphBoolParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphBoolParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetBeiDouEphBoolParamForEachSVResult::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void GetBeiDouEphBoolParamForEachSVResult::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphBoolParamForSV
///
#include "gen/SetQzssEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphBoolParamForSV::CmdName = "SetQzssEphBoolParamForSV";
    const char* const SetQzssEphBoolParamForSV::Documentation = "Set various boolean parameters in the QZSS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(SetQzssEphBoolParamForSV);


    SetQzssEphBoolParamForSV::SetQzssEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    SetQzssEphBoolParamForSV::SetQzssEphBoolParamForSV(int svId, const std::string& paramName, bool val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetQzssEphBoolParamForSVPtr SetQzssEphBoolParamForSV::create(int svId, const std::string& paramName, bool val)
    {
      return SetQzssEphBoolParamForSVPtr(new SetQzssEphBoolParamForSV(svId, paramName, val));
    }

    SetQzssEphBoolParamForSVPtr SetQzssEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphBoolParamForSV>(ptr);
    }

    bool SetQzssEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string SetQzssEphBoolParamForSV::documentation() const { return Documentation; }


    int SetQzssEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssEphBoolParamForSV::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetQzssEphBoolParamForSV::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphemerisBoolParam
///
#include "gen/SetQzssEphemerisBoolParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphemerisBoolParam::CmdName = "SetQzssEphemerisBoolParam";
    const char* const SetQzssEphemerisBoolParam::Documentation = "Please note the command SetQzssEphemerisBoolParam is deprecated since 21.3. You may use SetQzssEphBoolParamForSV.\n\nSet various boolean parameters in the QZSS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(SetQzssEphemerisBoolParam);


    SetQzssEphemerisBoolParam::SetQzssEphemerisBoolParam()
      : CommandBase(CmdName)
    {}

    SetQzssEphemerisBoolParam::SetQzssEphemerisBoolParam(int svId, const std::string& paramName, bool val)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    SetQzssEphemerisBoolParamPtr SetQzssEphemerisBoolParam::create(int svId, const std::string& paramName, bool val)
    {
      return SetQzssEphemerisBoolParamPtr(new SetQzssEphemerisBoolParam(svId, paramName, val));
    }

    SetQzssEphemerisBoolParamPtr SetQzssEphemerisBoolParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphemerisBoolParam>(ptr);
    }

    bool SetQzssEphemerisBoolParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string SetQzssEphemerisBoolParam::documentation() const { return Documentation; }


    int SetQzssEphemerisBoolParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssEphemerisBoolParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssEphemerisBoolParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssEphemerisBoolParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphemerisBoolParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssEphemerisBoolParam::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetQzssEphemerisBoolParam::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphBoolParamForSV
///
#include "gen/GetQzssEphBoolParamForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphBoolParamForSV::CmdName = "GetQzssEphBoolParamForSV";
    const char* const GetQzssEphBoolParamForSV::Documentation = "Get various boolean parameters in the QZSS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(GetQzssEphBoolParamForSV);


    GetQzssEphBoolParamForSV::GetQzssEphBoolParamForSV()
      : CommandBase(CmdName)
    {}

    GetQzssEphBoolParamForSV::GetQzssEphBoolParamForSV(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetQzssEphBoolParamForSVPtr GetQzssEphBoolParamForSV::create(int svId, const std::string& paramName)
    {
      return GetQzssEphBoolParamForSVPtr(new GetQzssEphBoolParamForSV(svId, paramName));
    }

    GetQzssEphBoolParamForSVPtr GetQzssEphBoolParamForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphBoolParamForSV>(ptr);
    }

    bool GetQzssEphBoolParamForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetQzssEphBoolParamForSV::documentation() const { return Documentation; }


    int GetQzssEphBoolParamForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssEphBoolParamForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphBoolParamForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphBoolParamForSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphBoolParamForSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisBoolParam
///
#include "gen/GetQzssEphemerisBoolParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisBoolParam::CmdName = "GetQzssEphemerisBoolParam";
    const char* const GetQzssEphemerisBoolParam::Documentation = "Please note the command GetQzssEphemerisBoolParam is deprecated since 21.3. You may use GetQzssEphBoolParamForSV.\n\nGet various boolean parameters in the QZSS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(GetQzssEphemerisBoolParam);


    GetQzssEphemerisBoolParam::GetQzssEphemerisBoolParam()
      : CommandBase(CmdName)
    {}

    GetQzssEphemerisBoolParam::GetQzssEphemerisBoolParam(int svId, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamName(paramName);
    }


    GetQzssEphemerisBoolParamPtr GetQzssEphemerisBoolParam::create(int svId, const std::string& paramName)
    {
      return GetQzssEphemerisBoolParamPtr(new GetQzssEphemerisBoolParam(svId, paramName));
    }

    GetQzssEphemerisBoolParamPtr GetQzssEphemerisBoolParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisBoolParam>(ptr);
    }

    bool GetQzssEphemerisBoolParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetQzssEphemerisBoolParam::documentation() const { return Documentation; }


    int GetQzssEphemerisBoolParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssEphemerisBoolParam::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphemerisBoolParam::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphemerisBoolParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphemerisBoolParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphBoolParamForSVResult
///
#include "gen/GetQzssEphBoolParamForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphBoolParamForSVResult::CmdName = "GetQzssEphBoolParamForSVResult";
    const char* const GetQzssEphBoolParamForSVResult::Documentation = "Result of GetQzssEphBoolParamForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssEphBoolParamForSVResult);


    GetQzssEphBoolParamForSVResult::GetQzssEphBoolParamForSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssEphBoolParamForSVResult::GetQzssEphBoolParamForSVResult(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamName(paramName);
      setVal(val);
    }


    GetQzssEphBoolParamForSVResultPtr GetQzssEphBoolParamForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::string& paramName, bool val)
    {
      return GetQzssEphBoolParamForSVResultPtr(new GetQzssEphBoolParamForSVResult(relatedCommand, svId, paramName, val));
    }

    GetQzssEphBoolParamForSVResultPtr GetQzssEphBoolParamForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphBoolParamForSVResult>(ptr);
    }

    bool GetQzssEphBoolParamForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string GetQzssEphBoolParamForSVResult::documentation() const { return Documentation; }


    int GetQzssEphBoolParamForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphBoolParamForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssEphBoolParamForSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphBoolParamForSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssEphBoolParamForSVResult::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void GetQzssEphBoolParamForSVResult::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphBoolParamForEachSV
///
#include "gen/SetQzssEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphBoolParamForEachSV::CmdName = "SetQzssEphBoolParamForEachSV";
    const char* const SetQzssEphBoolParamForEachSV::Documentation = "Set QZSS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetQzssEphBoolParamForEachSV);


    SetQzssEphBoolParamForEachSV::SetQzssEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    SetQzssEphBoolParamForEachSV::SetQzssEphBoolParamForEachSV(const std::string& paramName, const std::vector<bool>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetQzssEphBoolParamForEachSVPtr SetQzssEphBoolParamForEachSV::create(const std::string& paramName, const std::vector<bool>& val)
    {
      return SetQzssEphBoolParamForEachSVPtr(new SetQzssEphBoolParamForEachSV(paramName, val));
    }

    SetQzssEphBoolParamForEachSVPtr SetQzssEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphBoolParamForEachSV>(ptr);
    }

    bool SetQzssEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetQzssEphBoolParamForEachSV::documentation() const { return Documentation; }


    int SetQzssEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetQzssEphBoolParamForEachSV::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetQzssEphBoolParamForEachSV::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphemerisBoolParams
///
#include "gen/SetQzssEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphemerisBoolParams::CmdName = "SetQzssEphemerisBoolParams";
    const char* const SetQzssEphemerisBoolParams::Documentation = "Please note the command SetQzssEphemerisBoolParams is deprecated since 21.3. You may use SetQzssEphBoolParamForEachSV.\n\nSet QZSS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(SetQzssEphemerisBoolParams);


    SetQzssEphemerisBoolParams::SetQzssEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    SetQzssEphemerisBoolParams::SetQzssEphemerisBoolParams(const std::string& paramName, const std::vector<bool>& val)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
      setVal(val);
    }


    SetQzssEphemerisBoolParamsPtr SetQzssEphemerisBoolParams::create(const std::string& paramName, const std::vector<bool>& val)
    {
      return SetQzssEphemerisBoolParamsPtr(new SetQzssEphemerisBoolParams(paramName, val));
    }

    SetQzssEphemerisBoolParamsPtr SetQzssEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphemerisBoolParams>(ptr);
    }

    bool SetQzssEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
        ;

    }

    std::string SetQzssEphemerisBoolParams::documentation() const { return Documentation; }


    int SetQzssEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetQzssEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetQzssEphemerisBoolParams::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void SetQzssEphemerisBoolParams::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphBoolParamForEachSV
///
#include "gen/GetQzssEphBoolParamForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphBoolParamForEachSV::CmdName = "GetQzssEphBoolParamForEachSV";
    const char* const GetQzssEphBoolParamForEachSV::Documentation = "Get QZSS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetQzssEphBoolParamForEachSV);


    GetQzssEphBoolParamForEachSV::GetQzssEphBoolParamForEachSV()
      : CommandBase(CmdName)
    {}

    GetQzssEphBoolParamForEachSV::GetQzssEphBoolParamForEachSV(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetQzssEphBoolParamForEachSVPtr GetQzssEphBoolParamForEachSV::create(const std::string& paramName)
    {
      return GetQzssEphBoolParamForEachSVPtr(new GetQzssEphBoolParamForEachSV(paramName));
    }

    GetQzssEphBoolParamForEachSVPtr GetQzssEphBoolParamForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphBoolParamForEachSV>(ptr);
    }

    bool GetQzssEphBoolParamForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetQzssEphBoolParamForEachSV::documentation() const { return Documentation; }


    int GetQzssEphBoolParamForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssEphBoolParamForEachSV::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphBoolParamForEachSV::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisBoolParams
///
#include "gen/GetQzssEphemerisBoolParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisBoolParams::CmdName = "GetQzssEphemerisBoolParams";
    const char* const GetQzssEphemerisBoolParams::Documentation = "Please note the command GetQzssEphemerisBoolParams is deprecated since 21.3. You may use GetQzssEphBoolParamForEachSV.\n\nGet QZSS ephemeris boolean parameter value for all satellites";

    REGISTER_COMMAND_FACTORY(GetQzssEphemerisBoolParams);


    GetQzssEphemerisBoolParams::GetQzssEphemerisBoolParams()
      : CommandBase(CmdName)
    {}

    GetQzssEphemerisBoolParams::GetQzssEphemerisBoolParams(const std::string& paramName)
      : CommandBase(CmdName)
    {

      setParamName(paramName);
    }


    GetQzssEphemerisBoolParamsPtr GetQzssEphemerisBoolParams::create(const std::string& paramName)
    {
      return GetQzssEphemerisBoolParamsPtr(new GetQzssEphemerisBoolParams(paramName));
    }

    GetQzssEphemerisBoolParamsPtr GetQzssEphemerisBoolParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisBoolParams>(ptr);
    }

    bool GetQzssEphemerisBoolParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetQzssEphemerisBoolParams::documentation() const { return Documentation; }


    int GetQzssEphemerisBoolParams::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssEphemerisBoolParams::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphemerisBoolParams::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphBoolParamForEachSVResult
///
#include "gen/GetQzssEphBoolParamForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphBoolParamForEachSVResult::CmdName = "GetQzssEphBoolParamForEachSVResult";
    const char* const GetQzssEphBoolParamForEachSVResult::Documentation = "Result of GetQzssEphBoolParamForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssEphBoolParamForEachSVResult);


    GetQzssEphBoolParamForEachSVResult::GetQzssEphBoolParamForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetQzssEphBoolParamForEachSVResult::GetQzssEphBoolParamForEachSVResult(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val)
      : CommandResult(CmdName, relatedCommand)
    {

      setParamName(paramName);
      setVal(val);
    }


    GetQzssEphBoolParamForEachSVResultPtr GetQzssEphBoolParamForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& paramName, const std::vector<bool>& val)
    {
      return GetQzssEphBoolParamForEachSVResultPtr(new GetQzssEphBoolParamForEachSVResult(relatedCommand, paramName, val));
    }

    GetQzssEphBoolParamForEachSVResultPtr GetQzssEphBoolParamForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphBoolParamForEachSVResult>(ptr);
    }

    bool GetQzssEphBoolParamForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Val"])
        ;

    }

    std::string GetQzssEphBoolParamForEachSVResult::documentation() const { return Documentation; }


    std::string GetQzssEphBoolParamForEachSVResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetQzssEphBoolParamForEachSVResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetQzssEphBoolParamForEachSVResult::val() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Val"]);
    }

    void GetQzssEphBoolParamForEachSVResult::setVal(const std::vector<bool>& val)
    {
      m_values.AddMember("Val", parse_json<std::vector<bool>>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasEphParamsForSV
///
#include "gen/SetSbasEphParamsForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasEphParamsForSV::CmdName = "SetSbasEphParamsForSV";
    const char* const SetSbasEphParamsForSV::Documentation = "Set parameters for a SBAS satellite ephemeris (runtime modification only available for health parameter)";

    REGISTER_COMMAND_FACTORY(SetSbasEphParamsForSV);


    SetSbasEphParamsForSV::SetSbasEphParamsForSV()
      : CommandBase(CmdName)
    {}

    SetSbasEphParamsForSV::SetSbasEphParamsForSV(int svId, const std::map<std::string, double>& paramValueDict)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamValueDict(paramValueDict);
    }


    SetSbasEphParamsForSVPtr SetSbasEphParamsForSV::create(int svId, const std::map<std::string, double>& paramValueDict)
    {
      return SetSbasEphParamsForSVPtr(new SetSbasEphParamsForSV(svId, paramValueDict));
    }

    SetSbasEphParamsForSVPtr SetSbasEphParamsForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasEphParamsForSV>(ptr);
    }

    bool SetSbasEphParamsForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, double>>::is_valid(m_values["ParamValueDict"])
        ;

    }

    std::string SetSbasEphParamsForSV::documentation() const { return Documentation; }


    int SetSbasEphParamsForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetSbasEphParamsForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasEphParamsForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, double> SetSbasEphParamsForSV::paramValueDict() const
    {
      return parse_json<std::map<std::string, double>>::parse(m_values["ParamValueDict"]);
    }

    void SetSbasEphParamsForSV::setParamValueDict(const std::map<std::string, double>& paramValueDict)
    {
      m_values.AddMember("ParamValueDict", parse_json<std::map<std::string, double>>::format(paramValueDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasEphParamsForSV
///
#include "gen/GetSbasEphParamsForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasEphParamsForSV::CmdName = "GetSbasEphParamsForSV";
    const char* const GetSbasEphParamsForSV::Documentation = "Get parameters for a SBAS satellite ephemeris (runtime modification only available for health parameter)";

    REGISTER_COMMAND_FACTORY(GetSbasEphParamsForSV);


    GetSbasEphParamsForSV::GetSbasEphParamsForSV()
      : CommandBase(CmdName)
    {}

    GetSbasEphParamsForSV::GetSbasEphParamsForSV(int svId, const std::vector<std::string>& paramArray)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setParamArray(paramArray);
    }


    GetSbasEphParamsForSVPtr GetSbasEphParamsForSV::create(int svId, const std::vector<std::string>& paramArray)
    {
      return GetSbasEphParamsForSVPtr(new GetSbasEphParamsForSV(svId, paramArray));
    }

    GetSbasEphParamsForSVPtr GetSbasEphParamsForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasEphParamsForSV>(ptr);
    }

    bool GetSbasEphParamsForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["ParamArray"])
        ;

    }

    std::string GetSbasEphParamsForSV::documentation() const { return Documentation; }


    int GetSbasEphParamsForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetSbasEphParamsForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSbasEphParamsForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetSbasEphParamsForSV::paramArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["ParamArray"]);
    }

    void GetSbasEphParamsForSV::setParamArray(const std::vector<std::string>& paramArray)
    {
      m_values.AddMember("ParamArray", parse_json<std::vector<std::string>>::format(paramArray, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasEphParamsForSVResult
///
#include "gen/GetSbasEphParamsForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasEphParamsForSVResult::CmdName = "GetSbasEphParamsForSVResult";
    const char* const GetSbasEphParamsForSVResult::Documentation = "Result of GetSbasEphParamsForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasEphParamsForSVResult);


    GetSbasEphParamsForSVResult::GetSbasEphParamsForSVResult()
      : CommandResult(CmdName)
    {}

    GetSbasEphParamsForSVResult::GetSbasEphParamsForSVResult(CommandBasePtr relatedCommand, int svId, const std::map<std::string, double>& paramValueDict)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setParamValueDict(paramValueDict);
    }


    GetSbasEphParamsForSVResultPtr GetSbasEphParamsForSVResult::create(CommandBasePtr relatedCommand, int svId, const std::map<std::string, double>& paramValueDict)
    {
      return GetSbasEphParamsForSVResultPtr(new GetSbasEphParamsForSVResult(relatedCommand, svId, paramValueDict));
    }

    GetSbasEphParamsForSVResultPtr GetSbasEphParamsForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasEphParamsForSVResult>(ptr);
    }

    bool GetSbasEphParamsForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::map<std::string, double>>::is_valid(m_values["ParamValueDict"])
        ;

    }

    std::string GetSbasEphParamsForSVResult::documentation() const { return Documentation; }


    int GetSbasEphParamsForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetSbasEphParamsForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::map<std::string, double> GetSbasEphParamsForSVResult::paramValueDict() const
    {
      return parse_json<std::map<std::string, double>>::parse(m_values["ParamValueDict"]);
    }

    void GetSbasEphParamsForSVResult::setParamValueDict(const std::map<std::string, double>& paramValueDict)
    {
      m_values.AddMember("ParamValueDict", parse_json<std::map<std::string, double>>::format(paramValueDict, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasRangingHealthForSV
///
#include "gen/SetSbasRangingHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasRangingHealthForSV::CmdName = "SetSbasRangingHealthForSV";
    const char* const SetSbasRangingHealthForSV::Documentation = "Apply ranging flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasRangingHealthForSV);


    SetSbasRangingHealthForSV::SetSbasRangingHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasRangingHealthForSV::SetSbasRangingHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasRangingHealthForSVPtr SetSbasRangingHealthForSV::create(int svId, bool health)
    {
      return SetSbasRangingHealthForSVPtr(new SetSbasRangingHealthForSV(svId, health));
    }

    SetSbasRangingHealthForSVPtr SetSbasRangingHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasRangingHealthForSV>(ptr);
    }

    bool SetSbasRangingHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasRangingHealthForSV::documentation() const { return Documentation; }


    int SetSbasRangingHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasRangingHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasRangingHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasRangingHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasRangingHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasCorrectionsHealthForSV
///
#include "gen/SetSbasCorrectionsHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasCorrectionsHealthForSV::CmdName = "SetSbasCorrectionsHealthForSV";
    const char* const SetSbasCorrectionsHealthForSV::Documentation = "Apply correction flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasCorrectionsHealthForSV);


    SetSbasCorrectionsHealthForSV::SetSbasCorrectionsHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasCorrectionsHealthForSV::SetSbasCorrectionsHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasCorrectionsHealthForSVPtr SetSbasCorrectionsHealthForSV::create(int svId, bool health)
    {
      return SetSbasCorrectionsHealthForSVPtr(new SetSbasCorrectionsHealthForSV(svId, health));
    }

    SetSbasCorrectionsHealthForSVPtr SetSbasCorrectionsHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasCorrectionsHealthForSV>(ptr);
    }

    bool SetSbasCorrectionsHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasCorrectionsHealthForSV::documentation() const { return Documentation; }


    int SetSbasCorrectionsHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasCorrectionsHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasCorrectionsHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasCorrectionsHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasCorrectionsHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasIntegrityHealthForSV
///
#include "gen/SetSbasIntegrityHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasIntegrityHealthForSV::CmdName = "SetSbasIntegrityHealthForSV";
    const char* const SetSbasIntegrityHealthForSV::Documentation = "Apply integrity flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasIntegrityHealthForSV);


    SetSbasIntegrityHealthForSV::SetSbasIntegrityHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasIntegrityHealthForSV::SetSbasIntegrityHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasIntegrityHealthForSVPtr SetSbasIntegrityHealthForSV::create(int svId, bool health)
    {
      return SetSbasIntegrityHealthForSVPtr(new SetSbasIntegrityHealthForSV(svId, health));
    }

    SetSbasIntegrityHealthForSVPtr SetSbasIntegrityHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasIntegrityHealthForSV>(ptr);
    }

    bool SetSbasIntegrityHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasIntegrityHealthForSV::documentation() const { return Documentation; }


    int SetSbasIntegrityHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasIntegrityHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasIntegrityHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasIntegrityHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasIntegrityHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasReservedHealthForSV
///
#include "gen/SetSbasReservedHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasReservedHealthForSV::CmdName = "SetSbasReservedHealthForSV";
    const char* const SetSbasReservedHealthForSV::Documentation = "Apply reserved flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasReservedHealthForSV);


    SetSbasReservedHealthForSV::SetSbasReservedHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasReservedHealthForSV::SetSbasReservedHealthForSV(int svId, bool health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasReservedHealthForSVPtr SetSbasReservedHealthForSV::create(int svId, bool health)
    {
      return SetSbasReservedHealthForSVPtr(new SetSbasReservedHealthForSV(svId, health));
    }

    SetSbasReservedHealthForSVPtr SetSbasReservedHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasReservedHealthForSV>(ptr);
    }

    bool SetSbasReservedHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasReservedHealthForSV::documentation() const { return Documentation; }


    int SetSbasReservedHealthForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasReservedHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasReservedHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasReservedHealthForSV::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasReservedHealthForSV::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasServiceHealthForSV
///
#include "gen/SetSbasServiceHealthForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasServiceHealthForSV::CmdName = "SetSbasServiceHealthForSV";
    const char* const SetSbasServiceHealthForSV::Documentation = "Apply service provider for a satellite";

    REGISTER_COMMAND_FACTORY(SetSbasServiceHealthForSV);


    SetSbasServiceHealthForSV::SetSbasServiceHealthForSV()
      : CommandBase(CmdName)
    {}

    SetSbasServiceHealthForSV::SetSbasServiceHealthForSV(int svId, int health)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setHealth(health);
    }


    SetSbasServiceHealthForSVPtr SetSbasServiceHealthForSV::create(int svId, int health)
    {
      return SetSbasServiceHealthForSVPtr(new SetSbasServiceHealthForSV(svId, health));
    }

    SetSbasServiceHealthForSVPtr SetSbasServiceHealthForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasServiceHealthForSV>(ptr);
    }

    bool SetSbasServiceHealthForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasServiceHealthForSV::documentation() const { return Documentation; }


    int SetSbasServiceHealthForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetSbasServiceHealthForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetSbasServiceHealthForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSbasServiceHealthForSV::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetSbasServiceHealthForSV::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetPerturbations
///
#include "gen/ResetPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetPerturbations::CmdName = "ResetPerturbations";
    const char* const ResetPerturbations::Documentation = "Set orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) to zero for the specified constellation.";

    REGISTER_COMMAND_FACTORY(ResetPerturbations);


    ResetPerturbations::ResetPerturbations()
      : CommandBase(CmdName)
    {}

    ResetPerturbations::ResetPerturbations(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    ResetPerturbationsPtr ResetPerturbations::create(const std::string& system, int svId)
    {
      return ResetPerturbationsPtr(new ResetPerturbations(system, svId));
    }

    ResetPerturbationsPtr ResetPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetPerturbations>(ptr);
    }

    bool ResetPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string ResetPerturbations::documentation() const { return Documentation; }


    int ResetPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ResetPerturbations::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ResetPerturbations::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ResetPerturbations::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void ResetPerturbations::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPerturbations
///
#include "gen/SetPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPerturbations::CmdName = "SetPerturbations";
    const char* const SetPerturbations::Documentation = "Set orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for the specified constellation.";

    REGISTER_COMMAND_FACTORY(SetPerturbations);


    SetPerturbations::SetPerturbations()
      : CommandBase(CmdName)
    {}

    SetPerturbations::SetPerturbations(const std::string& system, int svId, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetPerturbationsPtr SetPerturbations::create(const std::string& system, int svId, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return SetPerturbationsPtr(new SetPerturbations(system, svId, crs, crc, cis, cic, cus, cuc));
    }

    SetPerturbationsPtr SetPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPerturbations>(ptr);
    }

    bool SetPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetPerturbations::documentation() const { return Documentation; }


    int SetPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPerturbations::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPerturbations::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPerturbations::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPerturbations::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void SetPerturbations::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void SetPerturbations::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void SetPerturbations::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void SetPerturbations::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void SetPerturbations::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPerturbations::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void SetPerturbations::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPerturbations
///
#include "gen/GetPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPerturbations::CmdName = "GetPerturbations";
    const char* const GetPerturbations::Documentation = "Get orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetPerturbations);


    GetPerturbations::GetPerturbations()
      : CommandBase(CmdName)
    {}

    GetPerturbations::GetPerturbations(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetPerturbationsPtr GetPerturbations::create(const std::string& system, int svId)
    {
      return GetPerturbationsPtr(new GetPerturbations(system, svId));
    }

    GetPerturbationsPtr GetPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPerturbations>(ptr);
    }

    bool GetPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetPerturbations::documentation() const { return Documentation; }


    int GetPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPerturbations::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPerturbations::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPerturbations::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPerturbations::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPerturbationsResult
///
#include "gen/GetPerturbationsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPerturbationsResult::CmdName = "GetPerturbationsResult";
    const char* const GetPerturbationsResult::Documentation = "Result of GetPerturbations";

    REGISTER_COMMAND_RESULT_FACTORY(GetPerturbationsResult);


    GetPerturbationsResult::GetPerturbationsResult()
      : CommandResult(CmdName)
    {}

    GetPerturbationsResult::GetPerturbationsResult(CommandBasePtr relatedCommand, const std::string& system, int svId, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetPerturbationsResultPtr GetPerturbationsResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return GetPerturbationsResultPtr(new GetPerturbationsResult(relatedCommand, system, svId, crs, crc, cis, cic, cus, cuc));
    }

    GetPerturbationsResultPtr GetPerturbationsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPerturbationsResult>(ptr);
    }

    bool GetPerturbationsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetPerturbationsResult::documentation() const { return Documentation; }


    std::string GetPerturbationsResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPerturbationsResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPerturbationsResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPerturbationsResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void GetPerturbationsResult::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void GetPerturbationsResult::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void GetPerturbationsResult::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void GetPerturbationsResult::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void GetPerturbationsResult::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPerturbationsResult::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void GetPerturbationsResult::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPerturbationsForAllSat
///
#include "gen/SetPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPerturbationsForAllSat::CmdName = "SetPerturbationsForAllSat";
    const char* const SetPerturbationsForAllSat::Documentation = "Set orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites of the specified constellation..\nAll parameters are zero based index (index 0 => SV ID 1, index 1 => SV ID 2, etc)";

    REGISTER_COMMAND_FACTORY(SetPerturbationsForAllSat);


    SetPerturbationsForAllSat::SetPerturbationsForAllSat()
      : CommandBase(CmdName)
    {}

    SetPerturbationsForAllSat::SetPerturbationsForAllSat(const std::string& system, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetPerturbationsForAllSatPtr SetPerturbationsForAllSat::create(const std::string& system, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return SetPerturbationsForAllSatPtr(new SetPerturbationsForAllSat(system, crs, crc, cis, cic, cus, cuc));
    }

    SetPerturbationsForAllSatPtr SetPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPerturbationsForAllSat>(ptr);
    }

    bool SetPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetPerturbationsForAllSat::documentation() const { return Documentation; }


    int SetPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPerturbationsForAllSat::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPerturbationsForAllSat::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void SetPerturbationsForAllSat::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void SetPerturbationsForAllSat::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void SetPerturbationsForAllSat::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void SetPerturbationsForAllSat::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void SetPerturbationsForAllSat::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPerturbationsForAllSat::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void SetPerturbationsForAllSat::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPerturbationsForAllSat
///
#include "gen/GetPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPerturbationsForAllSat::CmdName = "GetPerturbationsForAllSat";
    const char* const GetPerturbationsForAllSat::Documentation = "Get orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites of the specified constellation..\nAll parameters are zero based index (index 0 => SV ID 1, index 1 => SV ID 2, etc)";

    REGISTER_COMMAND_FACTORY(GetPerturbationsForAllSat);


    GetPerturbationsForAllSat::GetPerturbationsForAllSat()
      : CommandBase(CmdName)
    {}

    GetPerturbationsForAllSat::GetPerturbationsForAllSat(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetPerturbationsForAllSatPtr GetPerturbationsForAllSat::create(const std::string& system)
    {
      return GetPerturbationsForAllSatPtr(new GetPerturbationsForAllSat(system));
    }

    GetPerturbationsForAllSatPtr GetPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPerturbationsForAllSat>(ptr);
    }

    bool GetPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetPerturbationsForAllSat::documentation() const { return Documentation; }


    int GetPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPerturbationsForAllSat::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPerturbationsForAllSat::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPerturbationsForAllSatResult
///
#include "gen/GetPerturbationsForAllSatResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPerturbationsForAllSatResult::CmdName = "GetPerturbationsForAllSatResult";
    const char* const GetPerturbationsForAllSatResult::Documentation = "Result of GetPerturbationsForAllSat";

    REGISTER_COMMAND_RESULT_FACTORY(GetPerturbationsForAllSatResult);


    GetPerturbationsForAllSatResult::GetPerturbationsForAllSatResult()
      : CommandResult(CmdName)
    {}

    GetPerturbationsForAllSatResult::GetPerturbationsForAllSatResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetPerturbationsForAllSatResultPtr GetPerturbationsForAllSatResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return GetPerturbationsForAllSatResultPtr(new GetPerturbationsForAllSatResult(relatedCommand, system, crs, crc, cis, cic, cus, cuc));
    }

    GetPerturbationsForAllSatResultPtr GetPerturbationsForAllSatResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPerturbationsForAllSatResult>(ptr);
    }

    bool GetPerturbationsForAllSatResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetPerturbationsForAllSatResult::documentation() const { return Documentation; }


    std::string GetPerturbationsForAllSatResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPerturbationsForAllSatResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void GetPerturbationsForAllSatResult::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void GetPerturbationsForAllSatResult::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void GetPerturbationsForAllSatResult::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void GetPerturbationsForAllSatResult::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void GetPerturbationsForAllSatResult::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPerturbationsForAllSatResult::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void GetPerturbationsForAllSatResult::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGpsCNav
///
#include "gen/SetMessageModificationToGpsCNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGpsCNav::CmdName = "SetMessageModificationToGpsCNav";
    const char* const SetMessageModificationToGpsCNav::Documentation = "Set (or Modify) event to change GPS CNAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGpsCNav);


    SetMessageModificationToGpsCNav::SetMessageModificationToGpsCNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGpsCNav::SetMessageModificationToGpsCNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGpsCNavPtr SetMessageModificationToGpsCNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToGpsCNavPtr(new SetMessageModificationToGpsCNav(signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id));
    }

    SetMessageModificationToGpsCNavPtr SetMessageModificationToGpsCNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGpsCNav>(ptr);
    }

    bool SetMessageModificationToGpsCNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGpsCNav::documentation() const { return Documentation; }


    int SetMessageModificationToGpsCNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGpsCNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGpsCNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGpsCNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGpsCNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGpsCNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToGpsCNav::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGpsCNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGpsCNav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToGpsCNav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGpsCNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGpsCNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsCNav
///
#include "gen/GetMessageModificationToGpsCNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsCNav::CmdName = "GetMessageModificationToGpsCNav";
    const char* const GetMessageModificationToGpsCNav::Documentation = "Get infos about the GPS CNAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGpsCNav);


    GetMessageModificationToGpsCNav::GetMessageModificationToGpsCNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGpsCNav::GetMessageModificationToGpsCNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGpsCNavPtr GetMessageModificationToGpsCNav::create(const std::string& id)
    {
      return GetMessageModificationToGpsCNavPtr(new GetMessageModificationToGpsCNav(id));
    }

    GetMessageModificationToGpsCNavPtr GetMessageModificationToGpsCNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsCNav>(ptr);
    }

    bool GetMessageModificationToGpsCNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsCNav::documentation() const { return Documentation; }


    int GetMessageModificationToGpsCNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGpsCNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsCNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsCNavResult
///
#include "gen/GetMessageModificationToGpsCNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsCNavResult::CmdName = "GetMessageModificationToGpsCNavResult";
    const char* const GetMessageModificationToGpsCNavResult::Documentation = "Result of GetMessageModificationToGpsCNav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGpsCNavResult);


    GetMessageModificationToGpsCNavResult::GetMessageModificationToGpsCNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGpsCNavResult::GetMessageModificationToGpsCNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGpsCNavResultPtr GetMessageModificationToGpsCNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToGpsCNavResultPtr(new GetMessageModificationToGpsCNavResult(relatedCommand, signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id));
    }

    GetMessageModificationToGpsCNavResultPtr GetMessageModificationToGpsCNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsCNavResult>(ptr);
    }

    bool GetMessageModificationToGpsCNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsCNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGpsCNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGpsCNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGpsCNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGpsCNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGpsCNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNavResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToGpsCNavResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGpsCNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGpsCNavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToGpsCNavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGpsCNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsCNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGpsMNav
///
#include "gen/SetMessageModificationToGpsMNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGpsMNav::CmdName = "SetMessageModificationToGpsMNav";
    const char* const SetMessageModificationToGpsMNav::Documentation = "Set (or Modify) event to change GPS MNAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGpsMNav);


    SetMessageModificationToGpsMNav::SetMessageModificationToGpsMNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGpsMNav::SetMessageModificationToGpsMNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, int occurrence, const std::string& condition, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setOccurrence(occurrence);
      setCondition(condition);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGpsMNavPtr SetMessageModificationToGpsMNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, int occurrence, const std::string& condition, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToGpsMNavPtr(new SetMessageModificationToGpsMNav(signalArray, svId, startTime, stopTime, messageType, occurrence, condition, bitModifications, id));
    }

    SetMessageModificationToGpsMNavPtr SetMessageModificationToGpsMNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGpsMNav>(ptr);
    }

    bool SetMessageModificationToGpsMNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<int>::is_valid(m_values["Occurrence"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGpsMNav::documentation() const { return Documentation; }


    int SetMessageModificationToGpsMNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGpsMNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGpsMNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGpsMNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGpsMNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGpsMNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToGpsMNav::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsMNav::occurrence() const
    {
      return parse_json<int>::parse(m_values["Occurrence"]);
    }

    void SetMessageModificationToGpsMNav::setOccurrence(int occurrence)
    {
      m_values.AddMember("Occurrence", parse_json<int>::format(occurrence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsMNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGpsMNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsMNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGpsMNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsMNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGpsMNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsMNav
///
#include "gen/GetMessageModificationToGpsMNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsMNav::CmdName = "GetMessageModificationToGpsMNav";
    const char* const GetMessageModificationToGpsMNav::Documentation = "Get infos about the GPS MNAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGpsMNav);


    GetMessageModificationToGpsMNav::GetMessageModificationToGpsMNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGpsMNav::GetMessageModificationToGpsMNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGpsMNavPtr GetMessageModificationToGpsMNav::create(const std::string& id)
    {
      return GetMessageModificationToGpsMNavPtr(new GetMessageModificationToGpsMNav(id));
    }

    GetMessageModificationToGpsMNavPtr GetMessageModificationToGpsMNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsMNav>(ptr);
    }

    bool GetMessageModificationToGpsMNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsMNav::documentation() const { return Documentation; }


    int GetMessageModificationToGpsMNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGpsMNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsMNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsMNavResult
///
#include "gen/GetMessageModificationToGpsMNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsMNavResult::CmdName = "GetMessageModificationToGpsMNavResult";
    const char* const GetMessageModificationToGpsMNavResult::Documentation = "Result of GetMessageModificationToGpsMNav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGpsMNavResult);


    GetMessageModificationToGpsMNavResult::GetMessageModificationToGpsMNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGpsMNavResult::GetMessageModificationToGpsMNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, int occurrence, const std::string& condition, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setOccurrence(occurrence);
      setCondition(condition);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGpsMNavResultPtr GetMessageModificationToGpsMNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, int occurrence, const std::string& condition, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToGpsMNavResultPtr(new GetMessageModificationToGpsMNavResult(relatedCommand, signalArray, svId, startTime, stopTime, messageType, occurrence, condition, bitModifications, id));
    }

    GetMessageModificationToGpsMNavResultPtr GetMessageModificationToGpsMNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsMNavResult>(ptr);
    }

    bool GetMessageModificationToGpsMNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<int>::is_valid(m_values["Occurrence"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsMNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGpsMNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGpsMNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGpsMNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGpsMNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGpsMNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToGpsMNavResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsMNavResult::occurrence() const
    {
      return parse_json<int>::parse(m_values["Occurrence"]);
    }

    void GetMessageModificationToGpsMNavResult::setOccurrence(int occurrence)
    {
      m_values.AddMember("Occurrence", parse_json<int>::format(occurrence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsMNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGpsMNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsMNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGpsMNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsMNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsMNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGpsCNav2
///
#include "gen/SetMessageModificationToGpsCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGpsCNav2::CmdName = "SetMessageModificationToGpsCNav2";
    const char* const SetMessageModificationToGpsCNav2::Documentation = "Set (or Modify) event to change GPS CNAV-2 message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGpsCNav2);


    SetMessageModificationToGpsCNav2::SetMessageModificationToGpsCNav2()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGpsCNav2::SetMessageModificationToGpsCNav2(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGpsCNav2Ptr SetMessageModificationToGpsCNav2::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToGpsCNav2Ptr(new SetMessageModificationToGpsCNav2(signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id));
    }

    SetMessageModificationToGpsCNav2Ptr SetMessageModificationToGpsCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGpsCNav2>(ptr);
    }

    bool SetMessageModificationToGpsCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGpsCNav2::documentation() const { return Documentation; }


    int SetMessageModificationToGpsCNav2::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGpsCNav2::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGpsCNav2::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav2::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGpsCNav2::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav2::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGpsCNav2::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav2::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGpsCNav2::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsCNav2::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToGpsCNav2::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav2::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGpsCNav2::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGpsCNav2::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToGpsCNav2::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav2::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGpsCNav2::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGpsCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsCNav2
///
#include "gen/GetMessageModificationToGpsCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsCNav2::CmdName = "GetMessageModificationToGpsCNav2";
    const char* const GetMessageModificationToGpsCNav2::Documentation = "Get infos about the GPS CNAV-2 message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGpsCNav2);


    GetMessageModificationToGpsCNav2::GetMessageModificationToGpsCNav2()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGpsCNav2::GetMessageModificationToGpsCNav2(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGpsCNav2Ptr GetMessageModificationToGpsCNav2::create(const std::string& id)
    {
      return GetMessageModificationToGpsCNav2Ptr(new GetMessageModificationToGpsCNav2(id));
    }

    GetMessageModificationToGpsCNav2Ptr GetMessageModificationToGpsCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsCNav2>(ptr);
    }

    bool GetMessageModificationToGpsCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsCNav2::documentation() const { return Documentation; }


    int GetMessageModificationToGpsCNav2::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGpsCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsCNav2Result
///
#include "gen/GetMessageModificationToGpsCNav2Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsCNav2Result::CmdName = "GetMessageModificationToGpsCNav2Result";
    const char* const GetMessageModificationToGpsCNav2Result::Documentation = "Result of GetMessageModificationToGpsCNav2";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGpsCNav2Result);


    GetMessageModificationToGpsCNav2Result::GetMessageModificationToGpsCNav2Result()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGpsCNav2Result::GetMessageModificationToGpsCNav2Result(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGpsCNav2ResultPtr GetMessageModificationToGpsCNav2Result::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToGpsCNav2ResultPtr(new GetMessageModificationToGpsCNav2Result(relatedCommand, signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id));
    }

    GetMessageModificationToGpsCNav2ResultPtr GetMessageModificationToGpsCNav2Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsCNav2Result>(ptr);
    }

    bool GetMessageModificationToGpsCNav2Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsCNav2Result::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGpsCNav2Result::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGpsCNav2Result::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNav2Result::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGpsCNav2Result::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNav2Result::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGpsCNav2Result::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNav2Result::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGpsCNav2Result::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsCNav2Result::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToGpsCNav2Result::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNav2Result::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGpsCNav2Result::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGpsCNav2Result::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToGpsCNav2Result::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNav2Result::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGpsCNav2Result::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsCNav2Result::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsCNav2Result::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGpsLNav
///
#include "gen/SetMessageModificationToGpsLNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGpsLNav::CmdName = "SetMessageModificationToGpsLNav";
    const char* const SetMessageModificationToGpsLNav::Documentation = "Set (or Modify) event to change GPS LNAV message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to bits 25..30 will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGpsLNav);


    SetMessageModificationToGpsLNav::SetMessageModificationToGpsLNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGpsLNav::SetMessageModificationToGpsLNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    SetMessageModificationToGpsLNavPtr SetMessageModificationToGpsLNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return SetMessageModificationToGpsLNavPtr(new SetMessageModificationToGpsLNav(signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id));
    }

    SetMessageModificationToGpsLNavPtr SetMessageModificationToGpsLNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGpsLNav>(ptr);
    }

    bool SetMessageModificationToGpsLNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGpsLNav::documentation() const { return Documentation; }


    int SetMessageModificationToGpsLNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGpsLNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGpsLNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGpsLNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGpsLNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGpsLNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToGpsLNav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToGpsLNav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGpsLNav::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetMessageModificationToGpsLNav::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGpsLNav::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetMessageModificationToGpsLNav::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsLNav::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void SetMessageModificationToGpsLNav::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGpsLNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGpsLNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsLNav
///
#include "gen/GetMessageModificationToGpsLNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsLNav::CmdName = "GetMessageModificationToGpsLNav";
    const char* const GetMessageModificationToGpsLNav::Documentation = "Get infos about the GPS LNAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGpsLNav);


    GetMessageModificationToGpsLNav::GetMessageModificationToGpsLNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGpsLNav::GetMessageModificationToGpsLNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGpsLNavPtr GetMessageModificationToGpsLNav::create(const std::string& id)
    {
      return GetMessageModificationToGpsLNavPtr(new GetMessageModificationToGpsLNav(id));
    }

    GetMessageModificationToGpsLNavPtr GetMessageModificationToGpsLNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsLNav>(ptr);
    }

    bool GetMessageModificationToGpsLNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsLNav::documentation() const { return Documentation; }


    int GetMessageModificationToGpsLNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGpsLNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsLNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGpsLNavResult
///
#include "gen/GetMessageModificationToGpsLNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGpsLNavResult::CmdName = "GetMessageModificationToGpsLNavResult";
    const char* const GetMessageModificationToGpsLNavResult::Documentation = "Result of GetMessageModificationToGpsLNav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGpsLNavResult);


    GetMessageModificationToGpsLNavResult::GetMessageModificationToGpsLNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGpsLNavResult::GetMessageModificationToGpsLNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    GetMessageModificationToGpsLNavResultPtr GetMessageModificationToGpsLNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return GetMessageModificationToGpsLNavResultPtr(new GetMessageModificationToGpsLNavResult(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id));
    }

    GetMessageModificationToGpsLNavResultPtr GetMessageModificationToGpsLNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGpsLNavResult>(ptr);
    }

    bool GetMessageModificationToGpsLNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGpsLNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGpsLNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGpsLNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGpsLNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGpsLNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGpsLNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToGpsLNavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToGpsLNavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGpsLNavResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetMessageModificationToGpsLNavResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGpsLNavResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetMessageModificationToGpsLNavResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsLNavResult::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void GetMessageModificationToGpsLNavResult::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGpsLNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGpsLNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGalileoFNav
///
#include "gen/SetMessageModificationToGalileoFNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGalileoFNav::CmdName = "SetMessageModificationToGalileoFNav";
    const char* const SetMessageModificationToGalileoFNav::Documentation = "Set (or Modify) event to change Galileo F/NAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGalileoFNav);


    SetMessageModificationToGalileoFNav::SetMessageModificationToGalileoFNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGalileoFNav::SetMessageModificationToGalileoFNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGalileoFNavPtr SetMessageModificationToGalileoFNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToGalileoFNavPtr(new SetMessageModificationToGalileoFNav(signalArray, svId, startTime, stopTime, subframe, page, condition, updateCRC, bitModifications, id));
    }

    SetMessageModificationToGalileoFNavPtr SetMessageModificationToGalileoFNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGalileoFNav>(ptr);
    }

    bool SetMessageModificationToGalileoFNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGalileoFNav::documentation() const { return Documentation; }


    int SetMessageModificationToGalileoFNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGalileoFNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGalileoFNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGalileoFNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGalileoFNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGalileoFNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToGalileoFNav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoFNav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToGalileoFNav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoFNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGalileoFNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGalileoFNav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToGalileoFNav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoFNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGalileoFNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoFNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGalileoFNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoFNav
///
#include "gen/GetMessageModificationToGalileoFNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoFNav::CmdName = "GetMessageModificationToGalileoFNav";
    const char* const GetMessageModificationToGalileoFNav::Documentation = "Get infos about the Galileo F/NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGalileoFNav);


    GetMessageModificationToGalileoFNav::GetMessageModificationToGalileoFNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGalileoFNav::GetMessageModificationToGalileoFNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGalileoFNavPtr GetMessageModificationToGalileoFNav::create(const std::string& id)
    {
      return GetMessageModificationToGalileoFNavPtr(new GetMessageModificationToGalileoFNav(id));
    }

    GetMessageModificationToGalileoFNavPtr GetMessageModificationToGalileoFNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoFNav>(ptr);
    }

    bool GetMessageModificationToGalileoFNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoFNav::documentation() const { return Documentation; }


    int GetMessageModificationToGalileoFNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGalileoFNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoFNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoFNavResult
///
#include "gen/GetMessageModificationToGalileoFNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoFNavResult::CmdName = "GetMessageModificationToGalileoFNavResult";
    const char* const GetMessageModificationToGalileoFNavResult::Documentation = "Result of GetMessageModificationToGalileoFNav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGalileoFNavResult);


    GetMessageModificationToGalileoFNavResult::GetMessageModificationToGalileoFNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGalileoFNavResult::GetMessageModificationToGalileoFNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGalileoFNavResultPtr GetMessageModificationToGalileoFNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToGalileoFNavResultPtr(new GetMessageModificationToGalileoFNavResult(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, condition, updateCRC, bitModifications, id));
    }

    GetMessageModificationToGalileoFNavResultPtr GetMessageModificationToGalileoFNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoFNavResult>(ptr);
    }

    bool GetMessageModificationToGalileoFNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoFNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGalileoFNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGalileoFNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGalileoFNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGalileoFNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGalileoFNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToGalileoFNavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoFNavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToGalileoFNavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoFNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGalileoFNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGalileoFNavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToGalileoFNavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoFNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGalileoFNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoFNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoFNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGalileoINav
///
#include "gen/SetMessageModificationToGalileoINav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGalileoINav::CmdName = "SetMessageModificationToGalileoINav";
    const char* const SetMessageModificationToGalileoINav::Documentation = "Set (or Modify) event to change Galileo I/NAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGalileoINav);


    SetMessageModificationToGalileoINav::SetMessageModificationToGalileoINav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGalileoINav::SetMessageModificationToGalileoINav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToGalileoINavPtr SetMessageModificationToGalileoINav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToGalileoINavPtr(new SetMessageModificationToGalileoINav(signalArray, svId, startTime, stopTime, subframe, page, condition, updateCRC, bitModifications, id));
    }

    SetMessageModificationToGalileoINavPtr SetMessageModificationToGalileoINav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGalileoINav>(ptr);
    }

    bool SetMessageModificationToGalileoINav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGalileoINav::documentation() const { return Documentation; }


    int SetMessageModificationToGalileoINav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGalileoINav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGalileoINav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGalileoINav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGalileoINav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGalileoINav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToGalileoINav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGalileoINav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToGalileoINav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoINav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToGalileoINav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGalileoINav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToGalileoINav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoINav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToGalileoINav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGalileoINav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGalileoINav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoINav
///
#include "gen/GetMessageModificationToGalileoINav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoINav::CmdName = "GetMessageModificationToGalileoINav";
    const char* const GetMessageModificationToGalileoINav::Documentation = "Get infos about the Galileo I/NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGalileoINav);


    GetMessageModificationToGalileoINav::GetMessageModificationToGalileoINav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGalileoINav::GetMessageModificationToGalileoINav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGalileoINavPtr GetMessageModificationToGalileoINav::create(const std::string& id)
    {
      return GetMessageModificationToGalileoINavPtr(new GetMessageModificationToGalileoINav(id));
    }

    GetMessageModificationToGalileoINavPtr GetMessageModificationToGalileoINav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoINav>(ptr);
    }

    bool GetMessageModificationToGalileoINav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoINav::documentation() const { return Documentation; }


    int GetMessageModificationToGalileoINav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGalileoINav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoINav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGalileoINavResult
///
#include "gen/GetMessageModificationToGalileoINavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGalileoINavResult::CmdName = "GetMessageModificationToGalileoINavResult";
    const char* const GetMessageModificationToGalileoINavResult::Documentation = "Result of GetMessageModificationToGalileoINav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGalileoINavResult);


    GetMessageModificationToGalileoINavResult::GetMessageModificationToGalileoINavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGalileoINavResult::GetMessageModificationToGalileoINavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToGalileoINavResultPtr GetMessageModificationToGalileoINavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToGalileoINavResultPtr(new GetMessageModificationToGalileoINavResult(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, condition, updateCRC, bitModifications, id));
    }

    GetMessageModificationToGalileoINavResultPtr GetMessageModificationToGalileoINavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGalileoINavResult>(ptr);
    }

    bool GetMessageModificationToGalileoINavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGalileoINavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGalileoINavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGalileoINavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGalileoINavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGalileoINavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGalileoINavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToGalileoINavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGalileoINavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToGalileoINavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoINavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToGalileoINavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGalileoINavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToGalileoINavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoINavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToGalileoINavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGalileoINavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGalileoINavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToGlonassNav
///
#include "gen/SetMessageModificationToGlonassNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToGlonassNav::CmdName = "SetMessageModificationToGlonassNav";
    const char* const SetMessageModificationToGlonassNav::Documentation = "Set (or Modify) event to change GLONASS NAV message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessage strings. The Modification parameter is a string where the first character applies to bit\n85 of frame string and last character applies to Hamming Code bit 1.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   ' ' white space are ignored (use them to separate the string into bytes to help reading)\n   '-' or any other byte value will have no effect\n\nExample:\n\n\"-0--- 1------- -------- -------- -------- -------- -------- -------- -------- -------- ---1--X-\"\n  |  |                                           |  |\n  |  +- Force bit 80 to '1'               Force Hamming code bit 5 to '1' -+  |\n  |                                               |\n  +------ Force bit 84 to 0                   Negate Hamming code bit 2 ----+\n\nNote: if UpdateHammingCode is true, any modification to bits 1..8 will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToGlonassNav);


    SetMessageModificationToGlonassNav::SetMessageModificationToGlonassNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToGlonassNav::SetMessageModificationToGlonassNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& stringModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setFrame(frame);
      setStringNumber(stringNumber);
      setUpdateHammingCode(updateHammingCode);
      setStringModification(stringModification);
      setId(id);
    }


    SetMessageModificationToGlonassNavPtr SetMessageModificationToGlonassNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& stringModification, const std::string& id)
    {
      return SetMessageModificationToGlonassNavPtr(new SetMessageModificationToGlonassNav(signalArray, svId, startTime, stopTime, frame, stringNumber, updateHammingCode, stringModification, id));
    }

    SetMessageModificationToGlonassNavPtr SetMessageModificationToGlonassNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToGlonassNav>(ptr);
    }

    bool SetMessageModificationToGlonassNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Frame"])
          && parse_json<int>::is_valid(m_values["StringNumber"])
          && parse_json<bool>::is_valid(m_values["UpdateHammingCode"])
          && parse_json<std::string>::is_valid(m_values["StringModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToGlonassNav::documentation() const { return Documentation; }


    int SetMessageModificationToGlonassNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToGlonassNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToGlonassNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToGlonassNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToGlonassNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToGlonassNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::frame() const
    {
      return parse_json<int>::parse(m_values["Frame"]);
    }

    void SetMessageModificationToGlonassNav::setFrame(int frame)
    {
      m_values.AddMember("Frame", parse_json<int>::format(frame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToGlonassNav::stringNumber() const
    {
      return parse_json<int>::parse(m_values["StringNumber"]);
    }

    void SetMessageModificationToGlonassNav::setStringNumber(int stringNumber)
    {
      m_values.AddMember("StringNumber", parse_json<int>::format(stringNumber, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToGlonassNav::updateHammingCode() const
    {
      return parse_json<bool>::parse(m_values["UpdateHammingCode"]);
    }

    void SetMessageModificationToGlonassNav::setUpdateHammingCode(bool updateHammingCode)
    {
      m_values.AddMember("UpdateHammingCode", parse_json<bool>::format(updateHammingCode, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGlonassNav::stringModification() const
    {
      return parse_json<std::string>::parse(m_values["StringModification"]);
    }

    void SetMessageModificationToGlonassNav::setStringModification(const std::string& stringModification)
    {
      m_values.AddMember("StringModification", parse_json<std::string>::format(stringModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToGlonassNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToGlonassNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGlonassNav
///
#include "gen/GetMessageModificationToGlonassNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGlonassNav::CmdName = "GetMessageModificationToGlonassNav";
    const char* const GetMessageModificationToGlonassNav::Documentation = "Get infos about the GLONASS NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToGlonassNav);


    GetMessageModificationToGlonassNav::GetMessageModificationToGlonassNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToGlonassNav::GetMessageModificationToGlonassNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToGlonassNavPtr GetMessageModificationToGlonassNav::create(const std::string& id)
    {
      return GetMessageModificationToGlonassNavPtr(new GetMessageModificationToGlonassNav(id));
    }

    GetMessageModificationToGlonassNavPtr GetMessageModificationToGlonassNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGlonassNav>(ptr);
    }

    bool GetMessageModificationToGlonassNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGlonassNav::documentation() const { return Documentation; }


    int GetMessageModificationToGlonassNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToGlonassNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGlonassNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToGlonassNavResult
///
#include "gen/GetMessageModificationToGlonassNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToGlonassNavResult::CmdName = "GetMessageModificationToGlonassNavResult";
    const char* const GetMessageModificationToGlonassNavResult::Documentation = "Result of GetMessageModificationToGlonassNav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToGlonassNavResult);


    GetMessageModificationToGlonassNavResult::GetMessageModificationToGlonassNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToGlonassNavResult::GetMessageModificationToGlonassNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& stringModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setFrame(frame);
      setStringNumber(stringNumber);
      setUpdateHammingCode(updateHammingCode);
      setStringModification(stringModification);
      setId(id);
    }


    GetMessageModificationToGlonassNavResultPtr GetMessageModificationToGlonassNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& stringModification, const std::string& id)
    {
      return GetMessageModificationToGlonassNavResultPtr(new GetMessageModificationToGlonassNavResult(relatedCommand, signalArray, svId, startTime, stopTime, frame, stringNumber, updateHammingCode, stringModification, id));
    }

    GetMessageModificationToGlonassNavResultPtr GetMessageModificationToGlonassNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToGlonassNavResult>(ptr);
    }

    bool GetMessageModificationToGlonassNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Frame"])
          && parse_json<int>::is_valid(m_values["StringNumber"])
          && parse_json<bool>::is_valid(m_values["UpdateHammingCode"])
          && parse_json<std::string>::is_valid(m_values["StringModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToGlonassNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToGlonassNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToGlonassNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToGlonassNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToGlonassNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToGlonassNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::frame() const
    {
      return parse_json<int>::parse(m_values["Frame"]);
    }

    void GetMessageModificationToGlonassNavResult::setFrame(int frame)
    {
      m_values.AddMember("Frame", parse_json<int>::format(frame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToGlonassNavResult::stringNumber() const
    {
      return parse_json<int>::parse(m_values["StringNumber"]);
    }

    void GetMessageModificationToGlonassNavResult::setStringNumber(int stringNumber)
    {
      m_values.AddMember("StringNumber", parse_json<int>::format(stringNumber, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToGlonassNavResult::updateHammingCode() const
    {
      return parse_json<bool>::parse(m_values["UpdateHammingCode"]);
    }

    void GetMessageModificationToGlonassNavResult::setUpdateHammingCode(bool updateHammingCode)
    {
      m_values.AddMember("UpdateHammingCode", parse_json<bool>::format(updateHammingCode, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGlonassNavResult::stringModification() const
    {
      return parse_json<std::string>::parse(m_values["StringModification"]);
    }

    void GetMessageModificationToGlonassNavResult::setStringModification(const std::string& stringModification)
    {
      m_values.AddMember("StringModification", parse_json<std::string>::format(stringModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToGlonassNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToGlonassNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToBeiDouD1Nav
///
#include "gen/SetMessageModificationToBeiDouD1Nav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToBeiDouD1Nav::CmdName = "SetMessageModificationToBeiDouD1Nav";
    const char* const SetMessageModificationToBeiDouD1Nav::Documentation = "Set (or Modify) event to change BeiDou D1 NAV navigation message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to parity bits will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToBeiDouD1Nav);


    SetMessageModificationToBeiDouD1Nav::SetMessageModificationToBeiDouD1Nav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToBeiDouD1Nav::SetMessageModificationToBeiDouD1Nav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    SetMessageModificationToBeiDouD1NavPtr SetMessageModificationToBeiDouD1Nav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return SetMessageModificationToBeiDouD1NavPtr(new SetMessageModificationToBeiDouD1Nav(signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id));
    }

    SetMessageModificationToBeiDouD1NavPtr SetMessageModificationToBeiDouD1Nav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToBeiDouD1Nav>(ptr);
    }

    bool SetMessageModificationToBeiDouD1Nav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToBeiDouD1Nav::documentation() const { return Documentation; }


    int SetMessageModificationToBeiDouD1Nav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToBeiDouD1Nav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD1Nav::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToBeiDouD1Nav::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouD1Nav::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouD1Nav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToBeiDouD1Nav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouD1Nav
///
#include "gen/GetMessageModificationToBeiDouD1Nav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouD1Nav::CmdName = "GetMessageModificationToBeiDouD1Nav";
    const char* const GetMessageModificationToBeiDouD1Nav::Documentation = "Get infos about the BeiDou D1 NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToBeiDouD1Nav);


    GetMessageModificationToBeiDouD1Nav::GetMessageModificationToBeiDouD1Nav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToBeiDouD1Nav::GetMessageModificationToBeiDouD1Nav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToBeiDouD1NavPtr GetMessageModificationToBeiDouD1Nav::create(const std::string& id)
    {
      return GetMessageModificationToBeiDouD1NavPtr(new GetMessageModificationToBeiDouD1Nav(id));
    }

    GetMessageModificationToBeiDouD1NavPtr GetMessageModificationToBeiDouD1Nav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouD1Nav>(ptr);
    }

    bool GetMessageModificationToBeiDouD1Nav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouD1Nav::documentation() const { return Documentation; }


    int GetMessageModificationToBeiDouD1Nav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToBeiDouD1Nav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouD1Nav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouD1NavResult
///
#include "gen/GetMessageModificationToBeiDouD1NavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouD1NavResult::CmdName = "GetMessageModificationToBeiDouD1NavResult";
    const char* const GetMessageModificationToBeiDouD1NavResult::Documentation = "Result of GetMessageModificationToBeiDouD1Nav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToBeiDouD1NavResult);


    GetMessageModificationToBeiDouD1NavResult::GetMessageModificationToBeiDouD1NavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToBeiDouD1NavResult::GetMessageModificationToBeiDouD1NavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    GetMessageModificationToBeiDouD1NavResultPtr GetMessageModificationToBeiDouD1NavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return GetMessageModificationToBeiDouD1NavResultPtr(new GetMessageModificationToBeiDouD1NavResult(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id));
    }

    GetMessageModificationToBeiDouD1NavResultPtr GetMessageModificationToBeiDouD1NavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouD1NavResult>(ptr);
    }

    bool GetMessageModificationToBeiDouD1NavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouD1NavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToBeiDouD1NavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD1NavResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToBeiDouD1NavResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouD1NavResult::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouD1NavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouD1NavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToBeiDouD2Nav
///
#include "gen/SetMessageModificationToBeiDouD2Nav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToBeiDouD2Nav::CmdName = "SetMessageModificationToBeiDouD2Nav";
    const char* const SetMessageModificationToBeiDouD2Nav::Documentation = "Set (or Modify) event to change BeiDou D2 NAV message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to parity bits will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToBeiDouD2Nav);


    SetMessageModificationToBeiDouD2Nav::SetMessageModificationToBeiDouD2Nav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToBeiDouD2Nav::SetMessageModificationToBeiDouD2Nav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    SetMessageModificationToBeiDouD2NavPtr SetMessageModificationToBeiDouD2Nav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return SetMessageModificationToBeiDouD2NavPtr(new SetMessageModificationToBeiDouD2Nav(signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id));
    }

    SetMessageModificationToBeiDouD2NavPtr SetMessageModificationToBeiDouD2Nav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToBeiDouD2Nav>(ptr);
    }

    bool SetMessageModificationToBeiDouD2Nav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToBeiDouD2Nav::documentation() const { return Documentation; }


    int SetMessageModificationToBeiDouD2Nav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToBeiDouD2Nav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouD2Nav::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToBeiDouD2Nav::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouD2Nav::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouD2Nav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToBeiDouD2Nav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouD2Nav
///
#include "gen/GetMessageModificationToBeiDouD2Nav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouD2Nav::CmdName = "GetMessageModificationToBeiDouD2Nav";
    const char* const GetMessageModificationToBeiDouD2Nav::Documentation = "Get infos about the BeiDou D2 NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToBeiDouD2Nav);


    GetMessageModificationToBeiDouD2Nav::GetMessageModificationToBeiDouD2Nav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToBeiDouD2Nav::GetMessageModificationToBeiDouD2Nav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToBeiDouD2NavPtr GetMessageModificationToBeiDouD2Nav::create(const std::string& id)
    {
      return GetMessageModificationToBeiDouD2NavPtr(new GetMessageModificationToBeiDouD2Nav(id));
    }

    GetMessageModificationToBeiDouD2NavPtr GetMessageModificationToBeiDouD2Nav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouD2Nav>(ptr);
    }

    bool GetMessageModificationToBeiDouD2Nav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouD2Nav::documentation() const { return Documentation; }


    int GetMessageModificationToBeiDouD2Nav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToBeiDouD2Nav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouD2Nav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouD2NavResult
///
#include "gen/GetMessageModificationToBeiDouD2NavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouD2NavResult::CmdName = "GetMessageModificationToBeiDouD2NavResult";
    const char* const GetMessageModificationToBeiDouD2NavResult::Documentation = "Result of GetMessageModificationToBeiDouD2Nav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToBeiDouD2NavResult);


    GetMessageModificationToBeiDouD2NavResult::GetMessageModificationToBeiDouD2NavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToBeiDouD2NavResult::GetMessageModificationToBeiDouD2NavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    GetMessageModificationToBeiDouD2NavResultPtr GetMessageModificationToBeiDouD2NavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int page, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return GetMessageModificationToBeiDouD2NavResultPtr(new GetMessageModificationToBeiDouD2NavResult(relatedCommand, signalArray, svId, startTime, stopTime, subframe, page, word, updateParity, wordModification, id));
    }

    GetMessageModificationToBeiDouD2NavResultPtr GetMessageModificationToBeiDouD2NavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouD2NavResult>(ptr);
    }

    bool GetMessageModificationToBeiDouD2NavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouD2NavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToBeiDouD2NavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouD2NavResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToBeiDouD2NavResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouD2NavResult::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouD2NavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouD2NavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToBeiDouCNav1
///
#include "gen/SetMessageModificationToBeiDouCNav1.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToBeiDouCNav1::CmdName = "SetMessageModificationToBeiDouCNav1";
    const char* const SetMessageModificationToBeiDouCNav1::Documentation = "Set (or Modify) event to change BeiDou CNAV1 message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToBeiDouCNav1);


    SetMessageModificationToBeiDouCNav1::SetMessageModificationToBeiDouCNav1()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToBeiDouCNav1::SetMessageModificationToBeiDouCNav1(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToBeiDouCNav1Ptr SetMessageModificationToBeiDouCNav1::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToBeiDouCNav1Ptr(new SetMessageModificationToBeiDouCNav1(signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id));
    }

    SetMessageModificationToBeiDouCNav1Ptr SetMessageModificationToBeiDouCNav1::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToBeiDouCNav1>(ptr);
    }

    bool SetMessageModificationToBeiDouCNav1::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToBeiDouCNav1::documentation() const { return Documentation; }


    int SetMessageModificationToBeiDouCNav1::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToBeiDouCNav1::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToBeiDouCNav1::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav1::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToBeiDouCNav1::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav1::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToBeiDouCNav1::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav1::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToBeiDouCNav1::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav1::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToBeiDouCNav1::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav1::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToBeiDouCNav1::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToBeiDouCNav1::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToBeiDouCNav1::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav1::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToBeiDouCNav1::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav1::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToBeiDouCNav1::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouCNav1
///
#include "gen/GetMessageModificationToBeiDouCNav1.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouCNav1::CmdName = "GetMessageModificationToBeiDouCNav1";
    const char* const GetMessageModificationToBeiDouCNav1::Documentation = "Get infos about the BeiDou CNAV1 message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToBeiDouCNav1);


    GetMessageModificationToBeiDouCNav1::GetMessageModificationToBeiDouCNav1()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToBeiDouCNav1::GetMessageModificationToBeiDouCNav1(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToBeiDouCNav1Ptr GetMessageModificationToBeiDouCNav1::create(const std::string& id)
    {
      return GetMessageModificationToBeiDouCNav1Ptr(new GetMessageModificationToBeiDouCNav1(id));
    }

    GetMessageModificationToBeiDouCNav1Ptr GetMessageModificationToBeiDouCNav1::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouCNav1>(ptr);
    }

    bool GetMessageModificationToBeiDouCNav1::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouCNav1::documentation() const { return Documentation; }


    int GetMessageModificationToBeiDouCNav1::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToBeiDouCNav1::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouCNav1::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouCNav1Result
///
#include "gen/GetMessageModificationToBeiDouCNav1Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouCNav1Result::CmdName = "GetMessageModificationToBeiDouCNav1Result";
    const char* const GetMessageModificationToBeiDouCNav1Result::Documentation = "Result of GetMessageModificationToBeiDouCNav1";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToBeiDouCNav1Result);


    GetMessageModificationToBeiDouCNav1Result::GetMessageModificationToBeiDouCNav1Result()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToBeiDouCNav1Result::GetMessageModificationToBeiDouCNav1Result(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToBeiDouCNav1ResultPtr GetMessageModificationToBeiDouCNav1Result::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToBeiDouCNav1ResultPtr(new GetMessageModificationToBeiDouCNav1Result(relatedCommand, signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id));
    }

    GetMessageModificationToBeiDouCNav1ResultPtr GetMessageModificationToBeiDouCNav1Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouCNav1Result>(ptr);
    }

    bool GetMessageModificationToBeiDouCNav1Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouCNav1Result::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToBeiDouCNav1Result::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav1Result::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav1Result::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav1Result::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav1Result::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav1Result::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToBeiDouCNav1Result::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav1Result::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav1Result::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouCNav1Result::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToBeiDouCNav2
///
#include "gen/SetMessageModificationToBeiDouCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToBeiDouCNav2::CmdName = "SetMessageModificationToBeiDouCNav2";
    const char* const SetMessageModificationToBeiDouCNav2::Documentation = "Set (or Modify) event to change BeiDou CNAV2 message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToBeiDouCNav2);


    SetMessageModificationToBeiDouCNav2::SetMessageModificationToBeiDouCNav2()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToBeiDouCNav2::SetMessageModificationToBeiDouCNav2(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToBeiDouCNav2Ptr SetMessageModificationToBeiDouCNav2::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToBeiDouCNav2Ptr(new SetMessageModificationToBeiDouCNav2(signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id));
    }

    SetMessageModificationToBeiDouCNav2Ptr SetMessageModificationToBeiDouCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToBeiDouCNav2>(ptr);
    }

    bool SetMessageModificationToBeiDouCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToBeiDouCNav2::documentation() const { return Documentation; }


    int SetMessageModificationToBeiDouCNav2::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToBeiDouCNav2::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToBeiDouCNav2::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav2::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToBeiDouCNav2::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav2::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToBeiDouCNav2::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav2::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToBeiDouCNav2::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToBeiDouCNav2::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToBeiDouCNav2::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav2::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToBeiDouCNav2::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToBeiDouCNav2::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToBeiDouCNav2::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav2::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToBeiDouCNav2::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToBeiDouCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToBeiDouCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouCNav2
///
#include "gen/GetMessageModificationToBeiDouCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouCNav2::CmdName = "GetMessageModificationToBeiDouCNav2";
    const char* const GetMessageModificationToBeiDouCNav2::Documentation = "Get infos about the BeiDou CNAV2 message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToBeiDouCNav2);


    GetMessageModificationToBeiDouCNav2::GetMessageModificationToBeiDouCNav2()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToBeiDouCNav2::GetMessageModificationToBeiDouCNav2(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToBeiDouCNav2Ptr GetMessageModificationToBeiDouCNav2::create(const std::string& id)
    {
      return GetMessageModificationToBeiDouCNav2Ptr(new GetMessageModificationToBeiDouCNav2(id));
    }

    GetMessageModificationToBeiDouCNav2Ptr GetMessageModificationToBeiDouCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouCNav2>(ptr);
    }

    bool GetMessageModificationToBeiDouCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouCNav2::documentation() const { return Documentation; }


    int GetMessageModificationToBeiDouCNav2::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToBeiDouCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToBeiDouCNav2Result
///
#include "gen/GetMessageModificationToBeiDouCNav2Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToBeiDouCNav2Result::CmdName = "GetMessageModificationToBeiDouCNav2Result";
    const char* const GetMessageModificationToBeiDouCNav2Result::Documentation = "Result of GetMessageModificationToBeiDouCNav2";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToBeiDouCNav2Result);


    GetMessageModificationToBeiDouCNav2Result::GetMessageModificationToBeiDouCNav2Result()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToBeiDouCNav2Result::GetMessageModificationToBeiDouCNav2Result(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToBeiDouCNav2ResultPtr GetMessageModificationToBeiDouCNav2Result::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToBeiDouCNav2ResultPtr(new GetMessageModificationToBeiDouCNav2Result(relatedCommand, signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id));
    }

    GetMessageModificationToBeiDouCNav2ResultPtr GetMessageModificationToBeiDouCNav2Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToBeiDouCNav2Result>(ptr);
    }

    bool GetMessageModificationToBeiDouCNav2Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToBeiDouCNav2Result::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToBeiDouCNav2Result::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav2Result::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav2Result::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav2Result::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToBeiDouCNav2Result::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav2Result::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToBeiDouCNav2Result::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav2Result::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToBeiDouCNav2Result::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToBeiDouCNav2Result::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToQzssLNav
///
#include "gen/SetMessageModificationToQzssLNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToQzssLNav::CmdName = "SetMessageModificationToQzssLNav";
    const char* const SetMessageModificationToQzssLNav::Documentation = "Set (or Modify) event to change QZSS LNAV message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to bits 25..30 will have no effect.\n\nThe ID parameter is automatically updated with a unique ID by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToQzssLNav);


    SetMessageModificationToQzssLNav::SetMessageModificationToQzssLNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToQzssLNav::SetMessageModificationToQzssLNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int lNavSvId, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setLNavSvId(lNavSvId);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    SetMessageModificationToQzssLNavPtr SetMessageModificationToQzssLNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int lNavSvId, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return SetMessageModificationToQzssLNavPtr(new SetMessageModificationToQzssLNav(signalArray, svId, startTime, stopTime, subframe, lNavSvId, word, updateParity, wordModification, id));
    }

    SetMessageModificationToQzssLNavPtr SetMessageModificationToQzssLNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToQzssLNav>(ptr);
    }

    bool SetMessageModificationToQzssLNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["LNavSvId"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToQzssLNav::documentation() const { return Documentation; }


    int SetMessageModificationToQzssLNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToQzssLNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToQzssLNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToQzssLNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToQzssLNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToQzssLNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToQzssLNav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::lNavSvId() const
    {
      return parse_json<int>::parse(m_values["LNavSvId"]);
    }

    void SetMessageModificationToQzssLNav::setLNavSvId(int lNavSvId)
    {
      m_values.AddMember("LNavSvId", parse_json<int>::format(lNavSvId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssLNav::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetMessageModificationToQzssLNav::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToQzssLNav::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetMessageModificationToQzssLNav::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssLNav::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void SetMessageModificationToQzssLNav::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssLNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToQzssLNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssLNav
///
#include "gen/GetMessageModificationToQzssLNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssLNav::CmdName = "GetMessageModificationToQzssLNav";
    const char* const GetMessageModificationToQzssLNav::Documentation = "Get infos about the QZSS LNAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToQzssLNav);


    GetMessageModificationToQzssLNav::GetMessageModificationToQzssLNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToQzssLNav::GetMessageModificationToQzssLNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToQzssLNavPtr GetMessageModificationToQzssLNav::create(const std::string& id)
    {
      return GetMessageModificationToQzssLNavPtr(new GetMessageModificationToQzssLNav(id));
    }

    GetMessageModificationToQzssLNavPtr GetMessageModificationToQzssLNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssLNav>(ptr);
    }

    bool GetMessageModificationToQzssLNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssLNav::documentation() const { return Documentation; }


    int GetMessageModificationToQzssLNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToQzssLNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssLNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssLNavResult
///
#include "gen/GetMessageModificationToQzssLNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssLNavResult::CmdName = "GetMessageModificationToQzssLNavResult";
    const char* const GetMessageModificationToQzssLNavResult::Documentation = "Result of GetMessageModificationToQzssLNav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToQzssLNavResult);


    GetMessageModificationToQzssLNavResult::GetMessageModificationToQzssLNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToQzssLNavResult::GetMessageModificationToQzssLNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int lNavSvId, int word, bool updateParity, const std::string& wordModification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setLNavSvId(lNavSvId);
      setWord(word);
      setUpdateParity(updateParity);
      setWordModification(wordModification);
      setId(id);
    }


    GetMessageModificationToQzssLNavResultPtr GetMessageModificationToQzssLNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int lNavSvId, int word, bool updateParity, const std::string& wordModification, const std::string& id)
    {
      return GetMessageModificationToQzssLNavResultPtr(new GetMessageModificationToQzssLNavResult(relatedCommand, signalArray, svId, startTime, stopTime, subframe, lNavSvId, word, updateParity, wordModification, id));
    }

    GetMessageModificationToQzssLNavResultPtr GetMessageModificationToQzssLNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssLNavResult>(ptr);
    }

    bool GetMessageModificationToQzssLNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["LNavSvId"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["WordModification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssLNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToQzssLNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToQzssLNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToQzssLNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToQzssLNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToQzssLNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToQzssLNavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::lNavSvId() const
    {
      return parse_json<int>::parse(m_values["LNavSvId"]);
    }

    void GetMessageModificationToQzssLNavResult::setLNavSvId(int lNavSvId)
    {
      m_values.AddMember("LNavSvId", parse_json<int>::format(lNavSvId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssLNavResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetMessageModificationToQzssLNavResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToQzssLNavResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetMessageModificationToQzssLNavResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssLNavResult::wordModification() const
    {
      return parse_json<std::string>::parse(m_values["WordModification"]);
    }

    void GetMessageModificationToQzssLNavResult::setWordModification(const std::string& wordModification)
    {
      m_values.AddMember("WordModification", parse_json<std::string>::format(wordModification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssLNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssLNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToQzssSlas
///
#include "gen/SetMessageModificationToQzssSlas.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToQzssSlas::CmdName = "SetMessageModificationToQzssSlas";
    const char* const SetMessageModificationToQzssSlas::Documentation = "Set (or Modify) event to change QZSS SLAS message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToQzssSlas);


    SetMessageModificationToQzssSlas::SetMessageModificationToQzssSlas()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToQzssSlas::SetMessageModificationToQzssSlas(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToQzssSlasPtr SetMessageModificationToQzssSlas::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToQzssSlasPtr(new SetMessageModificationToQzssSlas(signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id));
    }

    SetMessageModificationToQzssSlasPtr SetMessageModificationToQzssSlas::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToQzssSlas>(ptr);
    }

    bool SetMessageModificationToQzssSlas::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToQzssSlas::documentation() const { return Documentation; }


    int SetMessageModificationToQzssSlas::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToQzssSlas::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToQzssSlas::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssSlas::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToQzssSlas::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssSlas::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToQzssSlas::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssSlas::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToQzssSlas::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssSlas::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToQzssSlas::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssSlas::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToQzssSlas::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToQzssSlas::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToQzssSlas::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssSlas::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToQzssSlas::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssSlas::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToQzssSlas::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssSlas
///
#include "gen/GetMessageModificationToQzssSlas.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssSlas::CmdName = "GetMessageModificationToQzssSlas";
    const char* const GetMessageModificationToQzssSlas::Documentation = "Get infos about the QZSS SLAS message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToQzssSlas);


    GetMessageModificationToQzssSlas::GetMessageModificationToQzssSlas()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToQzssSlas::GetMessageModificationToQzssSlas(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToQzssSlasPtr GetMessageModificationToQzssSlas::create(const std::string& id)
    {
      return GetMessageModificationToQzssSlasPtr(new GetMessageModificationToQzssSlas(id));
    }

    GetMessageModificationToQzssSlasPtr GetMessageModificationToQzssSlas::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssSlas>(ptr);
    }

    bool GetMessageModificationToQzssSlas::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssSlas::documentation() const { return Documentation; }


    int GetMessageModificationToQzssSlas::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToQzssSlas::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssSlas::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssSlasResult
///
#include "gen/GetMessageModificationToQzssSlasResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssSlasResult::CmdName = "GetMessageModificationToQzssSlasResult";
    const char* const GetMessageModificationToQzssSlasResult::Documentation = "Result of GetMessageModificationToQzssSlas";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToQzssSlasResult);


    GetMessageModificationToQzssSlasResult::GetMessageModificationToQzssSlasResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToQzssSlasResult::GetMessageModificationToQzssSlasResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToQzssSlasResultPtr GetMessageModificationToQzssSlasResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToQzssSlasResultPtr(new GetMessageModificationToQzssSlasResult(relatedCommand, signalArray, svId, startTime, stopTime, messageType, condition, updateCRC, bitModifications, id));
    }

    GetMessageModificationToQzssSlasResultPtr GetMessageModificationToQzssSlasResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssSlasResult>(ptr);
    }

    bool GetMessageModificationToQzssSlasResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssSlasResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToQzssSlasResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToQzssSlasResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssSlasResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToQzssSlasResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssSlasResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToQzssSlasResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssSlasResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToQzssSlasResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssSlasResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToQzssSlasResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssSlasResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToQzssSlasResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToQzssSlasResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToQzssSlasResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssSlasResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToQzssSlasResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssSlasResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssSlasResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToQzssCNav2
///
#include "gen/SetMessageModificationToQzssCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToQzssCNav2::CmdName = "SetMessageModificationToQzssCNav2";
    const char* const SetMessageModificationToQzssCNav2::Documentation = "Set (or Modify) event to change QZSS CNAV2 message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToQzssCNav2);


    SetMessageModificationToQzssCNav2::SetMessageModificationToQzssCNav2()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToQzssCNav2::SetMessageModificationToQzssCNav2(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToQzssCNav2Ptr SetMessageModificationToQzssCNav2::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToQzssCNav2Ptr(new SetMessageModificationToQzssCNav2(signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id));
    }

    SetMessageModificationToQzssCNav2Ptr SetMessageModificationToQzssCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToQzssCNav2>(ptr);
    }

    bool SetMessageModificationToQzssCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToQzssCNav2::documentation() const { return Documentation; }


    int SetMessageModificationToQzssCNav2::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToQzssCNav2::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToQzssCNav2::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav2::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToQzssCNav2::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav2::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToQzssCNav2::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav2::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToQzssCNav2::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToQzssCNav2::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetMessageModificationToQzssCNav2::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssCNav2::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToQzssCNav2::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToQzssCNav2::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToQzssCNav2::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssCNav2::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToQzssCNav2::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToQzssCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToQzssCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssCNav2
///
#include "gen/GetMessageModificationToQzssCNav2.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssCNav2::CmdName = "GetMessageModificationToQzssCNav2";
    const char* const GetMessageModificationToQzssCNav2::Documentation = "Get infos about the QZSS CNAV2 message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToQzssCNav2);


    GetMessageModificationToQzssCNav2::GetMessageModificationToQzssCNav2()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToQzssCNav2::GetMessageModificationToQzssCNav2(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToQzssCNav2Ptr GetMessageModificationToQzssCNav2::create(const std::string& id)
    {
      return GetMessageModificationToQzssCNav2Ptr(new GetMessageModificationToQzssCNav2(id));
    }

    GetMessageModificationToQzssCNav2Ptr GetMessageModificationToQzssCNav2::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssCNav2>(ptr);
    }

    bool GetMessageModificationToQzssCNav2::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssCNav2::documentation() const { return Documentation; }


    int GetMessageModificationToQzssCNav2::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToQzssCNav2::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssCNav2::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToQzssCNav2Result
///
#include "gen/GetMessageModificationToQzssCNav2Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToQzssCNav2Result::CmdName = "GetMessageModificationToQzssCNav2Result";
    const char* const GetMessageModificationToQzssCNav2Result::Documentation = "Result of GetMessageModificationToQzssCNav2";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToQzssCNav2Result);


    GetMessageModificationToQzssCNav2Result::GetMessageModificationToQzssCNav2Result()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToQzssCNav2Result::GetMessageModificationToQzssCNav2Result(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPage(page);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToQzssCNav2ResultPtr GetMessageModificationToQzssCNav2Result::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int page, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToQzssCNav2ResultPtr(new GetMessageModificationToQzssCNav2Result(relatedCommand, signalArray, svId, startTime, stopTime, page, condition, updateCRC, bitModifications, id));
    }

    GetMessageModificationToQzssCNav2ResultPtr GetMessageModificationToQzssCNav2Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToQzssCNav2Result>(ptr);
    }

    bool GetMessageModificationToQzssCNav2Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToQzssCNav2Result::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToQzssCNav2Result::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToQzssCNav2Result::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNav2Result::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToQzssCNav2Result::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNav2Result::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToQzssCNav2Result::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNav2Result::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToQzssCNav2Result::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToQzssCNav2Result::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetMessageModificationToQzssCNav2Result::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssCNav2Result::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToQzssCNav2Result::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToQzssCNav2Result::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToQzssCNav2Result::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssCNav2Result::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToQzssCNav2Result::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToQzssCNav2Result::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToQzssCNav2Result::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMessageModificationToNavICNav
///
#include "gen/SetMessageModificationToNavICNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMessageModificationToNavICNav::CmdName = "SetMessageModificationToNavICNav";
    const char* const SetMessageModificationToNavICNav::Documentation = "Set (or Modify) event to change NavIC NAV message bits. If you send this command without setting the ID\nparameter, or if you set the ID with a value never used before, a new Modification event will be\ncreated. If you reuse the same event ID, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbit modifications.\n\nBitModifications can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bit modifications using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetMessageModificationToNavICNav);


    SetMessageModificationToNavICNav::SetMessageModificationToNavICNav()
      : CommandBase(CmdName)
    {}

    SetMessageModificationToNavICNav::SetMessageModificationToNavICNav(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    SetMessageModificationToNavICNavPtr SetMessageModificationToNavICNav::create(const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return SetMessageModificationToNavICNavPtr(new SetMessageModificationToNavICNav(signalArray, svId, startTime, stopTime, subframe, messageType, condition, updateCRC, bitModifications, id));
    }

    SetMessageModificationToNavICNavPtr SetMessageModificationToNavICNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMessageModificationToNavICNav>(ptr);
    }

    bool SetMessageModificationToNavICNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMessageModificationToNavICNav::documentation() const { return Documentation; }


    int SetMessageModificationToNavICNav::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetMessageModificationToNavICNav::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void SetMessageModificationToNavICNav::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMessageModificationToNavICNav::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetMessageModificationToNavICNav::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetMessageModificationToNavICNav::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetMessageModificationToNavICNav::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMessageModificationToNavICNav::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetMessageModificationToNavICNav::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToNavICNav::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetMessageModificationToNavICNav::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetMessageModificationToNavICNav::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetMessageModificationToNavICNav::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToNavICNav::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void SetMessageModificationToNavICNav::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMessageModificationToNavICNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMessageModificationToNavICNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToNavICNav
///
#include "gen/GetMessageModificationToNavICNav.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToNavICNav::CmdName = "GetMessageModificationToNavICNav";
    const char* const GetMessageModificationToNavICNav::Documentation = "Get infos about the NavIC NAV message modification with this ID.";

    REGISTER_COMMAND_FACTORY(GetMessageModificationToNavICNav);


    GetMessageModificationToNavICNav::GetMessageModificationToNavICNav()
      : CommandBase(CmdName)
    {}

    GetMessageModificationToNavICNav::GetMessageModificationToNavICNav(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMessageModificationToNavICNavPtr GetMessageModificationToNavICNav::create(const std::string& id)
    {
      return GetMessageModificationToNavICNavPtr(new GetMessageModificationToNavICNav(id));
    }

    GetMessageModificationToNavICNavPtr GetMessageModificationToNavICNav::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToNavICNav>(ptr);
    }

    bool GetMessageModificationToNavICNav::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToNavICNav::documentation() const { return Documentation; }


    int GetMessageModificationToNavICNav::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModificationToNavICNav::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToNavICNav::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationToNavICNavResult
///
#include "gen/GetMessageModificationToNavICNavResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationToNavICNavResult::CmdName = "GetMessageModificationToNavICNavResult";
    const char* const GetMessageModificationToNavICNavResult::Documentation = "Result of GetMessageModificationToNavICNav";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationToNavICNavResult);


    GetMessageModificationToNavICNavResult::GetMessageModificationToNavICNavResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationToNavICNavResult::GetMessageModificationToNavICNavResult(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignalArray(signalArray);
      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitModifications(bitModifications);
      setId(id);
    }


    GetMessageModificationToNavICNavResultPtr GetMessageModificationToNavICNavResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& signalArray, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitModifications, const std::string& id)
    {
      return GetMessageModificationToNavICNavResultPtr(new GetMessageModificationToNavICNavResult(relatedCommand, signalArray, svId, startTime, stopTime, subframe, messageType, condition, updateCRC, bitModifications, id));
    }

    GetMessageModificationToNavICNavResultPtr GetMessageModificationToNavICNavResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationToNavICNavResult>(ptr);
    }

    bool GetMessageModificationToNavICNavResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["SignalArray"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitModifications"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMessageModificationToNavICNavResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationToNavICNavResult::signalArray() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["SignalArray"]);
    }

    void GetMessageModificationToNavICNavResult::setSignalArray(const std::vector<std::string>& signalArray)
    {
      m_values.AddMember("SignalArray", parse_json<std::vector<std::string>>::format(signalArray, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModificationToNavICNavResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetMessageModificationToNavICNavResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetMessageModificationToNavICNavResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetMessageModificationToNavICNavResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModificationToNavICNavResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetMessageModificationToNavICNavResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToNavICNavResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetMessageModificationToNavICNavResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetMessageModificationToNavICNavResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetMessageModificationToNavICNavResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToNavICNavResult::bitModifications() const
    {
      return parse_json<std::string>::parse(m_values["BitModifications"]);
    }

    void GetMessageModificationToNavICNavResult::setBitModifications(const std::string& bitModifications)
    {
      m_values.AddMember("BitModifications", parse_json<std::string>::format(bitModifications, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMessageModificationToNavICNavResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMessageModificationToNavICNavResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveMessageModificationForNavMsgFamily
///
#include "gen/RemoveMessageModificationForNavMsgFamily.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveMessageModificationForNavMsgFamily::CmdName = "RemoveMessageModificationForNavMsgFamily";
    const char* const RemoveMessageModificationForNavMsgFamily::Documentation = "Removes a message modification event for the navigation message family.";

    REGISTER_COMMAND_FACTORY(RemoveMessageModificationForNavMsgFamily);


    RemoveMessageModificationForNavMsgFamily::RemoveMessageModificationForNavMsgFamily()
      : CommandBase(CmdName)
    {}

    RemoveMessageModificationForNavMsgFamily::RemoveMessageModificationForNavMsgFamily(const std::string& navMsgFamily, const std::string& id)
      : CommandBase(CmdName)
    {

      setNavMsgFamily(navMsgFamily);
      setId(id);
    }


    RemoveMessageModificationForNavMsgFamilyPtr RemoveMessageModificationForNavMsgFamily::create(const std::string& navMsgFamily, const std::string& id)
    {
      return RemoveMessageModificationForNavMsgFamilyPtr(new RemoveMessageModificationForNavMsgFamily(navMsgFamily, id));
    }

    RemoveMessageModificationForNavMsgFamilyPtr RemoveMessageModificationForNavMsgFamily::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveMessageModificationForNavMsgFamily>(ptr);
    }

    bool RemoveMessageModificationForNavMsgFamily::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["NavMsgFamily"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveMessageModificationForNavMsgFamily::documentation() const { return Documentation; }


    int RemoveMessageModificationForNavMsgFamily::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveMessageModificationForNavMsgFamily::navMsgFamily() const
    {
      return parse_json<std::string>::parse(m_values["NavMsgFamily"]);
    }

    void RemoveMessageModificationForNavMsgFamily::setNavMsgFamily(const std::string& navMsgFamily)
    {
      m_values.AddMember("NavMsgFamily", parse_json<std::string>::format(navMsgFamily, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveMessageModificationForNavMsgFamily::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveMessageModificationForNavMsgFamily::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllMessageModificationsForNavMsgFamily
///
#include "gen/ClearAllMessageModificationsForNavMsgFamily.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllMessageModificationsForNavMsgFamily::CmdName = "ClearAllMessageModificationsForNavMsgFamily";
    const char* const ClearAllMessageModificationsForNavMsgFamily::Documentation = "Clear all message modification events for this navigation message family.";

    REGISTER_COMMAND_FACTORY(ClearAllMessageModificationsForNavMsgFamily);


    ClearAllMessageModificationsForNavMsgFamily::ClearAllMessageModificationsForNavMsgFamily()
      : CommandBase(CmdName)
    {}

    ClearAllMessageModificationsForNavMsgFamily::ClearAllMessageModificationsForNavMsgFamily(const std::string& navMsgFamily)
      : CommandBase(CmdName)
    {

      setNavMsgFamily(navMsgFamily);
    }


    ClearAllMessageModificationsForNavMsgFamilyPtr ClearAllMessageModificationsForNavMsgFamily::create(const std::string& navMsgFamily)
    {
      return ClearAllMessageModificationsForNavMsgFamilyPtr(new ClearAllMessageModificationsForNavMsgFamily(navMsgFamily));
    }

    ClearAllMessageModificationsForNavMsgFamilyPtr ClearAllMessageModificationsForNavMsgFamily::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllMessageModificationsForNavMsgFamily>(ptr);
    }

    bool ClearAllMessageModificationsForNavMsgFamily::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["NavMsgFamily"])
        ;

    }

    std::string ClearAllMessageModificationsForNavMsgFamily::documentation() const { return Documentation; }


    int ClearAllMessageModificationsForNavMsgFamily::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ClearAllMessageModificationsForNavMsgFamily::navMsgFamily() const
    {
      return parse_json<std::string>::parse(m_values["NavMsgFamily"]);
    }

    void ClearAllMessageModificationsForNavMsgFamily::setNavMsgFamily(const std::string& navMsgFamily)
    {
      m_values.AddMember("NavMsgFamily", parse_json<std::string>::format(navMsgFamily, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMessageModificationIdsForNavMsgFamily
///
#include "gen/GetAllMessageModificationIdsForNavMsgFamily.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMessageModificationIdsForNavMsgFamily::CmdName = "GetAllMessageModificationIdsForNavMsgFamily";
    const char* const GetAllMessageModificationIdsForNavMsgFamily::Documentation = "Get all the message modification event's IDs for this navigation message family and SV ID.";

    REGISTER_COMMAND_FACTORY(GetAllMessageModificationIdsForNavMsgFamily);


    GetAllMessageModificationIdsForNavMsgFamily::GetAllMessageModificationIdsForNavMsgFamily()
      : CommandBase(CmdName)
    {}

    GetAllMessageModificationIdsForNavMsgFamily::GetAllMessageModificationIdsForNavMsgFamily(const std::string& navMsgFamily, int svId)
      : CommandBase(CmdName)
    {

      setNavMsgFamily(navMsgFamily);
      setSvId(svId);
    }


    GetAllMessageModificationIdsForNavMsgFamilyPtr GetAllMessageModificationIdsForNavMsgFamily::create(const std::string& navMsgFamily, int svId)
    {
      return GetAllMessageModificationIdsForNavMsgFamilyPtr(new GetAllMessageModificationIdsForNavMsgFamily(navMsgFamily, svId));
    }

    GetAllMessageModificationIdsForNavMsgFamilyPtr GetAllMessageModificationIdsForNavMsgFamily::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMessageModificationIdsForNavMsgFamily>(ptr);
    }

    bool GetAllMessageModificationIdsForNavMsgFamily::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["NavMsgFamily"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetAllMessageModificationIdsForNavMsgFamily::documentation() const { return Documentation; }


    int GetAllMessageModificationIdsForNavMsgFamily::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMessageModificationIdsForNavMsgFamily::navMsgFamily() const
    {
      return parse_json<std::string>::parse(m_values["NavMsgFamily"]);
    }

    void GetAllMessageModificationIdsForNavMsgFamily::setNavMsgFamily(const std::string& navMsgFamily)
    {
      m_values.AddMember("NavMsgFamily", parse_json<std::string>::format(navMsgFamily, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllMessageModificationIdsForNavMsgFamily::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllMessageModificationIdsForNavMsgFamily::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMessageModificationIdsForNavMsgFamilyResult
///
#include "gen/GetAllMessageModificationIdsForNavMsgFamilyResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMessageModificationIdsForNavMsgFamilyResult::CmdName = "GetAllMessageModificationIdsForNavMsgFamilyResult";
    const char* const GetAllMessageModificationIdsForNavMsgFamilyResult::Documentation = "Result of GetAllMessageModificationIdsForNavMsgFamily.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllMessageModificationIdsForNavMsgFamilyResult);


    GetAllMessageModificationIdsForNavMsgFamilyResult::GetAllMessageModificationIdsForNavMsgFamilyResult()
      : CommandResult(CmdName)
    {}

    GetAllMessageModificationIdsForNavMsgFamilyResult::GetAllMessageModificationIdsForNavMsgFamilyResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllMessageModificationIdsForNavMsgFamilyResultPtr GetAllMessageModificationIdsForNavMsgFamilyResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetAllMessageModificationIdsForNavMsgFamilyResultPtr(new GetAllMessageModificationIdsForNavMsgFamilyResult(relatedCommand, ids));
    }

    GetAllMessageModificationIdsForNavMsgFamilyResultPtr GetAllMessageModificationIdsForNavMsgFamilyResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMessageModificationIdsForNavMsgFamilyResult>(ptr);
    }

    bool GetAllMessageModificationIdsForNavMsgFamilyResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllMessageModificationIdsForNavMsgFamilyResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllMessageModificationIdsForNavMsgFamilyResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllMessageModificationIdsForNavMsgFamilyResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveMessageModificationForSignal
///
#include "gen/RemoveMessageModificationForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveMessageModificationForSignal::CmdName = "RemoveMessageModificationForSignal";
    const char* const RemoveMessageModificationForSignal::Documentation = "Removes the signal for the message modification.";

    REGISTER_COMMAND_FACTORY(RemoveMessageModificationForSignal);


    RemoveMessageModificationForSignal::RemoveMessageModificationForSignal()
      : CommandBase(CmdName)
    {}

    RemoveMessageModificationForSignal::RemoveMessageModificationForSignal(const std::string& signal, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setId(id);
    }


    RemoveMessageModificationForSignalPtr RemoveMessageModificationForSignal::create(const std::string& signal, const std::string& id)
    {
      return RemoveMessageModificationForSignalPtr(new RemoveMessageModificationForSignal(signal, id));
    }

    RemoveMessageModificationForSignalPtr RemoveMessageModificationForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveMessageModificationForSignal>(ptr);
    }

    bool RemoveMessageModificationForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveMessageModificationForSignal::documentation() const { return Documentation; }


    int RemoveMessageModificationForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveMessageModificationForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void RemoveMessageModificationForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveMessageModificationForSignal::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveMessageModificationForSignal::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveMessageModification
///
#include "gen/RemoveMessageModification.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveMessageModification::CmdName = "RemoveMessageModification";
    const char* const RemoveMessageModification::Documentation = "Please note the command RemoveMessageModification is deprecated since 21.3. You may use RemoveMessageModificationForSignal.\n\nRemoves the signal for the message modification.";

    REGISTER_COMMAND_FACTORY(RemoveMessageModification);


    RemoveMessageModification::RemoveMessageModification()
      : CommandBase(CmdName)
    {}

    RemoveMessageModification::RemoveMessageModification(const std::string& signal, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setId(id);
    }


    RemoveMessageModificationPtr RemoveMessageModification::create(const std::string& signal, const std::string& id)
    {
      return RemoveMessageModificationPtr(new RemoveMessageModification(signal, id));
    }

    RemoveMessageModificationPtr RemoveMessageModification::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveMessageModification>(ptr);
    }

    bool RemoveMessageModification::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveMessageModification::documentation() const { return Documentation; }


    int RemoveMessageModification::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveMessageModification::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void RemoveMessageModification::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveMessageModification::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveMessageModification::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllMessageModificationsForSignal
///
#include "gen/ClearAllMessageModificationsForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllMessageModificationsForSignal::CmdName = "ClearAllMessageModificationsForSignal";
    const char* const ClearAllMessageModificationsForSignal::Documentation = "Clear the signal for all message modifications.";

    REGISTER_COMMAND_FACTORY(ClearAllMessageModificationsForSignal);


    ClearAllMessageModificationsForSignal::ClearAllMessageModificationsForSignal()
      : CommandBase(CmdName)
    {}

    ClearAllMessageModificationsForSignal::ClearAllMessageModificationsForSignal(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    ClearAllMessageModificationsForSignalPtr ClearAllMessageModificationsForSignal::create(const std::string& signal)
    {
      return ClearAllMessageModificationsForSignalPtr(new ClearAllMessageModificationsForSignal(signal));
    }

    ClearAllMessageModificationsForSignalPtr ClearAllMessageModificationsForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllMessageModificationsForSignal>(ptr);
    }

    bool ClearAllMessageModificationsForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string ClearAllMessageModificationsForSignal::documentation() const { return Documentation; }


    int ClearAllMessageModificationsForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ClearAllMessageModificationsForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void ClearAllMessageModificationsForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllMessageModifications
///
#include "gen/ClearAllMessageModifications.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllMessageModifications::CmdName = "ClearAllMessageModifications";
    const char* const ClearAllMessageModifications::Documentation = "Please note the command ClearAllMessageModifications is deprecated since 21.3. You may use ClearAllMessageModificationsForSignal.\n\nClear the signal for all message modifications.";

    REGISTER_COMMAND_FACTORY(ClearAllMessageModifications);


    ClearAllMessageModifications::ClearAllMessageModifications()
      : CommandBase(CmdName)
    {}

    ClearAllMessageModifications::ClearAllMessageModifications(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    ClearAllMessageModificationsPtr ClearAllMessageModifications::create(const std::string& signal)
    {
      return ClearAllMessageModificationsPtr(new ClearAllMessageModifications(signal));
    }

    ClearAllMessageModificationsPtr ClearAllMessageModifications::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllMessageModifications>(ptr);
    }

    bool ClearAllMessageModifications::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string ClearAllMessageModifications::documentation() const { return Documentation; }


    int ClearAllMessageModifications::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ClearAllMessageModifications::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void ClearAllMessageModifications::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMessageModificationIdsForSignal
///
#include "gen/GetAllMessageModificationIdsForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMessageModificationIdsForSignal::CmdName = "GetAllMessageModificationIdsForSignal";
    const char* const GetAllMessageModificationIdsForSignal::Documentation = "Get all the message modification event's IDs for this signal and SV ID.";

    REGISTER_COMMAND_FACTORY(GetAllMessageModificationIdsForSignal);


    GetAllMessageModificationIdsForSignal::GetAllMessageModificationIdsForSignal()
      : CommandBase(CmdName)
    {}

    GetAllMessageModificationIdsForSignal::GetAllMessageModificationIdsForSignal(const std::string& signal, int svId)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
    }


    GetAllMessageModificationIdsForSignalPtr GetAllMessageModificationIdsForSignal::create(const std::string& signal, int svId)
    {
      return GetAllMessageModificationIdsForSignalPtr(new GetAllMessageModificationIdsForSignal(signal, svId));
    }

    GetAllMessageModificationIdsForSignalPtr GetAllMessageModificationIdsForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMessageModificationIdsForSignal>(ptr);
    }

    bool GetAllMessageModificationIdsForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetAllMessageModificationIdsForSignal::documentation() const { return Documentation; }


    int GetAllMessageModificationIdsForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMessageModificationIdsForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetAllMessageModificationIdsForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllMessageModificationIdsForSignal::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllMessageModificationIdsForSignal::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMessageModificationIdsForSignalResult
///
#include "gen/GetAllMessageModificationIdsForSignalResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMessageModificationIdsForSignalResult::CmdName = "GetAllMessageModificationIdsForSignalResult";
    const char* const GetAllMessageModificationIdsForSignalResult::Documentation = "Result of GetAllMessageModificationIdsForSignal.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllMessageModificationIdsForSignalResult);


    GetAllMessageModificationIdsForSignalResult::GetAllMessageModificationIdsForSignalResult()
      : CommandResult(CmdName)
    {}

    GetAllMessageModificationIdsForSignalResult::GetAllMessageModificationIdsForSignalResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllMessageModificationIdsForSignalResultPtr GetAllMessageModificationIdsForSignalResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetAllMessageModificationIdsForSignalResultPtr(new GetAllMessageModificationIdsForSignalResult(relatedCommand, ids));
    }

    GetAllMessageModificationIdsForSignalResultPtr GetAllMessageModificationIdsForSignalResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMessageModificationIdsForSignalResult>(ptr);
    }

    bool GetAllMessageModificationIdsForSignalResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllMessageModificationIdsForSignalResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllMessageModificationIdsForSignalResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllMessageModificationIdsForSignalResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetInterferenceCW
///
#include "gen/SetInterferenceCW.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetInterferenceCW::CmdName = "SetInterferenceCW";
    const char* const SetInterferenceCW::Documentation = "Add or update continuous wave interference.";

    REGISTER_COMMAND_FACTORY(SetInterferenceCW);


    SetInterferenceCW::SetInterferenceCW()
      : CommandBase(CmdName)
    {}

    SetInterferenceCW::SetInterferenceCW(int startTime, int stopTime, double centralFreq, double power, bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setStartTime(startTime);
      setStopTime(stopTime);
      setCentralFreq(centralFreq);
      setPower(power);
      setEnabled(enabled);
      setId(id);
    }


    SetInterferenceCWPtr SetInterferenceCW::create(int startTime, int stopTime, double centralFreq, double power, bool enabled, const std::string& id)
    {
      return SetInterferenceCWPtr(new SetInterferenceCW(startTime, stopTime, centralFreq, power, enabled, id));
    }

    SetInterferenceCWPtr SetInterferenceCW::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetInterferenceCW>(ptr);
    }

    bool SetInterferenceCW::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetInterferenceCW::documentation() const { return Documentation; }


    int SetInterferenceCW::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetInterferenceCW::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetInterferenceCW::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetInterferenceCW::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetInterferenceCW::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceCW::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetInterferenceCW::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceCW::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetInterferenceCW::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetInterferenceCW::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetInterferenceCW::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetInterferenceCW::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetInterferenceCW::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetInterferenceChirp
///
#include "gen/SetInterferenceChirp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetInterferenceChirp::CmdName = "SetInterferenceChirp";
    const char* const SetInterferenceChirp::Documentation = "Add or update chirp signal interference.";

    REGISTER_COMMAND_FACTORY(SetInterferenceChirp);


    SetInterferenceChirp::SetInterferenceChirp()
      : CommandBase(CmdName)
    {}

    SetInterferenceChirp::SetInterferenceChirp(int startTime, int stopTime, double centralFreq, double power, double bandwidth, double sweepTime, bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setStartTime(startTime);
      setStopTime(stopTime);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setSweepTime(sweepTime);
      setEnabled(enabled);
      setId(id);
    }


    SetInterferenceChirpPtr SetInterferenceChirp::create(int startTime, int stopTime, double centralFreq, double power, double bandwidth, double sweepTime, bool enabled, const std::string& id)
    {
      return SetInterferenceChirpPtr(new SetInterferenceChirp(startTime, stopTime, centralFreq, power, bandwidth, sweepTime, enabled, id));
    }

    SetInterferenceChirpPtr SetInterferenceChirp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetInterferenceChirp>(ptr);
    }

    bool SetInterferenceChirp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<double>::is_valid(m_values["SweepTime"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetInterferenceChirp::documentation() const { return Documentation; }


    int SetInterferenceChirp::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetInterferenceChirp::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetInterferenceChirp::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetInterferenceChirp::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetInterferenceChirp::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceChirp::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetInterferenceChirp::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceChirp::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetInterferenceChirp::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceChirp::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void SetInterferenceChirp::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetInterferenceChirp::sweepTime() const
    {
      return parse_json<double>::parse(m_values["SweepTime"]);
    }

    void SetInterferenceChirp::setSweepTime(double sweepTime)
    {
      m_values.AddMember("SweepTime", parse_json<double>::format(sweepTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetInterferenceChirp::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetInterferenceChirp::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetInterferenceChirp::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetInterferenceChirp::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveInterference
///
#include "gen/RemoveInterference.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveInterference::CmdName = "RemoveInterference";
    const char* const RemoveInterference::Documentation = "Removes an interference. When adding an event, the simulator\nsets the Id parameter. Use that Id here to remove the associated interference.";

    REGISTER_COMMAND_FACTORY(RemoveInterference);


    RemoveInterference::RemoveInterference()
      : CommandBase(CmdName)
    {}

    RemoveInterference::RemoveInterference(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveInterferencePtr RemoveInterference::create(const std::string& id)
    {
      return RemoveInterferencePtr(new RemoveInterference(id));
    }

    RemoveInterferencePtr RemoveInterference::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveInterference>(ptr);
    }

    bool RemoveInterference::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveInterference::documentation() const { return Documentation; }


    int RemoveInterference::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveInterference::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveInterference::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllInterferences
///
#include "gen/RemoveAllInterferences.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllInterferences::CmdName = "RemoveAllInterferences";
    const char* const RemoveAllInterferences::Documentation = "Clear all interferences";

    REGISTER_COMMAND_FACTORY(RemoveAllInterferences);


    RemoveAllInterferences::RemoveAllInterferences()
      : CommandBase(CmdName)
    {

    }


    RemoveAllInterferencesPtr RemoveAllInterferences::create()
    {
      return RemoveAllInterferencesPtr(new RemoveAllInterferences());
    }

    RemoveAllInterferencesPtr RemoveAllInterferences::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllInterferences>(ptr);
    }

    bool RemoveAllInterferences::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllInterferences::documentation() const { return Documentation; }


    int RemoveAllInterferences::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of SetPseudorangeRampForSV
///
#include "gen/SetPseudorangeRampForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeRampForSV::CmdName = "SetPseudorangeRampForSV";
    const char* const SetPseudorangeRampForSV::Documentation = "Set PSR ramp event. This function lets user change the pseudorange of any satellite.\nIf SV ID is set to 0, the change is applied to all satellites.\n\n         Hold Start Time\n         |     Hold Stop Time\n         |     |\n         ...........\n       ..       ...\n       ..        ...\n  .......           .........> Time\n      |           |\n      Start Time      Stop Time\n";

    REGISTER_COMMAND_FACTORY(SetPseudorangeRampForSV);


    SetPseudorangeRampForSV::SetPseudorangeRampForSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeRampForSV::SetPseudorangeRampForSV(const std::string& system, int svId, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setOffset(offset);
      setStartTime(startTime);
      setHoldStartTime(holdStartTime);
      setHoldStopTime(holdStopTime);
      setStopTime(stopTime);
      setId(id);
    }


    SetPseudorangeRampForSVPtr SetPseudorangeRampForSV::create(const std::string& system, int svId, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
    {
      return SetPseudorangeRampForSVPtr(new SetPseudorangeRampForSV(system, svId, offset, startTime, holdStartTime, holdStopTime, stopTime, id));
    }

    SetPseudorangeRampForSVPtr SetPseudorangeRampForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeRampForSV>(ptr);
    }

    bool SetPseudorangeRampForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["HoldStartTime"])
          && parse_json<int>::is_valid(m_values["HoldStopTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetPseudorangeRampForSV::documentation() const { return Documentation; }


    int SetPseudorangeRampForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeRampForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeRampForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPseudorangeRampForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeRampForSV::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPseudorangeRampForSV::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetPseudorangeRampForSV::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::holdStartTime() const
    {
      return parse_json<int>::parse(m_values["HoldStartTime"]);
    }

    void SetPseudorangeRampForSV::setHoldStartTime(int holdStartTime)
    {
      m_values.AddMember("HoldStartTime", parse_json<int>::format(holdStartTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::holdStopTime() const
    {
      return parse_json<int>::parse(m_values["HoldStopTime"]);
    }

    void SetPseudorangeRampForSV::setHoldStopTime(int holdStopTime)
    {
      m_values.AddMember("HoldStopTime", parse_json<int>::format(holdStopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRampForSV::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetPseudorangeRampForSV::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetPseudorangeRampForSV::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetPseudorangeRampForSV::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeRampForSV
///
#include "gen/GetPseudorangeRampForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeRampForSV::CmdName = "GetPseudorangeRampForSV";
    const char* const GetPseudorangeRampForSV::Documentation = "Get PSR ramp event. This function lets user change the pseudorange of any satellite.\nIf SV ID is set to 0, the change is applied to all satellites.\n\n         Hold Start Time\n         |     Hold Stop Time\n         |     |\n         ...........\n       ..       ...\n       ..        ...\n  .......           .........> Time\n      |           |\n      Start Time      Stop Time\n";

    REGISTER_COMMAND_FACTORY(GetPseudorangeRampForSV);


    GetPseudorangeRampForSV::GetPseudorangeRampForSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeRampForSV::GetPseudorangeRampForSV(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetPseudorangeRampForSVPtr GetPseudorangeRampForSV::create(const std::string& id)
    {
      return GetPseudorangeRampForSVPtr(new GetPseudorangeRampForSV(id));
    }

    GetPseudorangeRampForSVPtr GetPseudorangeRampForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeRampForSV>(ptr);
    }

    bool GetPseudorangeRampForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetPseudorangeRampForSV::documentation() const { return Documentation; }


    int GetPseudorangeRampForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeRampForSV::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetPseudorangeRampForSV::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeRampForSVResult
///
#include "gen/GetPseudorangeRampForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeRampForSVResult::CmdName = "GetPseudorangeRampForSVResult";
    const char* const GetPseudorangeRampForSVResult::Documentation = "Result of GetPseudorangeRampForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeRampForSVResult);


    GetPseudorangeRampForSVResult::GetPseudorangeRampForSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeRampForSVResult::GetPseudorangeRampForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setOffset(offset);
      setStartTime(startTime);
      setHoldStartTime(holdStartTime);
      setHoldStopTime(holdStopTime);
      setStopTime(stopTime);
      setId(id);
    }


    GetPseudorangeRampForSVResultPtr GetPseudorangeRampForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
    {
      return GetPseudorangeRampForSVResultPtr(new GetPseudorangeRampForSVResult(relatedCommand, system, svId, offset, startTime, holdStartTime, holdStopTime, stopTime, id));
    }

    GetPseudorangeRampForSVResultPtr GetPseudorangeRampForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeRampForSVResult>(ptr);
    }

    bool GetPseudorangeRampForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["HoldStartTime"])
          && parse_json<int>::is_valid(m_values["HoldStopTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetPseudorangeRampForSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeRampForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeRampForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeRampForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeRampForSVResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPseudorangeRampForSVResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetPseudorangeRampForSVResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::holdStartTime() const
    {
      return parse_json<int>::parse(m_values["HoldStartTime"]);
    }

    void GetPseudorangeRampForSVResult::setHoldStartTime(int holdStartTime)
    {
      m_values.AddMember("HoldStartTime", parse_json<int>::format(holdStartTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::holdStopTime() const
    {
      return parse_json<int>::parse(m_values["HoldStopTime"]);
    }

    void GetPseudorangeRampForSVResult::setHoldStopTime(int holdStopTime)
    {
      m_values.AddMember("HoldStopTime", parse_json<int>::format(holdStopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampForSVResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetPseudorangeRampForSVResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetPseudorangeRampForSVResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetPseudorangeRampForSVResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllPseudorangeRampForSV
///
#include "gen/GetAllPseudorangeRampForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllPseudorangeRampForSV::CmdName = "GetAllPseudorangeRampForSV";
    const char* const GetAllPseudorangeRampForSV::Documentation = "Get a list of all the pseudorange ramps IDs for a system's satellite.";

    REGISTER_COMMAND_FACTORY(GetAllPseudorangeRampForSV);


    GetAllPseudorangeRampForSV::GetAllPseudorangeRampForSV()
      : CommandBase(CmdName)
    {}

    GetAllPseudorangeRampForSV::GetAllPseudorangeRampForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetAllPseudorangeRampForSVPtr GetAllPseudorangeRampForSV::create(const std::string& system, int svId)
    {
      return GetAllPseudorangeRampForSVPtr(new GetAllPseudorangeRampForSV(system, svId));
    }

    GetAllPseudorangeRampForSVPtr GetAllPseudorangeRampForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllPseudorangeRampForSV>(ptr);
    }

    bool GetAllPseudorangeRampForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetAllPseudorangeRampForSV::documentation() const { return Documentation; }


    int GetAllPseudorangeRampForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllPseudorangeRampForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllPseudorangeRampForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllPseudorangeRampForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllPseudorangeRampForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllPseudorangeRampForSVResult
///
#include "gen/GetAllPseudorangeRampForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllPseudorangeRampForSVResult::CmdName = "GetAllPseudorangeRampForSVResult";
    const char* const GetAllPseudorangeRampForSVResult::Documentation = "result of GetAllPseudorangeRampForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllPseudorangeRampForSVResult);


    GetAllPseudorangeRampForSVResult::GetAllPseudorangeRampForSVResult()
      : CommandResult(CmdName)
    {}

    GetAllPseudorangeRampForSVResult::GetAllPseudorangeRampForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setIds(ids);
    }


    GetAllPseudorangeRampForSVResultPtr GetAllPseudorangeRampForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const std::vector<std::string>& ids)
    {
      return GetAllPseudorangeRampForSVResultPtr(new GetAllPseudorangeRampForSVResult(relatedCommand, system, svId, ids));
    }

    GetAllPseudorangeRampForSVResultPtr GetAllPseudorangeRampForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllPseudorangeRampForSVResult>(ptr);
    }

    bool GetAllPseudorangeRampForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllPseudorangeRampForSVResult::documentation() const { return Documentation; }


    std::string GetAllPseudorangeRampForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllPseudorangeRampForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllPseudorangeRampForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllPseudorangeRampForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetAllPseudorangeRampForSVResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllPseudorangeRampForSVResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemovePseudorangeRamp
///
#include "gen/RemovePseudorangeRamp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemovePseudorangeRamp::CmdName = "RemovePseudorangeRamp";
    const char* const RemovePseudorangeRamp::Documentation = "Removes a PSR ramp events. When adding an event, the simulator\nsets the Id parameter. Use that Id here to remove the associated ramp.";

    REGISTER_COMMAND_FACTORY(RemovePseudorangeRamp);


    RemovePseudorangeRamp::RemovePseudorangeRamp()
      : CommandBase(CmdName)
    {}

    RemovePseudorangeRamp::RemovePseudorangeRamp(const std::string& system, const std::string& id)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setId(id);
    }


    RemovePseudorangeRampPtr RemovePseudorangeRamp::create(const std::string& system, const std::string& id)
    {
      return RemovePseudorangeRampPtr(new RemovePseudorangeRamp(system, id));
    }

    RemovePseudorangeRampPtr RemovePseudorangeRamp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemovePseudorangeRamp>(ptr);
    }

    bool RemovePseudorangeRamp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemovePseudorangeRamp::documentation() const { return Documentation; }


    int RemovePseudorangeRamp::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemovePseudorangeRamp::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemovePseudorangeRamp::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemovePseudorangeRamp::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemovePseudorangeRamp::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllPseudorangeRampForSV
///
#include "gen/RemoveAllPseudorangeRampForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllPseudorangeRampForSV::CmdName = "RemoveAllPseudorangeRampForSV";
    const char* const RemoveAllPseudorangeRampForSV::Documentation = "Remove all PSR Ramps for the specified system's satellite.";

    REGISTER_COMMAND_FACTORY(RemoveAllPseudorangeRampForSV);


    RemoveAllPseudorangeRampForSV::RemoveAllPseudorangeRampForSV()
      : CommandBase(CmdName)
    {}

    RemoveAllPseudorangeRampForSV::RemoveAllPseudorangeRampForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    RemoveAllPseudorangeRampForSVPtr RemoveAllPseudorangeRampForSV::create(const std::string& system, int svId)
    {
      return RemoveAllPseudorangeRampForSVPtr(new RemoveAllPseudorangeRampForSV(system, svId));
    }

    RemoveAllPseudorangeRampForSVPtr RemoveAllPseudorangeRampForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllPseudorangeRampForSV>(ptr);
    }

    bool RemoveAllPseudorangeRampForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string RemoveAllPseudorangeRampForSV::documentation() const { return Documentation; }


    int RemoveAllPseudorangeRampForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllPseudorangeRampForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllPseudorangeRampForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int RemoveAllPseudorangeRampForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void RemoveAllPseudorangeRampForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllPseudorangeRampForSystem
///
#include "gen/RemoveAllPseudorangeRampForSystem.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllPseudorangeRampForSystem::CmdName = "RemoveAllPseudorangeRampForSystem";
    const char* const RemoveAllPseudorangeRampForSystem::Documentation = "Remove all PSR Ramps for all satellites of the specified system.";

    REGISTER_COMMAND_FACTORY(RemoveAllPseudorangeRampForSystem);


    RemoveAllPseudorangeRampForSystem::RemoveAllPseudorangeRampForSystem()
      : CommandBase(CmdName)
    {}

    RemoveAllPseudorangeRampForSystem::RemoveAllPseudorangeRampForSystem(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    RemoveAllPseudorangeRampForSystemPtr RemoveAllPseudorangeRampForSystem::create(const std::string& system)
    {
      return RemoveAllPseudorangeRampForSystemPtr(new RemoveAllPseudorangeRampForSystem(system));
    }

    RemoveAllPseudorangeRampForSystemPtr RemoveAllPseudorangeRampForSystem::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllPseudorangeRampForSystem>(ptr);
    }

    bool RemoveAllPseudorangeRampForSystem::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RemoveAllPseudorangeRampForSystem::documentation() const { return Documentation; }


    int RemoveAllPseudorangeRampForSystem::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllPseudorangeRampForSystem::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllPseudorangeRampForSystem::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllPseudorangeRamp
///
#include "gen/RemoveAllPseudorangeRamp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllPseudorangeRamp::CmdName = "RemoveAllPseudorangeRamp";
    const char* const RemoveAllPseudorangeRamp::Documentation = "Please note the command RemoveAllPseudorangeRamp is deprecated since 21.3. You may use RemoveAllPseudorangeRampForSystem.\n\nRemove all PSR Ramps for all satellites of the specified system.";

    REGISTER_COMMAND_FACTORY(RemoveAllPseudorangeRamp);


    RemoveAllPseudorangeRamp::RemoveAllPseudorangeRamp()
      : CommandBase(CmdName)
    {}

    RemoveAllPseudorangeRamp::RemoveAllPseudorangeRamp(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    RemoveAllPseudorangeRampPtr RemoveAllPseudorangeRamp::create(const std::string& system)
    {
      return RemoveAllPseudorangeRampPtr(new RemoveAllPseudorangeRamp(system));
    }

    RemoveAllPseudorangeRampPtr RemoveAllPseudorangeRamp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllPseudorangeRamp>(ptr);
    }

    bool RemoveAllPseudorangeRamp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RemoveAllPseudorangeRamp::documentation() const { return Documentation; }


    int RemoveAllPseudorangeRamp::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllPseudorangeRamp::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllPseudorangeRamp::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAlmanacInitialUploadTimeOffset
///
#include "gen/SetAlmanacInitialUploadTimeOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAlmanacInitialUploadTimeOffset::CmdName = "SetAlmanacInitialUploadTimeOffset";
    const char* const SetAlmanacInitialUploadTimeOffset::Documentation = "Set next almanac upload time relative to simulation start time.";

    REGISTER_COMMAND_FACTORY(SetAlmanacInitialUploadTimeOffset);


    SetAlmanacInitialUploadTimeOffset::SetAlmanacInitialUploadTimeOffset()
      : CommandBase(CmdName)
    {}

    SetAlmanacInitialUploadTimeOffset::SetAlmanacInitialUploadTimeOffset(const std::string& system, int offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setOffset(offset);
    }


    SetAlmanacInitialUploadTimeOffsetPtr SetAlmanacInitialUploadTimeOffset::create(const std::string& system, int offset)
    {
      return SetAlmanacInitialUploadTimeOffsetPtr(new SetAlmanacInitialUploadTimeOffset(system, offset));
    }

    SetAlmanacInitialUploadTimeOffsetPtr SetAlmanacInitialUploadTimeOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAlmanacInitialUploadTimeOffset>(ptr);
    }

    bool SetAlmanacInitialUploadTimeOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetAlmanacInitialUploadTimeOffset::documentation() const { return Documentation; }


    int SetAlmanacInitialUploadTimeOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAlmanacInitialUploadTimeOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAlmanacInitialUploadTimeOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAlmanacInitialUploadTimeOffset::offset() const
    {
      return parse_json<int>::parse(m_values["Offset"]);
    }

    void SetAlmanacInitialUploadTimeOffset::setOffset(int offset)
    {
      m_values.AddMember("Offset", parse_json<int>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAlmanacInitialUploadTimeOffset
///
#include "gen/GetAlmanacInitialUploadTimeOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAlmanacInitialUploadTimeOffset::CmdName = "GetAlmanacInitialUploadTimeOffset";
    const char* const GetAlmanacInitialUploadTimeOffset::Documentation = "Get next almanac upload time relative to simulation start time.";

    REGISTER_COMMAND_FACTORY(GetAlmanacInitialUploadTimeOffset);


    GetAlmanacInitialUploadTimeOffset::GetAlmanacInitialUploadTimeOffset()
      : CommandBase(CmdName)
    {

    }


    GetAlmanacInitialUploadTimeOffsetPtr GetAlmanacInitialUploadTimeOffset::create()
    {
      return GetAlmanacInitialUploadTimeOffsetPtr(new GetAlmanacInitialUploadTimeOffset());
    }

    GetAlmanacInitialUploadTimeOffsetPtr GetAlmanacInitialUploadTimeOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAlmanacInitialUploadTimeOffset>(ptr);
    }

    bool GetAlmanacInitialUploadTimeOffset::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAlmanacInitialUploadTimeOffset::documentation() const { return Documentation; }


    int GetAlmanacInitialUploadTimeOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAlmanacInitialUploadTimeOffsetResult
///
#include "gen/GetAlmanacInitialUploadTimeOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAlmanacInitialUploadTimeOffsetResult::CmdName = "GetAlmanacInitialUploadTimeOffsetResult";
    const char* const GetAlmanacInitialUploadTimeOffsetResult::Documentation = "Result of GetAlmanacInitialUploadTimeOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetAlmanacInitialUploadTimeOffsetResult);


    GetAlmanacInitialUploadTimeOffsetResult::GetAlmanacInitialUploadTimeOffsetResult()
      : CommandResult(CmdName)
    {}

    GetAlmanacInitialUploadTimeOffsetResult::GetAlmanacInitialUploadTimeOffsetResult(CommandBasePtr relatedCommand, const std::string& system, int offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setOffset(offset);
    }


    GetAlmanacInitialUploadTimeOffsetResultPtr GetAlmanacInitialUploadTimeOffsetResult::create(CommandBasePtr relatedCommand, const std::string& system, int offset)
    {
      return GetAlmanacInitialUploadTimeOffsetResultPtr(new GetAlmanacInitialUploadTimeOffsetResult(relatedCommand, system, offset));
    }

    GetAlmanacInitialUploadTimeOffsetResultPtr GetAlmanacInitialUploadTimeOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAlmanacInitialUploadTimeOffsetResult>(ptr);
    }

    bool GetAlmanacInitialUploadTimeOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetAlmanacInitialUploadTimeOffsetResult::documentation() const { return Documentation; }


    std::string GetAlmanacInitialUploadTimeOffsetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAlmanacInitialUploadTimeOffsetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAlmanacInitialUploadTimeOffsetResult::offset() const
    {
      return parse_json<int>::parse(m_values["Offset"]);
    }

    void GetAlmanacInitialUploadTimeOffsetResult::setOffset(int offset)
    {
      m_values.AddMember("Offset", parse_json<int>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAlmanacUploadTimeInterval
///
#include "gen/SetAlmanacUploadTimeInterval.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAlmanacUploadTimeInterval::CmdName = "SetAlmanacUploadTimeInterval";
    const char* const SetAlmanacUploadTimeInterval::Documentation = "Set almanac upload interval in seconds. After the initial upload set with command \nSetAlmanacInitialUploadTimeOffset, the almanac will automatically update at each interval.";

    REGISTER_COMMAND_FACTORY(SetAlmanacUploadTimeInterval);


    SetAlmanacUploadTimeInterval::SetAlmanacUploadTimeInterval()
      : CommandBase(CmdName)
    {}

    SetAlmanacUploadTimeInterval::SetAlmanacUploadTimeInterval(const std::string& system, int interval)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setInterval(interval);
    }


    SetAlmanacUploadTimeIntervalPtr SetAlmanacUploadTimeInterval::create(const std::string& system, int interval)
    {
      return SetAlmanacUploadTimeIntervalPtr(new SetAlmanacUploadTimeInterval(system, interval));
    }

    SetAlmanacUploadTimeIntervalPtr SetAlmanacUploadTimeInterval::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAlmanacUploadTimeInterval>(ptr);
    }

    bool SetAlmanacUploadTimeInterval::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Interval"])
        ;

    }

    std::string SetAlmanacUploadTimeInterval::documentation() const { return Documentation; }


    int SetAlmanacUploadTimeInterval::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAlmanacUploadTimeInterval::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAlmanacUploadTimeInterval::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAlmanacUploadTimeInterval::interval() const
    {
      return parse_json<int>::parse(m_values["Interval"]);
    }

    void SetAlmanacUploadTimeInterval::setInterval(int interval)
    {
      m_values.AddMember("Interval", parse_json<int>::format(interval, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAlmanacUploadTimeInterval
///
#include "gen/GetAlmanacUploadTimeInterval.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAlmanacUploadTimeInterval::CmdName = "GetAlmanacUploadTimeInterval";
    const char* const GetAlmanacUploadTimeInterval::Documentation = "Get almanac upload interval in seconds. After the initial upload set with command \nSetAlmanacInitialUploadTimeOffset, the almanac will automatically update at each interval.";

    REGISTER_COMMAND_FACTORY(GetAlmanacUploadTimeInterval);


    GetAlmanacUploadTimeInterval::GetAlmanacUploadTimeInterval()
      : CommandBase(CmdName)
    {

    }


    GetAlmanacUploadTimeIntervalPtr GetAlmanacUploadTimeInterval::create()
    {
      return GetAlmanacUploadTimeIntervalPtr(new GetAlmanacUploadTimeInterval());
    }

    GetAlmanacUploadTimeIntervalPtr GetAlmanacUploadTimeInterval::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAlmanacUploadTimeInterval>(ptr);
    }

    bool GetAlmanacUploadTimeInterval::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAlmanacUploadTimeInterval::documentation() const { return Documentation; }


    int GetAlmanacUploadTimeInterval::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAlmanacUploadTimeIntervalResult
///
#include "gen/GetAlmanacUploadTimeIntervalResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAlmanacUploadTimeIntervalResult::CmdName = "GetAlmanacUploadTimeIntervalResult";
    const char* const GetAlmanacUploadTimeIntervalResult::Documentation = "Result of GetAlmanacUploadTimeInterval";

    REGISTER_COMMAND_RESULT_FACTORY(GetAlmanacUploadTimeIntervalResult);


    GetAlmanacUploadTimeIntervalResult::GetAlmanacUploadTimeIntervalResult()
      : CommandResult(CmdName)
    {}

    GetAlmanacUploadTimeIntervalResult::GetAlmanacUploadTimeIntervalResult(CommandBasePtr relatedCommand, const std::string& system, int interval)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setInterval(interval);
    }


    GetAlmanacUploadTimeIntervalResultPtr GetAlmanacUploadTimeIntervalResult::create(CommandBasePtr relatedCommand, const std::string& system, int interval)
    {
      return GetAlmanacUploadTimeIntervalResultPtr(new GetAlmanacUploadTimeIntervalResult(relatedCommand, system, interval));
    }

    GetAlmanacUploadTimeIntervalResultPtr GetAlmanacUploadTimeIntervalResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAlmanacUploadTimeIntervalResult>(ptr);
    }

    bool GetAlmanacUploadTimeIntervalResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Interval"])
        ;

    }

    std::string GetAlmanacUploadTimeIntervalResult::documentation() const { return Documentation; }


    std::string GetAlmanacUploadTimeIntervalResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAlmanacUploadTimeIntervalResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAlmanacUploadTimeIntervalResult::interval() const
    {
      return parse_json<int>::parse(m_values["Interval"]);
    }

    void GetAlmanacUploadTimeIntervalResult::setInterval(int interval)
    {
      m_values.AddMember("Interval", parse_json<int>::format(interval, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMultipathForSV
///
#include "gen/SetMultipathForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMultipathForSV::CmdName = "SetMultipathForSV";
    const char* const SetMultipathForSV::Documentation = "Add or update signal echo (multipath). Offsets (power loss, pseudorange, Doppler and carrier phase) are all relative to line-of-sight signal.\nIf Id is not set, or unknown to Skydel, a new echo will be added. Otherwise, existing echo will be updated.";

    REGISTER_COMMAND_FACTORY(SetMultipathForSV);


    SetMultipathForSV::SetMultipathForSV()
      : CommandBase(CmdName)
    {}

    SetMultipathForSV::SetMultipathForSV(const std::string& signal, int svId, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
      setPowerLoss(powerLoss);
      setPseudorange(pseudorange);
      setDoppler(doppler);
      setCarrierPhase(carrierPhase);
      setEcho(echo);
      setId(id);
    }


    SetMultipathForSVPtr SetMultipathForSV::create(const std::string& signal, int svId, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo, const std::string& id)
    {
      return SetMultipathForSVPtr(new SetMultipathForSV(signal, svId, powerLoss, pseudorange, doppler, carrierPhase, echo, id));
    }

    SetMultipathForSVPtr SetMultipathForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMultipathForSV>(ptr);
    }

    bool SetMultipathForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["PowerLoss"])
          && parse_json<double>::is_valid(m_values["Pseudorange"])
          && parse_json<double>::is_valid(m_values["Doppler"])
          && parse_json<double>::is_valid(m_values["CarrierPhase"])
          && parse_json<int>::is_valid(m_values["Echo"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMultipathForSV::documentation() const { return Documentation; }


    int SetMultipathForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetMultipathForSV::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetMultipathForSV::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMultipathForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetMultipathForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipathForSV::powerLoss() const
    {
      return parse_json<double>::parse(m_values["PowerLoss"]);
    }

    void SetMultipathForSV::setPowerLoss(double powerLoss)
    {
      m_values.AddMember("PowerLoss", parse_json<double>::format(powerLoss, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipathForSV::pseudorange() const
    {
      return parse_json<double>::parse(m_values["Pseudorange"]);
    }

    void SetMultipathForSV::setPseudorange(double pseudorange)
    {
      m_values.AddMember("Pseudorange", parse_json<double>::format(pseudorange, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipathForSV::doppler() const
    {
      return parse_json<double>::parse(m_values["Doppler"]);
    }

    void SetMultipathForSV::setDoppler(double doppler)
    {
      m_values.AddMember("Doppler", parse_json<double>::format(doppler, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipathForSV::carrierPhase() const
    {
      return parse_json<double>::parse(m_values["CarrierPhase"]);
    }

    void SetMultipathForSV::setCarrierPhase(double carrierPhase)
    {
      m_values.AddMember("CarrierPhase", parse_json<double>::format(carrierPhase, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMultipathForSV::echo() const
    {
      return parse_json<int>::parse(m_values["Echo"]);
    }

    void SetMultipathForSV::setEcho(int echo)
    {
      m_values.AddMember("Echo", parse_json<int>::format(echo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMultipathForSV::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMultipathForSV::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableMultipath
///
#include "gen/EnableMultipath.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableMultipath::CmdName = "EnableMultipath";
    const char* const EnableMultipath::Documentation = "Enable/Disable a multipath signal.";

    REGISTER_COMMAND_FACTORY(EnableMultipath);


    EnableMultipath::EnableMultipath()
      : CommandBase(CmdName)
    {}

    EnableMultipath::EnableMultipath(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    EnableMultipathPtr EnableMultipath::create(bool enabled, const std::string& id)
    {
      return EnableMultipathPtr(new EnableMultipath(enabled, id));
    }

    EnableMultipathPtr EnableMultipath::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableMultipath>(ptr);
    }

    bool EnableMultipath::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EnableMultipath::documentation() const { return Documentation; }


    int EnableMultipath::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool EnableMultipath::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableMultipath::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableMultipath::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EnableMultipath::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveMultipath
///
#include "gen/RemoveMultipath.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveMultipath::CmdName = "RemoveMultipath";
    const char* const RemoveMultipath::Documentation = "Removes a multipath signal.";

    REGISTER_COMMAND_FACTORY(RemoveMultipath);


    RemoveMultipath::RemoveMultipath()
      : CommandBase(CmdName)
    {}

    RemoveMultipath::RemoveMultipath(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveMultipathPtr RemoveMultipath::create(const std::string& id)
    {
      return RemoveMultipathPtr(new RemoveMultipath(id));
    }

    RemoveMultipathPtr RemoveMultipath::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveMultipath>(ptr);
    }

    bool RemoveMultipath::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveMultipath::documentation() const { return Documentation; }


    int RemoveMultipath::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RemoveMultipath::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveMultipath::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllMultipathForSignal
///
#include "gen/RemoveAllMultipathForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllMultipathForSignal::CmdName = "RemoveAllMultipathForSignal";
    const char* const RemoveAllMultipathForSignal::Documentation = "Disable all multipath in all satellites but only for the specified signal.";

    REGISTER_COMMAND_FACTORY(RemoveAllMultipathForSignal);


    RemoveAllMultipathForSignal::RemoveAllMultipathForSignal()
      : CommandBase(CmdName)
    {}

    RemoveAllMultipathForSignal::RemoveAllMultipathForSignal(const std::string& signal, bool reset)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setReset(reset);
    }


    RemoveAllMultipathForSignalPtr RemoveAllMultipathForSignal::create(const std::string& signal, bool reset)
    {
      return RemoveAllMultipathForSignalPtr(new RemoveAllMultipathForSignal(signal, reset));
    }

    RemoveAllMultipathForSignalPtr RemoveAllMultipathForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllMultipathForSignal>(ptr);
    }

    bool RemoveAllMultipathForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<bool>::is_valid(m_values["Reset"])
        ;

    }

    std::string RemoveAllMultipathForSignal::documentation() const { return Documentation; }


    int RemoveAllMultipathForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllMultipathForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void RemoveAllMultipathForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool RemoveAllMultipathForSignal::reset() const
    {
      return parse_json<bool>::parse(m_values["Reset"]);
    }

    void RemoveAllMultipathForSignal::setReset(bool reset)
    {
      m_values.AddMember("Reset", parse_json<bool>::format(reset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllMultipathForSV
///
#include "gen/RemoveAllMultipathForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllMultipathForSV::CmdName = "RemoveAllMultipathForSV";
    const char* const RemoveAllMultipathForSV::Documentation = "Disable all multipath for the specified satellite.";

    REGISTER_COMMAND_FACTORY(RemoveAllMultipathForSV);


    RemoveAllMultipathForSV::RemoveAllMultipathForSV()
      : CommandBase(CmdName)
    {}

    RemoveAllMultipathForSV::RemoveAllMultipathForSV(const std::string& system, int svId, bool reset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setReset(reset);
    }


    RemoveAllMultipathForSVPtr RemoveAllMultipathForSV::create(const std::string& system, int svId, bool reset)
    {
      return RemoveAllMultipathForSVPtr(new RemoveAllMultipathForSV(system, svId, reset));
    }

    RemoveAllMultipathForSVPtr RemoveAllMultipathForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllMultipathForSV>(ptr);
    }

    bool RemoveAllMultipathForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Reset"])
        ;

    }

    std::string RemoveAllMultipathForSV::documentation() const { return Documentation; }


    int RemoveAllMultipathForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllMultipathForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllMultipathForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int RemoveAllMultipathForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void RemoveAllMultipathForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool RemoveAllMultipathForSV::reset() const
    {
      return parse_json<bool>::parse(m_values["Reset"]);
    }

    void RemoveAllMultipathForSV::setReset(bool reset)
    {
      m_values.AddMember("Reset", parse_json<bool>::format(reset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllMultipathForSystem
///
#include "gen/RemoveAllMultipathForSystem.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllMultipathForSystem::CmdName = "RemoveAllMultipathForSystem";
    const char* const RemoveAllMultipathForSystem::Documentation = "Disable all multipath for the specified constellation.";

    REGISTER_COMMAND_FACTORY(RemoveAllMultipathForSystem);


    RemoveAllMultipathForSystem::RemoveAllMultipathForSystem()
      : CommandBase(CmdName)
    {}

    RemoveAllMultipathForSystem::RemoveAllMultipathForSystem(const std::string& system, bool reset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setReset(reset);
    }


    RemoveAllMultipathForSystemPtr RemoveAllMultipathForSystem::create(const std::string& system, bool reset)
    {
      return RemoveAllMultipathForSystemPtr(new RemoveAllMultipathForSystem(system, reset));
    }

    RemoveAllMultipathForSystemPtr RemoveAllMultipathForSystem::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllMultipathForSystem>(ptr);
    }

    bool RemoveAllMultipathForSystem::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["Reset"])
        ;

    }

    std::string RemoveAllMultipathForSystem::documentation() const { return Documentation; }


    int RemoveAllMultipathForSystem::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveAllMultipathForSystem::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllMultipathForSystem::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool RemoveAllMultipathForSystem::reset() const
    {
      return parse_json<bool>::parse(m_values["Reset"]);
    }

    void RemoveAllMultipathForSystem::setReset(bool reset)
    {
      m_values.AddMember("Reset", parse_json<bool>::format(reset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMultipathForID
///
#include "gen/GetMultipathForID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMultipathForID::CmdName = "GetMultipathForID";
    const char* const GetMultipathForID::Documentation = "Get multipath infos for the specified multipath ID.";

    REGISTER_COMMAND_FACTORY(GetMultipathForID);


    GetMultipathForID::GetMultipathForID()
      : CommandBase(CmdName)
    {}

    GetMultipathForID::GetMultipathForID(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMultipathForIDPtr GetMultipathForID::create(const std::string& id)
    {
      return GetMultipathForIDPtr(new GetMultipathForID(id));
    }

    GetMultipathForIDPtr GetMultipathForID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMultipathForID>(ptr);
    }

    bool GetMultipathForID::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMultipathForID::documentation() const { return Documentation; }


    int GetMultipathForID::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMultipathForID::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMultipathForID::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMultipathForIDResult
///
#include "gen/GetMultipathForIDResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMultipathForIDResult::CmdName = "GetMultipathForIDResult";
    const char* const GetMultipathForIDResult::Documentation = "Result of GetMultipathForIDResult.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMultipathForIDResult);


    GetMultipathForIDResult::GetMultipathForIDResult()
      : CommandResult(CmdName)
    {}

    GetMultipathForIDResult::GetMultipathForIDResult(CommandBasePtr relatedCommand, const std::string& id, const std::string& system, const std::string& signal, int svId, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo)
      : CommandResult(CmdName, relatedCommand)
    {

      setId(id);
      setSystem(system);
      setSignal(signal);
      setSvId(svId);
      setPowerLoss(powerLoss);
      setPseudorange(pseudorange);
      setDoppler(doppler);
      setCarrierPhase(carrierPhase);
      setEcho(echo);
    }


    GetMultipathForIDResultPtr GetMultipathForIDResult::create(CommandBasePtr relatedCommand, const std::string& id, const std::string& system, const std::string& signal, int svId, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo)
    {
      return GetMultipathForIDResultPtr(new GetMultipathForIDResult(relatedCommand, id, system, signal, svId, powerLoss, pseudorange, doppler, carrierPhase, echo));
    }

    GetMultipathForIDResultPtr GetMultipathForIDResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMultipathForIDResult>(ptr);
    }

    bool GetMultipathForIDResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["PowerLoss"])
          && parse_json<double>::is_valid(m_values["Pseudorange"])
          && parse_json<double>::is_valid(m_values["Doppler"])
          && parse_json<double>::is_valid(m_values["CarrierPhase"])
          && parse_json<int>::is_valid(m_values["Echo"])
        ;

    }

    std::string GetMultipathForIDResult::documentation() const { return Documentation; }


    std::string GetMultipathForIDResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMultipathForIDResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMultipathForIDResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetMultipathForIDResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMultipathForIDResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetMultipathForIDResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMultipathForIDResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMultipathForIDResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathForIDResult::powerLoss() const
    {
      return parse_json<double>::parse(m_values["PowerLoss"]);
    }

    void GetMultipathForIDResult::setPowerLoss(double powerLoss)
    {
      m_values.AddMember("PowerLoss", parse_json<double>::format(powerLoss, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathForIDResult::pseudorange() const
    {
      return parse_json<double>::parse(m_values["Pseudorange"]);
    }

    void GetMultipathForIDResult::setPseudorange(double pseudorange)
    {
      m_values.AddMember("Pseudorange", parse_json<double>::format(pseudorange, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathForIDResult::doppler() const
    {
      return parse_json<double>::parse(m_values["Doppler"]);
    }

    void GetMultipathForIDResult::setDoppler(double doppler)
    {
      m_values.AddMember("Doppler", parse_json<double>::format(doppler, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathForIDResult::carrierPhase() const
    {
      return parse_json<double>::parse(m_values["CarrierPhase"]);
    }

    void GetMultipathForIDResult::setCarrierPhase(double carrierPhase)
    {
      m_values.AddMember("CarrierPhase", parse_json<double>::format(carrierPhase, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMultipathForIDResult::echo() const
    {
      return parse_json<int>::parse(m_values["Echo"]);
    }

    void GetMultipathForIDResult::setEcho(int echo)
    {
      m_values.AddMember("Echo", parse_json<int>::format(echo, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMultipathForSystem
///
#include "gen/GetAllMultipathForSystem.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMultipathForSystem::CmdName = "GetAllMultipathForSystem";
    const char* const GetAllMultipathForSystem::Documentation = "Get all multipath ID for the specified constellation.";

    REGISTER_COMMAND_FACTORY(GetAllMultipathForSystem);


    GetAllMultipathForSystem::GetAllMultipathForSystem()
      : CommandBase(CmdName)
    {}

    GetAllMultipathForSystem::GetAllMultipathForSystem(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetAllMultipathForSystemPtr GetAllMultipathForSystem::create(const std::string& system)
    {
      return GetAllMultipathForSystemPtr(new GetAllMultipathForSystem(system));
    }

    GetAllMultipathForSystemPtr GetAllMultipathForSystem::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMultipathForSystem>(ptr);
    }

    bool GetAllMultipathForSystem::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetAllMultipathForSystem::documentation() const { return Documentation; }


    int GetAllMultipathForSystem::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMultipathForSystem::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllMultipathForSystem::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMultipathForSV
///
#include "gen/GetAllMultipathForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMultipathForSV::CmdName = "GetAllMultipathForSV";
    const char* const GetAllMultipathForSV::Documentation = "Get all multipath ID for the specified satellite of the constellation.";

    REGISTER_COMMAND_FACTORY(GetAllMultipathForSV);


    GetAllMultipathForSV::GetAllMultipathForSV()
      : CommandBase(CmdName)
    {}

    GetAllMultipathForSV::GetAllMultipathForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetAllMultipathForSVPtr GetAllMultipathForSV::create(const std::string& system, int svId)
    {
      return GetAllMultipathForSVPtr(new GetAllMultipathForSV(system, svId));
    }

    GetAllMultipathForSVPtr GetAllMultipathForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMultipathForSV>(ptr);
    }

    bool GetAllMultipathForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetAllMultipathForSV::documentation() const { return Documentation; }


    int GetAllMultipathForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMultipathForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllMultipathForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllMultipathForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetAllMultipathForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMultipathForSignal
///
#include "gen/GetAllMultipathForSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMultipathForSignal::CmdName = "GetAllMultipathForSignal";
    const char* const GetAllMultipathForSignal::Documentation = "Get all multipath ID for the specified signal.";

    REGISTER_COMMAND_FACTORY(GetAllMultipathForSignal);


    GetAllMultipathForSignal::GetAllMultipathForSignal()
      : CommandBase(CmdName)
    {}

    GetAllMultipathForSignal::GetAllMultipathForSignal(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetAllMultipathForSignalPtr GetAllMultipathForSignal::create(const std::string& signal)
    {
      return GetAllMultipathForSignalPtr(new GetAllMultipathForSignal(signal));
    }

    GetAllMultipathForSignalPtr GetAllMultipathForSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMultipathForSignal>(ptr);
    }

    bool GetAllMultipathForSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetAllMultipathForSignal::documentation() const { return Documentation; }


    int GetAllMultipathForSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMultipathForSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetAllMultipathForSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMultipathForResult
///
#include "gen/GetAllMultipathForResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMultipathForResult::CmdName = "GetAllMultipathForResult";
    const char* const GetAllMultipathForResult::Documentation = "Result of GetAllMultipathFor(Signal|SV|System) commands.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllMultipathForResult);


    GetAllMultipathForResult::GetAllMultipathForResult()
      : CommandResult(CmdName)
    {}

    GetAllMultipathForResult::GetAllMultipathForResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllMultipathForResultPtr GetAllMultipathForResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetAllMultipathForResultPtr(new GetAllMultipathForResult(relatedCommand, ids));
    }

    GetAllMultipathForResultPtr GetAllMultipathForResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMultipathForResult>(ptr);
    }

    bool GetAllMultipathForResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllMultipathForResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllMultipathForResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllMultipathForResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLosForSV
///
#include "gen/EnableLosForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLosForSV::CmdName = "EnableLosForSV";
    const char* const EnableLosForSV::Documentation = "Set Direct Line Of Sight signal from satellite enabled or disabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(EnableLosForSV);


    EnableLosForSV::EnableLosForSV()
      : CommandBase(CmdName)
    {}

    EnableLosForSV::EnableLosForSV(const std::string& system, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnableLosForSVPtr EnableLosForSV::create(const std::string& system, int svId, bool enabled)
    {
      return EnableLosForSVPtr(new EnableLosForSV(system, svId, enabled));
    }

    EnableLosForSVPtr EnableLosForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLosForSV>(ptr);
    }

    bool EnableLosForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLosForSV::documentation() const { return Documentation; }


    int EnableLosForSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableLosForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableLosForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnableLosForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnableLosForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableLosForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLosForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLosEnabledForSV
///
#include "gen/IsLosEnabledForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLosEnabledForSV::CmdName = "IsLosEnabledForSV";
    const char* const IsLosEnabledForSV::Documentation = "Get Direct Line Of Sight signal from satellite enabled or disabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(IsLosEnabledForSV);


    IsLosEnabledForSV::IsLosEnabledForSV()
      : CommandBase(CmdName)
    {}

    IsLosEnabledForSV::IsLosEnabledForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    IsLosEnabledForSVPtr IsLosEnabledForSV::create(const std::string& system, int svId)
    {
      return IsLosEnabledForSVPtr(new IsLosEnabledForSV(system, svId));
    }

    IsLosEnabledForSVPtr IsLosEnabledForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLosEnabledForSV>(ptr);
    }

    bool IsLosEnabledForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsLosEnabledForSV::documentation() const { return Documentation; }


    int IsLosEnabledForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsLosEnabledForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLosEnabledForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsLosEnabledForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsLosEnabledForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLosEnabledForSVResult
///
#include "gen/IsLosEnabledForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLosEnabledForSVResult::CmdName = "IsLosEnabledForSVResult";
    const char* const IsLosEnabledForSVResult::Documentation = "Result of IsLosEnabledForSV";

    REGISTER_COMMAND_RESULT_FACTORY(IsLosEnabledForSVResult);


    IsLosEnabledForSVResult::IsLosEnabledForSVResult()
      : CommandResult(CmdName)
    {}

    IsLosEnabledForSVResult::IsLosEnabledForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsLosEnabledForSVResultPtr IsLosEnabledForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
    {
      return IsLosEnabledForSVResultPtr(new IsLosEnabledForSVResult(relatedCommand, system, svId, enabled));
    }

    IsLosEnabledForSVResultPtr IsLosEnabledForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLosEnabledForSVResult>(ptr);
    }

    bool IsLosEnabledForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLosEnabledForSVResult::documentation() const { return Documentation; }


    std::string IsLosEnabledForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLosEnabledForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsLosEnabledForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsLosEnabledForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsLosEnabledForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLosEnabledForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllLOSForSystem
///
#include "gen/ClearAllLOSForSystem.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllLOSForSystem::CmdName = "ClearAllLOSForSystem";
    const char* const ClearAllLOSForSystem::Documentation = "Enable Direct Line of Sight (LoS) of all satellites for the specified constellation.";

    REGISTER_COMMAND_FACTORY(ClearAllLOSForSystem);


    ClearAllLOSForSystem::ClearAllLOSForSystem()
      : CommandBase(CmdName)
    {}

    ClearAllLOSForSystem::ClearAllLOSForSystem(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    ClearAllLOSForSystemPtr ClearAllLOSForSystem::create(const std::string& system)
    {
      return ClearAllLOSForSystemPtr(new ClearAllLOSForSystem(system));
    }

    ClearAllLOSForSystemPtr ClearAllLOSForSystem::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllLOSForSystem>(ptr);
    }

    bool ClearAllLOSForSystem::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string ClearAllLOSForSystem::documentation() const { return Documentation; }


    int ClearAllLOSForSystem::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string ClearAllLOSForSystem::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ClearAllLOSForSystem::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLosForEachSV
///
#include "gen/EnableLosForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLosForEachSV::CmdName = "EnableLosForEachSV";
    const char* const EnableLosForEachSV::Documentation = "Set Direct Line Of Sight signal from satellite disabled or enabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(EnableLosForEachSV);


    EnableLosForEachSV::EnableLosForEachSV()
      : CommandBase(CmdName)
    {}

    EnableLosForEachSV::EnableLosForEachSV(const std::string& system, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    EnableLosForEachSVPtr EnableLosForEachSV::create(const std::string& system, const std::vector<bool>& enabled)
    {
      return EnableLosForEachSVPtr(new EnableLosForEachSV(system, enabled));
    }

    EnableLosForEachSVPtr EnableLosForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLosForEachSV>(ptr);
    }

    bool EnableLosForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLosForEachSV::documentation() const { return Documentation; }


    int EnableLosForEachSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableLosForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableLosForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableLosForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableLosForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLOSEnabledForEachSV
///
#include "gen/IsLOSEnabledForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLOSEnabledForEachSV::CmdName = "IsLOSEnabledForEachSV";
    const char* const IsLOSEnabledForEachSV::Documentation = "Get Direct Line Of Sight signal from satellite disabled or enabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(IsLOSEnabledForEachSV);


    IsLOSEnabledForEachSV::IsLOSEnabledForEachSV()
      : CommandBase(CmdName)
    {}

    IsLOSEnabledForEachSV::IsLOSEnabledForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsLOSEnabledForEachSVPtr IsLOSEnabledForEachSV::create(const std::string& system)
    {
      return IsLOSEnabledForEachSVPtr(new IsLOSEnabledForEachSV(system));
    }

    IsLOSEnabledForEachSVPtr IsLOSEnabledForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLOSEnabledForEachSV>(ptr);
    }

    bool IsLOSEnabledForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsLOSEnabledForEachSV::documentation() const { return Documentation; }


    int IsLOSEnabledForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsLOSEnabledForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLOSEnabledForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLOSEnabledForEachSVResult
///
#include "gen/IsLOSEnabledForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLOSEnabledForEachSVResult::CmdName = "IsLOSEnabledForEachSVResult";
    const char* const IsLOSEnabledForEachSVResult::Documentation = "Result of IsLOSEnabledForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(IsLOSEnabledForEachSVResult);


    IsLOSEnabledForEachSVResult::IsLOSEnabledForEachSVResult()
      : CommandResult(CmdName)
    {}

    IsLOSEnabledForEachSVResult::IsLOSEnabledForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    IsLOSEnabledForEachSVResultPtr IsLOSEnabledForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
    {
      return IsLOSEnabledForEachSVResultPtr(new IsLOSEnabledForEachSVResult(relatedCommand, system, enabled));
    }

    IsLOSEnabledForEachSVResultPtr IsLOSEnabledForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLOSEnabledForEachSVResult>(ptr);
    }

    bool IsLOSEnabledForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLOSEnabledForEachSVResult::documentation() const { return Documentation; }


    std::string IsLOSEnabledForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLOSEnabledForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsLOSEnabledForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsLOSEnabledForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddPlugInInstance
///
#include "gen/AddPlugInInstance.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddPlugInInstance::CmdName = "AddPlugInInstance";
    const char* const AddPlugInInstance::Documentation = "Set Add a plug-in instance of specified type.";

    REGISTER_COMMAND_FACTORY(AddPlugInInstance);


    AddPlugInInstance::AddPlugInInstance()
      : CommandBase(CmdName)
    {}

    AddPlugInInstance::AddPlugInInstance(const std::string& name, const std::string& type)
      : CommandBase(CmdName)
    {

      setName(name);
      setType(type);
    }


    AddPlugInInstancePtr AddPlugInInstance::create(const std::string& name, const std::string& type)
    {
      return AddPlugInInstancePtr(new AddPlugInInstance(name, type));
    }

    AddPlugInInstancePtr AddPlugInInstance::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddPlugInInstance>(ptr);
    }

    bool AddPlugInInstance::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string AddPlugInInstance::documentation() const { return Documentation; }


    int AddPlugInInstance::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddPlugInInstance::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void AddPlugInInstance::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddPlugInInstance::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void AddPlugInInstance::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPlugInInstance
///
#include "gen/GetPlugInInstance.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPlugInInstance::CmdName = "GetPlugInInstance";
    const char* const GetPlugInInstance::Documentation = "Get Add a plug-in instance of specified type.";

    REGISTER_COMMAND_FACTORY(GetPlugInInstance);


    GetPlugInInstance::GetPlugInInstance()
      : CommandBase(CmdName)
    {

    }


    GetPlugInInstancePtr GetPlugInInstance::create()
    {
      return GetPlugInInstancePtr(new GetPlugInInstance());
    }

    GetPlugInInstancePtr GetPlugInInstance::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPlugInInstance>(ptr);
    }

    bool GetPlugInInstance::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetPlugInInstance::documentation() const { return Documentation; }


    int GetPlugInInstance::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetPlugInInstanceResult
///
#include "gen/GetPlugInInstanceResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPlugInInstanceResult::CmdName = "GetPlugInInstanceResult";
    const char* const GetPlugInInstanceResult::Documentation = "Result of GetPlugInInstance";

    REGISTER_COMMAND_RESULT_FACTORY(GetPlugInInstanceResult);


    GetPlugInInstanceResult::GetPlugInInstanceResult()
      : CommandResult(CmdName)
    {}

    GetPlugInInstanceResult::GetPlugInInstanceResult(CommandBasePtr relatedCommand, const std::string& name, const std::string& type)
      : CommandResult(CmdName, relatedCommand)
    {

      setName(name);
      setType(type);
    }


    GetPlugInInstanceResultPtr GetPlugInInstanceResult::create(CommandBasePtr relatedCommand, const std::string& name, const std::string& type)
    {
      return GetPlugInInstanceResultPtr(new GetPlugInInstanceResult(relatedCommand, name, type));
    }

    GetPlugInInstanceResultPtr GetPlugInInstanceResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPlugInInstanceResult>(ptr);
    }

    bool GetPlugInInstanceResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
          && parse_json<std::string>::is_valid(m_values["Type"])
        ;

    }

    std::string GetPlugInInstanceResult::documentation() const { return Documentation; }


    std::string GetPlugInInstanceResult::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void GetPlugInInstanceResult::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetPlugInInstanceResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetPlugInInstanceResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemovePlugInInstance
///
#include "gen/RemovePlugInInstance.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemovePlugInInstance::CmdName = "RemovePlugInInstance";
    const char* const RemovePlugInInstance::Documentation = "Removes the plug-in instance.";

    REGISTER_COMMAND_FACTORY(RemovePlugInInstance);


    RemovePlugInInstance::RemovePlugInInstance()
      : CommandBase(CmdName)
    {}

    RemovePlugInInstance::RemovePlugInInstance(const std::string& name)
      : CommandBase(CmdName)
    {

      setName(name);
    }


    RemovePlugInInstancePtr RemovePlugInInstance::create(const std::string& name)
    {
      return RemovePlugInInstancePtr(new RemovePlugInInstance(name));
    }

    RemovePlugInInstancePtr RemovePlugInInstance::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemovePlugInInstance>(ptr);
    }

    bool RemovePlugInInstance::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Name"])
        ;

    }

    std::string RemovePlugInInstance::documentation() const { return Documentation; }


    int RemovePlugInInstance::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemovePlugInInstance::name() const
    {
      return parse_json<std::string>::parse(m_values["Name"]);
    }

    void RemovePlugInInstance::setName(const std::string& name)
    {
      m_values.AddMember("Name", parse_json<std::string>::format(name, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetDefaultIntTxPersistence
///
#include "gen/SetDefaultIntTxPersistence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetDefaultIntTxPersistence::CmdName = "SetDefaultIntTxPersistence";
    const char* const SetDefaultIntTxPersistence::Documentation = "Set wether by default transmitters should keep the modification done during simulation.";

    REGISTER_COMMAND_FACTORY(SetDefaultIntTxPersistence);


    SetDefaultIntTxPersistence::SetDefaultIntTxPersistence()
      : CommandBase(CmdName)
    {}

    SetDefaultIntTxPersistence::SetDefaultIntTxPersistence(bool defaultValue)
      : CommandBase(CmdName)
    {

      setDefaultValue(defaultValue);
    }


    SetDefaultIntTxPersistencePtr SetDefaultIntTxPersistence::create(bool defaultValue)
    {
      return SetDefaultIntTxPersistencePtr(new SetDefaultIntTxPersistence(defaultValue));
    }

    SetDefaultIntTxPersistencePtr SetDefaultIntTxPersistence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetDefaultIntTxPersistence>(ptr);
    }

    bool SetDefaultIntTxPersistence::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["DefaultValue"])
        ;

    }

    std::string SetDefaultIntTxPersistence::documentation() const { return Documentation; }


    int SetDefaultIntTxPersistence::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool SetDefaultIntTxPersistence::defaultValue() const
    {
      return parse_json<bool>::parse(m_values["DefaultValue"]);
    }

    void SetDefaultIntTxPersistence::setDefaultValue(bool defaultValue)
    {
      m_values.AddMember("DefaultValue", parse_json<bool>::format(defaultValue, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetDefaultIntTxPersistence
///
#include "gen/GetDefaultIntTxPersistence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDefaultIntTxPersistence::CmdName = "GetDefaultIntTxPersistence";
    const char* const GetDefaultIntTxPersistence::Documentation = "Get wether by default transmitters should keep the modification done during simulation.";

    REGISTER_COMMAND_FACTORY(GetDefaultIntTxPersistence);


    GetDefaultIntTxPersistence::GetDefaultIntTxPersistence()
      : CommandBase(CmdName)
    {

    }


    GetDefaultIntTxPersistencePtr GetDefaultIntTxPersistence::create()
    {
      return GetDefaultIntTxPersistencePtr(new GetDefaultIntTxPersistence());
    }

    GetDefaultIntTxPersistencePtr GetDefaultIntTxPersistence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDefaultIntTxPersistence>(ptr);
    }

    bool GetDefaultIntTxPersistence::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetDefaultIntTxPersistence::documentation() const { return Documentation; }


    int GetDefaultIntTxPersistence::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetDefaultIntTxPersistenceResult
///
#include "gen/GetDefaultIntTxPersistenceResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetDefaultIntTxPersistenceResult::CmdName = "GetDefaultIntTxPersistenceResult";
    const char* const GetDefaultIntTxPersistenceResult::Documentation = "Result of GetDefaultIntTxPersistence";

    REGISTER_COMMAND_RESULT_FACTORY(GetDefaultIntTxPersistenceResult);


    GetDefaultIntTxPersistenceResult::GetDefaultIntTxPersistenceResult()
      : CommandResult(CmdName)
    {}

    GetDefaultIntTxPersistenceResult::GetDefaultIntTxPersistenceResult(CommandBasePtr relatedCommand, bool defaultValue)
      : CommandResult(CmdName, relatedCommand)
    {

      setDefaultValue(defaultValue);
    }


    GetDefaultIntTxPersistenceResultPtr GetDefaultIntTxPersistenceResult::create(CommandBasePtr relatedCommand, bool defaultValue)
    {
      return GetDefaultIntTxPersistenceResultPtr(new GetDefaultIntTxPersistenceResult(relatedCommand, defaultValue));
    }

    GetDefaultIntTxPersistenceResultPtr GetDefaultIntTxPersistenceResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetDefaultIntTxPersistenceResult>(ptr);
    }

    bool GetDefaultIntTxPersistenceResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["DefaultValue"])
        ;

    }

    std::string GetDefaultIntTxPersistenceResult::documentation() const { return Documentation; }


    bool GetDefaultIntTxPersistenceResult::defaultValue() const
    {
      return parse_json<bool>::parse(m_values["DefaultValue"]);
    }

    void GetDefaultIntTxPersistenceResult::setDefaultValue(bool defaultValue)
    {
      m_values.AddMember("DefaultValue", parse_json<bool>::format(defaultValue, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllIntTxID
///
#include "gen/GetAllIntTxID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllIntTxID::CmdName = "GetAllIntTxID";
    const char* const GetAllIntTxID::Documentation = "get the ID of all interferences transmitters.";

    REGISTER_COMMAND_FACTORY(GetAllIntTxID);


    GetAllIntTxID::GetAllIntTxID()
      : CommandBase(CmdName)
    {

    }


    GetAllIntTxIDPtr GetAllIntTxID::create()
    {
      return GetAllIntTxIDPtr(new GetAllIntTxID());
    }

    GetAllIntTxIDPtr GetAllIntTxID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllIntTxID>(ptr);
    }

    bool GetAllIntTxID::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAllIntTxID::documentation() const { return Documentation; }


    int GetAllIntTxID::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAllIntTxIDResult
///
#include "gen/GetAllIntTxIDResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllIntTxIDResult::CmdName = "GetAllIntTxIDResult";
    const char* const GetAllIntTxIDResult::Documentation = "Result of GetAllIntTxID";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllIntTxIDResult);


    GetAllIntTxIDResult::GetAllIntTxIDResult()
      : CommandResult(CmdName)
    {}

    GetAllIntTxIDResult::GetAllIntTxIDResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllIntTxIDResultPtr GetAllIntTxIDResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetAllIntTxIDResultPtr(new GetAllIntTxIDResult(relatedCommand, ids));
    }

    GetAllIntTxIDResultPtr GetAllIntTxIDResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllIntTxIDResult>(ptr);
    }

    bool GetAllIntTxIDResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllIntTxIDResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllIntTxIDResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllIntTxIDResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddIntTx
///
#include "gen/AddIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddIntTx::CmdName = "AddIntTx";
    const char* const AddIntTx::Documentation = "Set an interference transmitter. For set : the transmitter Id parameter is not set (empty string),\nSkydel will assign a unique Id to the transmitter. If the Id is set and already used by Skydel, the\ncommand will fail.";

    REGISTER_COMMAND_FACTORY(AddIntTx);


    AddIntTx::AddIntTx()
      : CommandBase(CmdName)
    {}

    AddIntTx::AddIntTx(const std::string& usualName, bool enabled, int group, bool dynamic, double power, const std::string& id)
      : CommandBase(CmdName)
    {

      setUsualName(usualName);
      setEnabled(enabled);
      setGroup(group);
      setDynamic(dynamic);
      setPower(power);
      setId(id);
    }


    AddIntTxPtr AddIntTx::create(const std::string& usualName, bool enabled, int group, bool dynamic, double power, const std::string& id)
    {
      return AddIntTxPtr(new AddIntTx(usualName, enabled, group, dynamic, power, id));
    }

    AddIntTxPtr AddIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddIntTx>(ptr);
    }

    bool AddIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<bool>::is_valid(m_values["Dynamic"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string AddIntTx::documentation() const { return Documentation; }


    int AddIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string AddIntTx::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void AddIntTx::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool AddIntTx::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void AddIntTx::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int AddIntTx::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void AddIntTx::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool AddIntTx::dynamic() const
    {
      return parse_json<bool>::parse(m_values["Dynamic"]);
    }

    void AddIntTx::setDynamic(bool dynamic)
    {
      m_values.AddMember("Dynamic", parse_json<bool>::format(dynamic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double AddIntTx::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void AddIntTx::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void AddIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTx
///
#include "gen/GetIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTx::CmdName = "GetIntTx";
    const char* const GetIntTx::Documentation = "Get an interference transmitter. For set : the transmitter Id parameter is not set (empty string),\nSkydel will assign a unique Id to the transmitter. If the Id is set and already used by Skydel, the\ncommand will fail.";

    REGISTER_COMMAND_FACTORY(GetIntTx);


    GetIntTx::GetIntTx()
      : CommandBase(CmdName)
    {}

    GetIntTx::GetIntTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxPtr GetIntTx::create(const std::string& id)
    {
      return GetIntTxPtr(new GetIntTx(id));
    }

    GetIntTxPtr GetIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTx>(ptr);
    }

    bool GetIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTx::documentation() const { return Documentation; }


    int GetIntTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxResult
///
#include "gen/GetIntTxResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxResult::CmdName = "GetIntTxResult";
    const char* const GetIntTxResult::Documentation = "Result of GetIntTx";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxResult);


    GetIntTxResult::GetIntTxResult()
      : CommandResult(CmdName)
    {}

    GetIntTxResult::GetIntTxResult(CommandBasePtr relatedCommand, const std::string& usualName, bool enabled, int group, bool dynamic, double power, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setUsualName(usualName);
      setEnabled(enabled);
      setGroup(group);
      setDynamic(dynamic);
      setPower(power);
      setId(id);
    }


    GetIntTxResultPtr GetIntTxResult::create(CommandBasePtr relatedCommand, const std::string& usualName, bool enabled, int group, bool dynamic, double power, const std::string& id)
    {
      return GetIntTxResultPtr(new GetIntTxResult(relatedCommand, usualName, enabled, group, dynamic, power, id));
    }

    GetIntTxResultPtr GetIntTxResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxResult>(ptr);
    }

    bool GetIntTxResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<bool>::is_valid(m_values["Dynamic"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxResult::documentation() const { return Documentation; }


    std::string GetIntTxResult::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void GetIntTxResult::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIntTxResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxResult::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void GetIntTxResult::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIntTxResult::dynamic() const
    {
      return parse_json<bool>::parse(m_values["Dynamic"]);
    }

    void GetIntTxResult::setDynamic(bool dynamic)
    {
      m_values.AddMember("Dynamic", parse_json<bool>::format(dynamic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RenameIntTx
///
#include "gen/RenameIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RenameIntTx::CmdName = "RenameIntTx";
    const char* const RenameIntTx::Documentation = "Rename a transmitter.";

    REGISTER_COMMAND_FACTORY(RenameIntTx);


    RenameIntTx::RenameIntTx()
      : CommandBase(CmdName)
    {}

    RenameIntTx::RenameIntTx(const std::string& usualName, const std::string& id)
      : CommandBase(CmdName)
    {

      setUsualName(usualName);
      setId(id);
    }


    RenameIntTxPtr RenameIntTx::create(const std::string& usualName, const std::string& id)
    {
      return RenameIntTxPtr(new RenameIntTx(usualName, id));
    }

    RenameIntTxPtr RenameIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RenameIntTx>(ptr);
    }

    bool RenameIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RenameIntTx::documentation() const { return Documentation; }


    int RenameIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RenameIntTx::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void RenameIntTx::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RenameIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeIntTxColor
///
#include "gen/ChangeIntTxColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeIntTxColor::CmdName = "ChangeIntTxColor";
    const char* const ChangeIntTxColor::Documentation = "Set a transmitter color in spectrums";

    REGISTER_COMMAND_FACTORY(ChangeIntTxColor);


    ChangeIntTxColor::ChangeIntTxColor()
      : CommandBase(CmdName)
    {}

    ChangeIntTxColor::ChangeIntTxColor(const std::string& color, const std::string& id)
      : CommandBase(CmdName)
    {

      setColor(color);
      setId(id);
    }


    ChangeIntTxColorPtr ChangeIntTxColor::create(const std::string& color, const std::string& id)
    {
      return ChangeIntTxColorPtr(new ChangeIntTxColor(color, id));
    }

    ChangeIntTxColorPtr ChangeIntTxColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeIntTxColor>(ptr);
    }

    bool ChangeIntTxColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ChangeIntTxColor::documentation() const { return Documentation; }


    int ChangeIntTxColor::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string ChangeIntTxColor::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void ChangeIntTxColor::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeIntTxColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeIntTxColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxColor
///
#include "gen/GetIntTxColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxColor::CmdName = "GetIntTxColor";
    const char* const GetIntTxColor::Documentation = "Get a transmitter color in spectrums";

    REGISTER_COMMAND_FACTORY(GetIntTxColor);


    GetIntTxColor::GetIntTxColor()
      : CommandBase(CmdName)
    {}

    GetIntTxColor::GetIntTxColor(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxColorPtr GetIntTxColor::create(const std::string& id)
    {
      return GetIntTxColorPtr(new GetIntTxColor(id));
    }

    GetIntTxColorPtr GetIntTxColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxColor>(ptr);
    }

    bool GetIntTxColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxColor::documentation() const { return Documentation; }


    int GetIntTxColor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxColorResult
///
#include "gen/GetIntTxColorResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxColorResult::CmdName = "GetIntTxColorResult";
    const char* const GetIntTxColorResult::Documentation = "Result of GetIntTxColor";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxColorResult);


    GetIntTxColorResult::GetIntTxColorResult()
      : CommandResult(CmdName)
    {}

    GetIntTxColorResult::GetIntTxColorResult(CommandBasePtr relatedCommand, const std::string& color, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setColor(color);
      setId(id);
    }


    GetIntTxColorResultPtr GetIntTxColorResult::create(CommandBasePtr relatedCommand, const std::string& color, const std::string& id)
    {
      return GetIntTxColorResultPtr(new GetIntTxColorResult(relatedCommand, color, id));
    }

    GetIntTxColorResultPtr GetIntTxColorResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxColorResult>(ptr);
    }

    bool GetIntTxColorResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxColorResult::documentation() const { return Documentation; }


    std::string GetIntTxColorResult::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void GetIntTxColorResult::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxColorResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxColorResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableIntTx
///
#include "gen/EnableIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableIntTx::CmdName = "EnableIntTx";
    const char* const EnableIntTx::Documentation = "Enable/Disable the interference transmitter.";

    REGISTER_COMMAND_FACTORY(EnableIntTx);


    EnableIntTx::EnableIntTx()
      : CommandBase(CmdName)
    {}

    EnableIntTx::EnableIntTx(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    EnableIntTxPtr EnableIntTx::create(bool enabled, const std::string& id)
    {
      return EnableIntTxPtr(new EnableIntTx(enabled, id));
    }

    EnableIntTxPtr EnableIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableIntTx>(ptr);
    }

    bool EnableIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EnableIntTx::documentation() const { return Documentation; }


    int EnableIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool EnableIntTx::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableIntTx::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EnableIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxGroup
///
#include "gen/SetIntTxGroup.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxGroup::CmdName = "SetIntTxGroup";
    const char* const SetIntTxGroup::Documentation = "Set the interference transmitter group (which links to a specific RF output target).";

    REGISTER_COMMAND_FACTORY(SetIntTxGroup);


    SetIntTxGroup::SetIntTxGroup()
      : CommandBase(CmdName)
    {}

    SetIntTxGroup::SetIntTxGroup(int group, const std::string& id)
      : CommandBase(CmdName)
    {

      setGroup(group);
      setId(id);
    }


    SetIntTxGroupPtr SetIntTxGroup::create(int group, const std::string& id)
    {
      return SetIntTxGroupPtr(new SetIntTxGroup(group, id));
    }

    SetIntTxGroupPtr SetIntTxGroup::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxGroup>(ptr);
    }

    bool SetIntTxGroup::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Group"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxGroup::documentation() const { return Documentation; }


    int SetIntTxGroup::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetIntTxGroup::group() const
    {
      return parse_json<int>::parse(m_values["Group"]);
    }

    void SetIntTxGroup::setGroup(int group)
    {
      m_values.AddMember("Group", parse_json<int>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxGroup::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxGroup::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxRefPower
///
#include "gen/SetIntTxRefPower.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxRefPower::CmdName = "SetIntTxRefPower";
    const char* const SetIntTxRefPower::Documentation = "Set the interference transmitter reference power.";

    REGISTER_COMMAND_FACTORY(SetIntTxRefPower);


    SetIntTxRefPower::SetIntTxRefPower()
      : CommandBase(CmdName)
    {}

    SetIntTxRefPower::SetIntTxRefPower(double power, const std::string& id)
      : CommandBase(CmdName)
    {

      setPower(power);
      setId(id);
    }


    SetIntTxRefPowerPtr SetIntTxRefPower::create(double power, const std::string& id)
    {
      return SetIntTxRefPowerPtr(new SetIntTxRefPower(power, id));
    }

    SetIntTxRefPowerPtr SetIntTxRefPower::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxRefPower>(ptr);
    }

    bool SetIntTxRefPower::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxRefPower::documentation() const { return Documentation; }


    int SetIntTxRefPower::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxRefPower::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxRefPower::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxRefPower::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxRefPower::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxPersistence
///
#include "gen/SetIntTxPersistence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxPersistence::CmdName = "SetIntTxPersistence";
    const char* const SetIntTxPersistence::Documentation = "Set wether the transmitter should keep the modifications done during the simulation.";

    REGISTER_COMMAND_FACTORY(SetIntTxPersistence);


    SetIntTxPersistence::SetIntTxPersistence()
      : CommandBase(CmdName)
    {}

    SetIntTxPersistence::SetIntTxPersistence(bool persistence, const std::string& id)
      : CommandBase(CmdName)
    {

      setPersistence(persistence);
      setId(id);
    }


    SetIntTxPersistencePtr SetIntTxPersistence::create(bool persistence, const std::string& id)
    {
      return SetIntTxPersistencePtr(new SetIntTxPersistence(persistence, id));
    }

    SetIntTxPersistencePtr SetIntTxPersistence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxPersistence>(ptr);
    }

    bool SetIntTxPersistence::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Persistence"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxPersistence::documentation() const { return Documentation; }


    int SetIntTxPersistence::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxPersistence::persistence() const
    {
      return parse_json<bool>::parse(m_values["Persistence"]);
    }

    void SetIntTxPersistence::setPersistence(bool persistence)
    {
      m_values.AddMember("Persistence", parse_json<bool>::format(persistence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxPersistence::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxPersistence::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxPersistence
///
#include "gen/GetIntTxPersistence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxPersistence::CmdName = "GetIntTxPersistence";
    const char* const GetIntTxPersistence::Documentation = "Get wether the transmitter should keep the modifications done during the simulation.";

    REGISTER_COMMAND_FACTORY(GetIntTxPersistence);


    GetIntTxPersistence::GetIntTxPersistence()
      : CommandBase(CmdName)
    {}

    GetIntTxPersistence::GetIntTxPersistence(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxPersistencePtr GetIntTxPersistence::create(const std::string& id)
    {
      return GetIntTxPersistencePtr(new GetIntTxPersistence(id));
    }

    GetIntTxPersistencePtr GetIntTxPersistence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxPersistence>(ptr);
    }

    bool GetIntTxPersistence::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxPersistence::documentation() const { return Documentation; }


    int GetIntTxPersistence::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxPersistence::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxPersistence::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxPersistenceResult
///
#include "gen/GetIntTxPersistenceResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxPersistenceResult::CmdName = "GetIntTxPersistenceResult";
    const char* const GetIntTxPersistenceResult::Documentation = "Result of GetIntTxPersistence";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxPersistenceResult);


    GetIntTxPersistenceResult::GetIntTxPersistenceResult()
      : CommandResult(CmdName)
    {}

    GetIntTxPersistenceResult::GetIntTxPersistenceResult(CommandBasePtr relatedCommand, bool persistence, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPersistence(persistence);
      setId(id);
    }


    GetIntTxPersistenceResultPtr GetIntTxPersistenceResult::create(CommandBasePtr relatedCommand, bool persistence, const std::string& id)
    {
      return GetIntTxPersistenceResultPtr(new GetIntTxPersistenceResult(relatedCommand, persistence, id));
    }

    GetIntTxPersistenceResultPtr GetIntTxPersistenceResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxPersistenceResult>(ptr);
    }

    bool GetIntTxPersistenceResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Persistence"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxPersistenceResult::documentation() const { return Documentation; }


    bool GetIntTxPersistenceResult::persistence() const
    {
      return parse_json<bool>::parse(m_values["Persistence"]);
    }

    void GetIntTxPersistenceResult::setPersistence(bool persistence)
    {
      m_values.AddMember("Persistence", parse_json<bool>::format(persistence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxPersistenceResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxPersistenceResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnorePropagationLoss
///
#include "gen/SetIntTxIgnorePropagationLoss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnorePropagationLoss::CmdName = "SetIntTxIgnorePropagationLoss";
    const char* const SetIntTxIgnorePropagationLoss::Documentation = "Set whether a dynamic transmitter should ignore propagation loss or not.";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnorePropagationLoss);


    SetIntTxIgnorePropagationLoss::SetIntTxIgnorePropagationLoss()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnorePropagationLoss::SetIntTxIgnorePropagationLoss(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnorePropagationLossPtr SetIntTxIgnorePropagationLoss::create(bool ignore, const std::string& id)
    {
      return SetIntTxIgnorePropagationLossPtr(new SetIntTxIgnorePropagationLoss(ignore, id));
    }

    SetIntTxIgnorePropagationLossPtr SetIntTxIgnorePropagationLoss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnorePropagationLoss>(ptr);
    }

    bool SetIntTxIgnorePropagationLoss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnorePropagationLoss::documentation() const { return Documentation; }


    int SetIntTxIgnorePropagationLoss::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnorePropagationLoss::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnorePropagationLoss::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnorePropagationLoss::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnorePropagationLoss::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnoreRxAntennaPatterns
///
#include "gen/SetIntTxIgnoreRxAntennaPatterns.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnoreRxAntennaPatterns::CmdName = "SetIntTxIgnoreRxAntennaPatterns";
    const char* const SetIntTxIgnoreRxAntennaPatterns::Documentation = "Set whether a dynamic transmitter should ignore the vehicle's antenna patterns (gain and phase).";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnoreRxAntennaPatterns);


    SetIntTxIgnoreRxAntennaPatterns::SetIntTxIgnoreRxAntennaPatterns()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnoreRxAntennaPatterns::SetIntTxIgnoreRxAntennaPatterns(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnoreRxAntennaPatternsPtr SetIntTxIgnoreRxAntennaPatterns::create(bool ignore, const std::string& id)
    {
      return SetIntTxIgnoreRxAntennaPatternsPtr(new SetIntTxIgnoreRxAntennaPatterns(ignore, id));
    }

    SetIntTxIgnoreRxAntennaPatternsPtr SetIntTxIgnoreRxAntennaPatterns::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnoreRxAntennaPatterns>(ptr);
    }

    bool SetIntTxIgnoreRxAntennaPatterns::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnoreRxAntennaPatterns::documentation() const { return Documentation; }


    int SetIntTxIgnoreRxAntennaPatterns::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnoreRxAntennaPatterns::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnoreRxAntennaPatterns::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnoreRxAntennaPatterns::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnoreRxAntennaPatterns::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnoreVehicleAntennaPattern
///
#include "gen/SetIntTxIgnoreVehicleAntennaPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnoreVehicleAntennaPattern::CmdName = "SetIntTxIgnoreVehicleAntennaPattern";
    const char* const SetIntTxIgnoreVehicleAntennaPattern::Documentation = "Please note the command SetIntTxIgnoreVehicleAntennaPattern is deprecated since 20.2. You may use SetIntTxIgnoreRxAntennaPatterns.\n\nSet whether a dynamic transmitter should ignore the vehicle's antenna patterns (gain and phase).";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnoreVehicleAntennaPattern);


    SetIntTxIgnoreVehicleAntennaPattern::SetIntTxIgnoreVehicleAntennaPattern()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnoreVehicleAntennaPattern::SetIntTxIgnoreVehicleAntennaPattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnoreVehicleAntennaPatternPtr SetIntTxIgnoreVehicleAntennaPattern::create(bool ignore, const std::string& id)
    {
      return SetIntTxIgnoreVehicleAntennaPatternPtr(new SetIntTxIgnoreVehicleAntennaPattern(ignore, id));
    }

    SetIntTxIgnoreVehicleAntennaPatternPtr SetIntTxIgnoreVehicleAntennaPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnoreVehicleAntennaPattern>(ptr);
    }

    bool SetIntTxIgnoreVehicleAntennaPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnoreVehicleAntennaPattern::documentation() const { return Documentation; }


    int SetIntTxIgnoreVehicleAntennaPattern::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnoreVehicleAntennaPattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnoreVehicleAntennaPattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnoreVehicleAntennaPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnoreVehicleAntennaPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnoreRxAntennaGainPattern
///
#include "gen/SetIntTxIgnoreRxAntennaGainPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnoreRxAntennaGainPattern::CmdName = "SetIntTxIgnoreRxAntennaGainPattern";
    const char* const SetIntTxIgnoreRxAntennaGainPattern::Documentation = "Set whether a dynamic transmitter should ignore the receiver's antenna gain pattern.";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnoreRxAntennaGainPattern);


    SetIntTxIgnoreRxAntennaGainPattern::SetIntTxIgnoreRxAntennaGainPattern()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnoreRxAntennaGainPattern::SetIntTxIgnoreRxAntennaGainPattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnoreRxAntennaGainPatternPtr SetIntTxIgnoreRxAntennaGainPattern::create(bool ignore, const std::string& id)
    {
      return SetIntTxIgnoreRxAntennaGainPatternPtr(new SetIntTxIgnoreRxAntennaGainPattern(ignore, id));
    }

    SetIntTxIgnoreRxAntennaGainPatternPtr SetIntTxIgnoreRxAntennaGainPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnoreRxAntennaGainPattern>(ptr);
    }

    bool SetIntTxIgnoreRxAntennaGainPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnoreRxAntennaGainPattern::documentation() const { return Documentation; }


    int SetIntTxIgnoreRxAntennaGainPattern::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnoreRxAntennaGainPattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnoreRxAntennaGainPattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnoreRxAntennaGainPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnoreRxAntennaGainPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxIgnoreRxAntennaGainPattern
///
#include "gen/IsIntTxIgnoreRxAntennaGainPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxIgnoreRxAntennaGainPattern::CmdName = "IsIntTxIgnoreRxAntennaGainPattern";
    const char* const IsIntTxIgnoreRxAntennaGainPattern::Documentation = "Get whether a dynamic transmitter ignore the receiver's antenna gain pattern.";

    REGISTER_COMMAND_FACTORY(IsIntTxIgnoreRxAntennaGainPattern);


    IsIntTxIgnoreRxAntennaGainPattern::IsIntTxIgnoreRxAntennaGainPattern()
      : CommandBase(CmdName)
    {}

    IsIntTxIgnoreRxAntennaGainPattern::IsIntTxIgnoreRxAntennaGainPattern(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsIntTxIgnoreRxAntennaGainPatternPtr IsIntTxIgnoreRxAntennaGainPattern::create(const std::string& id)
    {
      return IsIntTxIgnoreRxAntennaGainPatternPtr(new IsIntTxIgnoreRxAntennaGainPattern(id));
    }

    IsIntTxIgnoreRxAntennaGainPatternPtr IsIntTxIgnoreRxAntennaGainPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxIgnoreRxAntennaGainPattern>(ptr);
    }

    bool IsIntTxIgnoreRxAntennaGainPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxIgnoreRxAntennaGainPattern::documentation() const { return Documentation; }


    int IsIntTxIgnoreRxAntennaGainPattern::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsIntTxIgnoreRxAntennaGainPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxIgnoreRxAntennaGainPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxIgnoreRxAntennaGainPatternResult
///
#include "gen/IsIntTxIgnoreRxAntennaGainPatternResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxIgnoreRxAntennaGainPatternResult::CmdName = "IsIntTxIgnoreRxAntennaGainPatternResult";
    const char* const IsIntTxIgnoreRxAntennaGainPatternResult::Documentation = "Result of IsIntTxIgnoreRxAntennaGainPattern";

    REGISTER_COMMAND_RESULT_FACTORY(IsIntTxIgnoreRxAntennaGainPatternResult);


    IsIntTxIgnoreRxAntennaGainPatternResult::IsIntTxIgnoreRxAntennaGainPatternResult()
      : CommandResult(CmdName)
    {}

    IsIntTxIgnoreRxAntennaGainPatternResult::IsIntTxIgnoreRxAntennaGainPatternResult(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setIgnore(ignore);
      setId(id);
    }


    IsIntTxIgnoreRxAntennaGainPatternResultPtr IsIntTxIgnoreRxAntennaGainPatternResult::create(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
    {
      return IsIntTxIgnoreRxAntennaGainPatternResultPtr(new IsIntTxIgnoreRxAntennaGainPatternResult(relatedCommand, ignore, id));
    }

    IsIntTxIgnoreRxAntennaGainPatternResultPtr IsIntTxIgnoreRxAntennaGainPatternResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxIgnoreRxAntennaGainPatternResult>(ptr);
    }

    bool IsIntTxIgnoreRxAntennaGainPatternResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxIgnoreRxAntennaGainPatternResult::documentation() const { return Documentation; }


    bool IsIntTxIgnoreRxAntennaGainPatternResult::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void IsIntTxIgnoreRxAntennaGainPatternResult::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsIntTxIgnoreRxAntennaGainPatternResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxIgnoreRxAntennaGainPatternResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIgnoreRxAntennaPhasePattern
///
#include "gen/SetIntTxIgnoreRxAntennaPhasePattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIgnoreRxAntennaPhasePattern::CmdName = "SetIntTxIgnoreRxAntennaPhasePattern";
    const char* const SetIntTxIgnoreRxAntennaPhasePattern::Documentation = "Set whether a dynamic transmitter should ignore the receiver's antenna phase pattern.";

    REGISTER_COMMAND_FACTORY(SetIntTxIgnoreRxAntennaPhasePattern);


    SetIntTxIgnoreRxAntennaPhasePattern::SetIntTxIgnoreRxAntennaPhasePattern()
      : CommandBase(CmdName)
    {}

    SetIntTxIgnoreRxAntennaPhasePattern::SetIntTxIgnoreRxAntennaPhasePattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetIntTxIgnoreRxAntennaPhasePatternPtr SetIntTxIgnoreRxAntennaPhasePattern::create(bool ignore, const std::string& id)
    {
      return SetIntTxIgnoreRxAntennaPhasePatternPtr(new SetIntTxIgnoreRxAntennaPhasePattern(ignore, id));
    }

    SetIntTxIgnoreRxAntennaPhasePatternPtr SetIntTxIgnoreRxAntennaPhasePattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIgnoreRxAntennaPhasePattern>(ptr);
    }

    bool SetIntTxIgnoreRxAntennaPhasePattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxIgnoreRxAntennaPhasePattern::documentation() const { return Documentation; }


    int SetIntTxIgnoreRxAntennaPhasePattern::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIgnoreRxAntennaPhasePattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetIntTxIgnoreRxAntennaPhasePattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIgnoreRxAntennaPhasePattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxIgnoreRxAntennaPhasePattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxIgnoreRxAntennaPhasePattern
///
#include "gen/IsIntTxIgnoreRxAntennaPhasePattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxIgnoreRxAntennaPhasePattern::CmdName = "IsIntTxIgnoreRxAntennaPhasePattern";
    const char* const IsIntTxIgnoreRxAntennaPhasePattern::Documentation = "Get whether a dynamic transmitter ignore the receiver's antenna phase pattern.";

    REGISTER_COMMAND_FACTORY(IsIntTxIgnoreRxAntennaPhasePattern);


    IsIntTxIgnoreRxAntennaPhasePattern::IsIntTxIgnoreRxAntennaPhasePattern()
      : CommandBase(CmdName)
    {}

    IsIntTxIgnoreRxAntennaPhasePattern::IsIntTxIgnoreRxAntennaPhasePattern(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsIntTxIgnoreRxAntennaPhasePatternPtr IsIntTxIgnoreRxAntennaPhasePattern::create(const std::string& id)
    {
      return IsIntTxIgnoreRxAntennaPhasePatternPtr(new IsIntTxIgnoreRxAntennaPhasePattern(id));
    }

    IsIntTxIgnoreRxAntennaPhasePatternPtr IsIntTxIgnoreRxAntennaPhasePattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxIgnoreRxAntennaPhasePattern>(ptr);
    }

    bool IsIntTxIgnoreRxAntennaPhasePattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxIgnoreRxAntennaPhasePattern::documentation() const { return Documentation; }


    int IsIntTxIgnoreRxAntennaPhasePattern::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsIntTxIgnoreRxAntennaPhasePattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxIgnoreRxAntennaPhasePattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxIgnoreRxAntennaPhasePatternResult
///
#include "gen/IsIntTxIgnoreRxAntennaPhasePatternResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxIgnoreRxAntennaPhasePatternResult::CmdName = "IsIntTxIgnoreRxAntennaPhasePatternResult";
    const char* const IsIntTxIgnoreRxAntennaPhasePatternResult::Documentation = "Result of IsIntTxIgnoreRxAntennaPhasePattern";

    REGISTER_COMMAND_RESULT_FACTORY(IsIntTxIgnoreRxAntennaPhasePatternResult);


    IsIntTxIgnoreRxAntennaPhasePatternResult::IsIntTxIgnoreRxAntennaPhasePatternResult()
      : CommandResult(CmdName)
    {}

    IsIntTxIgnoreRxAntennaPhasePatternResult::IsIntTxIgnoreRxAntennaPhasePatternResult(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setIgnore(ignore);
      setId(id);
    }


    IsIntTxIgnoreRxAntennaPhasePatternResultPtr IsIntTxIgnoreRxAntennaPhasePatternResult::create(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
    {
      return IsIntTxIgnoreRxAntennaPhasePatternResultPtr(new IsIntTxIgnoreRxAntennaPhasePatternResult(relatedCommand, ignore, id));
    }

    IsIntTxIgnoreRxAntennaPhasePatternResultPtr IsIntTxIgnoreRxAntennaPhasePatternResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxIgnoreRxAntennaPhasePatternResult>(ptr);
    }

    bool IsIntTxIgnoreRxAntennaPhasePatternResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxIgnoreRxAntennaPhasePatternResult::documentation() const { return Documentation; }


    bool IsIntTxIgnoreRxAntennaPhasePatternResult::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void IsIntTxIgnoreRxAntennaPhasePatternResult::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsIntTxIgnoreRxAntennaPhasePatternResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxIgnoreRxAntennaPhasePatternResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxNone
///
#include "gen/SetIntTxNone.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxNone::CmdName = "SetIntTxNone";
    const char* const SetIntTxNone::Documentation = "Set an undefined trajectory to a transmitter, thus preventing it to be modulated (default value).";

    REGISTER_COMMAND_FACTORY(SetIntTxNone);


    SetIntTxNone::SetIntTxNone()
      : CommandBase(CmdName)
    {}

    SetIntTxNone::SetIntTxNone(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    SetIntTxNonePtr SetIntTxNone::create(const std::string& id)
    {
      return SetIntTxNonePtr(new SetIntTxNone(id));
    }

    SetIntTxNonePtr SetIntTxNone::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxNone>(ptr);
    }

    bool SetIntTxNone::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxNone::documentation() const { return Documentation; }


    int SetIntTxNone::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetIntTxNone::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxNone::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxFix
///
#include "gen/SetIntTxFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxFix::CmdName = "SetIntTxFix";
    const char* const SetIntTxFix::Documentation = "Set interference transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(SetIntTxFix);


    SetIntTxFix::SetIntTxFix()
      : CommandBase(CmdName)
    {}

    SetIntTxFix::SetIntTxFix(double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetIntTxFixPtr SetIntTxFix::create(double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
    {
      return SetIntTxFixPtr(new SetIntTxFix(lat, lon, alt, yaw, pitch, roll, id));
    }

    SetIntTxFixPtr SetIntTxFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxFix>(ptr);
    }

    bool SetIntTxFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxFix::documentation() const { return Documentation; }


    int SetIntTxFix::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxFix::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetIntTxFix::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetIntTxFix::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetIntTxFix::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetIntTxFix::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetIntTxFix::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFix::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetIntTxFix::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxFix::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxFix::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxFix
///
#include "gen/GetIntTxFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxFix::CmdName = "GetIntTxFix";
    const char* const GetIntTxFix::Documentation = "Get interference transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(GetIntTxFix);


    GetIntTxFix::GetIntTxFix()
      : CommandBase(CmdName)
    {}

    GetIntTxFix::GetIntTxFix(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxFixPtr GetIntTxFix::create(const std::string& id)
    {
      return GetIntTxFixPtr(new GetIntTxFix(id));
    }

    GetIntTxFixPtr GetIntTxFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxFix>(ptr);
    }

    bool GetIntTxFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxFix::documentation() const { return Documentation; }


    int GetIntTxFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxFix::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxFix::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxFixResult
///
#include "gen/GetIntTxFixResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxFixResult::CmdName = "GetIntTxFixResult";
    const char* const GetIntTxFixResult::Documentation = "Result of GetIntTxFix";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxFixResult);


    GetIntTxFixResult::GetIntTxFixResult()
      : CommandResult(CmdName)
    {}

    GetIntTxFixResult::GetIntTxFixResult(CommandBasePtr relatedCommand, double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetIntTxFixResultPtr GetIntTxFixResult::create(CommandBasePtr relatedCommand, double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
    {
      return GetIntTxFixResultPtr(new GetIntTxFixResult(relatedCommand, lat, lon, alt, yaw, pitch, roll, id));
    }

    GetIntTxFixResultPtr GetIntTxFixResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxFixResult>(ptr);
    }

    bool GetIntTxFixResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxFixResult::documentation() const { return Documentation; }


    double GetIntTxFixResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetIntTxFixResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetIntTxFixResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetIntTxFixResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetIntTxFixResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetIntTxFixResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetIntTxFixResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxFixResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxFixResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxFixEcef
///
#include "gen/SetIntTxFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxFixEcef::CmdName = "SetIntTxFixEcef";
    const char* const SetIntTxFixEcef::Documentation = "Set interference transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(SetIntTxFixEcef);


    SetIntTxFixEcef::SetIntTxFixEcef()
      : CommandBase(CmdName)
    {}

    SetIntTxFixEcef::SetIntTxFixEcef(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetIntTxFixEcefPtr SetIntTxFixEcef::create(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return SetIntTxFixEcefPtr(new SetIntTxFixEcef(x, y, z, yaw, pitch, roll, id));
    }

    SetIntTxFixEcefPtr SetIntTxFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxFixEcef>(ptr);
    }

    bool SetIntTxFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxFixEcef::documentation() const { return Documentation; }


    int SetIntTxFixEcef::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxFixEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetIntTxFixEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetIntTxFixEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetIntTxFixEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetIntTxFixEcef::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetIntTxFixEcef::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxFixEcef::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetIntTxFixEcef::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxFixEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxFixEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxFixEcef
///
#include "gen/GetIntTxFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxFixEcef::CmdName = "GetIntTxFixEcef";
    const char* const GetIntTxFixEcef::Documentation = "Get interference transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(GetIntTxFixEcef);


    GetIntTxFixEcef::GetIntTxFixEcef()
      : CommandBase(CmdName)
    {}

    GetIntTxFixEcef::GetIntTxFixEcef(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxFixEcefPtr GetIntTxFixEcef::create(const std::string& id)
    {
      return GetIntTxFixEcefPtr(new GetIntTxFixEcef(id));
    }

    GetIntTxFixEcefPtr GetIntTxFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxFixEcef>(ptr);
    }

    bool GetIntTxFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxFixEcef::documentation() const { return Documentation; }


    int GetIntTxFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxFixEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxFixEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxFixEcefResult
///
#include "gen/GetIntTxFixEcefResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxFixEcefResult::CmdName = "GetIntTxFixEcefResult";
    const char* const GetIntTxFixEcefResult::Documentation = "Result of GetIntTxFixEcef";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxFixEcefResult);


    GetIntTxFixEcefResult::GetIntTxFixEcefResult()
      : CommandResult(CmdName)
    {}

    GetIntTxFixEcefResult::GetIntTxFixEcefResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetIntTxFixEcefResultPtr GetIntTxFixEcefResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return GetIntTxFixEcefResultPtr(new GetIntTxFixEcefResult(relatedCommand, x, y, z, yaw, pitch, roll, id));
    }

    GetIntTxFixEcefResultPtr GetIntTxFixEcefResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxFixEcefResult>(ptr);
    }

    bool GetIntTxFixEcefResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxFixEcefResult::documentation() const { return Documentation; }


    double GetIntTxFixEcefResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetIntTxFixEcefResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetIntTxFixEcefResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetIntTxFixEcefResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetIntTxFixEcefResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetIntTxFixEcefResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxFixEcefResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetIntTxFixEcefResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxFixEcefResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxFixEcefResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxCircular
///
#include "gen/SetIntTxCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxCircular::CmdName = "SetIntTxCircular";
    const char* const SetIntTxCircular::Documentation = "Set interference transmitter circular trajectory";

    REGISTER_COMMAND_FACTORY(SetIntTxCircular);


    SetIntTxCircular::SetIntTxCircular()
      : CommandBase(CmdName)
    {}

    SetIntTxCircular::SetIntTxCircular(double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
      : CommandBase(CmdName)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setId(id);
      setOriginAngle(originAngle);
    }


    SetIntTxCircularPtr SetIntTxCircular::create(double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
    {
      return SetIntTxCircularPtr(new SetIntTxCircular(lat, lon, alt, radius, speed, clockwise, id, originAngle));
    }

    SetIntTxCircularPtr SetIntTxCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxCircular>(ptr);
    }

    bool SetIntTxCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string SetIntTxCircular::documentation() const { return Documentation; }


    int SetIntTxCircular::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxCircular::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetIntTxCircular::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCircular::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetIntTxCircular::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCircular::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetIntTxCircular::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCircular::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void SetIntTxCircular::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCircular::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void SetIntTxCircular::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetIntTxCircular::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void SetIntTxCircular::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxCircular::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxCircular::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> SetIntTxCircular::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void SetIntTxCircular::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxCircular
///
#include "gen/GetIntTxCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxCircular::CmdName = "GetIntTxCircular";
    const char* const GetIntTxCircular::Documentation = "Get interference transmitter circular trajectory";

    REGISTER_COMMAND_FACTORY(GetIntTxCircular);


    GetIntTxCircular::GetIntTxCircular()
      : CommandBase(CmdName)
    {}

    GetIntTxCircular::GetIntTxCircular(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxCircularPtr GetIntTxCircular::create(const std::string& id)
    {
      return GetIntTxCircularPtr(new GetIntTxCircular(id));
    }

    GetIntTxCircularPtr GetIntTxCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxCircular>(ptr);
    }

    bool GetIntTxCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxCircular::documentation() const { return Documentation; }


    int GetIntTxCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxCircular::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxCircular::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxCircularResult
///
#include "gen/GetIntTxCircularResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxCircularResult::CmdName = "GetIntTxCircularResult";
    const char* const GetIntTxCircularResult::Documentation = "Result of GetIntTxCircular";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxCircularResult);


    GetIntTxCircularResult::GetIntTxCircularResult()
      : CommandResult(CmdName)
    {}

    GetIntTxCircularResult::GetIntTxCircularResult(CommandBasePtr relatedCommand, double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
      : CommandResult(CmdName, relatedCommand)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setId(id);
      setOriginAngle(originAngle);
    }


    GetIntTxCircularResultPtr GetIntTxCircularResult::create(CommandBasePtr relatedCommand, double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
    {
      return GetIntTxCircularResultPtr(new GetIntTxCircularResult(relatedCommand, lat, lon, alt, radius, speed, clockwise, id, originAngle));
    }

    GetIntTxCircularResultPtr GetIntTxCircularResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxCircularResult>(ptr);
    }

    bool GetIntTxCircularResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string GetIntTxCircularResult::documentation() const { return Documentation; }


    double GetIntTxCircularResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetIntTxCircularResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCircularResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetIntTxCircularResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCircularResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetIntTxCircularResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCircularResult::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void GetIntTxCircularResult::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCircularResult::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void GetIntTxCircularResult::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIntTxCircularResult::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void GetIntTxCircularResult::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxCircularResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxCircularResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetIntTxCircularResult::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void GetIntTxCircularResult::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxHil
///
#include "gen/SetIntTxHil.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxHil::CmdName = "SetIntTxHil";
    const char* const SetIntTxHil::Documentation = "Set interference transmitter HIL trajectory";

    REGISTER_COMMAND_FACTORY(SetIntTxHil);


    SetIntTxHil::SetIntTxHil()
      : CommandBase(CmdName)
    {}

    SetIntTxHil::SetIntTxHil(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    SetIntTxHilPtr SetIntTxHil::create(const std::string& id)
    {
      return SetIntTxHilPtr(new SetIntTxHil(id));
    }

    SetIntTxHilPtr SetIntTxHil::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxHil>(ptr);
    }

    bool SetIntTxHil::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxHil::documentation() const { return Documentation; }


    int SetIntTxHil::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetIntTxHil::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxHil::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BeginIntTxTrackDefinition
///
#include "gen/BeginIntTxTrackDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BeginIntTxTrackDefinition::CmdName = "BeginIntTxTrackDefinition";
    const char* const BeginIntTxTrackDefinition::Documentation = "Begins a new interference track definition. Actual track remains unchanged until\nEndIntTxTrackDefinition command is sent and successful. After this command, the\nclient must push time and position pairs to form a complete track. Once all the\npositions are sent, the client must send the command EndIntTxTrackDefinition.";

    REGISTER_COMMAND_FACTORY(BeginIntTxTrackDefinition);


    BeginIntTxTrackDefinition::BeginIntTxTrackDefinition()
      : CommandBase(CmdName)
    {}

    BeginIntTxTrackDefinition::BeginIntTxTrackDefinition(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    BeginIntTxTrackDefinitionPtr BeginIntTxTrackDefinition::create(const std::string& id)
    {
      return BeginIntTxTrackDefinitionPtr(new BeginIntTxTrackDefinition(id));
    }

    BeginIntTxTrackDefinitionPtr BeginIntTxTrackDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BeginIntTxTrackDefinition>(ptr);
    }

    bool BeginIntTxTrackDefinition::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string BeginIntTxTrackDefinition::documentation() const { return Documentation; }


    int BeginIntTxTrackDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string BeginIntTxTrackDefinition::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void BeginIntTxTrackDefinition::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of PushIntTxTrackEcef
///
#include "gen/PushIntTxTrackEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushIntTxTrackEcef::CmdName = "PushIntTxTrackEcef";
    const char* const PushIntTxTrackEcef::Documentation = "Push an interference track ecef node. Must be called after BeginIntTxTrackDefinition and before EndIntTxTrackDefinition.";

    REGISTER_COMMAND_FACTORY(PushIntTxTrackEcef);


    PushIntTxTrackEcef::PushIntTxTrackEcef()
      : CommandBase(CmdName)
    {}

    PushIntTxTrackEcef::PushIntTxTrackEcef(int time, double x, double y, double z, const std::string& id)
      : CommandBase(CmdName)
    {

      setTime(time);
      setX(x);
      setY(y);
      setZ(z);
      setId(id);
    }


    PushIntTxTrackEcefPtr PushIntTxTrackEcef::create(int time, double x, double y, double z, const std::string& id)
    {
      return PushIntTxTrackEcefPtr(new PushIntTxTrackEcef(time, x, y, z, id));
    }

    PushIntTxTrackEcefPtr PushIntTxTrackEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushIntTxTrackEcef>(ptr);
    }

    bool PushIntTxTrackEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string PushIntTxTrackEcef::documentation() const { return Documentation; }


    int PushIntTxTrackEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int PushIntTxTrackEcef::time() const
    {
      return parse_json<int>::parse(m_values["Time"]);
    }

    void PushIntTxTrackEcef::setTime(int time)
    {
      m_values.AddMember("Time", parse_json<int>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushIntTxTrackEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushIntTxTrackEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushIntTxTrackEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string PushIntTxTrackEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void PushIntTxTrackEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of PushIntTxTrackEcefNed
///
#include "gen/PushIntTxTrackEcefNed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const PushIntTxTrackEcefNed::CmdName = "PushIntTxTrackEcefNed";
    const char* const PushIntTxTrackEcefNed::Documentation = "Push an interference track ecef and ned attitude node. Must be called after BeginIntTxTrackDefinition and before EndIntTxTrackDefinition.";

    REGISTER_COMMAND_FACTORY(PushIntTxTrackEcefNed);


    PushIntTxTrackEcefNed::PushIntTxTrackEcefNed()
      : CommandBase(CmdName)
    {}

    PushIntTxTrackEcefNed::PushIntTxTrackEcefNed(int time, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setTime(time);
      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    PushIntTxTrackEcefNedPtr PushIntTxTrackEcefNed::create(int time, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return PushIntTxTrackEcefNedPtr(new PushIntTxTrackEcefNed(time, x, y, z, yaw, pitch, roll, id));
    }

    PushIntTxTrackEcefNedPtr PushIntTxTrackEcefNed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<PushIntTxTrackEcefNed>(ptr);
    }

    bool PushIntTxTrackEcefNed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string PushIntTxTrackEcefNed::documentation() const { return Documentation; }


    int PushIntTxTrackEcefNed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int PushIntTxTrackEcefNed::time() const
    {
      return parse_json<int>::parse(m_values["Time"]);
    }

    void PushIntTxTrackEcefNed::setTime(int time)
    {
      m_values.AddMember("Time", parse_json<int>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void PushIntTxTrackEcefNed::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void PushIntTxTrackEcefNed::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void PushIntTxTrackEcefNed::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void PushIntTxTrackEcefNed::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void PushIntTxTrackEcefNed::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double PushIntTxTrackEcefNed::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void PushIntTxTrackEcefNed::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string PushIntTxTrackEcefNed::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void PushIntTxTrackEcefNed::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EndIntTxTrackDefinition
///
#include "gen/EndIntTxTrackDefinition.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndIntTxTrackDefinition::CmdName = "EndIntTxTrackDefinition";
    const char* const EndIntTxTrackDefinition::Documentation = "This command completes the track started with BeginIntTxTrackDefinition command. If\nthe track is accepted, the current track in the configuration is replaced with\nthis new track. If the track is not accepted, the current track in the config\nremains unchanged.";

    REGISTER_COMMAND_FACTORY(EndIntTxTrackDefinition);


    EndIntTxTrackDefinition::EndIntTxTrackDefinition()
      : CommandBase(CmdName)
    {}

    EndIntTxTrackDefinition::EndIntTxTrackDefinition(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    EndIntTxTrackDefinitionPtr EndIntTxTrackDefinition::create(const std::string& id)
    {
      return EndIntTxTrackDefinitionPtr(new EndIntTxTrackDefinition(id));
    }

    EndIntTxTrackDefinitionPtr EndIntTxTrackDefinition::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndIntTxTrackDefinition>(ptr);
    }

    bool EndIntTxTrackDefinition::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EndIntTxTrackDefinition::documentation() const { return Documentation; }


    int EndIntTxTrackDefinition::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EndIntTxTrackDefinition::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EndIntTxTrackDefinition::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EndIntTxTrackDefinitionResult
///
#include "gen/EndIntTxTrackDefinitionResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndIntTxTrackDefinitionResult::CmdName = "EndIntTxTrackDefinitionResult";
    const char* const EndIntTxTrackDefinitionResult::Documentation = "EndIntTxTrackDefinition Result with created track informations.";

    REGISTER_COMMAND_RESULT_FACTORY(EndIntTxTrackDefinitionResult);


    EndIntTxTrackDefinitionResult::EndIntTxTrackDefinitionResult()
      : CommandResult(CmdName)
    {}

    EndIntTxTrackDefinitionResult::EndIntTxTrackDefinitionResult(CommandBasePtr relatedCommand, int count, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setCount(count);
      setId(id);
    }


    EndIntTxTrackDefinitionResultPtr EndIntTxTrackDefinitionResult::create(CommandBasePtr relatedCommand, int count, const std::string& id)
    {
      return EndIntTxTrackDefinitionResultPtr(new EndIntTxTrackDefinitionResult(relatedCommand, count, id));
    }

    EndIntTxTrackDefinitionResultPtr EndIntTxTrackDefinitionResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndIntTxTrackDefinitionResult>(ptr);
    }

    bool EndIntTxTrackDefinitionResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Count"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EndIntTxTrackDefinitionResult::documentation() const { return Documentation; }


    int EndIntTxTrackDefinitionResult::count() const
    {
      return parse_json<int>::parse(m_values["Count"]);
    }

    void EndIntTxTrackDefinitionResult::setCount(int count)
    {
      m_values.AddMember("Count", parse_json<int>::format(count, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EndIntTxTrackDefinitionResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EndIntTxTrackDefinitionResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportNmeaIntTxTrack
///
#include "gen/ImportNmeaIntTxTrack.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportNmeaIntTxTrack::CmdName = "ImportNmeaIntTxTrack";
    const char* const ImportNmeaIntTxTrack::Documentation = "Import NMEA interference track file";

    REGISTER_COMMAND_FACTORY(ImportNmeaIntTxTrack);


    ImportNmeaIntTxTrack::ImportNmeaIntTxTrack()
      : CommandBase(CmdName)
    {}

    ImportNmeaIntTxTrack::ImportNmeaIntTxTrack(const std::string& path, const std::string& id)
      : CommandBase(CmdName)
    {

      setPath(path);
      setId(id);
    }


    ImportNmeaIntTxTrackPtr ImportNmeaIntTxTrack::create(const std::string& path, const std::string& id)
    {
      return ImportNmeaIntTxTrackPtr(new ImportNmeaIntTxTrack(path, id));
    }

    ImportNmeaIntTxTrackPtr ImportNmeaIntTxTrack::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportNmeaIntTxTrack>(ptr);
    }

    bool ImportNmeaIntTxTrack::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ImportNmeaIntTxTrack::documentation() const { return Documentation; }


    int ImportNmeaIntTxTrack::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportNmeaIntTxTrack::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportNmeaIntTxTrack::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportNmeaIntTxTrack::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ImportNmeaIntTxTrack::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableIntTxTrajectorySmoothing
///
#include "gen/EnableIntTxTrajectorySmoothing.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableIntTxTrajectorySmoothing::CmdName = "EnableIntTxTrajectorySmoothing";
    const char* const EnableIntTxTrajectorySmoothing::Documentation = "Set trajectory smoothing for interference Track enabled or disabled";

    REGISTER_COMMAND_FACTORY(EnableIntTxTrajectorySmoothing);


    EnableIntTxTrajectorySmoothing::EnableIntTxTrajectorySmoothing()
      : CommandBase(CmdName)
    {}

    EnableIntTxTrajectorySmoothing::EnableIntTxTrajectorySmoothing(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    EnableIntTxTrajectorySmoothingPtr EnableIntTxTrajectorySmoothing::create(bool enabled, const std::string& id)
    {
      return EnableIntTxTrajectorySmoothingPtr(new EnableIntTxTrajectorySmoothing(enabled, id));
    }

    EnableIntTxTrajectorySmoothingPtr EnableIntTxTrajectorySmoothing::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableIntTxTrajectorySmoothing>(ptr);
    }

    bool EnableIntTxTrajectorySmoothing::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EnableIntTxTrajectorySmoothing::documentation() const { return Documentation; }


    int EnableIntTxTrajectorySmoothing::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableIntTxTrajectorySmoothing::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableIntTxTrajectorySmoothing::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableIntTxTrajectorySmoothing::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EnableIntTxTrajectorySmoothing::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxTrajectorySmoothingEnabled
///
#include "gen/IsIntTxTrajectorySmoothingEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxTrajectorySmoothingEnabled::CmdName = "IsIntTxTrajectorySmoothingEnabled";
    const char* const IsIntTxTrajectorySmoothingEnabled::Documentation = "Get trajectory smoothing for interference Track enabled or disabled";

    REGISTER_COMMAND_FACTORY(IsIntTxTrajectorySmoothingEnabled);


    IsIntTxTrajectorySmoothingEnabled::IsIntTxTrajectorySmoothingEnabled()
      : CommandBase(CmdName)
    {}

    IsIntTxTrajectorySmoothingEnabled::IsIntTxTrajectorySmoothingEnabled(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsIntTxTrajectorySmoothingEnabledPtr IsIntTxTrajectorySmoothingEnabled::create(const std::string& id)
    {
      return IsIntTxTrajectorySmoothingEnabledPtr(new IsIntTxTrajectorySmoothingEnabled(id));
    }

    IsIntTxTrajectorySmoothingEnabledPtr IsIntTxTrajectorySmoothingEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxTrajectorySmoothingEnabled>(ptr);
    }

    bool IsIntTxTrajectorySmoothingEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxTrajectorySmoothingEnabled::documentation() const { return Documentation; }


    int IsIntTxTrajectorySmoothingEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsIntTxTrajectorySmoothingEnabled::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxTrajectorySmoothingEnabled::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxTrajectorySmoothingEnabledResult
///
#include "gen/IsIntTxTrajectorySmoothingEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxTrajectorySmoothingEnabledResult::CmdName = "IsIntTxTrajectorySmoothingEnabledResult";
    const char* const IsIntTxTrajectorySmoothingEnabledResult::Documentation = "Result of IsIntTxTrajectorySmoothingEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsIntTxTrajectorySmoothingEnabledResult);


    IsIntTxTrajectorySmoothingEnabledResult::IsIntTxTrajectorySmoothingEnabledResult()
      : CommandResult(CmdName)
    {}

    IsIntTxTrajectorySmoothingEnabledResult::IsIntTxTrajectorySmoothingEnabledResult(CommandBasePtr relatedCommand, bool enabled, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setId(id);
    }


    IsIntTxTrajectorySmoothingEnabledResultPtr IsIntTxTrajectorySmoothingEnabledResult::create(CommandBasePtr relatedCommand, bool enabled, const std::string& id)
    {
      return IsIntTxTrajectorySmoothingEnabledResultPtr(new IsIntTxTrajectorySmoothingEnabledResult(relatedCommand, enabled, id));
    }

    IsIntTxTrajectorySmoothingEnabledResultPtr IsIntTxTrajectorySmoothingEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxTrajectorySmoothingEnabledResult>(ptr);
    }

    bool IsIntTxTrajectorySmoothingEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxTrajectorySmoothingEnabledResult::documentation() const { return Documentation; }


    bool IsIntTxTrajectorySmoothingEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsIntTxTrajectorySmoothingEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsIntTxTrajectorySmoothingEnabledResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxTrajectorySmoothingEnabledResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ForceIntTxAttitudeToZero
///
#include "gen/ForceIntTxAttitudeToZero.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ForceIntTxAttitudeToZero::CmdName = "ForceIntTxAttitudeToZero";
    const char* const ForceIntTxAttitudeToZero::Documentation = "Set force interference vehicle yaw, pitch and roll to zero enabled or disabled";

    REGISTER_COMMAND_FACTORY(ForceIntTxAttitudeToZero);


    ForceIntTxAttitudeToZero::ForceIntTxAttitudeToZero()
      : CommandBase(CmdName)
    {}

    ForceIntTxAttitudeToZero::ForceIntTxAttitudeToZero(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    ForceIntTxAttitudeToZeroPtr ForceIntTxAttitudeToZero::create(bool enabled, const std::string& id)
    {
      return ForceIntTxAttitudeToZeroPtr(new ForceIntTxAttitudeToZero(enabled, id));
    }

    ForceIntTxAttitudeToZeroPtr ForceIntTxAttitudeToZero::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ForceIntTxAttitudeToZero>(ptr);
    }

    bool ForceIntTxAttitudeToZero::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ForceIntTxAttitudeToZero::documentation() const { return Documentation; }


    int ForceIntTxAttitudeToZero::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ForceIntTxAttitudeToZero::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void ForceIntTxAttitudeToZero::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ForceIntTxAttitudeToZero::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ForceIntTxAttitudeToZero::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxAttitudeToZeroForced
///
#include "gen/IsIntTxAttitudeToZeroForced.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxAttitudeToZeroForced::CmdName = "IsIntTxAttitudeToZeroForced";
    const char* const IsIntTxAttitudeToZeroForced::Documentation = "Get force interference vehicle yaw, pitch and roll to zero enabled or disabled";

    REGISTER_COMMAND_FACTORY(IsIntTxAttitudeToZeroForced);


    IsIntTxAttitudeToZeroForced::IsIntTxAttitudeToZeroForced()
      : CommandBase(CmdName)
    {}

    IsIntTxAttitudeToZeroForced::IsIntTxAttitudeToZeroForced(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsIntTxAttitudeToZeroForcedPtr IsIntTxAttitudeToZeroForced::create(const std::string& id)
    {
      return IsIntTxAttitudeToZeroForcedPtr(new IsIntTxAttitudeToZeroForced(id));
    }

    IsIntTxAttitudeToZeroForcedPtr IsIntTxAttitudeToZeroForced::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxAttitudeToZeroForced>(ptr);
    }

    bool IsIntTxAttitudeToZeroForced::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxAttitudeToZeroForced::documentation() const { return Documentation; }


    int IsIntTxAttitudeToZeroForced::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsIntTxAttitudeToZeroForced::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxAttitudeToZeroForced::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIntTxAttitudeToZeroForcedResult
///
#include "gen/IsIntTxAttitudeToZeroForcedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIntTxAttitudeToZeroForcedResult::CmdName = "IsIntTxAttitudeToZeroForcedResult";
    const char* const IsIntTxAttitudeToZeroForcedResult::Documentation = "Result of IsIntTxAttitudeToZeroForced";

    REGISTER_COMMAND_RESULT_FACTORY(IsIntTxAttitudeToZeroForcedResult);


    IsIntTxAttitudeToZeroForcedResult::IsIntTxAttitudeToZeroForcedResult()
      : CommandResult(CmdName)
    {}

    IsIntTxAttitudeToZeroForcedResult::IsIntTxAttitudeToZeroForcedResult(CommandBasePtr relatedCommand, bool enabled, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setId(id);
    }


    IsIntTxAttitudeToZeroForcedResultPtr IsIntTxAttitudeToZeroForcedResult::create(CommandBasePtr relatedCommand, bool enabled, const std::string& id)
    {
      return IsIntTxAttitudeToZeroForcedResultPtr(new IsIntTxAttitudeToZeroForcedResult(relatedCommand, enabled, id));
    }

    IsIntTxAttitudeToZeroForcedResultPtr IsIntTxAttitudeToZeroForcedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIntTxAttitudeToZeroForcedResult>(ptr);
    }

    bool IsIntTxAttitudeToZeroForcedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsIntTxAttitudeToZeroForcedResult::documentation() const { return Documentation; }


    bool IsIntTxAttitudeToZeroForcedResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsIntTxAttitudeToZeroForcedResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsIntTxAttitudeToZeroForcedResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsIntTxAttitudeToZeroForcedResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxVehicleType
///
#include "gen/SetIntTxVehicleType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxVehicleType::CmdName = "SetIntTxVehicleType";
    const char* const SetIntTxVehicleType::Documentation = "Set Set interference vehicle type for Track Trajectory";

    REGISTER_COMMAND_FACTORY(SetIntTxVehicleType);


    SetIntTxVehicleType::SetIntTxVehicleType()
      : CommandBase(CmdName)
    {}

    SetIntTxVehicleType::SetIntTxVehicleType(const std::string& type, const std::string& id)
      : CommandBase(CmdName)
    {

      setType(type);
      setId(id);
    }


    SetIntTxVehicleTypePtr SetIntTxVehicleType::create(const std::string& type, const std::string& id)
    {
      return SetIntTxVehicleTypePtr(new SetIntTxVehicleType(type, id));
    }

    SetIntTxVehicleTypePtr SetIntTxVehicleType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxVehicleType>(ptr);
    }

    bool SetIntTxVehicleType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxVehicleType::documentation() const { return Documentation; }


    int SetIntTxVehicleType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetIntTxVehicleType::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetIntTxVehicleType::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxVehicleType::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxVehicleType::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxVehicleType
///
#include "gen/GetIntTxVehicleType.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxVehicleType::CmdName = "GetIntTxVehicleType";
    const char* const GetIntTxVehicleType::Documentation = "Get Set interference vehicle type for Track Trajectory";

    REGISTER_COMMAND_FACTORY(GetIntTxVehicleType);


    GetIntTxVehicleType::GetIntTxVehicleType()
      : CommandBase(CmdName)
    {}

    GetIntTxVehicleType::GetIntTxVehicleType(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxVehicleTypePtr GetIntTxVehicleType::create(const std::string& id)
    {
      return GetIntTxVehicleTypePtr(new GetIntTxVehicleType(id));
    }

    GetIntTxVehicleTypePtr GetIntTxVehicleType::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxVehicleType>(ptr);
    }

    bool GetIntTxVehicleType::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxVehicleType::documentation() const { return Documentation; }


    int GetIntTxVehicleType::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxVehicleType::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxVehicleType::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxVehicleTypeResult
///
#include "gen/GetIntTxVehicleTypeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxVehicleTypeResult::CmdName = "GetIntTxVehicleTypeResult";
    const char* const GetIntTxVehicleTypeResult::Documentation = "Result of GetIntTxVehicleType";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxVehicleTypeResult);


    GetIntTxVehicleTypeResult::GetIntTxVehicleTypeResult()
      : CommandResult(CmdName)
    {}

    GetIntTxVehicleTypeResult::GetIntTxVehicleTypeResult(CommandBasePtr relatedCommand, const std::string& type, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setType(type);
      setId(id);
    }


    GetIntTxVehicleTypeResultPtr GetIntTxVehicleTypeResult::create(CommandBasePtr relatedCommand, const std::string& type, const std::string& id)
    {
      return GetIntTxVehicleTypeResultPtr(new GetIntTxVehicleTypeResult(relatedCommand, type, id));
    }

    GetIntTxVehicleTypeResultPtr GetIntTxVehicleTypeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxVehicleTypeResult>(ptr);
    }

    bool GetIntTxVehicleTypeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxVehicleTypeResult::documentation() const { return Documentation; }


    std::string GetIntTxVehicleTypeResult::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void GetIntTxVehicleTypeResult::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxVehicleTypeResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxVehicleTypeResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxTrajectory
///
#include "gen/GetIntTxTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxTrajectory::CmdName = "GetIntTxTrajectory";
    const char* const GetIntTxTrajectory::Documentation = "Get interference transmitter trajectory";

    REGISTER_COMMAND_FACTORY(GetIntTxTrajectory);


    GetIntTxTrajectory::GetIntTxTrajectory()
      : CommandBase(CmdName)
    {}

    GetIntTxTrajectory::GetIntTxTrajectory(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxTrajectoryPtr GetIntTxTrajectory::create(const std::string& id)
    {
      return GetIntTxTrajectoryPtr(new GetIntTxTrajectory(id));
    }

    GetIntTxTrajectoryPtr GetIntTxTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxTrajectory>(ptr);
    }

    bool GetIntTxTrajectory::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxTrajectory::documentation() const { return Documentation; }


    int GetIntTxTrajectory::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxTrajectory::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxTrajectory::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxTrajectoryResult
///
#include "gen/GetIntTxTrajectoryResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxTrajectoryResult::CmdName = "GetIntTxTrajectoryResult";
    const char* const GetIntTxTrajectoryResult::Documentation = "Result of GetIntTxTrajectory";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxTrajectoryResult);


    GetIntTxTrajectoryResult::GetIntTxTrajectoryResult()
      : CommandResult(CmdName)
    {}

    GetIntTxTrajectoryResult::GetIntTxTrajectoryResult(CommandBasePtr relatedCommand, const std::string& trajectoryType, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setTrajectoryType(trajectoryType);
      setId(id);
    }


    GetIntTxTrajectoryResultPtr GetIntTxTrajectoryResult::create(CommandBasePtr relatedCommand, const std::string& trajectoryType, const std::string& id)
    {
      return GetIntTxTrajectoryResultPtr(new GetIntTxTrajectoryResult(relatedCommand, trajectoryType, id));
    }

    GetIntTxTrajectoryResultPtr GetIntTxTrajectoryResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxTrajectoryResult>(ptr);
    }

    bool GetIntTxTrajectoryResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TrajectoryType"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxTrajectoryResult::documentation() const { return Documentation; }


    std::string GetIntTxTrajectoryResult::trajectoryType() const
    {
      return parse_json<std::string>::parse(m_values["TrajectoryType"]);
    }

    void GetIntTxTrajectoryResult::setTrajectoryType(const std::string& trajectoryType)
    {
      m_values.AddMember("TrajectoryType", parse_json<std::string>::format(trajectoryType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxTrajectoryResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxTrajectoryResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxAntenna
///
#include "gen/SetIntTxAntenna.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxAntenna::CmdName = "SetIntTxAntenna";
    const char* const SetIntTxAntenna::Documentation = "Set transmitter antenna pattern.";

    REGISTER_COMMAND_FACTORY(SetIntTxAntenna);


    SetIntTxAntenna::SetIntTxAntenna()
      : CommandBase(CmdName)
    {}

    SetIntTxAntenna::SetIntTxAntenna(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
      : CommandBase(CmdName)
    {

      setGain(gain);
      setType(type);
      setId(id);
    }


    SetIntTxAntennaPtr SetIntTxAntenna::create(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
    {
      return SetIntTxAntennaPtr(new SetIntTxAntenna(gain, type, id));
    }

    SetIntTxAntennaPtr SetIntTxAntenna::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxAntenna>(ptr);
    }

    bool SetIntTxAntenna::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxAntenna::documentation() const { return Documentation; }


    int SetIntTxAntenna::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetIntTxAntenna::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void SetIntTxAntenna::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetIntTxAntenna::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetIntTxAntenna::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxAntenna::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxAntenna::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAntenna
///
#include "gen/GetIntTxAntenna.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAntenna::CmdName = "GetIntTxAntenna";
    const char* const GetIntTxAntenna::Documentation = "Get transmitter antenna pattern.";

    REGISTER_COMMAND_FACTORY(GetIntTxAntenna);


    GetIntTxAntenna::GetIntTxAntenna()
      : CommandBase(CmdName)
    {}

    GetIntTxAntenna::GetIntTxAntenna(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxAntennaPtr GetIntTxAntenna::create(const std::string& id)
    {
      return GetIntTxAntennaPtr(new GetIntTxAntenna(id));
    }

    GetIntTxAntennaPtr GetIntTxAntenna::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAntenna>(ptr);
    }

    bool GetIntTxAntenna::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxAntenna::documentation() const { return Documentation; }


    int GetIntTxAntenna::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxAntenna::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxAntenna::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAntennaResult
///
#include "gen/GetIntTxAntennaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAntennaResult::CmdName = "GetIntTxAntennaResult";
    const char* const GetIntTxAntennaResult::Documentation = "Result of GetIntTxAntenna";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxAntennaResult);


    GetIntTxAntennaResult::GetIntTxAntennaResult()
      : CommandResult(CmdName)
    {}

    GetIntTxAntennaResult::GetIntTxAntennaResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
      setType(type);
      setId(id);
    }


    GetIntTxAntennaResultPtr GetIntTxAntennaResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
    {
      return GetIntTxAntennaResultPtr(new GetIntTxAntennaResult(relatedCommand, gain, type, id));
    }

    GetIntTxAntennaResultPtr GetIntTxAntennaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAntennaResult>(ptr);
    }

    bool GetIntTxAntennaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxAntennaResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetIntTxAntennaResult::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void GetIntTxAntennaResult::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetIntTxAntennaResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetIntTxAntennaResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAntennaResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxAntennaResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxAntennaOffset
///
#include "gen/SetIntTxAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxAntennaOffset::CmdName = "SetIntTxAntennaOffset";
    const char* const SetIntTxAntennaOffset::Documentation = "Set antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the transmitter trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(SetIntTxAntennaOffset);


    SetIntTxAntennaOffset::SetIntTxAntennaOffset()
      : CommandBase(CmdName)
    {}

    SetIntTxAntennaOffset::SetIntTxAntennaOffset(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetIntTxAntennaOffsetPtr SetIntTxAntennaOffset::create(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return SetIntTxAntennaOffsetPtr(new SetIntTxAntennaOffset(x, y, z, yaw, pitch, roll, id));
    }

    SetIntTxAntennaOffsetPtr SetIntTxAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxAntennaOffset>(ptr);
    }

    bool SetIntTxAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetIntTxAntennaOffset::documentation() const { return Documentation; }


    int SetIntTxAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    double SetIntTxAntennaOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetIntTxAntennaOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetIntTxAntennaOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetIntTxAntennaOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetIntTxAntennaOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetIntTxAntennaOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAntennaOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetIntTxAntennaOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxAntennaOffset::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetIntTxAntennaOffset::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAntennaOffset
///
#include "gen/GetIntTxAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAntennaOffset::CmdName = "GetIntTxAntennaOffset";
    const char* const GetIntTxAntennaOffset::Documentation = "Get antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the transmitter trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(GetIntTxAntennaOffset);


    GetIntTxAntennaOffset::GetIntTxAntennaOffset()
      : CommandBase(CmdName)
    {}

    GetIntTxAntennaOffset::GetIntTxAntennaOffset(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetIntTxAntennaOffsetPtr GetIntTxAntennaOffset::create(const std::string& id)
    {
      return GetIntTxAntennaOffsetPtr(new GetIntTxAntennaOffset(id));
    }

    GetIntTxAntennaOffsetPtr GetIntTxAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAntennaOffset>(ptr);
    }

    bool GetIntTxAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxAntennaOffset::documentation() const { return Documentation; }


    int GetIntTxAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxAntennaOffset::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxAntennaOffset::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAntennaOffsetResult
///
#include "gen/GetIntTxAntennaOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAntennaOffsetResult::CmdName = "GetIntTxAntennaOffsetResult";
    const char* const GetIntTxAntennaOffsetResult::Documentation = "Result of GetIntTxAntennaOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxAntennaOffsetResult);


    GetIntTxAntennaOffsetResult::GetIntTxAntennaOffsetResult()
      : CommandResult(CmdName)
    {}

    GetIntTxAntennaOffsetResult::GetIntTxAntennaOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetIntTxAntennaOffsetResultPtr GetIntTxAntennaOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return GetIntTxAntennaOffsetResultPtr(new GetIntTxAntennaOffsetResult(relatedCommand, x, y, z, yaw, pitch, roll, id));
    }

    GetIntTxAntennaOffsetResultPtr GetIntTxAntennaOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAntennaOffsetResult>(ptr);
    }

    bool GetIntTxAntennaOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetIntTxAntennaOffsetResult::documentation() const { return Documentation; }


    double GetIntTxAntennaOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetIntTxAntennaOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetIntTxAntennaOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetIntTxAntennaOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetIntTxAntennaOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetIntTxAntennaOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAntennaOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetIntTxAntennaOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAntennaOffsetResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetIntTxAntennaOffsetResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveIntTx
///
#include "gen/RemoveIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveIntTx::CmdName = "RemoveIntTx";
    const char* const RemoveIntTx::Documentation = "Removes the interference transmitter. See EnableIntTx if all you want is to\ndisable the interference temporarily.";

    REGISTER_COMMAND_FACTORY(RemoveIntTx);


    RemoveIntTx::RemoveIntTx()
      : CommandBase(CmdName)
    {}

    RemoveIntTx::RemoveIntTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveIntTxPtr RemoveIntTx::create(const std::string& id)
    {
      return RemoveIntTxPtr(new RemoveIntTx(id));
    }

    RemoveIntTxPtr RemoveIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveIntTx>(ptr);
    }

    bool RemoveIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveIntTx::documentation() const { return Documentation; }


    int RemoveIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RemoveIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllIntTx
///
#include "gen/RemoveAllIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllIntTx::CmdName = "RemoveAllIntTx";
    const char* const RemoveAllIntTx::Documentation = "Remove all the interference transmitters.";

    REGISTER_COMMAND_FACTORY(RemoveAllIntTx);


    RemoveAllIntTx::RemoveAllIntTx()
      : CommandBase(CmdName)
    {

    }


    RemoveAllIntTxPtr RemoveAllIntTx::create()
    {
      return RemoveAllIntTxPtr(new RemoveAllIntTx());
    }

    RemoveAllIntTxPtr RemoveAllIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllIntTx>(ptr);
    }

    bool RemoveAllIntTx::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllIntTx::documentation() const { return Documentation; }


    int RemoveAllIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetAllSignalsFromIntTx
///
#include "gen/GetAllSignalsFromIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSignalsFromIntTx::CmdName = "GetAllSignalsFromIntTx";
    const char* const GetAllSignalsFromIntTx::Documentation = "Get all signal ID for this interference transmitters.";

    REGISTER_COMMAND_FACTORY(GetAllSignalsFromIntTx);


    GetAllSignalsFromIntTx::GetAllSignalsFromIntTx()
      : CommandBase(CmdName)
    {}

    GetAllSignalsFromIntTx::GetAllSignalsFromIntTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetAllSignalsFromIntTxPtr GetAllSignalsFromIntTx::create(const std::string& id)
    {
      return GetAllSignalsFromIntTxPtr(new GetAllSignalsFromIntTx(id));
    }

    GetAllSignalsFromIntTxPtr GetAllSignalsFromIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSignalsFromIntTx>(ptr);
    }

    bool GetAllSignalsFromIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetAllSignalsFromIntTx::documentation() const { return Documentation; }


    int GetAllSignalsFromIntTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSignalsFromIntTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetAllSignalsFromIntTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSignalsFromIntTxResult
///
#include "gen/GetAllSignalsFromIntTxResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSignalsFromIntTxResult::CmdName = "GetAllSignalsFromIntTxResult";
    const char* const GetAllSignalsFromIntTxResult::Documentation = "Result of GetAllSignalsFromIntTx.";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllSignalsFromIntTxResult);


    GetAllSignalsFromIntTxResult::GetAllSignalsFromIntTxResult()
      : CommandResult(CmdName)
    {}

    GetAllSignalsFromIntTxResult::GetAllSignalsFromIntTxResult(CommandBasePtr relatedCommand, const std::string& id, const std::vector<std::string>& idsSignal)
      : CommandResult(CmdName, relatedCommand)
    {

      setId(id);
      setIdsSignal(idsSignal);
    }


    GetAllSignalsFromIntTxResultPtr GetAllSignalsFromIntTxResult::create(CommandBasePtr relatedCommand, const std::string& id, const std::vector<std::string>& idsSignal)
    {
      return GetAllSignalsFromIntTxResultPtr(new GetAllSignalsFromIntTxResult(relatedCommand, id, idsSignal));
    }

    GetAllSignalsFromIntTxResultPtr GetAllSignalsFromIntTxResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSignalsFromIntTxResult>(ptr);
    }

    bool GetAllSignalsFromIntTxResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["IdsSignal"])
        ;

    }

    std::string GetAllSignalsFromIntTxResult::documentation() const { return Documentation; }


    std::string GetAllSignalsFromIntTxResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetAllSignalsFromIntTxResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetAllSignalsFromIntTxResult::idsSignal() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["IdsSignal"]);
    }

    void GetAllSignalsFromIntTxResult::setIdsSignal(const std::vector<std::string>& idsSignal)
    {
      m_values.AddMember("IdsSignal", parse_json<std::vector<std::string>>::format(idsSignal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSignalFromIntTx
///
#include "gen/GetSignalFromIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSignalFromIntTx::CmdName = "GetSignalFromIntTx";
    const char* const GetSignalFromIntTx::Documentation = "Get all signal ID from this interference transmitters and this signal type. If the signal type is invalid, get the IDs of CW type.";

    REGISTER_COMMAND_FACTORY(GetSignalFromIntTx);


    GetSignalFromIntTx::GetSignalFromIntTx()
      : CommandBase(CmdName)
    {}

    GetSignalFromIntTx::GetSignalFromIntTx(const std::string& idTransmitter, const std::string& signalType)
      : CommandBase(CmdName)
    {

      setIdTransmitter(idTransmitter);
      setSignalType(signalType);
    }


    GetSignalFromIntTxPtr GetSignalFromIntTx::create(const std::string& idTransmitter, const std::string& signalType)
    {
      return GetSignalFromIntTxPtr(new GetSignalFromIntTx(idTransmitter, signalType));
    }

    GetSignalFromIntTxPtr GetSignalFromIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSignalFromIntTx>(ptr);
    }

    bool GetSignalFromIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["IdTransmitter"])
          && parse_json<std::string>::is_valid(m_values["SignalType"])
        ;

    }

    std::string GetSignalFromIntTx::documentation() const { return Documentation; }


    int GetSignalFromIntTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSignalFromIntTx::idTransmitter() const
    {
      return parse_json<std::string>::parse(m_values["IdTransmitter"]);
    }

    void GetSignalFromIntTx::setIdTransmitter(const std::string& idTransmitter)
    {
      m_values.AddMember("IdTransmitter", parse_json<std::string>::format(idTransmitter, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSignalFromIntTx::signalType() const
    {
      return parse_json<std::string>::parse(m_values["SignalType"]);
    }

    void GetSignalFromIntTx::setSignalType(const std::string& signalType)
    {
      m_values.AddMember("SignalType", parse_json<std::string>::format(signalType, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSignalFromIntTxResult
///
#include "gen/GetSignalFromIntTxResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSignalFromIntTxResult::CmdName = "GetSignalFromIntTxResult";
    const char* const GetSignalFromIntTxResult::Documentation = "Result of GetSignalFromIntTx.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSignalFromIntTxResult);


    GetSignalFromIntTxResult::GetSignalFromIntTxResult()
      : CommandResult(CmdName)
    {}

    GetSignalFromIntTxResult::GetSignalFromIntTxResult(CommandBasePtr relatedCommand, const std::string& idTransmitter, const std::string& signalType, const std::vector<std::string>& idsSignal)
      : CommandResult(CmdName, relatedCommand)
    {

      setIdTransmitter(idTransmitter);
      setSignalType(signalType);
      setIdsSignal(idsSignal);
    }


    GetSignalFromIntTxResultPtr GetSignalFromIntTxResult::create(CommandBasePtr relatedCommand, const std::string& idTransmitter, const std::string& signalType, const std::vector<std::string>& idsSignal)
    {
      return GetSignalFromIntTxResultPtr(new GetSignalFromIntTxResult(relatedCommand, idTransmitter, signalType, idsSignal));
    }

    GetSignalFromIntTxResultPtr GetSignalFromIntTxResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSignalFromIntTxResult>(ptr);
    }

    bool GetSignalFromIntTxResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["IdTransmitter"])
          && parse_json<std::string>::is_valid(m_values["SignalType"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["IdsSignal"])
        ;

    }

    std::string GetSignalFromIntTxResult::documentation() const { return Documentation; }


    std::string GetSignalFromIntTxResult::idTransmitter() const
    {
      return parse_json<std::string>::parse(m_values["IdTransmitter"]);
    }

    void GetSignalFromIntTxResult::setIdTransmitter(const std::string& idTransmitter)
    {
      m_values.AddMember("IdTransmitter", parse_json<std::string>::format(idTransmitter, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSignalFromIntTxResult::signalType() const
    {
      return parse_json<std::string>::parse(m_values["SignalType"]);
    }

    void GetSignalFromIntTxResult::setSignalType(const std::string& signalType)
    {
      m_values.AddMember("SignalType", parse_json<std::string>::format(signalType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetSignalFromIntTxResult::idsSignal() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["IdsSignal"]);
    }

    void GetSignalFromIntTxResult::setIdsSignal(const std::vector<std::string>& idsSignal)
    {
      m_values.AddMember("IdsSignal", parse_json<std::vector<std::string>>::format(idsSignal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxCW
///
#include "gen/SetIntTxCW.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxCW::CmdName = "SetIntTxCW";
    const char* const SetIntTxCW::Documentation = "Set continuous wave (CW) signal to interference transmitter. A transmitter can combine\nmultiple signals of different types to create complex waveform. The CW id (SignalId) can be an empty\nstring. In such case, Skydel will assign a unique ID. If the signal id is already in use for the\nspecified transmitted, the existing signal is updated, ortherwise a new signal is added.";

    REGISTER_COMMAND_FACTORY(SetIntTxCW);


    SetIntTxCW::SetIntTxCW()
      : CommandBase(CmdName)
    {}

    SetIntTxCW::SetIntTxCW(bool enabled, double centralFreq, double power, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<double>& initialPhaseOffset, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setInitialPhaseOffset(initialPhaseOffset);
      setGroup(group);
    }


    SetIntTxCWPtr SetIntTxCW::create(bool enabled, double centralFreq, double power, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<double>& initialPhaseOffset, const Sdx::optional<int>& group)
    {
      return SetIntTxCWPtr(new SetIntTxCW(enabled, centralFreq, power, transmitterId, signalId, initialPhaseOffset, group));
    }

    SetIntTxCWPtr SetIntTxCW::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxCW>(ptr);
    }

    bool SetIntTxCW::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["InitialPhaseOffset"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxCW::documentation() const { return Documentation; }


    int SetIntTxCW::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxCW::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxCW::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCW::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxCW::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxCW::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxCW::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxCW::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxCW::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxCW::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxCW::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> SetIntTxCW::initialPhaseOffset() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["InitialPhaseOffset"]);
    }

    void SetIntTxCW::setInitialPhaseOffset(const Sdx::optional<double>& initialPhaseOffset)
    {
      m_values.AddMember("InitialPhaseOffset", parse_json<Sdx::optional<double>>::format(initialPhaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxCW::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxCW::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxCW
///
#include "gen/GetIntTxCW.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxCW::CmdName = "GetIntTxCW";
    const char* const GetIntTxCW::Documentation = "Get informations about the CW signal of the transmitter.";

    REGISTER_COMMAND_FACTORY(GetIntTxCW);


    GetIntTxCW::GetIntTxCW()
      : CommandBase(CmdName)
    {}

    GetIntTxCW::GetIntTxCW(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxCWPtr GetIntTxCW::create(const std::string& transmitterId, const std::string& signalId)
    {
      return GetIntTxCWPtr(new GetIntTxCW(transmitterId, signalId));
    }

    GetIntTxCWPtr GetIntTxCW::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxCW>(ptr);
    }

    bool GetIntTxCW::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxCW::documentation() const { return Documentation; }


    int GetIntTxCW::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxCW::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxCW::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxCW::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxCW::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxCWResult
///
#include "gen/GetIntTxCWResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxCWResult::CmdName = "GetIntTxCWResult";
    const char* const GetIntTxCWResult::Documentation = "Result of GetIntTxCW";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxCWResult);


    GetIntTxCWResult::GetIntTxCWResult()
      : CommandResult(CmdName)
    {}

    GetIntTxCWResult::GetIntTxCWResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<double>& initialPhaseOffset, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setInitialPhaseOffset(initialPhaseOffset);
      setGroup(group);
    }


    GetIntTxCWResultPtr GetIntTxCWResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<double>& initialPhaseOffset, const Sdx::optional<int>& group)
    {
      return GetIntTxCWResultPtr(new GetIntTxCWResult(relatedCommand, enabled, centralFreq, power, transmitterId, signalId, initialPhaseOffset, group));
    }

    GetIntTxCWResultPtr GetIntTxCWResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxCWResult>(ptr);
    }

    bool GetIntTxCWResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["InitialPhaseOffset"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxCWResult::documentation() const { return Documentation; }


    bool GetIntTxCWResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxCWResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCWResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxCWResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxCWResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxCWResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxCWResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxCWResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxCWResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxCWResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetIntTxCWResult::initialPhaseOffset() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["InitialPhaseOffset"]);
    }

    void GetIntTxCWResult::setInitialPhaseOffset(const Sdx::optional<double>& initialPhaseOffset)
    {
      m_values.AddMember("InitialPhaseOffset", parse_json<Sdx::optional<double>>::format(initialPhaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxCWResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxCWResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxChirp
///
#include "gen/SetIntTxChirp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxChirp::CmdName = "SetIntTxChirp";
    const char* const SetIntTxChirp::Documentation = "Set Chirp signal to interference transmitter. A transmitter can combine\nmultiple signals of different types to create complex waveform. The signal id (SignalId) can be an empty\nstring. In such case, Skydel will assign a unique ID. If the signal id is already in use for the\nspecified transmitted, the existing signal is updated, ortherwise a new signal is added.";

    REGISTER_COMMAND_FACTORY(SetIntTxChirp);


    SetIntTxChirp::SetIntTxChirp()
      : CommandBase(CmdName)
    {}

    SetIntTxChirp::SetIntTxChirp(bool enabled, double centralFreq, double power, double bandwidth, double sweepTime, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setSweepTime(sweepTime);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    SetIntTxChirpPtr SetIntTxChirp::create(bool enabled, double centralFreq, double power, double bandwidth, double sweepTime, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return SetIntTxChirpPtr(new SetIntTxChirp(enabled, centralFreq, power, bandwidth, sweepTime, transmitterId, signalId, group));
    }

    SetIntTxChirpPtr SetIntTxChirp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxChirp>(ptr);
    }

    bool SetIntTxChirp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<double>::is_valid(m_values["SweepTime"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxChirp::documentation() const { return Documentation; }


    int SetIntTxChirp::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxChirp::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxChirp::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxChirp::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxChirp::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxChirp::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxChirp::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxChirp::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void SetIntTxChirp::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxChirp::sweepTime() const
    {
      return parse_json<double>::parse(m_values["SweepTime"]);
    }

    void SetIntTxChirp::setSweepTime(double sweepTime)
    {
      m_values.AddMember("SweepTime", parse_json<double>::format(sweepTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxChirp::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxChirp::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxChirp::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxChirp::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxChirp::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxChirp::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxChirp
///
#include "gen/GetIntTxChirp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxChirp::CmdName = "GetIntTxChirp";
    const char* const GetIntTxChirp::Documentation = "Get informations about the Chirp signal of the transmitter.";

    REGISTER_COMMAND_FACTORY(GetIntTxChirp);


    GetIntTxChirp::GetIntTxChirp()
      : CommandBase(CmdName)
    {}

    GetIntTxChirp::GetIntTxChirp(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxChirpPtr GetIntTxChirp::create(const std::string& transmitterId, const std::string& signalId)
    {
      return GetIntTxChirpPtr(new GetIntTxChirp(transmitterId, signalId));
    }

    GetIntTxChirpPtr GetIntTxChirp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxChirp>(ptr);
    }

    bool GetIntTxChirp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxChirp::documentation() const { return Documentation; }


    int GetIntTxChirp::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxChirp::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxChirp::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxChirp::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxChirp::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxChirpResult
///
#include "gen/GetIntTxChirpResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxChirpResult::CmdName = "GetIntTxChirpResult";
    const char* const GetIntTxChirpResult::Documentation = "Result of GetIntTxChirp";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxChirpResult);


    GetIntTxChirpResult::GetIntTxChirpResult()
      : CommandResult(CmdName)
    {}

    GetIntTxChirpResult::GetIntTxChirpResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double bandwidth, double sweepTime, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setSweepTime(sweepTime);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    GetIntTxChirpResultPtr GetIntTxChirpResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double bandwidth, double sweepTime, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return GetIntTxChirpResultPtr(new GetIntTxChirpResult(relatedCommand, enabled, centralFreq, power, bandwidth, sweepTime, transmitterId, signalId, group));
    }

    GetIntTxChirpResultPtr GetIntTxChirpResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxChirpResult>(ptr);
    }

    bool GetIntTxChirpResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<double>::is_valid(m_values["SweepTime"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxChirpResult::documentation() const { return Documentation; }


    bool GetIntTxChirpResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxChirpResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxChirpResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxChirpResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxChirpResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxChirpResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxChirpResult::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void GetIntTxChirpResult::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxChirpResult::sweepTime() const
    {
      return parse_json<double>::parse(m_values["SweepTime"]);
    }

    void GetIntTxChirpResult::setSweepTime(double sweepTime)
    {
      m_values.AddMember("SweepTime", parse_json<double>::format(sweepTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxChirpResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxChirpResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxChirpResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxChirpResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxChirpResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxChirpResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxPulse
///
#include "gen/SetIntTxPulse.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxPulse::CmdName = "SetIntTxPulse";
    const char* const SetIntTxPulse::Documentation = "Set pulse signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxPulse);


    SetIntTxPulse::SetIntTxPulse()
      : CommandBase(CmdName)
    {}

    SetIntTxPulse::SetIntTxPulse(bool enabled, double centralFreq, double power, double dutyCycle, int pulseRate, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setDutyCycle(dutyCycle);
      setPulseRate(pulseRate);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    SetIntTxPulsePtr SetIntTxPulse::create(bool enabled, double centralFreq, double power, double dutyCycle, int pulseRate, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return SetIntTxPulsePtr(new SetIntTxPulse(enabled, centralFreq, power, dutyCycle, pulseRate, transmitterId, signalId, group));
    }

    SetIntTxPulsePtr SetIntTxPulse::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxPulse>(ptr);
    }

    bool SetIntTxPulse::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["DutyCycle"])
          && parse_json<int>::is_valid(m_values["PulseRate"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxPulse::documentation() const { return Documentation; }


    int SetIntTxPulse::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxPulse::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxPulse::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxPulse::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxPulse::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxPulse::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxPulse::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxPulse::dutyCycle() const
    {
      return parse_json<double>::parse(m_values["DutyCycle"]);
    }

    void SetIntTxPulse::setDutyCycle(double dutyCycle)
    {
      m_values.AddMember("DutyCycle", parse_json<double>::format(dutyCycle, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxPulse::pulseRate() const
    {
      return parse_json<int>::parse(m_values["PulseRate"]);
    }

    void SetIntTxPulse::setPulseRate(int pulseRate)
    {
      m_values.AddMember("PulseRate", parse_json<int>::format(pulseRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxPulse::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxPulse::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxPulse::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxPulse::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxPulse::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxPulse::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxPulse
///
#include "gen/GetIntTxPulse.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxPulse::CmdName = "GetIntTxPulse";
    const char* const GetIntTxPulse::Documentation = "Get pulse signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxPulse);


    GetIntTxPulse::GetIntTxPulse()
      : CommandBase(CmdName)
    {}

    GetIntTxPulse::GetIntTxPulse(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxPulsePtr GetIntTxPulse::create(const std::string& transmitterId, const std::string& signalId)
    {
      return GetIntTxPulsePtr(new GetIntTxPulse(transmitterId, signalId));
    }

    GetIntTxPulsePtr GetIntTxPulse::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxPulse>(ptr);
    }

    bool GetIntTxPulse::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxPulse::documentation() const { return Documentation; }


    int GetIntTxPulse::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxPulse::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxPulse::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxPulse::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxPulse::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxPulseResult
///
#include "gen/GetIntTxPulseResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxPulseResult::CmdName = "GetIntTxPulseResult";
    const char* const GetIntTxPulseResult::Documentation = "Result of GetIntTxPulse";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxPulseResult);


    GetIntTxPulseResult::GetIntTxPulseResult()
      : CommandResult(CmdName)
    {}

    GetIntTxPulseResult::GetIntTxPulseResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double dutyCycle, int pulseRate, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setDutyCycle(dutyCycle);
      setPulseRate(pulseRate);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    GetIntTxPulseResultPtr GetIntTxPulseResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double dutyCycle, int pulseRate, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return GetIntTxPulseResultPtr(new GetIntTxPulseResult(relatedCommand, enabled, centralFreq, power, dutyCycle, pulseRate, transmitterId, signalId, group));
    }

    GetIntTxPulseResultPtr GetIntTxPulseResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxPulseResult>(ptr);
    }

    bool GetIntTxPulseResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["DutyCycle"])
          && parse_json<int>::is_valid(m_values["PulseRate"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxPulseResult::documentation() const { return Documentation; }


    bool GetIntTxPulseResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxPulseResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxPulseResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxPulseResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxPulseResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxPulseResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxPulseResult::dutyCycle() const
    {
      return parse_json<double>::parse(m_values["DutyCycle"]);
    }

    void GetIntTxPulseResult::setDutyCycle(double dutyCycle)
    {
      m_values.AddMember("DutyCycle", parse_json<double>::format(dutyCycle, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxPulseResult::pulseRate() const
    {
      return parse_json<int>::parse(m_values["PulseRate"]);
    }

    void GetIntTxPulseResult::setPulseRate(int pulseRate)
    {
      m_values.AddMember("PulseRate", parse_json<int>::format(pulseRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxPulseResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxPulseResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxPulseResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxPulseResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxPulseResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxPulseResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxBPSK
///
#include "gen/SetIntTxBPSK.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxBPSK::CmdName = "SetIntTxBPSK";
    const char* const SetIntTxBPSK::Documentation = "Set BPSK signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxBPSK);


    SetIntTxBPSK::SetIntTxBPSK()
      : CommandBase(CmdName)
    {}

    SetIntTxBPSK::SetIntTxBPSK(bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setCodeRate(codeRate);
      setCodeLengthMs(codeLengthMs);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    SetIntTxBPSKPtr SetIntTxBPSK::create(bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return SetIntTxBPSKPtr(new SetIntTxBPSK(enabled, centralFreq, power, codeRate, codeLengthMs, transmitterId, signalId, group));
    }

    SetIntTxBPSKPtr SetIntTxBPSK::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxBPSK>(ptr);
    }

    bool SetIntTxBPSK::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["CodeRate"])
          && parse_json<int>::is_valid(m_values["CodeLengthMs"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxBPSK::documentation() const { return Documentation; }


    int SetIntTxBPSK::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxBPSK::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxBPSK::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxBPSK::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxBPSK::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxBPSK::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxBPSK::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBPSK::codeRate() const
    {
      return parse_json<int>::parse(m_values["CodeRate"]);
    }

    void SetIntTxBPSK::setCodeRate(int codeRate)
    {
      m_values.AddMember("CodeRate", parse_json<int>::format(codeRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBPSK::codeLengthMs() const
    {
      return parse_json<int>::parse(m_values["CodeLengthMs"]);
    }

    void SetIntTxBPSK::setCodeLengthMs(int codeLengthMs)
    {
      m_values.AddMember("CodeLengthMs", parse_json<int>::format(codeLengthMs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxBPSK::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxBPSK::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxBPSK::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxBPSK::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxBPSK::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxBPSK::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxBPSK
///
#include "gen/GetIntTxBPSK.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxBPSK::CmdName = "GetIntTxBPSK";
    const char* const GetIntTxBPSK::Documentation = "Get BPSK signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxBPSK);


    GetIntTxBPSK::GetIntTxBPSK()
      : CommandBase(CmdName)
    {}

    GetIntTxBPSK::GetIntTxBPSK(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxBPSKPtr GetIntTxBPSK::create(const std::string& transmitterId, const std::string& signalId)
    {
      return GetIntTxBPSKPtr(new GetIntTxBPSK(transmitterId, signalId));
    }

    GetIntTxBPSKPtr GetIntTxBPSK::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxBPSK>(ptr);
    }

    bool GetIntTxBPSK::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxBPSK::documentation() const { return Documentation; }


    int GetIntTxBPSK::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxBPSK::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxBPSK::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBPSK::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxBPSK::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxBPSKResult
///
#include "gen/GetIntTxBPSKResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxBPSKResult::CmdName = "GetIntTxBPSKResult";
    const char* const GetIntTxBPSKResult::Documentation = "Result of GetIntTxBPSK";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxBPSKResult);


    GetIntTxBPSKResult::GetIntTxBPSKResult()
      : CommandResult(CmdName)
    {}

    GetIntTxBPSKResult::GetIntTxBPSKResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setCodeRate(codeRate);
      setCodeLengthMs(codeLengthMs);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    GetIntTxBPSKResultPtr GetIntTxBPSKResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return GetIntTxBPSKResultPtr(new GetIntTxBPSKResult(relatedCommand, enabled, centralFreq, power, codeRate, codeLengthMs, transmitterId, signalId, group));
    }

    GetIntTxBPSKResultPtr GetIntTxBPSKResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxBPSKResult>(ptr);
    }

    bool GetIntTxBPSKResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["CodeRate"])
          && parse_json<int>::is_valid(m_values["CodeLengthMs"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxBPSKResult::documentation() const { return Documentation; }


    bool GetIntTxBPSKResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxBPSKResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxBPSKResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxBPSKResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxBPSKResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxBPSKResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBPSKResult::codeRate() const
    {
      return parse_json<int>::parse(m_values["CodeRate"]);
    }

    void GetIntTxBPSKResult::setCodeRate(int codeRate)
    {
      m_values.AddMember("CodeRate", parse_json<int>::format(codeRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBPSKResult::codeLengthMs() const
    {
      return parse_json<int>::parse(m_values["CodeLengthMs"]);
    }

    void GetIntTxBPSKResult::setCodeLengthMs(int codeLengthMs)
    {
      m_values.AddMember("CodeLengthMs", parse_json<int>::format(codeLengthMs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBPSKResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxBPSKResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBPSKResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxBPSKResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxBPSKResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxBPSKResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxBOC
///
#include "gen/SetIntTxBOC.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxBOC::CmdName = "SetIntTxBOC";
    const char* const SetIntTxBOC::Documentation = "Set BOC signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxBOC);


    SetIntTxBOC::SetIntTxBOC()
      : CommandBase(CmdName)
    {}

    SetIntTxBOC::SetIntTxBOC(bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, int subCarrierRate, bool cosinePhaseBoc, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setCodeRate(codeRate);
      setCodeLengthMs(codeLengthMs);
      setSubCarrierRate(subCarrierRate);
      setCosinePhaseBoc(cosinePhaseBoc);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    SetIntTxBOCPtr SetIntTxBOC::create(bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, int subCarrierRate, bool cosinePhaseBoc, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return SetIntTxBOCPtr(new SetIntTxBOC(enabled, centralFreq, power, codeRate, codeLengthMs, subCarrierRate, cosinePhaseBoc, transmitterId, signalId, group));
    }

    SetIntTxBOCPtr SetIntTxBOC::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxBOC>(ptr);
    }

    bool SetIntTxBOC::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["CodeRate"])
          && parse_json<int>::is_valid(m_values["CodeLengthMs"])
          && parse_json<int>::is_valid(m_values["SubCarrierRate"])
          && parse_json<bool>::is_valid(m_values["CosinePhaseBoc"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxBOC::documentation() const { return Documentation; }


    int SetIntTxBOC::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxBOC::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxBOC::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxBOC::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxBOC::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxBOC::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxBOC::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBOC::codeRate() const
    {
      return parse_json<int>::parse(m_values["CodeRate"]);
    }

    void SetIntTxBOC::setCodeRate(int codeRate)
    {
      m_values.AddMember("CodeRate", parse_json<int>::format(codeRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBOC::codeLengthMs() const
    {
      return parse_json<int>::parse(m_values["CodeLengthMs"]);
    }

    void SetIntTxBOC::setCodeLengthMs(int codeLengthMs)
    {
      m_values.AddMember("CodeLengthMs", parse_json<int>::format(codeLengthMs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIntTxBOC::subCarrierRate() const
    {
      return parse_json<int>::parse(m_values["SubCarrierRate"]);
    }

    void SetIntTxBOC::setSubCarrierRate(int subCarrierRate)
    {
      m_values.AddMember("SubCarrierRate", parse_json<int>::format(subCarrierRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetIntTxBOC::cosinePhaseBoc() const
    {
      return parse_json<bool>::parse(m_values["CosinePhaseBoc"]);
    }

    void SetIntTxBOC::setCosinePhaseBoc(bool cosinePhaseBoc)
    {
      m_values.AddMember("CosinePhaseBoc", parse_json<bool>::format(cosinePhaseBoc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxBOC::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxBOC::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxBOC::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxBOC::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxBOC::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxBOC::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxBOC
///
#include "gen/GetIntTxBOC.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxBOC::CmdName = "GetIntTxBOC";
    const char* const GetIntTxBOC::Documentation = "Get BOC signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxBOC);


    GetIntTxBOC::GetIntTxBOC()
      : CommandBase(CmdName)
    {}

    GetIntTxBOC::GetIntTxBOC(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxBOCPtr GetIntTxBOC::create(const std::string& transmitterId, const std::string& signalId)
    {
      return GetIntTxBOCPtr(new GetIntTxBOC(transmitterId, signalId));
    }

    GetIntTxBOCPtr GetIntTxBOC::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxBOC>(ptr);
    }

    bool GetIntTxBOC::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxBOC::documentation() const { return Documentation; }


    int GetIntTxBOC::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxBOC::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxBOC::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBOC::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxBOC::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxBOCResult
///
#include "gen/GetIntTxBOCResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxBOCResult::CmdName = "GetIntTxBOCResult";
    const char* const GetIntTxBOCResult::Documentation = "Result of GetIntTxBOC";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxBOCResult);


    GetIntTxBOCResult::GetIntTxBOCResult()
      : CommandResult(CmdName)
    {}

    GetIntTxBOCResult::GetIntTxBOCResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, int subCarrierRate, bool cosinePhaseBoc, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setCodeRate(codeRate);
      setCodeLengthMs(codeLengthMs);
      setSubCarrierRate(subCarrierRate);
      setCosinePhaseBoc(cosinePhaseBoc);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    GetIntTxBOCResultPtr GetIntTxBOCResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, int codeRate, int codeLengthMs, int subCarrierRate, bool cosinePhaseBoc, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return GetIntTxBOCResultPtr(new GetIntTxBOCResult(relatedCommand, enabled, centralFreq, power, codeRate, codeLengthMs, subCarrierRate, cosinePhaseBoc, transmitterId, signalId, group));
    }

    GetIntTxBOCResultPtr GetIntTxBOCResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxBOCResult>(ptr);
    }

    bool GetIntTxBOCResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["CodeRate"])
          && parse_json<int>::is_valid(m_values["CodeLengthMs"])
          && parse_json<int>::is_valid(m_values["SubCarrierRate"])
          && parse_json<bool>::is_valid(m_values["CosinePhaseBoc"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxBOCResult::documentation() const { return Documentation; }


    bool GetIntTxBOCResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxBOCResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxBOCResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxBOCResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxBOCResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxBOCResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBOCResult::codeRate() const
    {
      return parse_json<int>::parse(m_values["CodeRate"]);
    }

    void GetIntTxBOCResult::setCodeRate(int codeRate)
    {
      m_values.AddMember("CodeRate", parse_json<int>::format(codeRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBOCResult::codeLengthMs() const
    {
      return parse_json<int>::parse(m_values["CodeLengthMs"]);
    }

    void GetIntTxBOCResult::setCodeLengthMs(int codeLengthMs)
    {
      m_values.AddMember("CodeLengthMs", parse_json<int>::format(codeLengthMs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIntTxBOCResult::subCarrierRate() const
    {
      return parse_json<int>::parse(m_values["SubCarrierRate"]);
    }

    void GetIntTxBOCResult::setSubCarrierRate(int subCarrierRate)
    {
      m_values.AddMember("SubCarrierRate", parse_json<int>::format(subCarrierRate, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIntTxBOCResult::cosinePhaseBoc() const
    {
      return parse_json<bool>::parse(m_values["CosinePhaseBoc"]);
    }

    void GetIntTxBOCResult::setCosinePhaseBoc(bool cosinePhaseBoc)
    {
      m_values.AddMember("CosinePhaseBoc", parse_json<bool>::format(cosinePhaseBoc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBOCResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxBOCResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxBOCResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxBOCResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxBOCResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxBOCResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxAWGN
///
#include "gen/SetIntTxAWGN.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxAWGN::CmdName = "SetIntTxAWGN";
    const char* const SetIntTxAWGN::Documentation = "Set AWGN signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxAWGN);


    SetIntTxAWGN::SetIntTxAWGN()
      : CommandBase(CmdName)
    {}

    SetIntTxAWGN::SetIntTxAWGN(bool enabled, double centralFreq, double power, double bandwidth, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& seed, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setSeed(seed);
      setGroup(group);
    }


    SetIntTxAWGNPtr SetIntTxAWGN::create(bool enabled, double centralFreq, double power, double bandwidth, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& seed, const Sdx::optional<int>& group)
    {
      return SetIntTxAWGNPtr(new SetIntTxAWGN(enabled, centralFreq, power, bandwidth, transmitterId, signalId, seed, group));
    }

    SetIntTxAWGNPtr SetIntTxAWGN::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxAWGN>(ptr);
    }

    bool SetIntTxAWGN::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Seed"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxAWGN::documentation() const { return Documentation; }


    int SetIntTxAWGN::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxAWGN::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxAWGN::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAWGN::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxAWGN::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAWGN::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxAWGN::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxAWGN::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void SetIntTxAWGN::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxAWGN::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxAWGN::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxAWGN::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxAWGN::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxAWGN::seed() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Seed"]);
    }

    void SetIntTxAWGN::setSeed(const Sdx::optional<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<Sdx::optional<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxAWGN::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxAWGN::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAWGN
///
#include "gen/GetIntTxAWGN.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAWGN::CmdName = "GetIntTxAWGN";
    const char* const GetIntTxAWGN::Documentation = "Get AWGN signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxAWGN);


    GetIntTxAWGN::GetIntTxAWGN()
      : CommandBase(CmdName)
    {}

    GetIntTxAWGN::GetIntTxAWGN(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxAWGNPtr GetIntTxAWGN::create(const std::string& transmitterId, const std::string& signalId)
    {
      return GetIntTxAWGNPtr(new GetIntTxAWGN(transmitterId, signalId));
    }

    GetIntTxAWGNPtr GetIntTxAWGN::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAWGN>(ptr);
    }

    bool GetIntTxAWGN::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxAWGN::documentation() const { return Documentation; }


    int GetIntTxAWGN::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxAWGN::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxAWGN::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAWGN::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxAWGN::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxAWGNResult
///
#include "gen/GetIntTxAWGNResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxAWGNResult::CmdName = "GetIntTxAWGNResult";
    const char* const GetIntTxAWGNResult::Documentation = "Result of GetIntTxAWGN";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxAWGNResult);


    GetIntTxAWGNResult::GetIntTxAWGNResult()
      : CommandResult(CmdName)
    {}

    GetIntTxAWGNResult::GetIntTxAWGNResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double bandwidth, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& seed, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setBandwidth(bandwidth);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setSeed(seed);
      setGroup(group);
    }


    GetIntTxAWGNResultPtr GetIntTxAWGNResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, double bandwidth, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& seed, const Sdx::optional<int>& group)
    {
      return GetIntTxAWGNResultPtr(new GetIntTxAWGNResult(relatedCommand, enabled, centralFreq, power, bandwidth, transmitterId, signalId, seed, group));
    }

    GetIntTxAWGNResultPtr GetIntTxAWGNResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxAWGNResult>(ptr);
    }

    bool GetIntTxAWGNResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Bandwidth"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Seed"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxAWGNResult::documentation() const { return Documentation; }


    bool GetIntTxAWGNResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxAWGNResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAWGNResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxAWGNResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAWGNResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxAWGNResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxAWGNResult::bandwidth() const
    {
      return parse_json<double>::parse(m_values["Bandwidth"]);
    }

    void GetIntTxAWGNResult::setBandwidth(double bandwidth)
    {
      m_values.AddMember("Bandwidth", parse_json<double>::format(bandwidth, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAWGNResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxAWGNResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxAWGNResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxAWGNResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxAWGNResult::seed() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Seed"]);
    }

    void GetIntTxAWGNResult::setSeed(const Sdx::optional<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<Sdx::optional<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxAWGNResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxAWGNResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIntTxIqFile
///
#include "gen/SetIntTxIqFile.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIntTxIqFile::CmdName = "SetIntTxIqFile";
    const char* const SetIntTxIqFile::Documentation = "Set IQ file signal interference.";

    REGISTER_COMMAND_FACTORY(SetIntTxIqFile);


    SetIntTxIqFile::SetIntTxIqFile()
      : CommandBase(CmdName)
    {}

    SetIntTxIqFile::SetIntTxIqFile(bool enabled, double centralFreq, double power, const std::string& path, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setPath(path);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    SetIntTxIqFilePtr SetIntTxIqFile::create(bool enabled, double centralFreq, double power, const std::string& path, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return SetIntTxIqFilePtr(new SetIntTxIqFile(enabled, centralFreq, power, path, transmitterId, signalId, group));
    }

    SetIntTxIqFilePtr SetIntTxIqFile::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIntTxIqFile>(ptr);
    }

    bool SetIntTxIqFile::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string SetIntTxIqFile::documentation() const { return Documentation; }


    int SetIntTxIqFile::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetIntTxIqFile::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetIntTxIqFile::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxIqFile::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void SetIntTxIqFile::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIntTxIqFile::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetIntTxIqFile::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIqFile::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void SetIntTxIqFile::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIqFile::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void SetIntTxIqFile::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetIntTxIqFile::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void SetIntTxIqFile::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> SetIntTxIqFile::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void SetIntTxIqFile::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxIqFile
///
#include "gen/GetIntTxIqFile.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxIqFile::CmdName = "GetIntTxIqFile";
    const char* const GetIntTxIqFile::Documentation = "Get IQ file signal interference.";

    REGISTER_COMMAND_FACTORY(GetIntTxIqFile);


    GetIntTxIqFile::GetIntTxIqFile()
      : CommandBase(CmdName)
    {}

    GetIntTxIqFile::GetIntTxIqFile(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    GetIntTxIqFilePtr GetIntTxIqFile::create(const std::string& transmitterId, const std::string& signalId)
    {
      return GetIntTxIqFilePtr(new GetIntTxIqFile(transmitterId, signalId));
    }

    GetIntTxIqFilePtr GetIntTxIqFile::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxIqFile>(ptr);
    }

    bool GetIntTxIqFile::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string GetIntTxIqFile::documentation() const { return Documentation; }


    int GetIntTxIqFile::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIntTxIqFile::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxIqFile::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxIqFile::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxIqFile::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIntTxIqFileResult
///
#include "gen/GetIntTxIqFileResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIntTxIqFileResult::CmdName = "GetIntTxIqFileResult";
    const char* const GetIntTxIqFileResult::Documentation = "Result of GetIntTxIqFile";

    REGISTER_COMMAND_RESULT_FACTORY(GetIntTxIqFileResult);


    GetIntTxIqFileResult::GetIntTxIqFileResult()
      : CommandResult(CmdName)
    {}

    GetIntTxIqFileResult::GetIntTxIqFileResult(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, const std::string& path, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
      setCentralFreq(centralFreq);
      setPower(power);
      setPath(path);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
      setGroup(group);
    }


    GetIntTxIqFileResultPtr GetIntTxIqFileResult::create(CommandBasePtr relatedCommand, bool enabled, double centralFreq, double power, const std::string& path, const std::string& transmitterId, const std::string& signalId, const Sdx::optional<int>& group)
    {
      return GetIntTxIqFileResultPtr(new GetIntTxIqFileResult(relatedCommand, enabled, centralFreq, power, path, transmitterId, signalId, group));
    }

    GetIntTxIqFileResultPtr GetIntTxIqFileResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIntTxIqFileResult>(ptr);
    }

    bool GetIntTxIqFileResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["CentralFreq"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
          && parse_json<Sdx::optional<int>>::is_valid(m_values["Group"])
        ;

    }

    std::string GetIntTxIqFileResult::documentation() const { return Documentation; }


    bool GetIntTxIqFileResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetIntTxIqFileResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxIqFileResult::centralFreq() const
    {
      return parse_json<double>::parse(m_values["CentralFreq"]);
    }

    void GetIntTxIqFileResult::setCentralFreq(double centralFreq)
    {
      m_values.AddMember("CentralFreq", parse_json<double>::format(centralFreq, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIntTxIqFileResult::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void GetIntTxIqFileResult::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxIqFileResult::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void GetIntTxIqFileResult::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxIqFileResult::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void GetIntTxIqFileResult::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetIntTxIqFileResult::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void GetIntTxIqFileResult::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<int> GetIntTxIqFileResult::group() const
    {
      return parse_json<Sdx::optional<int>>::parse(m_values["Group"]);
    }

    void GetIntTxIqFileResult::setGroup(const Sdx::optional<int>& group)
    {
      m_values.AddMember("Group", parse_json<Sdx::optional<int>>::format(group, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableIntTxSignal
///
#include "gen/EnableIntTxSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableIntTxSignal::CmdName = "EnableIntTxSignal";
    const char* const EnableIntTxSignal::Documentation = "Change whether a signal is enabled or disabled";

    REGISTER_COMMAND_FACTORY(EnableIntTxSignal);


    EnableIntTxSignal::EnableIntTxSignal()
      : CommandBase(CmdName)
    {}

    EnableIntTxSignal::EnableIntTxSignal(bool enabled, const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    EnableIntTxSignalPtr EnableIntTxSignal::create(bool enabled, const std::string& transmitterId, const std::string& signalId)
    {
      return EnableIntTxSignalPtr(new EnableIntTxSignal(enabled, transmitterId, signalId));
    }

    EnableIntTxSignalPtr EnableIntTxSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableIntTxSignal>(ptr);
    }

    bool EnableIntTxSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string EnableIntTxSignal::documentation() const { return Documentation; }


    int EnableIntTxSignal::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool EnableIntTxSignal::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableIntTxSignal::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableIntTxSignal::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void EnableIntTxSignal::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableIntTxSignal::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void EnableIntTxSignal::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveSignalFromIntTx
///
#include "gen/RemoveSignalFromIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveSignalFromIntTx::CmdName = "RemoveSignalFromIntTx";
    const char* const RemoveSignalFromIntTx::Documentation = "Removes the specified signal from the interference transmitter.";

    REGISTER_COMMAND_FACTORY(RemoveSignalFromIntTx);


    RemoveSignalFromIntTx::RemoveSignalFromIntTx()
      : CommandBase(CmdName)
    {}

    RemoveSignalFromIntTx::RemoveSignalFromIntTx(const std::string& transmitterId, const std::string& signalId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
      setSignalId(signalId);
    }


    RemoveSignalFromIntTxPtr RemoveSignalFromIntTx::create(const std::string& transmitterId, const std::string& signalId)
    {
      return RemoveSignalFromIntTxPtr(new RemoveSignalFromIntTx(transmitterId, signalId));
    }

    RemoveSignalFromIntTxPtr RemoveSignalFromIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveSignalFromIntTx>(ptr);
    }

    bool RemoveSignalFromIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
          && parse_json<std::string>::is_valid(m_values["SignalId"])
        ;

    }

    std::string RemoveSignalFromIntTx::documentation() const { return Documentation; }


    int RemoveSignalFromIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RemoveSignalFromIntTx::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void RemoveSignalFromIntTx::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveSignalFromIntTx::signalId() const
    {
      return parse_json<std::string>::parse(m_values["SignalId"]);
    }

    void RemoveSignalFromIntTx::setSignalId(const std::string& signalId)
    {
      m_values.AddMember("SignalId", parse_json<std::string>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllSignalsFromIntTx
///
#include "gen/RemoveAllSignalsFromIntTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllSignalsFromIntTx::CmdName = "RemoveAllSignalsFromIntTx";
    const char* const RemoveAllSignalsFromIntTx::Documentation = "Removes all signals from the interference transmitter.";

    REGISTER_COMMAND_FACTORY(RemoveAllSignalsFromIntTx);


    RemoveAllSignalsFromIntTx::RemoveAllSignalsFromIntTx()
      : CommandBase(CmdName)
    {}

    RemoveAllSignalsFromIntTx::RemoveAllSignalsFromIntTx(const std::string& transmitterId)
      : CommandBase(CmdName)
    {

      setTransmitterId(transmitterId);
    }


    RemoveAllSignalsFromIntTxPtr RemoveAllSignalsFromIntTx::create(const std::string& transmitterId)
    {
      return RemoveAllSignalsFromIntTxPtr(new RemoveAllSignalsFromIntTx(transmitterId));
    }

    RemoveAllSignalsFromIntTxPtr RemoveAllSignalsFromIntTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllSignalsFromIntTx>(ptr);
    }

    bool RemoveAllSignalsFromIntTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TransmitterId"])
        ;

    }

    std::string RemoveAllSignalsFromIntTx::documentation() const { return Documentation; }


    int RemoveAllSignalsFromIntTx::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string RemoveAllSignalsFromIntTx::transmitterId() const
    {
      return parse_json<std::string>::parse(m_values["TransmitterId"]);
    }

    void RemoveAllSignalsFromIntTx::setTransmitterId(const std::string& transmitterId)
    {
      m_values.AddMember("TransmitterId", parse_json<std::string>::format(transmitterId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetStreamingBuffer
///
#include "gen/SetStreamingBuffer.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetStreamingBuffer::CmdName = "SetStreamingBuffer";
    const char* const SetStreamingBuffer::Documentation = "Set streaming buffer size.";

    REGISTER_COMMAND_FACTORY(SetStreamingBuffer);


    SetStreamingBuffer::SetStreamingBuffer()
      : CommandBase(CmdName)
    {}

    SetStreamingBuffer::SetStreamingBuffer(int size)
      : CommandBase(CmdName)
    {

      setSize(size);
    }


    SetStreamingBufferPtr SetStreamingBuffer::create(int size)
    {
      return SetStreamingBufferPtr(new SetStreamingBuffer(size));
    }

    SetStreamingBufferPtr SetStreamingBuffer::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetStreamingBuffer>(ptr);
    }

    bool SetStreamingBuffer::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Size"])
        ;

    }

    std::string SetStreamingBuffer::documentation() const { return Documentation; }


    int SetStreamingBuffer::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    int SetStreamingBuffer::size() const
    {
      return parse_json<int>::parse(m_values["Size"]);
    }

    void SetStreamingBuffer::setSize(int size)
    {
      m_values.AddMember("Size", parse_json<int>::format(size, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSyncServer
///
#include "gen/SetSyncServer.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSyncServer::CmdName = "SetSyncServer";
    const char* const SetSyncServer::Documentation = "Set listening port for sync time server.";

    REGISTER_COMMAND_FACTORY(SetSyncServer);


    SetSyncServer::SetSyncServer()
      : CommandBase(CmdName)
    {}

    SetSyncServer::SetSyncServer(int port)
      : CommandBase(CmdName)
    {

      setPort(port);
    }


    SetSyncServerPtr SetSyncServer::create(int port)
    {
      return SetSyncServerPtr(new SetSyncServer(port));
    }

    SetSyncServerPtr SetSyncServer::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSyncServer>(ptr);
    }

    bool SetSyncServer::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Port"])
        ;

    }

    std::string SetSyncServer::documentation() const { return Documentation; }


    int SetSyncServer::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    int SetSyncServer::port() const
    {
      return parse_json<int>::parse(m_values["Port"]);
    }

    void SetSyncServer::setPort(int port)
    {
      m_values.AddMember("Port", parse_json<int>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSyncClient
///
#include "gen/SetSyncClient.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSyncClient::CmdName = "SetSyncClient";
    const char* const SetSyncClient::Documentation = "Set host and port to connect to sync time server.";

    REGISTER_COMMAND_FACTORY(SetSyncClient);


    SetSyncClient::SetSyncClient()
      : CommandBase(CmdName)
    {}

    SetSyncClient::SetSyncClient(const std::string& host, int port)
      : CommandBase(CmdName)
    {

      setHost(host);
      setPort(port);
    }


    SetSyncClientPtr SetSyncClient::create(const std::string& host, int port)
    {
      return SetSyncClientPtr(new SetSyncClient(host, port));
    }

    SetSyncClientPtr SetSyncClient::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSyncClient>(ptr);
    }

    bool SetSyncClient::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Host"])
          && parse_json<int>::is_valid(m_values["Port"])
        ;

    }

    std::string SetSyncClient::documentation() const { return Documentation; }


    int SetSyncClient::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    std::string SetSyncClient::host() const
    {
      return parse_json<std::string>::parse(m_values["Host"]);
    }

    void SetSyncClient::setHost(const std::string& host)
    {
      m_values.AddMember("Host", parse_json<std::string>::format(host, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSyncClient::port() const
    {
      return parse_json<int>::parse(m_values["Port"]);
    }

    void SetSyncClient::setPort(int port)
    {
      m_values.AddMember("Port", parse_json<int>::format(port, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSyncTime
///
#include "gen/SetSyncTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSyncTime::CmdName = "SetSyncTime";
    const char* const SetSyncTime::Documentation = "Set time delay to start streaming, in order to allign PPS out Signal with RF.\n2000 ms is a calibrated value.";

    REGISTER_COMMAND_FACTORY(SetSyncTime);


    SetSyncTime::SetSyncTime()
      : CommandBase(CmdName)
    {}

    SetSyncTime::SetSyncTime(double time)
      : CommandBase(CmdName)
    {

      setTime(time);
    }


    SetSyncTimePtr SetSyncTime::create(double time)
    {
      return SetSyncTimePtr(new SetSyncTime(time));
    }

    SetSyncTimePtr SetSyncTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSyncTime>(ptr);
    }

    bool SetSyncTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Time"])
        ;

    }

    std::string SetSyncTime::documentation() const { return Documentation; }


    int SetSyncTime::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    double SetSyncTime::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void SetSyncTime::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSyncTime
///
#include "gen/GetSyncTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSyncTime::CmdName = "GetSyncTime";
    const char* const GetSyncTime::Documentation = "Get time delay to start streaming, in order to allign PPS out Signal with RF.\n2000 ms is a calibrated value.";

    REGISTER_COMMAND_FACTORY(GetSyncTime);


    GetSyncTime::GetSyncTime()
      : CommandBase(CmdName)
    {

    }


    GetSyncTimePtr GetSyncTime::create()
    {
      return GetSyncTimePtr(new GetSyncTime());
    }

    GetSyncTimePtr GetSyncTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSyncTime>(ptr);
    }

    bool GetSyncTime::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSyncTime::documentation() const { return Documentation; }


    int GetSyncTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetSyncTimeResult
///
#include "gen/GetSyncTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSyncTimeResult::CmdName = "GetSyncTimeResult";
    const char* const GetSyncTimeResult::Documentation = "Result of GetSyncTime";

    REGISTER_COMMAND_RESULT_FACTORY(GetSyncTimeResult);


    GetSyncTimeResult::GetSyncTimeResult()
      : CommandResult(CmdName)
    {}

    GetSyncTimeResult::GetSyncTimeResult(CommandBasePtr relatedCommand, double time)
      : CommandResult(CmdName, relatedCommand)
    {

      setTime(time);
    }


    GetSyncTimeResultPtr GetSyncTimeResult::create(CommandBasePtr relatedCommand, double time)
    {
      return GetSyncTimeResultPtr(new GetSyncTimeResult(relatedCommand, time));
    }

    GetSyncTimeResultPtr GetSyncTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSyncTimeResult>(ptr);
    }

    bool GetSyncTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Time"])
        ;

    }

    std::string GetSyncTimeResult::documentation() const { return Documentation; }


    double GetSyncTimeResult::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void GetSyncTimeResult::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSyncTimeMaster
///
#include "gen/SetSyncTimeMaster.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSyncTimeMaster::CmdName = "SetSyncTimeMaster";
    const char* const SetSyncTimeMaster::Documentation = "Set time delay to start streaming after PPS synchronization. A value of 1500\nmeans the simulation will start streaming 1.5 sec after the PPS used for\nsynchornization.";

    REGISTER_COMMAND_FACTORY(SetSyncTimeMaster);


    SetSyncTimeMaster::SetSyncTimeMaster()
      : CommandBase(CmdName)
    {}

    SetSyncTimeMaster::SetSyncTimeMaster(double time)
      : CommandBase(CmdName)
    {

      setTime(time);
    }


    SetSyncTimeMasterPtr SetSyncTimeMaster::create(double time)
    {
      return SetSyncTimeMasterPtr(new SetSyncTimeMaster(time));
    }

    SetSyncTimeMasterPtr SetSyncTimeMaster::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSyncTimeMaster>(ptr);
    }

    bool SetSyncTimeMaster::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Time"])
        ;

    }

    std::string SetSyncTimeMaster::documentation() const { return Documentation; }


    int SetSyncTimeMaster::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    double SetSyncTimeMaster::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void SetSyncTimeMaster::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSyncTimeMaster
///
#include "gen/GetSyncTimeMaster.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSyncTimeMaster::CmdName = "GetSyncTimeMaster";
    const char* const GetSyncTimeMaster::Documentation = "Get time delay to start streaming after PPS synchronization. A value of 1500\nmeans the simulation will start streaming 1.5 sec after the PPS used for\nsynchornization.";

    REGISTER_COMMAND_FACTORY(GetSyncTimeMaster);


    GetSyncTimeMaster::GetSyncTimeMaster()
      : CommandBase(CmdName)
    {

    }


    GetSyncTimeMasterPtr GetSyncTimeMaster::create()
    {
      return GetSyncTimeMasterPtr(new GetSyncTimeMaster());
    }

    GetSyncTimeMasterPtr GetSyncTimeMaster::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSyncTimeMaster>(ptr);
    }

    bool GetSyncTimeMaster::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSyncTimeMaster::documentation() const { return Documentation; }


    int GetSyncTimeMaster::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetSyncTimeMasterResult
///
#include "gen/GetSyncTimeMasterResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSyncTimeMasterResult::CmdName = "GetSyncTimeMasterResult";
    const char* const GetSyncTimeMasterResult::Documentation = "Result of GetSyncTimeMaster";

    REGISTER_COMMAND_RESULT_FACTORY(GetSyncTimeMasterResult);


    GetSyncTimeMasterResult::GetSyncTimeMasterResult()
      : CommandResult(CmdName)
    {}

    GetSyncTimeMasterResult::GetSyncTimeMasterResult(CommandBasePtr relatedCommand, double time)
      : CommandResult(CmdName, relatedCommand)
    {

      setTime(time);
    }


    GetSyncTimeMasterResultPtr GetSyncTimeMasterResult::create(CommandBasePtr relatedCommand, double time)
    {
      return GetSyncTimeMasterResultPtr(new GetSyncTimeMasterResult(relatedCommand, time));
    }

    GetSyncTimeMasterResultPtr GetSyncTimeMasterResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSyncTimeMasterResult>(ptr);
    }

    bool GetSyncTimeMasterResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Time"])
        ;

    }

    std::string GetSyncTimeMasterResult::documentation() const { return Documentation; }


    double GetSyncTimeMasterResult::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void GetSyncTimeMasterResult::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of StopWhenCommandFail
///
#include "gen/StopWhenCommandFail.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const StopWhenCommandFail::CmdName = "StopWhenCommandFail";
    const char* const StopWhenCommandFail::Documentation = "Set If enabled, simulation stops when a command result fail.";

    REGISTER_COMMAND_FACTORY(StopWhenCommandFail);


    StopWhenCommandFail::StopWhenCommandFail()
      : CommandBase(CmdName)
    {}

    StopWhenCommandFail::StopWhenCommandFail(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    StopWhenCommandFailPtr StopWhenCommandFail::create(bool enabled)
    {
      return StopWhenCommandFailPtr(new StopWhenCommandFail(enabled));
    }

    StopWhenCommandFailPtr StopWhenCommandFail::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<StopWhenCommandFail>(ptr);
    }

    bool StopWhenCommandFail::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string StopWhenCommandFail::documentation() const { return Documentation; }


    int StopWhenCommandFail::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool StopWhenCommandFail::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void StopWhenCommandFail::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSimStopWhenCommandFailEnabled
///
#include "gen/IsSimStopWhenCommandFailEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSimStopWhenCommandFailEnabled::CmdName = "IsSimStopWhenCommandFailEnabled";
    const char* const IsSimStopWhenCommandFailEnabled::Documentation = "Get If enabled, simulation stops when a command result fail.";

    REGISTER_COMMAND_FACTORY(IsSimStopWhenCommandFailEnabled);


    IsSimStopWhenCommandFailEnabled::IsSimStopWhenCommandFailEnabled()
      : CommandBase(CmdName)
    {

    }


    IsSimStopWhenCommandFailEnabledPtr IsSimStopWhenCommandFailEnabled::create()
    {
      return IsSimStopWhenCommandFailEnabledPtr(new IsSimStopWhenCommandFailEnabled());
    }

    IsSimStopWhenCommandFailEnabledPtr IsSimStopWhenCommandFailEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSimStopWhenCommandFailEnabled>(ptr);
    }

    bool IsSimStopWhenCommandFailEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsSimStopWhenCommandFailEnabled::documentation() const { return Documentation; }


    int IsSimStopWhenCommandFailEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsSimStopWhenCommandFailEnabledResult
///
#include "gen/IsSimStopWhenCommandFailEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSimStopWhenCommandFailEnabledResult::CmdName = "IsSimStopWhenCommandFailEnabledResult";
    const char* const IsSimStopWhenCommandFailEnabledResult::Documentation = "Result of IsSimStopWhenCommandFailEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsSimStopWhenCommandFailEnabledResult);


    IsSimStopWhenCommandFailEnabledResult::IsSimStopWhenCommandFailEnabledResult()
      : CommandResult(CmdName)
    {}

    IsSimStopWhenCommandFailEnabledResult::IsSimStopWhenCommandFailEnabledResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsSimStopWhenCommandFailEnabledResultPtr IsSimStopWhenCommandFailEnabledResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsSimStopWhenCommandFailEnabledResultPtr(new IsSimStopWhenCommandFailEnabledResult(relatedCommand, enabled));
    }

    IsSimStopWhenCommandFailEnabledResultPtr IsSimStopWhenCommandFailEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSimStopWhenCommandFailEnabledResult>(ptr);
    }

    bool IsSimStopWhenCommandFailEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSimStopWhenCommandFailEnabledResult::documentation() const { return Documentation; }


    bool IsSimStopWhenCommandFailEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSimStopWhenCommandFailEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of StopMasterWhenSlaveStop
///
#include "gen/StopMasterWhenSlaveStop.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const StopMasterWhenSlaveStop::CmdName = "StopMasterWhenSlaveStop";
    const char* const StopMasterWhenSlaveStop::Documentation = "Set If enabled, master and all the slaves will stop if a slave stop.";

    REGISTER_COMMAND_FACTORY(StopMasterWhenSlaveStop);


    StopMasterWhenSlaveStop::StopMasterWhenSlaveStop()
      : CommandBase(CmdName)
    {}

    StopMasterWhenSlaveStop::StopMasterWhenSlaveStop(bool enabled)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
    }


    StopMasterWhenSlaveStopPtr StopMasterWhenSlaveStop::create(bool enabled)
    {
      return StopMasterWhenSlaveStopPtr(new StopMasterWhenSlaveStop(enabled));
    }

    StopMasterWhenSlaveStopPtr StopMasterWhenSlaveStop::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<StopMasterWhenSlaveStop>(ptr);
    }

    bool StopMasterWhenSlaveStop::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string StopMasterWhenSlaveStop::documentation() const { return Documentation; }


    int StopMasterWhenSlaveStop::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    bool StopMasterWhenSlaveStop::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void StopMasterWhenSlaveStop::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsStopMasterWhenSlaveStop
///
#include "gen/IsStopMasterWhenSlaveStop.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsStopMasterWhenSlaveStop::CmdName = "IsStopMasterWhenSlaveStop";
    const char* const IsStopMasterWhenSlaveStop::Documentation = "Get If enabled, master and all the slaves will stop if a slave stop.";

    REGISTER_COMMAND_FACTORY(IsStopMasterWhenSlaveStop);


    IsStopMasterWhenSlaveStop::IsStopMasterWhenSlaveStop()
      : CommandBase(CmdName)
    {

    }


    IsStopMasterWhenSlaveStopPtr IsStopMasterWhenSlaveStop::create()
    {
      return IsStopMasterWhenSlaveStopPtr(new IsStopMasterWhenSlaveStop());
    }

    IsStopMasterWhenSlaveStopPtr IsStopMasterWhenSlaveStop::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsStopMasterWhenSlaveStop>(ptr);
    }

    bool IsStopMasterWhenSlaveStop::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsStopMasterWhenSlaveStop::documentation() const { return Documentation; }


    int IsStopMasterWhenSlaveStop::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsStopMasterWhenSlaveStopResult
///
#include "gen/IsStopMasterWhenSlaveStopResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsStopMasterWhenSlaveStopResult::CmdName = "IsStopMasterWhenSlaveStopResult";
    const char* const IsStopMasterWhenSlaveStopResult::Documentation = "Result of IsStopMasterWhenSlaveStop";

    REGISTER_COMMAND_RESULT_FACTORY(IsStopMasterWhenSlaveStopResult);


    IsStopMasterWhenSlaveStopResult::IsStopMasterWhenSlaveStopResult()
      : CommandResult(CmdName)
    {}

    IsStopMasterWhenSlaveStopResult::IsStopMasterWhenSlaveStopResult(CommandBasePtr relatedCommand, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setEnabled(enabled);
    }


    IsStopMasterWhenSlaveStopResultPtr IsStopMasterWhenSlaveStopResult::create(CommandBasePtr relatedCommand, bool enabled)
    {
      return IsStopMasterWhenSlaveStopResultPtr(new IsStopMasterWhenSlaveStopResult(relatedCommand, enabled));
    }

    IsStopMasterWhenSlaveStopResultPtr IsStopMasterWhenSlaveStopResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsStopMasterWhenSlaveStopResult>(ptr);
    }

    bool IsStopMasterWhenSlaveStopResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsStopMasterWhenSlaveStopResult::documentation() const { return Documentation; }


    bool IsStopMasterWhenSlaveStopResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsStopMasterWhenSlaveStopResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ShowMapAnalysis
///
#include "gen/ShowMapAnalysis.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ShowMapAnalysis::CmdName = "ShowMapAnalysis";
    const char* const ShowMapAnalysis::Documentation = "Set if map is show/hide in Analysis tab.";

    REGISTER_COMMAND_FACTORY(ShowMapAnalysis);


    ShowMapAnalysis::ShowMapAnalysis()
      : CommandBase(CmdName)
    {}

    ShowMapAnalysis::ShowMapAnalysis(bool show)
      : CommandBase(CmdName)
    {

      setShow(show);
    }


    ShowMapAnalysisPtr ShowMapAnalysis::create(bool show)
    {
      return ShowMapAnalysisPtr(new ShowMapAnalysis(show));
    }

    ShowMapAnalysisPtr ShowMapAnalysis::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ShowMapAnalysis>(ptr);
    }

    bool ShowMapAnalysis::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Show"])
        ;

    }

    std::string ShowMapAnalysis::documentation() const { return Documentation; }


    int ShowMapAnalysis::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    bool ShowMapAnalysis::show() const
    {
      return parse_json<bool>::parse(m_values["Show"]);
    }

    void ShowMapAnalysis::setShow(bool show)
    {
      m_values.AddMember("Show", parse_json<bool>::format(show, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsMapAnalysisEnabled
///
#include "gen/IsMapAnalysisEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsMapAnalysisEnabled::CmdName = "IsMapAnalysisEnabled";
    const char* const IsMapAnalysisEnabled::Documentation = "Get if map is show/hide in Analysis tab.";

    REGISTER_COMMAND_FACTORY(IsMapAnalysisEnabled);


    IsMapAnalysisEnabled::IsMapAnalysisEnabled()
      : CommandBase(CmdName)
    {

    }


    IsMapAnalysisEnabledPtr IsMapAnalysisEnabled::create()
    {
      return IsMapAnalysisEnabledPtr(new IsMapAnalysisEnabled());
    }

    IsMapAnalysisEnabledPtr IsMapAnalysisEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsMapAnalysisEnabled>(ptr);
    }

    bool IsMapAnalysisEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsMapAnalysisEnabled::documentation() const { return Documentation; }


    int IsMapAnalysisEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsMapAnalysisEnabledResult
///
#include "gen/IsMapAnalysisEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsMapAnalysisEnabledResult::CmdName = "IsMapAnalysisEnabledResult";
    const char* const IsMapAnalysisEnabledResult::Documentation = "Result of IsMapAnalysisEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsMapAnalysisEnabledResult);


    IsMapAnalysisEnabledResult::IsMapAnalysisEnabledResult()
      : CommandResult(CmdName)
    {}

    IsMapAnalysisEnabledResult::IsMapAnalysisEnabledResult(CommandBasePtr relatedCommand, bool show)
      : CommandResult(CmdName, relatedCommand)
    {

      setShow(show);
    }


    IsMapAnalysisEnabledResultPtr IsMapAnalysisEnabledResult::create(CommandBasePtr relatedCommand, bool show)
    {
      return IsMapAnalysisEnabledResultPtr(new IsMapAnalysisEnabledResult(relatedCommand, show));
    }

    IsMapAnalysisEnabledResultPtr IsMapAnalysisEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsMapAnalysisEnabledResult>(ptr);
    }

    bool IsMapAnalysisEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Show"])
        ;

    }

    std::string IsMapAnalysisEnabledResult::documentation() const { return Documentation; }


    bool IsMapAnalysisEnabledResult::show() const
    {
      return parse_json<bool>::parse(m_values["Show"]);
    }

    void IsMapAnalysisEnabledResult::setShow(bool show)
    {
      m_values.AddMember("Show", parse_json<bool>::format(show, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpectrumVisible
///
#include "gen/SetSpectrumVisible.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpectrumVisible::CmdName = "SetSpectrumVisible";
    const char* const SetSpectrumVisible::Documentation = "Set if spectrums are show/hide.";

    REGISTER_COMMAND_FACTORY(SetSpectrumVisible);


    SetSpectrumVisible::SetSpectrumVisible()
      : CommandBase(CmdName)
    {}

    SetSpectrumVisible::SetSpectrumVisible(bool visible)
      : CommandBase(CmdName)
    {

      setVisible(visible);
    }


    SetSpectrumVisiblePtr SetSpectrumVisible::create(bool visible)
    {
      return SetSpectrumVisiblePtr(new SetSpectrumVisible(visible));
    }

    SetSpectrumVisiblePtr SetSpectrumVisible::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpectrumVisible>(ptr);
    }

    bool SetSpectrumVisible::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Visible"])
        ;

    }

    std::string SetSpectrumVisible::documentation() const { return Documentation; }


    int SetSpectrumVisible::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    bool SetSpectrumVisible::visible() const
    {
      return parse_json<bool>::parse(m_values["Visible"]);
    }

    void SetSpectrumVisible::setVisible(bool visible)
    {
      m_values.AddMember("Visible", parse_json<bool>::format(visible, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpectrumVisible
///
#include "gen/IsSpectrumVisible.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpectrumVisible::CmdName = "IsSpectrumVisible";
    const char* const IsSpectrumVisible::Documentation = "Get if spectrums are show/hide.";

    REGISTER_COMMAND_FACTORY(IsSpectrumVisible);


    IsSpectrumVisible::IsSpectrumVisible()
      : CommandBase(CmdName)
    {

    }


    IsSpectrumVisiblePtr IsSpectrumVisible::create()
    {
      return IsSpectrumVisiblePtr(new IsSpectrumVisible());
    }

    IsSpectrumVisiblePtr IsSpectrumVisible::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpectrumVisible>(ptr);
    }

    bool IsSpectrumVisible::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsSpectrumVisible::documentation() const { return Documentation; }


    int IsSpectrumVisible::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsSpectrumVisibleResult
///
#include "gen/IsSpectrumVisibleResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpectrumVisibleResult::CmdName = "IsSpectrumVisibleResult";
    const char* const IsSpectrumVisibleResult::Documentation = "Result of IsSpectrumVisible";

    REGISTER_COMMAND_RESULT_FACTORY(IsSpectrumVisibleResult);


    IsSpectrumVisibleResult::IsSpectrumVisibleResult()
      : CommandResult(CmdName)
    {}

    IsSpectrumVisibleResult::IsSpectrumVisibleResult(CommandBasePtr relatedCommand, bool visible)
      : CommandResult(CmdName, relatedCommand)
    {

      setVisible(visible);
    }


    IsSpectrumVisibleResultPtr IsSpectrumVisibleResult::create(CommandBasePtr relatedCommand, bool visible)
    {
      return IsSpectrumVisibleResultPtr(new IsSpectrumVisibleResult(relatedCommand, visible));
    }

    IsSpectrumVisibleResultPtr IsSpectrumVisibleResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpectrumVisibleResult>(ptr);
    }

    bool IsSpectrumVisibleResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Visible"])
        ;

    }

    std::string IsSpectrumVisibleResult::documentation() const { return Documentation; }


    bool IsSpectrumVisibleResult::visible() const
    {
      return parse_json<bool>::parse(m_values["Visible"]);
    }

    void IsSpectrumVisibleResult::setVisible(bool visible)
    {
      m_values.AddMember("Visible", parse_json<bool>::format(visible, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSimulatorState
///
#include "gen/GetSimulatorState.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSimulatorState::CmdName = "GetSimulatorState";
    const char* const GetSimulatorState::Documentation = "Ask current simulator state. Will return a SimulatorStateResult.";

    REGISTER_COMMAND_FACTORY(GetSimulatorState);


    GetSimulatorState::GetSimulatorState()
      : CommandBase(CmdName)
    {

    }


    GetSimulatorStatePtr GetSimulatorState::create()
    {
      return GetSimulatorStatePtr(new GetSimulatorState());
    }

    GetSimulatorStatePtr GetSimulatorState::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSimulatorState>(ptr);
    }

    bool GetSimulatorState::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSimulatorState::documentation() const { return Documentation; }


    int GetSimulatorState::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of WaitSimulatorState
///
#include "gen/WaitSimulatorState.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const WaitSimulatorState::CmdName = "WaitSimulatorState";
    const char* const WaitSimulatorState::Documentation = "Wait until simulator has reached the specified substate unless simulator goes to error state or specified failure substate. Will return a SimulatorStateResult.\nPossible substates are :\n-None\n-Incomplete\n-Ready\n-Initializing\n-Armed\n-Streaming RF\n-Sync Slave\n-WF Init (Slave)\n-WF Init (Master)\n-HIL Sync\n-Sync Init\n-Sync PPS Reset\n-Sync Start Time\n-Sync Start\n-Error";

    REGISTER_COMMAND_FACTORY(WaitSimulatorState);


    WaitSimulatorState::WaitSimulatorState()
      : CommandBase(CmdName)
    {}

    WaitSimulatorState::WaitSimulatorState(const std::string& state, const std::string& failureState)
      : CommandBase(CmdName)
    {

      setState(state);
      setFailureState(failureState);
    }


    WaitSimulatorStatePtr WaitSimulatorState::create(const std::string& state, const std::string& failureState)
    {
      return WaitSimulatorStatePtr(new WaitSimulatorState(state, failureState));
    }

    WaitSimulatorStatePtr WaitSimulatorState::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<WaitSimulatorState>(ptr);
    }

    bool WaitSimulatorState::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["State"])
          && parse_json<std::string>::is_valid(m_values["FailureState"])
        ;

    }

    std::string WaitSimulatorState::documentation() const { return Documentation; }


    int WaitSimulatorState::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::string WaitSimulatorState::state() const
    {
      return parse_json<std::string>::parse(m_values["State"]);
    }

    void WaitSimulatorState::setState(const std::string& state)
    {
      m_values.AddMember("State", parse_json<std::string>::format(state, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string WaitSimulatorState::failureState() const
    {
      return parse_json<std::string>::parse(m_values["FailureState"]);
    }

    void WaitSimulatorState::setFailureState(const std::string& failureState)
    {
      m_values.AddMember("FailureState", parse_json<std::string>::format(failureState, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AbortWaitSimulatorState
///
#include "gen/AbortWaitSimulatorState.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AbortWaitSimulatorState::CmdName = "AbortWaitSimulatorState";
    const char* const AbortWaitSimulatorState::Documentation = "Abort the current WaitSimulatorState if any.";

    REGISTER_COMMAND_FACTORY(AbortWaitSimulatorState);


    AbortWaitSimulatorState::AbortWaitSimulatorState()
      : CommandBase(CmdName)
    {

    }


    AbortWaitSimulatorStatePtr AbortWaitSimulatorState::create()
    {
      return AbortWaitSimulatorStatePtr(new AbortWaitSimulatorState());
    }

    AbortWaitSimulatorStatePtr AbortWaitSimulatorState::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AbortWaitSimulatorState>(ptr);
    }

    bool AbortWaitSimulatorState::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string AbortWaitSimulatorState::documentation() const { return Documentation; }


    int AbortWaitSimulatorState::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of SimulatorStateResult
///
#include "gen/SimulatorStateResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SimulatorStateResult::CmdName = "SimulatorStateResult";
    const char* const SimulatorStateResult::Documentation = "Simulator State Result.\nPossible substates are :\n-None\n-Incomplete\n-Ready\n-Initializing\n-Armed\n-Streaming RF\n-Sync Slave\n-WF Init (Slave)\n-WF Init (Master)\n-HIL Sync\n-Sync Init\n-Sync PPS Reset\n-Sync Start Time\n-Sync Start\n-Error";

    REGISTER_COMMAND_RESULT_FACTORY(SimulatorStateResult);


    SimulatorStateResult::SimulatorStateResult()
      : CommandResult(CmdName)
    {}

    SimulatorStateResult::SimulatorStateResult(CommandBasePtr relatedCommand, const std::string& state, const std::string& error, const Sdx::SimulatorState& stateId, const Sdx::SimulatorSubState& subStateId)
      : CommandResult(CmdName, relatedCommand)
    {

      setState(state);
      setError(error);
      setStateId(stateId);
      setSubStateId(subStateId);
    }


    SimulatorStateResultPtr SimulatorStateResult::create(CommandBasePtr relatedCommand, const std::string& state, const std::string& error, const Sdx::SimulatorState& stateId, const Sdx::SimulatorSubState& subStateId)
    {
      return SimulatorStateResultPtr(new SimulatorStateResult(relatedCommand, state, error, stateId, subStateId));
    }

    SimulatorStateResultPtr SimulatorStateResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SimulatorStateResult>(ptr);
    }

    bool SimulatorStateResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["State"])
          && parse_json<std::string>::is_valid(m_values["Error"])
          && parse_json<Sdx::SimulatorState>::is_valid(m_values["StateId"])
          && parse_json<Sdx::SimulatorSubState>::is_valid(m_values["SubStateId"])
        ;

    }

    std::string SimulatorStateResult::documentation() const { return Documentation; }


    std::string SimulatorStateResult::state() const
    {
      return parse_json<std::string>::parse(m_values["State"]);
    }

    void SimulatorStateResult::setState(const std::string& state)
    {
      m_values.AddMember("State", parse_json<std::string>::format(state, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SimulatorStateResult::error() const
    {
      return parse_json<std::string>::parse(m_values["Error"]);
    }

    void SimulatorStateResult::setError(const std::string& error)
    {
      m_values.AddMember("Error", parse_json<std::string>::format(error, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::SimulatorState SimulatorStateResult::stateId() const
    {
      return parse_json<Sdx::SimulatorState>::parse(m_values["StateId"]);
    }

    void SimulatorStateResult::setStateId(const Sdx::SimulatorState& stateId)
    {
      m_values.AddMember("StateId", parse_json<Sdx::SimulatorState>::format(stateId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::SimulatorSubState SimulatorStateResult::subStateId() const
    {
      return parse_json<Sdx::SimulatorSubState>::parse(m_values["SubStateId"]);
    }

    void SimulatorStateResult::setSubStateId(const Sdx::SimulatorSubState& subStateId)
    {
      m_values.AddMember("SubStateId", parse_json<Sdx::SimulatorSubState>::format(subStateId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BeginVehicleInfo
///
#include "gen/BeginVehicleInfo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BeginVehicleInfo::CmdName = "BeginVehicleInfo";
    const char* const BeginVehicleInfo::Documentation = "Begin receiving simulated vehicle informations. \nDuring simulation, you must call RemoteSimulator.lastVehicleInfo to get current simulation statistics or RemoteSimulator.nextVehicleInfo to get pending simulation statistics";

    REGISTER_COMMAND_FACTORY(BeginVehicleInfo);


    BeginVehicleInfo::BeginVehicleInfo()
      : CommandBase(CmdName)
    {

    }


    BeginVehicleInfoPtr BeginVehicleInfo::create()
    {
      return BeginVehicleInfoPtr(new BeginVehicleInfo());
    }

    BeginVehicleInfoPtr BeginVehicleInfo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BeginVehicleInfo>(ptr);
    }

    bool BeginVehicleInfo::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string BeginVehicleInfo::documentation() const { return Documentation; }


    int BeginVehicleInfo::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of EndVehicleInfo
///
#include "gen/EndVehicleInfo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EndVehicleInfo::CmdName = "EndVehicleInfo";
    const char* const EndVehicleInfo::Documentation = "End receiving simulated vehicle informations.";

    REGISTER_COMMAND_FACTORY(EndVehicleInfo);


    EndVehicleInfo::EndVehicleInfo()
      : CommandBase(CmdName)
    {

    }


    EndVehicleInfoPtr EndVehicleInfo::create()
    {
      return EndVehicleInfoPtr(new EndVehicleInfo());
    }

    EndVehicleInfoPtr EndVehicleInfo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EndVehicleInfo>(ptr);
    }

    bool EndVehicleInfo::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string EndVehicleInfo::documentation() const { return Documentation; }


    int EndVehicleInfo::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of MessageSequenceInsert
///
#include "gen/MessageSequenceInsert.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const MessageSequenceInsert::CmdName = "MessageSequenceInsert";
    const char* const MessageSequenceInsert::Documentation = "Insert message to sequence.";

    REGISTER_COMMAND_FACTORY(MessageSequenceInsert);


    MessageSequenceInsert::MessageSequenceInsert()
      : CommandBase(CmdName)
    {}

    MessageSequenceInsert::MessageSequenceInsert(const std::string& signal, int index, int type)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setIndex(index);
      setType(type);
    }


    MessageSequenceInsertPtr MessageSequenceInsert::create(const std::string& signal, int index, int type)
    {
      return MessageSequenceInsertPtr(new MessageSequenceInsert(signal, index, type));
    }

    MessageSequenceInsertPtr MessageSequenceInsert::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<MessageSequenceInsert>(ptr);
    }

    bool MessageSequenceInsert::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Index"])
          && parse_json<int>::is_valid(m_values["Type"])
        ;

    }

    std::string MessageSequenceInsert::documentation() const { return Documentation; }


    int MessageSequenceInsert::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string MessageSequenceInsert::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void MessageSequenceInsert::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceInsert::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void MessageSequenceInsert::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceInsert::type() const
    {
      return parse_json<int>::parse(m_values["Type"]);
    }

    void MessageSequenceInsert::setType(int type)
    {
      m_values.AddMember("Type", parse_json<int>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of MessageSequenceRemove
///
#include "gen/MessageSequenceRemove.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const MessageSequenceRemove::CmdName = "MessageSequenceRemove";
    const char* const MessageSequenceRemove::Documentation = "Remove message from sequence.";

    REGISTER_COMMAND_FACTORY(MessageSequenceRemove);


    MessageSequenceRemove::MessageSequenceRemove()
      : CommandBase(CmdName)
    {}

    MessageSequenceRemove::MessageSequenceRemove(const std::string& signal, int index)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setIndex(index);
    }


    MessageSequenceRemovePtr MessageSequenceRemove::create(const std::string& signal, int index)
    {
      return MessageSequenceRemovePtr(new MessageSequenceRemove(signal, index));
    }

    MessageSequenceRemovePtr MessageSequenceRemove::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<MessageSequenceRemove>(ptr);
    }

    bool MessageSequenceRemove::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Index"])
        ;

    }

    std::string MessageSequenceRemove::documentation() const { return Documentation; }


    int MessageSequenceRemove::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string MessageSequenceRemove::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void MessageSequenceRemove::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceRemove::index() const
    {
      return parse_json<int>::parse(m_values["Index"]);
    }

    void MessageSequenceRemove::setIndex(int index)
    {
      m_values.AddMember("Index", parse_json<int>::format(index, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of MessageSequenceSwap
///
#include "gen/MessageSequenceSwap.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const MessageSequenceSwap::CmdName = "MessageSequenceSwap";
    const char* const MessageSequenceSwap::Documentation = "Swap 2 messages in sequence.";

    REGISTER_COMMAND_FACTORY(MessageSequenceSwap);


    MessageSequenceSwap::MessageSequenceSwap()
      : CommandBase(CmdName)
    {}

    MessageSequenceSwap::MessageSequenceSwap(const std::string& signal, int indexI, int indexJ)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setIndexI(indexI);
      setIndexJ(indexJ);
    }


    MessageSequenceSwapPtr MessageSequenceSwap::create(const std::string& signal, int indexI, int indexJ)
    {
      return MessageSequenceSwapPtr(new MessageSequenceSwap(signal, indexI, indexJ));
    }

    MessageSequenceSwapPtr MessageSequenceSwap::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<MessageSequenceSwap>(ptr);
    }

    bool MessageSequenceSwap::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["IndexI"])
          && parse_json<int>::is_valid(m_values["IndexJ"])
        ;

    }

    std::string MessageSequenceSwap::documentation() const { return Documentation; }


    int MessageSequenceSwap::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string MessageSequenceSwap::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void MessageSequenceSwap::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceSwap::indexI() const
    {
      return parse_json<int>::parse(m_values["IndexI"]);
    }

    void MessageSequenceSwap::setIndexI(int indexI)
    {
      m_values.AddMember("IndexI", parse_json<int>::format(indexI, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int MessageSequenceSwap::indexJ() const
    {
      return parse_json<int>::parse(m_values["IndexJ"]);
    }

    void MessageSequenceSwap::setIndexJ(int indexJ)
    {
      m_values.AddMember("IndexJ", parse_json<int>::format(indexJ, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of MessageSequenceImport
///
#include "gen/MessageSequenceImport.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const MessageSequenceImport::CmdName = "MessageSequenceImport";
    const char* const MessageSequenceImport::Documentation = "Import a sequence file.\nA sequence file is a CSV with one message type per line.";

    REGISTER_COMMAND_FACTORY(MessageSequenceImport);


    MessageSequenceImport::MessageSequenceImport()
      : CommandBase(CmdName)
    {}

    MessageSequenceImport::MessageSequenceImport(const std::string& signal, const std::string& filename)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setFilename(filename);
    }


    MessageSequenceImportPtr MessageSequenceImport::create(const std::string& signal, const std::string& filename)
    {
      return MessageSequenceImportPtr(new MessageSequenceImport(signal, filename));
    }

    MessageSequenceImportPtr MessageSequenceImport::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<MessageSequenceImport>(ptr);
    }

    bool MessageSequenceImport::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::string>::is_valid(m_values["Filename"])
        ;

    }

    std::string MessageSequenceImport::documentation() const { return Documentation; }


    int MessageSequenceImport::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string MessageSequenceImport::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void MessageSequenceImport::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string MessageSequenceImport::filename() const
    {
      return parse_json<std::string>::parse(m_values["Filename"]);
    }

    void MessageSequenceImport::setFilename(const std::string& filename)
    {
      m_values.AddMember("Filename", parse_json<std::string>::format(filename, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageSequence
///
#include "gen/GetMessageSequence.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageSequence::CmdName = "GetMessageSequence";
    const char* const GetMessageSequence::Documentation = "Get the messages sequence for the signal";

    REGISTER_COMMAND_FACTORY(GetMessageSequence);


    GetMessageSequence::GetMessageSequence()
      : CommandBase(CmdName)
    {}

    GetMessageSequence::GetMessageSequence(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetMessageSequencePtr GetMessageSequence::create(const std::string& signal)
    {
      return GetMessageSequencePtr(new GetMessageSequence(signal));
    }

    GetMessageSequencePtr GetMessageSequence::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageSequence>(ptr);
    }

    bool GetMessageSequence::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetMessageSequence::documentation() const { return Documentation; }


    int GetMessageSequence::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageSequence::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetMessageSequence::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageSequenceResult
///
#include "gen/GetMessageSequenceResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageSequenceResult::CmdName = "GetMessageSequenceResult";
    const char* const GetMessageSequenceResult::Documentation = "Result of GetMessageSequence";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageSequenceResult);


    GetMessageSequenceResult::GetMessageSequenceResult()
      : CommandResult(CmdName)
    {}

    GetMessageSequenceResult::GetMessageSequenceResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<int>& sequence)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setSequence(sequence);
    }


    GetMessageSequenceResultPtr GetMessageSequenceResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<int>& sequence)
    {
      return GetMessageSequenceResultPtr(new GetMessageSequenceResult(relatedCommand, signal, sequence));
    }

    GetMessageSequenceResultPtr GetMessageSequenceResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageSequenceResult>(ptr);
    }

    bool GetMessageSequenceResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<int>>::is_valid(m_values["Sequence"])
        ;

    }

    std::string GetMessageSequenceResult::documentation() const { return Documentation; }


    std::string GetMessageSequenceResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetMessageSequenceResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetMessageSequenceResult::sequence() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Sequence"]);
    }

    void GetMessageSequenceResult::setSequence(const std::vector<int>& sequence)
    {
      m_values.AddMember("Sequence", parse_json<std::vector<int>>::format(sequence, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoFnavSatelliteK
///
#include "gen/SetGalileoFnavSatelliteK.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoFnavSatelliteK::CmdName = "SetGalileoFnavSatelliteK";
    const char* const SetGalileoFnavSatelliteK::Documentation = "Set the almanac satellite id for subframe 1 (Parameter K described in ICD 4.2.3 Frame Layout).";

    REGISTER_COMMAND_FACTORY(SetGalileoFnavSatelliteK);


    SetGalileoFnavSatelliteK::SetGalileoFnavSatelliteK()
      : CommandBase(CmdName)
    {}

    SetGalileoFnavSatelliteK::SetGalileoFnavSatelliteK(int prn, int k)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setK(k);
    }


    SetGalileoFnavSatelliteKPtr SetGalileoFnavSatelliteK::create(int prn, int k)
    {
      return SetGalileoFnavSatelliteKPtr(new SetGalileoFnavSatelliteK(prn, k));
    }

    SetGalileoFnavSatelliteKPtr SetGalileoFnavSatelliteK::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoFnavSatelliteK>(ptr);
    }

    bool SetGalileoFnavSatelliteK::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["K"])
        ;

    }

    std::string SetGalileoFnavSatelliteK::documentation() const { return Documentation; }


    int SetGalileoFnavSatelliteK::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGalileoFnavSatelliteK::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoFnavSatelliteK::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoFnavSatelliteK::k() const
    {
      return parse_json<int>::parse(m_values["K"]);
    }

    void SetGalileoFnavSatelliteK::setK(int k)
    {
      m_values.AddMember("K", parse_json<int>::format(k, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoFnavSatelliteK
///
#include "gen/GetGalileoFnavSatelliteK.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoFnavSatelliteK::CmdName = "GetGalileoFnavSatelliteK";
    const char* const GetGalileoFnavSatelliteK::Documentation = "Get the almanac satellite id for subframe 1 (Parameter K described in ICD 4.2.3 Frame Layout).";

    REGISTER_COMMAND_FACTORY(GetGalileoFnavSatelliteK);


    GetGalileoFnavSatelliteK::GetGalileoFnavSatelliteK()
      : CommandBase(CmdName)
    {}

    GetGalileoFnavSatelliteK::GetGalileoFnavSatelliteK(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGalileoFnavSatelliteKPtr GetGalileoFnavSatelliteK::create(int prn)
    {
      return GetGalileoFnavSatelliteKPtr(new GetGalileoFnavSatelliteK(prn));
    }

    GetGalileoFnavSatelliteKPtr GetGalileoFnavSatelliteK::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoFnavSatelliteK>(ptr);
    }

    bool GetGalileoFnavSatelliteK::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGalileoFnavSatelliteK::documentation() const { return Documentation; }


    int GetGalileoFnavSatelliteK::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoFnavSatelliteK::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoFnavSatelliteK::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoFnavSatelliteKResult
///
#include "gen/GetGalileoFnavSatelliteKResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoFnavSatelliteKResult::CmdName = "GetGalileoFnavSatelliteKResult";
    const char* const GetGalileoFnavSatelliteKResult::Documentation = "Result of GetGalileoFnavSatelliteK";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoFnavSatelliteKResult);


    GetGalileoFnavSatelliteKResult::GetGalileoFnavSatelliteKResult()
      : CommandResult(CmdName)
    {}

    GetGalileoFnavSatelliteKResult::GetGalileoFnavSatelliteKResult(CommandBasePtr relatedCommand, int prn, int k)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setK(k);
    }


    GetGalileoFnavSatelliteKResultPtr GetGalileoFnavSatelliteKResult::create(CommandBasePtr relatedCommand, int prn, int k)
    {
      return GetGalileoFnavSatelliteKResultPtr(new GetGalileoFnavSatelliteKResult(relatedCommand, prn, k));
    }

    GetGalileoFnavSatelliteKResultPtr GetGalileoFnavSatelliteKResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoFnavSatelliteKResult>(ptr);
    }

    bool GetGalileoFnavSatelliteKResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["K"])
        ;

    }

    std::string GetGalileoFnavSatelliteKResult::documentation() const { return Documentation; }


    int GetGalileoFnavSatelliteKResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoFnavSatelliteKResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoFnavSatelliteKResult::k() const
    {
      return parse_json<int>::parse(m_values["K"]);
    }

    void GetGalileoFnavSatelliteKResult::setK(int k)
    {
      m_values.AddMember("K", parse_json<int>::format(k, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CalibFunction
///
#include "gen/CalibFunction.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CalibFunction::CmdName = "CalibFunction";
    const char* const CalibFunction::Documentation = "Skydel special calibration function, internal use only";

    REGISTER_COMMAND_FACTORY(CalibFunction);


    CalibFunction::CalibFunction()
      : CommandBase(CmdName)
    {}

    CalibFunction::CalibFunction(int svId, const std::string& signal, bool enableSV, bool enableDoppler, double phaseOffet)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSignal(signal);
      setEnableSV(enableSV);
      setEnableDoppler(enableDoppler);
      setPhaseOffet(phaseOffet);
    }


    CalibFunctionPtr CalibFunction::create(int svId, const std::string& signal, bool enableSV, bool enableDoppler, double phaseOffet)
    {
      return CalibFunctionPtr(new CalibFunction(svId, signal, enableSV, enableDoppler, phaseOffet));
    }

    CalibFunctionPtr CalibFunction::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CalibFunction>(ptr);
    }

    bool CalibFunction::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<bool>::is_valid(m_values["EnableSV"])
          && parse_json<bool>::is_valid(m_values["EnableDoppler"])
          && parse_json<double>::is_valid(m_values["PhaseOffet"])
        ;

    }

    std::string CalibFunction::documentation() const { return Documentation; }


    int CalibFunction::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    int CalibFunction::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void CalibFunction::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string CalibFunction::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void CalibFunction::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool CalibFunction::enableSV() const
    {
      return parse_json<bool>::parse(m_values["EnableSV"]);
    }

    void CalibFunction::setEnableSV(bool enableSV)
    {
      m_values.AddMember("EnableSV", parse_json<bool>::format(enableSV, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool CalibFunction::enableDoppler() const
    {
      return parse_json<bool>::parse(m_values["EnableDoppler"]);
    }

    void CalibFunction::setEnableDoppler(bool enableDoppler)
    {
      m_values.AddMember("EnableDoppler", parse_json<bool>::format(enableDoppler, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double CalibFunction::phaseOffet() const
    {
      return parse_json<double>::parse(m_values["PhaseOffet"]);
    }

    void CalibFunction::setPhaseOffet(double phaseOffet)
    {
      m_values.AddMember("PhaseOffet", parse_json<double>::format(phaseOffet, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearStatusLog
///
#include "gen/ClearStatusLog.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearStatusLog::CmdName = "ClearStatusLog";
    const char* const ClearStatusLog::Documentation = "Clears the status log";

    REGISTER_COMMAND_FACTORY(ClearStatusLog);


    ClearStatusLog::ClearStatusLog()
      : CommandBase(CmdName)
    {

    }


    ClearStatusLogPtr ClearStatusLog::create()
    {
      return ClearStatusLogPtr(new ClearStatusLog());
    }

    ClearStatusLogPtr ClearStatusLog::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearStatusLog>(ptr);
    }

    bool ClearStatusLog::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearStatusLog::documentation() const { return Documentation; }


    int ClearStatusLog::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetStatusLog
///
#include "gen/GetStatusLog.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStatusLog::CmdName = "GetStatusLog";
    const char* const GetStatusLog::Documentation = "Returns the status log in a GetStatusLogResult and clears it";

    REGISTER_COMMAND_FACTORY(GetStatusLog);


    GetStatusLog::GetStatusLog()
      : CommandBase(CmdName)
    {

    }


    GetStatusLogPtr GetStatusLog::create()
    {
      return GetStatusLogPtr(new GetStatusLog());
    }

    GetStatusLogPtr GetStatusLog::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStatusLog>(ptr);
    }

    bool GetStatusLog::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetStatusLog::documentation() const { return Documentation; }


    int GetStatusLog::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetStatusLogResult
///
#include "gen/GetStatusLogResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetStatusLogResult::CmdName = "GetStatusLogResult";
    const char* const GetStatusLogResult::Documentation = "Represents a log, each element of the same record share the same index";

    REGISTER_COMMAND_RESULT_FACTORY(GetStatusLogResult);


    GetStatusLogResult::GetStatusLogResult()
      : CommandResult(CmdName)
    {}

    GetStatusLogResult::GetStatusLogResult(CommandBasePtr relatedCommand, const std::vector<Sdx::LogRecord>& records)
      : CommandResult(CmdName, relatedCommand)
    {

      setRecords(records);
    }


    GetStatusLogResultPtr GetStatusLogResult::create(CommandBasePtr relatedCommand, const std::vector<Sdx::LogRecord>& records)
    {
      return GetStatusLogResultPtr(new GetStatusLogResult(relatedCommand, records));
    }

    GetStatusLogResultPtr GetStatusLogResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetStatusLogResult>(ptr);
    }

    bool GetStatusLogResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<Sdx::LogRecord>>::is_valid(m_values["Records"])
        ;

    }

    std::string GetStatusLogResult::documentation() const { return Documentation; }


    std::vector<Sdx::LogRecord> GetStatusLogResult::records() const
    {
      return parse_json<std::vector<Sdx::LogRecord>>::parse(m_values["Records"]);
    }

    void GetStatusLogResult::setRecords(const std::vector<Sdx::LogRecord>& records)
    {
      m_values.AddMember("Records", parse_json<std::vector<Sdx::LogRecord>>::format(records, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CommandGroup
///
#include "gen/CommandGroup.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CommandGroup::CmdName = "CommandGroup";
    const char* const CommandGroup::Documentation = "Group multiple commands as one";

    REGISTER_COMMAND_FACTORY(CommandGroup);


    CommandGroup::CommandGroup()
      : CommandBase(CmdName)
    {}

    CommandGroup::CommandGroup(const std::vector<Sdx::CommandBasePtr>& commands)
      : CommandBase(CmdName)
    {

      setCommands(commands);
    }


    CommandGroupPtr CommandGroup::create(const std::vector<Sdx::CommandBasePtr>& commands)
    {
      return CommandGroupPtr(new CommandGroup(commands));
    }

    CommandGroupPtr CommandGroup::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CommandGroup>(ptr);
    }

    bool CommandGroup::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<Sdx::CommandBasePtr>>::is_valid(m_values["Commands"])
        ;

    }

    std::string CommandGroup::documentation() const { return Documentation; }


    int CommandGroup::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    std::vector<Sdx::CommandBasePtr> CommandGroup::commands() const
    {
      return parse_json<std::vector<Sdx::CommandBasePtr>>::parse(m_values["Commands"]);
    }

    void CommandGroup::setCommands(const std::vector<Sdx::CommandBasePtr>& commands)
    {
      m_values.AddMember("Commands", parse_json<std::vector<Sdx::CommandBasePtr>>::format(commands, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVisibleSV
///
#include "gen/GetVisibleSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVisibleSV::CmdName = "GetVisibleSV";
    const char* const GetVisibleSV::Documentation = "Get a list of visible satellites' SV IDs within a system, returns a GetVisibleSVResult";

    REGISTER_COMMAND_FACTORY(GetVisibleSV);


    GetVisibleSV::GetVisibleSV()
      : CommandBase(CmdName)
    {}

    GetVisibleSV::GetVisibleSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetVisibleSVPtr GetVisibleSV::create(const std::string& system)
    {
      return GetVisibleSVPtr(new GetVisibleSV(system));
    }

    GetVisibleSVPtr GetVisibleSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVisibleSV>(ptr);
    }

    bool GetVisibleSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetVisibleSV::documentation() const { return Documentation; }


    int GetVisibleSV::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string GetVisibleSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetVisibleSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVisibleSVResult
///
#include "gen/GetVisibleSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVisibleSVResult::CmdName = "GetVisibleSVResult";
    const char* const GetVisibleSVResult::Documentation = "Result of GetVisibleSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetVisibleSVResult);


    GetVisibleSVResult::GetVisibleSVResult()
      : CommandResult(CmdName)
    {}

    GetVisibleSVResult::GetVisibleSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<int>& svId)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetVisibleSVResultPtr GetVisibleSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<int>& svId)
    {
      return GetVisibleSVResultPtr(new GetVisibleSVResult(relatedCommand, system, svId));
    }

    GetVisibleSVResultPtr GetVisibleSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVisibleSVResult>(ptr);
    }

    bool GetVisibleSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<int>>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetVisibleSVResult::documentation() const { return Documentation; }


    std::string GetVisibleSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetVisibleSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetVisibleSVResult::svId() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvId"]);
    }

    void GetVisibleSVResult::setSvId(const std::vector<int>& svId)
    {
      m_values.AddMember("SvId", parse_json<std::vector<int>>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ArmPPS
///
#include "gen/ArmPPS.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ArmPPS::CmdName = "ArmPPS";
    const char* const ArmPPS::Documentation = "Arm the system for further PPS synchronization instructions.";

    REGISTER_COMMAND_FACTORY(ArmPPS);


    ArmPPS::ArmPPS()
      : CommandBase(CmdName)
    {

    }


    ArmPPSPtr ArmPPS::create()
    {
      return ArmPPSPtr(new ArmPPS());
    }

    ArmPPSPtr ArmPPS::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ArmPPS>(ptr);
    }

    bool ArmPPS::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ArmPPS::documentation() const { return Documentation; }


    int ArmPPS::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of WaitAndResetPPS
///
#include "gen/WaitAndResetPPS.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const WaitAndResetPPS::CmdName = "WaitAndResetPPS";
    const char* const WaitAndResetPPS::Documentation = "Ask Skydel to reset its PPS counter.";

    REGISTER_COMMAND_FACTORY(WaitAndResetPPS);


    WaitAndResetPPS::WaitAndResetPPS()
      : CommandBase(CmdName)
    {

    }


    WaitAndResetPPSPtr WaitAndResetPPS::create()
    {
      return WaitAndResetPPSPtr(new WaitAndResetPPS());
    }

    WaitAndResetPPSPtr WaitAndResetPPS::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<WaitAndResetPPS>(ptr);
    }

    bool WaitAndResetPPS::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string WaitAndResetPPS::documentation() const { return Documentation; }


    int WaitAndResetPPS::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of StartPPS
///
#include "gen/StartPPS.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const StartPPS::CmdName = "StartPPS";
    const char* const StartPPS::Documentation = "Start the simulation at the given PPS count.";

    REGISTER_COMMAND_FACTORY(StartPPS);


    StartPPS::StartPPS()
      : CommandBase(CmdName)
    {}

    StartPPS::StartPPS(int msec)
      : CommandBase(CmdName)
    {

      setMsec(msec);
    }


    StartPPSPtr StartPPS::create(int msec)
    {
      return StartPPSPtr(new StartPPS(msec));
    }

    StartPPSPtr StartPPS::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<StartPPS>(ptr);
    }

    bool StartPPS::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Msec"])
        ;

    }

    std::string StartPPS::documentation() const { return Documentation; }


    int StartPPS::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    int StartPPS::msec() const
    {
      return parse_json<int>::parse(m_values["Msec"]);
    }

    void StartPPS::setMsec(int msec)
    {
      m_values.AddMember("Msec", parse_json<int>::format(msec, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSV
///
#include "gen/EnableSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSV::CmdName = "EnableSV";
    const char* const EnableSV::Documentation = "Enable or disable a satellite for this constellation.";

    REGISTER_COMMAND_FACTORY(EnableSV);


    EnableSV::EnableSV()
      : CommandBase(CmdName)
    {}

    EnableSV::EnableSV(const std::string& system, int svId, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    EnableSVPtr EnableSV::create(const std::string& system, int svId, bool enabled)
    {
      return EnableSVPtr(new EnableSV(system, svId, enabled));
    }

    EnableSVPtr EnableSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSV>(ptr);
    }

    bool EnableSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSV::documentation() const { return Documentation; }


    int EnableSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EnableSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnableSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void EnableSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSVEnabled
///
#include "gen/IsSVEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSVEnabled::CmdName = "IsSVEnabled";
    const char* const IsSVEnabled::Documentation = "Get whether a satellite is enabled or disabled for this constellation.";

    REGISTER_COMMAND_FACTORY(IsSVEnabled);


    IsSVEnabled::IsSVEnabled()
      : CommandBase(CmdName)
    {}

    IsSVEnabled::IsSVEnabled(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    IsSVEnabledPtr IsSVEnabled::create(const std::string& system, int svId)
    {
      return IsSVEnabledPtr(new IsSVEnabled(system, svId));
    }

    IsSVEnabledPtr IsSVEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSVEnabled>(ptr);
    }

    bool IsSVEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsSVEnabled::documentation() const { return Documentation; }


    int IsSVEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSVEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSVEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSVEnabled::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSVEnabled::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSVEnabledResult
///
#include "gen/IsSVEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSVEnabledResult::CmdName = "IsSVEnabledResult";
    const char* const IsSVEnabledResult::Documentation = "Result of IsSVEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsSVEnabledResult);


    IsSVEnabledResult::IsSVEnabledResult()
      : CommandResult(CmdName)
    {}

    IsSVEnabledResult::IsSVEnabledResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
    }


    IsSVEnabledResultPtr IsSVEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled)
    {
      return IsSVEnabledResultPtr(new IsSVEnabledResult(relatedCommand, system, svId, enabled));
    }

    IsSVEnabledResultPtr IsSVEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSVEnabledResult>(ptr);
    }

    bool IsSVEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSVEnabledResult::documentation() const { return Documentation; }


    std::string IsSVEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSVEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSVEnabledResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSVEnabledResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSVEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSVEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableEachSV
///
#include "gen/EnableEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableEachSV::CmdName = "EnableEachSV";
    const char* const EnableEachSV::Documentation = "Enable or disable each satellite for this constellation.";

    REGISTER_COMMAND_FACTORY(EnableEachSV);


    EnableEachSV::EnableEachSV()
      : CommandBase(CmdName)
    {}

    EnableEachSV::EnableEachSV(const std::string& system, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    EnableEachSVPtr EnableEachSV::create(const std::string& system, const std::vector<bool>& enabled)
    {
      return EnableEachSVPtr(new EnableEachSV(system, enabled));
    }

    EnableEachSVPtr EnableEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableEachSV>(ptr);
    }

    bool EnableEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableEachSV::documentation() const { return Documentation; }


    int EnableEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EnableEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsEachSVEnabled
///
#include "gen/IsEachSVEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsEachSVEnabled::CmdName = "IsEachSVEnabled";
    const char* const IsEachSVEnabled::Documentation = "Get whether each satellite is enabled or disabled for this constellation.";

    REGISTER_COMMAND_FACTORY(IsEachSVEnabled);


    IsEachSVEnabled::IsEachSVEnabled()
      : CommandBase(CmdName)
    {}

    IsEachSVEnabled::IsEachSVEnabled(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsEachSVEnabledPtr IsEachSVEnabled::create(const std::string& system)
    {
      return IsEachSVEnabledPtr(new IsEachSVEnabled(system));
    }

    IsEachSVEnabledPtr IsEachSVEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsEachSVEnabled>(ptr);
    }

    bool IsEachSVEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsEachSVEnabled::documentation() const { return Documentation; }


    int IsEachSVEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsEachSVEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsEachSVEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsEachSVEnabledResult
///
#include "gen/IsEachSVEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsEachSVEnabledResult::CmdName = "IsEachSVEnabledResult";
    const char* const IsEachSVEnabledResult::Documentation = "Result of IsEachSVEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsEachSVEnabledResult);


    IsEachSVEnabledResult::IsEachSVEnabledResult()
      : CommandResult(CmdName)
    {}

    IsEachSVEnabledResult::IsEachSVEnabledResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    IsEachSVEnabledResultPtr IsEachSVEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
    {
      return IsEachSVEnabledResultPtr(new IsEachSVEnabledResult(relatedCommand, system, enabled));
    }

    IsEachSVEnabledResultPtr IsEachSVEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsEachSVEnabledResult>(ptr);
    }

    bool IsEachSVEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsEachSVEnabledResult::documentation() const { return Documentation; }


    std::string IsEachSVEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsEachSVEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsEachSVEnabledResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsEachSVEnabledResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableCnav2Pages
///
#include "gen/EnableCnav2Pages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableCnav2Pages::CmdName = "EnableCnav2Pages";
    const char* const EnableCnav2Pages::Documentation = "Set the enabled L1C CNAV2 pages";

    REGISTER_COMMAND_FACTORY(EnableCnav2Pages);


    EnableCnav2Pages::EnableCnav2Pages()
      : CommandBase(CmdName)
    {}

    EnableCnav2Pages::EnableCnav2Pages(const std::vector<int>& messages)
      : CommandBase(CmdName)
    {

      setMessages(messages);
    }


    EnableCnav2PagesPtr EnableCnav2Pages::create(const std::vector<int>& messages)
    {
      return EnableCnav2PagesPtr(new EnableCnav2Pages(messages));
    }

    EnableCnav2PagesPtr EnableCnav2Pages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableCnav2Pages>(ptr);
    }

    bool EnableCnav2Pages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["Messages"])
        ;

    }

    std::string EnableCnav2Pages::documentation() const { return Documentation; }


    int EnableCnav2Pages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<int> EnableCnav2Pages::messages() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Messages"]);
    }

    void EnableCnav2Pages::setMessages(const std::vector<int>& messages)
    {
      m_values.AddMember("Messages", parse_json<std::vector<int>>::format(messages, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetCnav2PagesEnabled
///
#include "gen/GetCnav2PagesEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetCnav2PagesEnabled::CmdName = "GetCnav2PagesEnabled";
    const char* const GetCnav2PagesEnabled::Documentation = "Get the enabled L1C CNAV2 pages";

    REGISTER_COMMAND_FACTORY(GetCnav2PagesEnabled);


    GetCnav2PagesEnabled::GetCnav2PagesEnabled()
      : CommandBase(CmdName)
    {

    }


    GetCnav2PagesEnabledPtr GetCnav2PagesEnabled::create()
    {
      return GetCnav2PagesEnabledPtr(new GetCnav2PagesEnabled());
    }

    GetCnav2PagesEnabledPtr GetCnav2PagesEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetCnav2PagesEnabled>(ptr);
    }

    bool GetCnav2PagesEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetCnav2PagesEnabled::documentation() const { return Documentation; }


    int GetCnav2PagesEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetCnav2PagesEnabledResult
///
#include "gen/GetCnav2PagesEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetCnav2PagesEnabledResult::CmdName = "GetCnav2PagesEnabledResult";
    const char* const GetCnav2PagesEnabledResult::Documentation = "Result of GetCnav2PagesEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(GetCnav2PagesEnabledResult);


    GetCnav2PagesEnabledResult::GetCnav2PagesEnabledResult()
      : CommandResult(CmdName)
    {}

    GetCnav2PagesEnabledResult::GetCnav2PagesEnabledResult(CommandBasePtr relatedCommand, const std::vector<int>& messages)
      : CommandResult(CmdName, relatedCommand)
    {

      setMessages(messages);
    }


    GetCnav2PagesEnabledResultPtr GetCnav2PagesEnabledResult::create(CommandBasePtr relatedCommand, const std::vector<int>& messages)
    {
      return GetCnav2PagesEnabledResultPtr(new GetCnav2PagesEnabledResult(relatedCommand, messages));
    }

    GetCnav2PagesEnabledResultPtr GetCnav2PagesEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetCnav2PagesEnabledResult>(ptr);
    }

    bool GetCnav2PagesEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["Messages"])
        ;

    }

    std::string GetCnav2PagesEnabledResult::documentation() const { return Documentation; }


    std::vector<int> GetCnav2PagesEnabledResult::messages() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Messages"]);
    }

    void GetCnav2PagesEnabledResult::setMessages(const std::vector<int>& messages)
    {
      m_values.AddMember("Messages", parse_json<std::vector<int>>::format(messages, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSbasMessages
///
#include "gen/EnableSbasMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSbasMessages::CmdName = "EnableSbasMessages";
    const char* const EnableSbasMessages::Documentation = "Set the enabled SBAS messages. Message 63 is always enabled";

    REGISTER_COMMAND_FACTORY(EnableSbasMessages);


    EnableSbasMessages::EnableSbasMessages()
      : CommandBase(CmdName)
    {}

    EnableSbasMessages::EnableSbasMessages(const std::vector<int>& messages)
      : CommandBase(CmdName)
    {

      setMessages(messages);
    }


    EnableSbasMessagesPtr EnableSbasMessages::create(const std::vector<int>& messages)
    {
      return EnableSbasMessagesPtr(new EnableSbasMessages(messages));
    }

    EnableSbasMessagesPtr EnableSbasMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSbasMessages>(ptr);
    }

    bool EnableSbasMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["Messages"])
        ;

    }

    std::string EnableSbasMessages::documentation() const { return Documentation; }


    int EnableSbasMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<int> EnableSbasMessages::messages() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Messages"]);
    }

    void EnableSbasMessages::setMessages(const std::vector<int>& messages)
    {
      m_values.AddMember("Messages", parse_json<std::vector<int>>::format(messages, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasMessagesEnabled
///
#include "gen/GetSbasMessagesEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMessagesEnabled::CmdName = "GetSbasMessagesEnabled";
    const char* const GetSbasMessagesEnabled::Documentation = "Get the enabled SBAS messages. Message 63 is always enabled";

    REGISTER_COMMAND_FACTORY(GetSbasMessagesEnabled);


    GetSbasMessagesEnabled::GetSbasMessagesEnabled()
      : CommandBase(CmdName)
    {

    }


    GetSbasMessagesEnabledPtr GetSbasMessagesEnabled::create()
    {
      return GetSbasMessagesEnabledPtr(new GetSbasMessagesEnabled());
    }

    GetSbasMessagesEnabledPtr GetSbasMessagesEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMessagesEnabled>(ptr);
    }

    bool GetSbasMessagesEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSbasMessagesEnabled::documentation() const { return Documentation; }


    int GetSbasMessagesEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetSbasMessagesEnabledResult
///
#include "gen/GetSbasMessagesEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMessagesEnabledResult::CmdName = "GetSbasMessagesEnabledResult";
    const char* const GetSbasMessagesEnabledResult::Documentation = "Result of GetSbasMessagesEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasMessagesEnabledResult);


    GetSbasMessagesEnabledResult::GetSbasMessagesEnabledResult()
      : CommandResult(CmdName)
    {}

    GetSbasMessagesEnabledResult::GetSbasMessagesEnabledResult(CommandBasePtr relatedCommand, const std::vector<int>& messages)
      : CommandResult(CmdName, relatedCommand)
    {

      setMessages(messages);
    }


    GetSbasMessagesEnabledResultPtr GetSbasMessagesEnabledResult::create(CommandBasePtr relatedCommand, const std::vector<int>& messages)
    {
      return GetSbasMessagesEnabledResultPtr(new GetSbasMessagesEnabledResult(relatedCommand, messages));
    }

    GetSbasMessagesEnabledResultPtr GetSbasMessagesEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMessagesEnabledResult>(ptr);
    }

    bool GetSbasMessagesEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["Messages"])
        ;

    }

    std::string GetSbasMessagesEnabledResult::documentation() const { return Documentation; }


    std::vector<int> GetSbasMessagesEnabledResult::messages() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Messages"]);
    }

    void GetSbasMessagesEnabledResult::setMessages(const std::vector<int>& messages)
    {
      m_values.AddMember("Messages", parse_json<std::vector<int>>::format(messages, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasMonitoredSystems
///
#include "gen/SetSbasMonitoredSystems.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasMonitoredSystems::CmdName = "SetSbasMonitoredSystems";
    const char* const SetSbasMonitoredSystems::Documentation = "Set the systems monitored by SBAS.";

    REGISTER_COMMAND_FACTORY(SetSbasMonitoredSystems);


    SetSbasMonitoredSystems::SetSbasMonitoredSystems()
      : CommandBase(CmdName)
    {}

    SetSbasMonitoredSystems::SetSbasMonitoredSystems(const std::vector<std::string>& systems)
      : CommandBase(CmdName)
    {

      setSystems(systems);
    }


    SetSbasMonitoredSystemsPtr SetSbasMonitoredSystems::create(const std::vector<std::string>& systems)
    {
      return SetSbasMonitoredSystemsPtr(new SetSbasMonitoredSystems(systems));
    }

    SetSbasMonitoredSystemsPtr SetSbasMonitoredSystems::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasMonitoredSystems>(ptr);
    }

    bool SetSbasMonitoredSystems::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Systems"])
        ;

    }

    std::string SetSbasMonitoredSystems::documentation() const { return Documentation; }


    int SetSbasMonitoredSystems::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetSbasMonitoredSystems::systems() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Systems"]);
    }

    void SetSbasMonitoredSystems::setSystems(const std::vector<std::string>& systems)
    {
      m_values.AddMember("Systems", parse_json<std::vector<std::string>>::format(systems, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasMonitoredSystems
///
#include "gen/GetSbasMonitoredSystems.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMonitoredSystems::CmdName = "GetSbasMonitoredSystems";
    const char* const GetSbasMonitoredSystems::Documentation = "Get the systems monitored by SBAS.";

    REGISTER_COMMAND_FACTORY(GetSbasMonitoredSystems);


    GetSbasMonitoredSystems::GetSbasMonitoredSystems()
      : CommandBase(CmdName)
    {

    }


    GetSbasMonitoredSystemsPtr GetSbasMonitoredSystems::create()
    {
      return GetSbasMonitoredSystemsPtr(new GetSbasMonitoredSystems());
    }

    GetSbasMonitoredSystemsPtr GetSbasMonitoredSystems::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMonitoredSystems>(ptr);
    }

    bool GetSbasMonitoredSystems::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSbasMonitoredSystems::documentation() const { return Documentation; }


    int GetSbasMonitoredSystems::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetSbasMonitoredSystemsResult
///
#include "gen/GetSbasMonitoredSystemsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasMonitoredSystemsResult::CmdName = "GetSbasMonitoredSystemsResult";
    const char* const GetSbasMonitoredSystemsResult::Documentation = "Result of GetSbasMonitoredSystems";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasMonitoredSystemsResult);


    GetSbasMonitoredSystemsResult::GetSbasMonitoredSystemsResult()
      : CommandResult(CmdName)
    {}

    GetSbasMonitoredSystemsResult::GetSbasMonitoredSystemsResult(CommandBasePtr relatedCommand, const std::vector<std::string>& systems)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystems(systems);
    }


    GetSbasMonitoredSystemsResultPtr GetSbasMonitoredSystemsResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& systems)
    {
      return GetSbasMonitoredSystemsResultPtr(new GetSbasMonitoredSystemsResult(relatedCommand, systems));
    }

    GetSbasMonitoredSystemsResultPtr GetSbasMonitoredSystemsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasMonitoredSystemsResult>(ptr);
    }

    bool GetSbasMonitoredSystemsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Systems"])
        ;

    }

    std::string GetSbasMonitoredSystemsResult::documentation() const { return Documentation; }


    std::vector<std::string> GetSbasMonitoredSystemsResult::systems() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Systems"]);
    }

    void GetSbasMonitoredSystemsResult::setSystems(const std::vector<std::string>& systems)
    {
      m_values.AddMember("Systems", parse_json<std::vector<std::string>>::format(systems, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasUdrei
///
#include "gen/SetSbasUdrei.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasUdrei::CmdName = "SetSbasUdrei";
    const char* const SetSbasUdrei::Documentation = "Set the global UDREI value transmitted by SBAS";

    REGISTER_COMMAND_FACTORY(SetSbasUdrei);


    SetSbasUdrei::SetSbasUdrei()
      : CommandBase(CmdName)
    {}

    SetSbasUdrei::SetSbasUdrei(int udrei)
      : CommandBase(CmdName)
    {

      setUdrei(udrei);
    }


    SetSbasUdreiPtr SetSbasUdrei::create(int udrei)
    {
      return SetSbasUdreiPtr(new SetSbasUdrei(udrei));
    }

    SetSbasUdreiPtr SetSbasUdrei::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasUdrei>(ptr);
    }

    bool SetSbasUdrei::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Udrei"])
        ;

    }

    std::string SetSbasUdrei::documentation() const { return Documentation; }


    int SetSbasUdrei::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetSbasUdrei::udrei() const
    {
      return parse_json<int>::parse(m_values["Udrei"]);
    }

    void SetSbasUdrei::setUdrei(int udrei)
    {
      m_values.AddMember("Udrei", parse_json<int>::format(udrei, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasUdrei
///
#include "gen/GetSbasUdrei.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasUdrei::CmdName = "GetSbasUdrei";
    const char* const GetSbasUdrei::Documentation = "Get the global UDREI value transmitted by SBAS";

    REGISTER_COMMAND_FACTORY(GetSbasUdrei);


    GetSbasUdrei::GetSbasUdrei()
      : CommandBase(CmdName)
    {

    }


    GetSbasUdreiPtr GetSbasUdrei::create()
    {
      return GetSbasUdreiPtr(new GetSbasUdrei());
    }

    GetSbasUdreiPtr GetSbasUdrei::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasUdrei>(ptr);
    }

    bool GetSbasUdrei::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetSbasUdrei::documentation() const { return Documentation; }


    int GetSbasUdrei::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetSbasUdreiResult
///
#include "gen/GetSbasUdreiResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasUdreiResult::CmdName = "GetSbasUdreiResult";
    const char* const GetSbasUdreiResult::Documentation = "Result of GetSbasUdrei";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasUdreiResult);


    GetSbasUdreiResult::GetSbasUdreiResult()
      : CommandResult(CmdName)
    {}

    GetSbasUdreiResult::GetSbasUdreiResult(CommandBasePtr relatedCommand, int udrei)
      : CommandResult(CmdName, relatedCommand)
    {

      setUdrei(udrei);
    }


    GetSbasUdreiResultPtr GetSbasUdreiResult::create(CommandBasePtr relatedCommand, int udrei)
    {
      return GetSbasUdreiResultPtr(new GetSbasUdreiResult(relatedCommand, udrei));
    }

    GetSbasUdreiResultPtr GetSbasUdreiResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasUdreiResult>(ptr);
    }

    bool GetSbasUdreiResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Udrei"])
        ;

    }

    std::string GetSbasUdreiResult::documentation() const { return Documentation; }


    int GetSbasUdreiResult::udrei() const
    {
      return parse_json<int>::parse(m_values["Udrei"]);
    }

    void GetSbasUdreiResult::setUdrei(int udrei)
    {
      m_values.AddMember("Udrei", parse_json<int>::format(udrei, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of BroadcastConfig
///
#include "gen/BroadcastConfig.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const BroadcastConfig::CmdName = "BroadcastConfig";
    const char* const BroadcastConfig::Documentation = "Ask the master to broadcast its configuration to all slaves.";

    REGISTER_COMMAND_FACTORY(BroadcastConfig);


    BroadcastConfig::BroadcastConfig()
      : CommandBase(CmdName)
    {

    }


    BroadcastConfigPtr BroadcastConfig::create()
    {
      return BroadcastConfigPtr(new BroadcastConfig());
    }

    BroadcastConfigPtr BroadcastConfig::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<BroadcastConfig>(ptr);
    }

    bool BroadcastConfig::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string BroadcastConfig::documentation() const { return Documentation; }


    int BroadcastConfig::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of CancelBroadcastConfig
///
#include "gen/CancelBroadcastConfig.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CancelBroadcastConfig::CmdName = "CancelBroadcastConfig";
    const char* const CancelBroadcastConfig::Documentation = "Cancel the current configuration broadcast if any.";

    REGISTER_COMMAND_FACTORY(CancelBroadcastConfig);


    CancelBroadcastConfig::CancelBroadcastConfig()
      : CommandBase(CmdName)
    {

    }


    CancelBroadcastConfigPtr CancelBroadcastConfig::create()
    {
      return CancelBroadcastConfigPtr(new CancelBroadcastConfig());
    }

    CancelBroadcastConfigPtr CancelBroadcastConfig::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CancelBroadcastConfig>(ptr);
    }

    bool CancelBroadcastConfig::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string CancelBroadcastConfig::documentation() const { return Documentation; }


    int CancelBroadcastConfig::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of SetConfigBroadcastOnStart
///
#include "gen/SetConfigBroadcastOnStart.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetConfigBroadcastOnStart::CmdName = "SetConfigBroadcastOnStart";
    const char* const SetConfigBroadcastOnStart::Documentation = "Set wether the master should send its configuration to every slave when simulation start.";

    REGISTER_COMMAND_FACTORY(SetConfigBroadcastOnStart);


    SetConfigBroadcastOnStart::SetConfigBroadcastOnStart()
      : CommandBase(CmdName)
    {}

    SetConfigBroadcastOnStart::SetConfigBroadcastOnStart(bool broadcastOnStart)
      : CommandBase(CmdName)
    {

      setBroadcastOnStart(broadcastOnStart);
    }


    SetConfigBroadcastOnStartPtr SetConfigBroadcastOnStart::create(bool broadcastOnStart)
    {
      return SetConfigBroadcastOnStartPtr(new SetConfigBroadcastOnStart(broadcastOnStart));
    }

    SetConfigBroadcastOnStartPtr SetConfigBroadcastOnStart::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetConfigBroadcastOnStart>(ptr);
    }

    bool SetConfigBroadcastOnStart::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["BroadcastOnStart"])
        ;

    }

    std::string SetConfigBroadcastOnStart::documentation() const { return Documentation; }


    int SetConfigBroadcastOnStart::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool SetConfigBroadcastOnStart::broadcastOnStart() const
    {
      return parse_json<bool>::parse(m_values["BroadcastOnStart"]);
    }

    void SetConfigBroadcastOnStart::setBroadcastOnStart(bool broadcastOnStart)
    {
      m_values.AddMember("BroadcastOnStart", parse_json<bool>::format(broadcastOnStart, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetConfigBroadcastOnStart
///
#include "gen/GetConfigBroadcastOnStart.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigBroadcastOnStart::CmdName = "GetConfigBroadcastOnStart";
    const char* const GetConfigBroadcastOnStart::Documentation = "Get wether the master should send its configuration to every slave when simulation start.";

    REGISTER_COMMAND_FACTORY(GetConfigBroadcastOnStart);


    GetConfigBroadcastOnStart::GetConfigBroadcastOnStart()
      : CommandBase(CmdName)
    {

    }


    GetConfigBroadcastOnStartPtr GetConfigBroadcastOnStart::create()
    {
      return GetConfigBroadcastOnStartPtr(new GetConfigBroadcastOnStart());
    }

    GetConfigBroadcastOnStartPtr GetConfigBroadcastOnStart::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigBroadcastOnStart>(ptr);
    }

    bool GetConfigBroadcastOnStart::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetConfigBroadcastOnStart::documentation() const { return Documentation; }


    int GetConfigBroadcastOnStart::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetConfigBroadcastOnStartResult
///
#include "gen/GetConfigBroadcastOnStartResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigBroadcastOnStartResult::CmdName = "GetConfigBroadcastOnStartResult";
    const char* const GetConfigBroadcastOnStartResult::Documentation = "Result of GetConfigBroadcastOnStart";

    REGISTER_COMMAND_RESULT_FACTORY(GetConfigBroadcastOnStartResult);


    GetConfigBroadcastOnStartResult::GetConfigBroadcastOnStartResult()
      : CommandResult(CmdName)
    {}

    GetConfigBroadcastOnStartResult::GetConfigBroadcastOnStartResult(CommandBasePtr relatedCommand, bool broadcastOnStart)
      : CommandResult(CmdName, relatedCommand)
    {

      setBroadcastOnStart(broadcastOnStart);
    }


    GetConfigBroadcastOnStartResultPtr GetConfigBroadcastOnStartResult::create(CommandBasePtr relatedCommand, bool broadcastOnStart)
    {
      return GetConfigBroadcastOnStartResultPtr(new GetConfigBroadcastOnStartResult(relatedCommand, broadcastOnStart));
    }

    GetConfigBroadcastOnStartResultPtr GetConfigBroadcastOnStartResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigBroadcastOnStartResult>(ptr);
    }

    bool GetConfigBroadcastOnStartResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["BroadcastOnStart"])
        ;

    }

    std::string GetConfigBroadcastOnStartResult::documentation() const { return Documentation; }


    bool GetConfigBroadcastOnStartResult::broadcastOnStart() const
    {
      return parse_json<bool>::parse(m_values["BroadcastOnStart"]);
    }

    void GetConfigBroadcastOnStartResult::setBroadcastOnStart(bool broadcastOnStart)
    {
      m_values.AddMember("BroadcastOnStart", parse_json<bool>::format(broadcastOnStart, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetConfigBroadcastFilter
///
#include "gen/SetConfigBroadcastFilter.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetConfigBroadcastFilter::CmdName = "SetConfigBroadcastFilter";
    const char* const SetConfigBroadcastFilter::Documentation = "Set the filter for configuration broadcast.";

    REGISTER_COMMAND_FACTORY(SetConfigBroadcastFilter);


    SetConfigBroadcastFilter::SetConfigBroadcastFilter()
      : CommandBase(CmdName)
    {}

    SetConfigBroadcastFilter::SetConfigBroadcastFilter(const std::vector<Sdx::ConfigFilter>& filter)
      : CommandBase(CmdName)
    {

      setFilter(filter);
    }


    SetConfigBroadcastFilterPtr SetConfigBroadcastFilter::create(const std::vector<Sdx::ConfigFilter>& filter)
    {
      return SetConfigBroadcastFilterPtr(new SetConfigBroadcastFilter(filter));
    }

    SetConfigBroadcastFilterPtr SetConfigBroadcastFilter::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetConfigBroadcastFilter>(ptr);
    }

    bool SetConfigBroadcastFilter::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<Sdx::ConfigFilter>>::is_valid(m_values["Filter"])
        ;

    }

    std::string SetConfigBroadcastFilter::documentation() const { return Documentation; }


    int SetConfigBroadcastFilter::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<Sdx::ConfigFilter> SetConfigBroadcastFilter::filter() const
    {
      return parse_json<std::vector<Sdx::ConfigFilter>>::parse(m_values["Filter"]);
    }

    void SetConfigBroadcastFilter::setFilter(const std::vector<Sdx::ConfigFilter>& filter)
    {
      m_values.AddMember("Filter", parse_json<std::vector<Sdx::ConfigFilter>>::format(filter, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetConfigBroadcastFilter
///
#include "gen/GetConfigBroadcastFilter.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigBroadcastFilter::CmdName = "GetConfigBroadcastFilter";
    const char* const GetConfigBroadcastFilter::Documentation = "Get the filter for configuration broadcast.";

    REGISTER_COMMAND_FACTORY(GetConfigBroadcastFilter);


    GetConfigBroadcastFilter::GetConfigBroadcastFilter()
      : CommandBase(CmdName)
    {

    }


    GetConfigBroadcastFilterPtr GetConfigBroadcastFilter::create()
    {
      return GetConfigBroadcastFilterPtr(new GetConfigBroadcastFilter());
    }

    GetConfigBroadcastFilterPtr GetConfigBroadcastFilter::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigBroadcastFilter>(ptr);
    }

    bool GetConfigBroadcastFilter::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetConfigBroadcastFilter::documentation() const { return Documentation; }


    int GetConfigBroadcastFilter::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetConfigBroadcastFilterResult
///
#include "gen/GetConfigBroadcastFilterResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigBroadcastFilterResult::CmdName = "GetConfigBroadcastFilterResult";
    const char* const GetConfigBroadcastFilterResult::Documentation = "Result of GetConfigBroadcastFilter";

    REGISTER_COMMAND_RESULT_FACTORY(GetConfigBroadcastFilterResult);


    GetConfigBroadcastFilterResult::GetConfigBroadcastFilterResult()
      : CommandResult(CmdName)
    {}

    GetConfigBroadcastFilterResult::GetConfigBroadcastFilterResult(CommandBasePtr relatedCommand, const std::vector<Sdx::ConfigFilter>& filter)
      : CommandResult(CmdName, relatedCommand)
    {

      setFilter(filter);
    }


    GetConfigBroadcastFilterResultPtr GetConfigBroadcastFilterResult::create(CommandBasePtr relatedCommand, const std::vector<Sdx::ConfigFilter>& filter)
    {
      return GetConfigBroadcastFilterResultPtr(new GetConfigBroadcastFilterResult(relatedCommand, filter));
    }

    GetConfigBroadcastFilterResultPtr GetConfigBroadcastFilterResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigBroadcastFilterResult>(ptr);
    }

    bool GetConfigBroadcastFilterResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<Sdx::ConfigFilter>>::is_valid(m_values["Filter"])
        ;

    }

    std::string GetConfigBroadcastFilterResult::documentation() const { return Documentation; }


    std::vector<Sdx::ConfigFilter> GetConfigBroadcastFilterResult::filter() const
    {
      return parse_json<std::vector<Sdx::ConfigFilter>>::parse(m_values["Filter"]);
    }

    void GetConfigBroadcastFilterResult::setFilter(const std::vector<Sdx::ConfigFilter>& filter)
    {
      m_values.AddMember("Filter", parse_json<std::vector<Sdx::ConfigFilter>>::format(filter, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseOffsetForSV
///
#include "gen/SetPseudorangeNoiseOffsetForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseOffsetForSV::CmdName = "SetPseudorangeNoiseOffsetForSV";
    const char* const SetPseudorangeNoiseOffsetForSV::Documentation = "Set the satellite pseudorange noise constant offset.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseOffsetForSV);


    SetPseudorangeNoiseOffsetForSV::SetPseudorangeNoiseOffsetForSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseOffsetForSV::SetPseudorangeNoiseOffsetForSV(const std::string& system, int svId, bool enabled, double offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
      setOffset(offset);
    }


    SetPseudorangeNoiseOffsetForSVPtr SetPseudorangeNoiseOffsetForSV::create(const std::string& system, int svId, bool enabled, double offset)
    {
      return SetPseudorangeNoiseOffsetForSVPtr(new SetPseudorangeNoiseOffsetForSV(system, svId, enabled, offset));
    }

    SetPseudorangeNoiseOffsetForSVPtr SetPseudorangeNoiseOffsetForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseOffsetForSV>(ptr);
    }

    bool SetPseudorangeNoiseOffsetForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPseudorangeNoiseOffsetForSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseOffsetForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseOffsetForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseOffsetForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseOffsetForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPseudorangeNoiseOffsetForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPseudorangeNoiseOffsetForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseOffsetForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseOffsetForSV::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPseudorangeNoiseOffsetForSV::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseOffsetForSV
///
#include "gen/GetPseudorangeNoiseOffsetForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseOffsetForSV::CmdName = "GetPseudorangeNoiseOffsetForSV";
    const char* const GetPseudorangeNoiseOffsetForSV::Documentation = "Get the satellite pseudorange noise constant offset.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseOffsetForSV);


    GetPseudorangeNoiseOffsetForSV::GetPseudorangeNoiseOffsetForSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseOffsetForSV::GetPseudorangeNoiseOffsetForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetPseudorangeNoiseOffsetForSVPtr GetPseudorangeNoiseOffsetForSV::create(const std::string& system, int svId)
    {
      return GetPseudorangeNoiseOffsetForSVPtr(new GetPseudorangeNoiseOffsetForSV(system, svId));
    }

    GetPseudorangeNoiseOffsetForSVPtr GetPseudorangeNoiseOffsetForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseOffsetForSV>(ptr);
    }

    bool GetPseudorangeNoiseOffsetForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetPseudorangeNoiseOffsetForSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseOffsetForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseOffsetForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseOffsetForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseOffsetForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseOffsetForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseOffsetForSVResult
///
#include "gen/GetPseudorangeNoiseOffsetForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseOffsetForSVResult::CmdName = "GetPseudorangeNoiseOffsetForSVResult";
    const char* const GetPseudorangeNoiseOffsetForSVResult::Documentation = "Result of GetPseudorangeNoiseOffsetForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseOffsetForSVResult);


    GetPseudorangeNoiseOffsetForSVResult::GetPseudorangeNoiseOffsetForSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseOffsetForSVResult::GetPseudorangeNoiseOffsetForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setEnabled(enabled);
      setOffset(offset);
    }


    GetPseudorangeNoiseOffsetForSVResultPtr GetPseudorangeNoiseOffsetForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool enabled, double offset)
    {
      return GetPseudorangeNoiseOffsetForSVResultPtr(new GetPseudorangeNoiseOffsetForSVResult(relatedCommand, system, svId, enabled, offset));
    }

    GetPseudorangeNoiseOffsetForSVResultPtr GetPseudorangeNoiseOffsetForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseOffsetForSVResult>(ptr);
    }

    bool GetPseudorangeNoiseOffsetForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPseudorangeNoiseOffsetForSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseOffsetForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseOffsetForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseOffsetForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseOffsetForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetPseudorangeNoiseOffsetForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseOffsetForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseOffsetForSVResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPseudorangeNoiseOffsetForSVResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseOffsetForEachSV
///
#include "gen/SetPseudorangeNoiseOffsetForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseOffsetForEachSV::CmdName = "SetPseudorangeNoiseOffsetForEachSV";
    const char* const SetPseudorangeNoiseOffsetForEachSV::Documentation = "Set the satellite pseudorange noise constant offset for all satellites.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseOffsetForEachSV);


    SetPseudorangeNoiseOffsetForEachSV::SetPseudorangeNoiseOffsetForEachSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseOffsetForEachSV::SetPseudorangeNoiseOffsetForEachSV(const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
      setOffset(offset);
    }


    SetPseudorangeNoiseOffsetForEachSVPtr SetPseudorangeNoiseOffsetForEachSV::create(const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
    {
      return SetPseudorangeNoiseOffsetForEachSVPtr(new SetPseudorangeNoiseOffsetForEachSV(system, enabled, offset));
    }

    SetPseudorangeNoiseOffsetForEachSVPtr SetPseudorangeNoiseOffsetForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseOffsetForEachSV>(ptr);
    }

    bool SetPseudorangeNoiseOffsetForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPseudorangeNoiseOffsetForEachSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseOffsetForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseOffsetForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseOffsetForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetPseudorangeNoiseOffsetForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseOffsetForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseOffsetForEachSV::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void SetPseudorangeNoiseOffsetForEachSV::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAllSatellitesPseudorangeNoiseOffset
///
#include "gen/SetAllSatellitesPseudorangeNoiseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAllSatellitesPseudorangeNoiseOffset::CmdName = "SetAllSatellitesPseudorangeNoiseOffset";
    const char* const SetAllSatellitesPseudorangeNoiseOffset::Documentation = "Please note the command SetAllSatellitesPseudorangeNoiseOffset is deprecated since 21.3. You may use SetPseudorangeNoiseOffsetForEachSV.\n\nSet the satellite pseudorange noise constant offset for all satellites.";

    REGISTER_COMMAND_FACTORY(SetAllSatellitesPseudorangeNoiseOffset);


    SetAllSatellitesPseudorangeNoiseOffset::SetAllSatellitesPseudorangeNoiseOffset()
      : CommandBase(CmdName)
    {}

    SetAllSatellitesPseudorangeNoiseOffset::SetAllSatellitesPseudorangeNoiseOffset(const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
      setOffset(offset);
    }


    SetAllSatellitesPseudorangeNoiseOffsetPtr SetAllSatellitesPseudorangeNoiseOffset::create(const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
    {
      return SetAllSatellitesPseudorangeNoiseOffsetPtr(new SetAllSatellitesPseudorangeNoiseOffset(system, enabled, offset));
    }

    SetAllSatellitesPseudorangeNoiseOffsetPtr SetAllSatellitesPseudorangeNoiseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAllSatellitesPseudorangeNoiseOffset>(ptr);
    }

    bool SetAllSatellitesPseudorangeNoiseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetAllSatellitesPseudorangeNoiseOffset::documentation() const { return Documentation; }


    int SetAllSatellitesPseudorangeNoiseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAllSatellitesPseudorangeNoiseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAllSatellitesPseudorangeNoiseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetAllSatellitesPseudorangeNoiseOffset::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetAllSatellitesPseudorangeNoiseOffset::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseOffset::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void SetAllSatellitesPseudorangeNoiseOffset::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseOffsetForEachSV
///
#include "gen/GetPseudorangeNoiseOffsetForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseOffsetForEachSV::CmdName = "GetPseudorangeNoiseOffsetForEachSV";
    const char* const GetPseudorangeNoiseOffsetForEachSV::Documentation = "Get the satellite pseudorange noise constant offset for all satellites.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseOffsetForEachSV);


    GetPseudorangeNoiseOffsetForEachSV::GetPseudorangeNoiseOffsetForEachSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseOffsetForEachSV::GetPseudorangeNoiseOffsetForEachSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetPseudorangeNoiseOffsetForEachSVPtr GetPseudorangeNoiseOffsetForEachSV::create(const std::string& system)
    {
      return GetPseudorangeNoiseOffsetForEachSVPtr(new GetPseudorangeNoiseOffsetForEachSV(system));
    }

    GetPseudorangeNoiseOffsetForEachSVPtr GetPseudorangeNoiseOffsetForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseOffsetForEachSV>(ptr);
    }

    bool GetPseudorangeNoiseOffsetForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetPseudorangeNoiseOffsetForEachSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseOffsetForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseOffsetForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseOffsetForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSatellitesPseudorangeNoiseOffset
///
#include "gen/GetAllSatellitesPseudorangeNoiseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSatellitesPseudorangeNoiseOffset::CmdName = "GetAllSatellitesPseudorangeNoiseOffset";
    const char* const GetAllSatellitesPseudorangeNoiseOffset::Documentation = "Please note the command GetAllSatellitesPseudorangeNoiseOffset is deprecated since 21.3. You may use GetPseudorangeNoiseOffsetForEachSV.\n\nGet the satellite pseudorange noise constant offset for all satellites.";

    REGISTER_COMMAND_FACTORY(GetAllSatellitesPseudorangeNoiseOffset);


    GetAllSatellitesPseudorangeNoiseOffset::GetAllSatellitesPseudorangeNoiseOffset()
      : CommandBase(CmdName)
    {}

    GetAllSatellitesPseudorangeNoiseOffset::GetAllSatellitesPseudorangeNoiseOffset(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetAllSatellitesPseudorangeNoiseOffsetPtr GetAllSatellitesPseudorangeNoiseOffset::create(const std::string& system)
    {
      return GetAllSatellitesPseudorangeNoiseOffsetPtr(new GetAllSatellitesPseudorangeNoiseOffset(system));
    }

    GetAllSatellitesPseudorangeNoiseOffsetPtr GetAllSatellitesPseudorangeNoiseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSatellitesPseudorangeNoiseOffset>(ptr);
    }

    bool GetAllSatellitesPseudorangeNoiseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetAllSatellitesPseudorangeNoiseOffset::documentation() const { return Documentation; }


    int GetAllSatellitesPseudorangeNoiseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSatellitesPseudorangeNoiseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSatellitesPseudorangeNoiseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseOffsetForEachSVResult
///
#include "gen/GetPseudorangeNoiseOffsetForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseOffsetForEachSVResult::CmdName = "GetPseudorangeNoiseOffsetForEachSVResult";
    const char* const GetPseudorangeNoiseOffsetForEachSVResult::Documentation = "Result of GetPseudorangeNoiseOffsetForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseOffsetForEachSVResult);


    GetPseudorangeNoiseOffsetForEachSVResult::GetPseudorangeNoiseOffsetForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseOffsetForEachSVResult::GetPseudorangeNoiseOffsetForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
      setOffset(offset);
    }


    GetPseudorangeNoiseOffsetForEachSVResultPtr GetPseudorangeNoiseOffsetForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled, const std::vector<double>& offset)
    {
      return GetPseudorangeNoiseOffsetForEachSVResultPtr(new GetPseudorangeNoiseOffsetForEachSVResult(relatedCommand, system, enabled, offset));
    }

    GetPseudorangeNoiseOffsetForEachSVResultPtr GetPseudorangeNoiseOffsetForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseOffsetForEachSVResult>(ptr);
    }

    bool GetPseudorangeNoiseOffsetForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPseudorangeNoiseOffsetForEachSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseOffsetForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseOffsetForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetPseudorangeNoiseOffsetForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseOffsetForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseOffsetForEachSVResult::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void GetPseudorangeNoiseOffsetForEachSVResult::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseSineWaveForSV
///
#include "gen/SetPseudorangeNoiseSineWaveForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseSineWaveForSV::CmdName = "SetPseudorangeNoiseSineWaveForSV";
    const char* const SetPseudorangeNoiseSineWaveForSV::Documentation = "Set the satellite pseudorange noise sine wave attributes.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseSineWaveForSV);


    SetPseudorangeNoiseSineWaveForSV::SetPseudorangeNoiseSineWaveForSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseSineWaveForSV::SetPseudorangeNoiseSineWaveForSV(const std::string& system, int svId, int sineWave, bool enabled, double amplitude, int period, double offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    SetPseudorangeNoiseSineWaveForSVPtr SetPseudorangeNoiseSineWaveForSV::create(const std::string& system, int svId, int sineWave, bool enabled, double amplitude, int period, double offset)
    {
      return SetPseudorangeNoiseSineWaveForSVPtr(new SetPseudorangeNoiseSineWaveForSV(system, svId, sineWave, enabled, amplitude, period, offset));
    }

    SetPseudorangeNoiseSineWaveForSVPtr SetPseudorangeNoiseSineWaveForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseSineWaveForSV>(ptr);
    }

    bool SetPseudorangeNoiseSineWaveForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Amplitude"])
          && parse_json<int>::is_valid(m_values["Period"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPseudorangeNoiseSineWaveForSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseSineWaveForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseSineWaveForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseSineWaveForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseSineWaveForSV::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPseudorangeNoiseSineWaveForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseSineWaveForSV::amplitude() const
    {
      return parse_json<double>::parse(m_values["Amplitude"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setAmplitude(double amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<double>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseSineWaveForSV::period() const
    {
      return parse_json<int>::parse(m_values["Period"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setPeriod(int period)
    {
      m_values.AddMember("Period", parse_json<int>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseSineWaveForSV::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPseudorangeNoiseSineWaveForSV::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseSineWaveForSV
///
#include "gen/GetPseudorangeNoiseSineWaveForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseSineWaveForSV::CmdName = "GetPseudorangeNoiseSineWaveForSV";
    const char* const GetPseudorangeNoiseSineWaveForSV::Documentation = "Get the satellite pseudorange noise sine wave attributes.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseSineWaveForSV);


    GetPseudorangeNoiseSineWaveForSV::GetPseudorangeNoiseSineWaveForSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseSineWaveForSV::GetPseudorangeNoiseSineWaveForSV(const std::string& system, int svId, int sineWave)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setSineWave(sineWave);
    }


    GetPseudorangeNoiseSineWaveForSVPtr GetPseudorangeNoiseSineWaveForSV::create(const std::string& system, int svId, int sineWave)
    {
      return GetPseudorangeNoiseSineWaveForSVPtr(new GetPseudorangeNoiseSineWaveForSV(system, svId, sineWave));
    }

    GetPseudorangeNoiseSineWaveForSVPtr GetPseudorangeNoiseSineWaveForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseSineWaveForSV>(ptr);
    }

    bool GetPseudorangeNoiseSineWaveForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SineWave"])
        ;

    }

    std::string GetPseudorangeNoiseSineWaveForSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseSineWaveForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseSineWaveForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseSineWaveForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseSineWaveForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSV::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetPseudorangeNoiseSineWaveForSV::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseSineWaveForSVResult
///
#include "gen/GetPseudorangeNoiseSineWaveForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseSineWaveForSVResult::CmdName = "GetPseudorangeNoiseSineWaveForSVResult";
    const char* const GetPseudorangeNoiseSineWaveForSVResult::Documentation = "Result of GetPseudorangeNoiseSineWaveForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseSineWaveForSVResult);


    GetPseudorangeNoiseSineWaveForSVResult::GetPseudorangeNoiseSineWaveForSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseSineWaveForSVResult::GetPseudorangeNoiseSineWaveForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, int sineWave, bool enabled, double amplitude, int period, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    GetPseudorangeNoiseSineWaveForSVResultPtr GetPseudorangeNoiseSineWaveForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, int sineWave, bool enabled, double amplitude, int period, double offset)
    {
      return GetPseudorangeNoiseSineWaveForSVResultPtr(new GetPseudorangeNoiseSineWaveForSVResult(relatedCommand, system, svId, sineWave, enabled, amplitude, period, offset));
    }

    GetPseudorangeNoiseSineWaveForSVResultPtr GetPseudorangeNoiseSineWaveForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseSineWaveForSVResult>(ptr);
    }

    bool GetPseudorangeNoiseSineWaveForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Amplitude"])
          && parse_json<int>::is_valid(m_values["Period"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPseudorangeNoiseSineWaveForSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseSineWaveForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSVResult::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetPseudorangeNoiseSineWaveForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseSineWaveForSVResult::amplitude() const
    {
      return parse_json<double>::parse(m_values["Amplitude"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setAmplitude(double amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<double>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForSVResult::period() const
    {
      return parse_json<int>::parse(m_values["Period"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setPeriod(int period)
    {
      m_values.AddMember("Period", parse_json<int>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseSineWaveForSVResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPseudorangeNoiseSineWaveForSVResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseSineWaveForEachSV
///
#include "gen/SetPseudorangeNoiseSineWaveForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseSineWaveForEachSV::CmdName = "SetPseudorangeNoiseSineWaveForEachSV";
    const char* const SetPseudorangeNoiseSineWaveForEachSV::Documentation = "Set the satellite pseudorange noise sine wave attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseSineWaveForEachSV);


    SetPseudorangeNoiseSineWaveForEachSV::SetPseudorangeNoiseSineWaveForEachSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseSineWaveForEachSV::SetPseudorangeNoiseSineWaveForEachSV(const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    SetPseudorangeNoiseSineWaveForEachSVPtr SetPseudorangeNoiseSineWaveForEachSV::create(const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
    {
      return SetPseudorangeNoiseSineWaveForEachSVPtr(new SetPseudorangeNoiseSineWaveForEachSV(system, sineWave, enabled, amplitude, period, offset));
    }

    SetPseudorangeNoiseSineWaveForEachSVPtr SetPseudorangeNoiseSineWaveForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseSineWaveForEachSV>(ptr);
    }

    bool SetPseudorangeNoiseSineWaveForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Amplitude"])
          && parse_json<std::vector<int>>::is_valid(m_values["Period"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetPseudorangeNoiseSineWaveForEachSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseSineWaveForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseSineWaveForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseSineWaveForEachSV::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetPseudorangeNoiseSineWaveForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseSineWaveForEachSV::amplitude() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Amplitude"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setAmplitude(const std::vector<double>& amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<std::vector<double>>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetPseudorangeNoiseSineWaveForEachSV::period() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Period"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setPeriod(const std::vector<int>& period)
    {
      m_values.AddMember("Period", parse_json<std::vector<int>>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseSineWaveForEachSV::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void SetPseudorangeNoiseSineWaveForEachSV::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAllSatellitesPseudorangeNoiseSineWave
///
#include "gen/SetAllSatellitesPseudorangeNoiseSineWave.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAllSatellitesPseudorangeNoiseSineWave::CmdName = "SetAllSatellitesPseudorangeNoiseSineWave";
    const char* const SetAllSatellitesPseudorangeNoiseSineWave::Documentation = "Please note the command SetAllSatellitesPseudorangeNoiseSineWave is deprecated since 21.3. You may use SetPseudorangeNoiseSineWaveForEachSV.\n\nSet the satellite pseudorange noise sine wave attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(SetAllSatellitesPseudorangeNoiseSineWave);


    SetAllSatellitesPseudorangeNoiseSineWave::SetAllSatellitesPseudorangeNoiseSineWave()
      : CommandBase(CmdName)
    {}

    SetAllSatellitesPseudorangeNoiseSineWave::SetAllSatellitesPseudorangeNoiseSineWave(const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    SetAllSatellitesPseudorangeNoiseSineWavePtr SetAllSatellitesPseudorangeNoiseSineWave::create(const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
    {
      return SetAllSatellitesPseudorangeNoiseSineWavePtr(new SetAllSatellitesPseudorangeNoiseSineWave(system, sineWave, enabled, amplitude, period, offset));
    }

    SetAllSatellitesPseudorangeNoiseSineWavePtr SetAllSatellitesPseudorangeNoiseSineWave::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAllSatellitesPseudorangeNoiseSineWave>(ptr);
    }

    bool SetAllSatellitesPseudorangeNoiseSineWave::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Amplitude"])
          && parse_json<std::vector<int>>::is_valid(m_values["Period"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetAllSatellitesPseudorangeNoiseSineWave::documentation() const { return Documentation; }


    int SetAllSatellitesPseudorangeNoiseSineWave::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAllSatellitesPseudorangeNoiseSineWave::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAllSatellitesPseudorangeNoiseSineWave::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetAllSatellitesPseudorangeNoiseSineWave::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseSineWave::amplitude() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Amplitude"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setAmplitude(const std::vector<double>& amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<std::vector<double>>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetAllSatellitesPseudorangeNoiseSineWave::period() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Period"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setPeriod(const std::vector<int>& period)
    {
      m_values.AddMember("Period", parse_json<std::vector<int>>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseSineWave::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void SetAllSatellitesPseudorangeNoiseSineWave::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseSineWaveForEachSV
///
#include "gen/GetPseudorangeNoiseSineWaveForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseSineWaveForEachSV::CmdName = "GetPseudorangeNoiseSineWaveForEachSV";
    const char* const GetPseudorangeNoiseSineWaveForEachSV::Documentation = "Get the satellite pseudorange noise sine wave attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseSineWaveForEachSV);


    GetPseudorangeNoiseSineWaveForEachSV::GetPseudorangeNoiseSineWaveForEachSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseSineWaveForEachSV::GetPseudorangeNoiseSineWaveForEachSV(const std::string& system, int sineWave)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSineWave(sineWave);
    }


    GetPseudorangeNoiseSineWaveForEachSVPtr GetPseudorangeNoiseSineWaveForEachSV::create(const std::string& system, int sineWave)
    {
      return GetPseudorangeNoiseSineWaveForEachSVPtr(new GetPseudorangeNoiseSineWaveForEachSV(system, sineWave));
    }

    GetPseudorangeNoiseSineWaveForEachSVPtr GetPseudorangeNoiseSineWaveForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseSineWaveForEachSV>(ptr);
    }

    bool GetPseudorangeNoiseSineWaveForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
        ;

    }

    std::string GetPseudorangeNoiseSineWaveForEachSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseSineWaveForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseSineWaveForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForEachSV::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSV::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSatellitesPseudorangeNoiseSineWave
///
#include "gen/GetAllSatellitesPseudorangeNoiseSineWave.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSatellitesPseudorangeNoiseSineWave::CmdName = "GetAllSatellitesPseudorangeNoiseSineWave";
    const char* const GetAllSatellitesPseudorangeNoiseSineWave::Documentation = "Please note the command GetAllSatellitesPseudorangeNoiseSineWave is deprecated since 21.3. You may use GetPseudorangeNoiseSineWaveForEachSV.\n\nGet the satellite pseudorange noise sine wave attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(GetAllSatellitesPseudorangeNoiseSineWave);


    GetAllSatellitesPseudorangeNoiseSineWave::GetAllSatellitesPseudorangeNoiseSineWave()
      : CommandBase(CmdName)
    {}

    GetAllSatellitesPseudorangeNoiseSineWave::GetAllSatellitesPseudorangeNoiseSineWave(const std::string& system, int sineWave)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSineWave(sineWave);
    }


    GetAllSatellitesPseudorangeNoiseSineWavePtr GetAllSatellitesPseudorangeNoiseSineWave::create(const std::string& system, int sineWave)
    {
      return GetAllSatellitesPseudorangeNoiseSineWavePtr(new GetAllSatellitesPseudorangeNoiseSineWave(system, sineWave));
    }

    GetAllSatellitesPseudorangeNoiseSineWavePtr GetAllSatellitesPseudorangeNoiseSineWave::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSatellitesPseudorangeNoiseSineWave>(ptr);
    }

    bool GetAllSatellitesPseudorangeNoiseSineWave::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
        ;

    }

    std::string GetAllSatellitesPseudorangeNoiseSineWave::documentation() const { return Documentation; }


    int GetAllSatellitesPseudorangeNoiseSineWave::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSatellitesPseudorangeNoiseSineWave::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSatellitesPseudorangeNoiseSineWave::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllSatellitesPseudorangeNoiseSineWave::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetAllSatellitesPseudorangeNoiseSineWave::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseSineWaveForEachSVResult
///
#include "gen/GetPseudorangeNoiseSineWaveForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseSineWaveForEachSVResult::CmdName = "GetPseudorangeNoiseSineWaveForEachSVResult";
    const char* const GetPseudorangeNoiseSineWaveForEachSVResult::Documentation = "Result of GetPseudorangeNoiseSineWaveForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseSineWaveForEachSVResult);


    GetPseudorangeNoiseSineWaveForEachSVResult::GetPseudorangeNoiseSineWaveForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseSineWaveForEachSVResult::GetPseudorangeNoiseSineWaveForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    GetPseudorangeNoiseSineWaveForEachSVResultPtr GetPseudorangeNoiseSineWaveForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int sineWave, const std::vector<bool>& enabled, const std::vector<double>& amplitude, const std::vector<int>& period, const std::vector<double>& offset)
    {
      return GetPseudorangeNoiseSineWaveForEachSVResultPtr(new GetPseudorangeNoiseSineWaveForEachSVResult(relatedCommand, system, sineWave, enabled, amplitude, period, offset));
    }

    GetPseudorangeNoiseSineWaveForEachSVResultPtr GetPseudorangeNoiseSineWaveForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseSineWaveForEachSVResult>(ptr);
    }

    bool GetPseudorangeNoiseSineWaveForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Amplitude"])
          && parse_json<std::vector<int>>::is_valid(m_values["Period"])
          && parse_json<std::vector<double>>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetPseudorangeNoiseSineWaveForEachSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseSineWaveForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseSineWaveForEachSVResult::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetPseudorangeNoiseSineWaveForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseSineWaveForEachSVResult::amplitude() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Amplitude"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setAmplitude(const std::vector<double>& amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<std::vector<double>>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetPseudorangeNoiseSineWaveForEachSVResult::period() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Period"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setPeriod(const std::vector<int>& period)
    {
      m_values.AddMember("Period", parse_json<std::vector<int>>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseSineWaveForEachSVResult::offset() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Offset"]);
    }

    void GetPseudorangeNoiseSineWaveForEachSVResult::setOffset(const std::vector<double>& offset)
    {
      m_values.AddMember("Offset", parse_json<std::vector<double>>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseGaussMarkovForSV
///
#include "gen/SetPseudorangeNoiseGaussMarkovForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseGaussMarkovForSV::CmdName = "SetPseudorangeNoiseGaussMarkovForSV";
    const char* const SetPseudorangeNoiseGaussMarkovForSV::Documentation = "Set the satellite pseudorange noise Gauss-Markov process attributes.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseGaussMarkovForSV);


    SetPseudorangeNoiseGaussMarkovForSV::SetPseudorangeNoiseGaussMarkovForSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseGaussMarkovForSV::SetPseudorangeNoiseGaussMarkovForSV(const std::string& system, int svId, int process, bool enabled, double sigma, double time, int seed)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    SetPseudorangeNoiseGaussMarkovForSVPtr SetPseudorangeNoiseGaussMarkovForSV::create(const std::string& system, int svId, int process, bool enabled, double sigma, double time, int seed)
    {
      return SetPseudorangeNoiseGaussMarkovForSVPtr(new SetPseudorangeNoiseGaussMarkovForSV(system, svId, process, enabled, sigma, time, seed));
    }

    SetPseudorangeNoiseGaussMarkovForSVPtr SetPseudorangeNoiseGaussMarkovForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseGaussMarkovForSV>(ptr);
    }

    bool SetPseudorangeNoiseGaussMarkovForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Sigma"])
          && parse_json<double>::is_valid(m_values["Time"])
          && parse_json<int>::is_valid(m_values["Seed"])
        ;

    }

    std::string SetPseudorangeNoiseGaussMarkovForSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseGaussMarkovForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseGaussMarkovForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseGaussMarkovForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseGaussMarkovForSV::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetPseudorangeNoiseGaussMarkovForSV::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseGaussMarkovForSV::sigma() const
    {
      return parse_json<double>::parse(m_values["Sigma"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setSigma(double sigma)
    {
      m_values.AddMember("Sigma", parse_json<double>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeNoiseGaussMarkovForSV::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseGaussMarkovForSV::seed() const
    {
      return parse_json<int>::parse(m_values["Seed"]);
    }

    void SetPseudorangeNoiseGaussMarkovForSV::setSeed(int seed)
    {
      m_values.AddMember("Seed", parse_json<int>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseGaussMarkovForSV
///
#include "gen/GetPseudorangeNoiseGaussMarkovForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseGaussMarkovForSV::CmdName = "GetPseudorangeNoiseGaussMarkovForSV";
    const char* const GetPseudorangeNoiseGaussMarkovForSV::Documentation = "Get the satellite pseudorange noise Gauss-Markov process attributes.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseGaussMarkovForSV);


    GetPseudorangeNoiseGaussMarkovForSV::GetPseudorangeNoiseGaussMarkovForSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseGaussMarkovForSV::GetPseudorangeNoiseGaussMarkovForSV(const std::string& system, int svId, int process)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setProcess(process);
    }


    GetPseudorangeNoiseGaussMarkovForSVPtr GetPseudorangeNoiseGaussMarkovForSV::create(const std::string& system, int svId, int process)
    {
      return GetPseudorangeNoiseGaussMarkovForSVPtr(new GetPseudorangeNoiseGaussMarkovForSV(system, svId, process));
    }

    GetPseudorangeNoiseGaussMarkovForSVPtr GetPseudorangeNoiseGaussMarkovForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseGaussMarkovForSV>(ptr);
    }

    bool GetPseudorangeNoiseGaussMarkovForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Process"])
        ;

    }

    std::string GetPseudorangeNoiseGaussMarkovForSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseGaussMarkovForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseGaussMarkovForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSV::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSV::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseGaussMarkovForSVResult
///
#include "gen/GetPseudorangeNoiseGaussMarkovForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseGaussMarkovForSVResult::CmdName = "GetPseudorangeNoiseGaussMarkovForSVResult";
    const char* const GetPseudorangeNoiseGaussMarkovForSVResult::Documentation = "Result of GetPseudorangeNoiseGaussMarkovForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseGaussMarkovForSVResult);


    GetPseudorangeNoiseGaussMarkovForSVResult::GetPseudorangeNoiseGaussMarkovForSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseGaussMarkovForSVResult::GetPseudorangeNoiseGaussMarkovForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, int process, bool enabled, double sigma, double time, int seed)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    GetPseudorangeNoiseGaussMarkovForSVResultPtr GetPseudorangeNoiseGaussMarkovForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, int process, bool enabled, double sigma, double time, int seed)
    {
      return GetPseudorangeNoiseGaussMarkovForSVResultPtr(new GetPseudorangeNoiseGaussMarkovForSVResult(relatedCommand, system, svId, process, enabled, sigma, time, seed));
    }

    GetPseudorangeNoiseGaussMarkovForSVResultPtr GetPseudorangeNoiseGaussMarkovForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseGaussMarkovForSVResult>(ptr);
    }

    bool GetPseudorangeNoiseGaussMarkovForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Sigma"])
          && parse_json<double>::is_valid(m_values["Time"])
          && parse_json<int>::is_valid(m_values["Seed"])
        ;

    }

    std::string GetPseudorangeNoiseGaussMarkovForSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseGaussMarkovForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSVResult::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetPseudorangeNoiseGaussMarkovForSVResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseGaussMarkovForSVResult::sigma() const
    {
      return parse_json<double>::parse(m_values["Sigma"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setSigma(double sigma)
    {
      m_values.AddMember("Sigma", parse_json<double>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeNoiseGaussMarkovForSVResult::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForSVResult::seed() const
    {
      return parse_json<int>::parse(m_values["Seed"]);
    }

    void GetPseudorangeNoiseGaussMarkovForSVResult::setSeed(int seed)
    {
      m_values.AddMember("Seed", parse_json<int>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeNoiseGaussMarkovForEachSV
///
#include "gen/SetPseudorangeNoiseGaussMarkovForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeNoiseGaussMarkovForEachSV::CmdName = "SetPseudorangeNoiseGaussMarkovForEachSV";
    const char* const SetPseudorangeNoiseGaussMarkovForEachSV::Documentation = "Set the satellite pseudorange noise Gauss-Markov process attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(SetPseudorangeNoiseGaussMarkovForEachSV);


    SetPseudorangeNoiseGaussMarkovForEachSV::SetPseudorangeNoiseGaussMarkovForEachSV()
      : CommandBase(CmdName)
    {}

    SetPseudorangeNoiseGaussMarkovForEachSV::SetPseudorangeNoiseGaussMarkovForEachSV(const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    SetPseudorangeNoiseGaussMarkovForEachSVPtr SetPseudorangeNoiseGaussMarkovForEachSV::create(const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
    {
      return SetPseudorangeNoiseGaussMarkovForEachSVPtr(new SetPseudorangeNoiseGaussMarkovForEachSV(system, process, enabled, sigma, time, seed));
    }

    SetPseudorangeNoiseGaussMarkovForEachSVPtr SetPseudorangeNoiseGaussMarkovForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeNoiseGaussMarkovForEachSV>(ptr);
    }

    bool SetPseudorangeNoiseGaussMarkovForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Sigma"])
          && parse_json<std::vector<double>>::is_valid(m_values["Time"])
          && parse_json<std::vector<int>>::is_valid(m_values["Seed"])
        ;

    }

    std::string SetPseudorangeNoiseGaussMarkovForEachSV::documentation() const { return Documentation; }


    int SetPseudorangeNoiseGaussMarkovForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeNoiseGaussMarkovForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeNoiseGaussMarkovForEachSV::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetPseudorangeNoiseGaussMarkovForEachSV::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseGaussMarkovForEachSV::sigma() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Sigma"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setSigma(const std::vector<double>& sigma)
    {
      m_values.AddMember("Sigma", parse_json<std::vector<double>>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetPseudorangeNoiseGaussMarkovForEachSV::time() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Time"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setTime(const std::vector<double>& time)
    {
      m_values.AddMember("Time", parse_json<std::vector<double>>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetPseudorangeNoiseGaussMarkovForEachSV::seed() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Seed"]);
    }

    void SetPseudorangeNoiseGaussMarkovForEachSV::setSeed(const std::vector<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<std::vector<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetAllSatellitesPseudorangeNoiseGaussMarkov
///
#include "gen/SetAllSatellitesPseudorangeNoiseGaussMarkov.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetAllSatellitesPseudorangeNoiseGaussMarkov::CmdName = "SetAllSatellitesPseudorangeNoiseGaussMarkov";
    const char* const SetAllSatellitesPseudorangeNoiseGaussMarkov::Documentation = "Please note the command SetAllSatellitesPseudorangeNoiseGaussMarkov is deprecated since 21.3. You may use SetPseudorangeNoiseGaussMarkovForEachSV.\n\nSet the satellite pseudorange noise Gauss-Markov process attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(SetAllSatellitesPseudorangeNoiseGaussMarkov);


    SetAllSatellitesPseudorangeNoiseGaussMarkov::SetAllSatellitesPseudorangeNoiseGaussMarkov()
      : CommandBase(CmdName)
    {}

    SetAllSatellitesPseudorangeNoiseGaussMarkov::SetAllSatellitesPseudorangeNoiseGaussMarkov(const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    SetAllSatellitesPseudorangeNoiseGaussMarkovPtr SetAllSatellitesPseudorangeNoiseGaussMarkov::create(const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
    {
      return SetAllSatellitesPseudorangeNoiseGaussMarkovPtr(new SetAllSatellitesPseudorangeNoiseGaussMarkov(system, process, enabled, sigma, time, seed));
    }

    SetAllSatellitesPseudorangeNoiseGaussMarkovPtr SetAllSatellitesPseudorangeNoiseGaussMarkov::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetAllSatellitesPseudorangeNoiseGaussMarkov>(ptr);
    }

    bool SetAllSatellitesPseudorangeNoiseGaussMarkov::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Sigma"])
          && parse_json<std::vector<double>>::is_valid(m_values["Time"])
          && parse_json<std::vector<int>>::is_valid(m_values["Seed"])
        ;

    }

    std::string SetAllSatellitesPseudorangeNoiseGaussMarkov::documentation() const { return Documentation; }


    int SetAllSatellitesPseudorangeNoiseGaussMarkov::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetAllSatellitesPseudorangeNoiseGaussMarkov::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetAllSatellitesPseudorangeNoiseGaussMarkov::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> SetAllSatellitesPseudorangeNoiseGaussMarkov::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseGaussMarkov::sigma() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Sigma"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setSigma(const std::vector<double>& sigma)
    {
      m_values.AddMember("Sigma", parse_json<std::vector<double>>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetAllSatellitesPseudorangeNoiseGaussMarkov::time() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Time"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setTime(const std::vector<double>& time)
    {
      m_values.AddMember("Time", parse_json<std::vector<double>>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> SetAllSatellitesPseudorangeNoiseGaussMarkov::seed() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Seed"]);
    }

    void SetAllSatellitesPseudorangeNoiseGaussMarkov::setSeed(const std::vector<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<std::vector<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseGaussMarkovForEachSV
///
#include "gen/GetPseudorangeNoiseGaussMarkovForEachSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseGaussMarkovForEachSV::CmdName = "GetPseudorangeNoiseGaussMarkovForEachSV";
    const char* const GetPseudorangeNoiseGaussMarkovForEachSV::Documentation = "Get the satellite pseudorange noise Gauss-Markov process attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(GetPseudorangeNoiseGaussMarkovForEachSV);


    GetPseudorangeNoiseGaussMarkovForEachSV::GetPseudorangeNoiseGaussMarkovForEachSV()
      : CommandBase(CmdName)
    {}

    GetPseudorangeNoiseGaussMarkovForEachSV::GetPseudorangeNoiseGaussMarkovForEachSV(const std::string& system, int process)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setProcess(process);
    }


    GetPseudorangeNoiseGaussMarkovForEachSVPtr GetPseudorangeNoiseGaussMarkovForEachSV::create(const std::string& system, int process)
    {
      return GetPseudorangeNoiseGaussMarkovForEachSVPtr(new GetPseudorangeNoiseGaussMarkovForEachSV(system, process));
    }

    GetPseudorangeNoiseGaussMarkovForEachSVPtr GetPseudorangeNoiseGaussMarkovForEachSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseGaussMarkovForEachSV>(ptr);
    }

    bool GetPseudorangeNoiseGaussMarkovForEachSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
        ;

    }

    std::string GetPseudorangeNoiseGaussMarkovForEachSV::documentation() const { return Documentation; }


    int GetPseudorangeNoiseGaussMarkovForEachSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeNoiseGaussMarkovForEachSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForEachSV::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSV::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSatellitesPseudorangeNoiseGaussMarkov
///
#include "gen/GetAllSatellitesPseudorangeNoiseGaussMarkov.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSatellitesPseudorangeNoiseGaussMarkov::CmdName = "GetAllSatellitesPseudorangeNoiseGaussMarkov";
    const char* const GetAllSatellitesPseudorangeNoiseGaussMarkov::Documentation = "Please note the command GetAllSatellitesPseudorangeNoiseGaussMarkov is deprecated since 21.3. You may use GetPseudorangeNoiseGaussMarkovForEachSV.\n\nGet the satellite pseudorange noise Gauss-Markov process attributes for all satellites.";

    REGISTER_COMMAND_FACTORY(GetAllSatellitesPseudorangeNoiseGaussMarkov);


    GetAllSatellitesPseudorangeNoiseGaussMarkov::GetAllSatellitesPseudorangeNoiseGaussMarkov()
      : CommandBase(CmdName)
    {}

    GetAllSatellitesPseudorangeNoiseGaussMarkov::GetAllSatellitesPseudorangeNoiseGaussMarkov(const std::string& system, int process)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setProcess(process);
    }


    GetAllSatellitesPseudorangeNoiseGaussMarkovPtr GetAllSatellitesPseudorangeNoiseGaussMarkov::create(const std::string& system, int process)
    {
      return GetAllSatellitesPseudorangeNoiseGaussMarkovPtr(new GetAllSatellitesPseudorangeNoiseGaussMarkov(system, process));
    }

    GetAllSatellitesPseudorangeNoiseGaussMarkovPtr GetAllSatellitesPseudorangeNoiseGaussMarkov::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSatellitesPseudorangeNoiseGaussMarkov>(ptr);
    }

    bool GetAllSatellitesPseudorangeNoiseGaussMarkov::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
        ;

    }

    std::string GetAllSatellitesPseudorangeNoiseGaussMarkov::documentation() const { return Documentation; }


    int GetAllSatellitesPseudorangeNoiseGaussMarkov::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllSatellitesPseudorangeNoiseGaussMarkov::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllSatellitesPseudorangeNoiseGaussMarkov::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllSatellitesPseudorangeNoiseGaussMarkov::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetAllSatellitesPseudorangeNoiseGaussMarkov::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeNoiseGaussMarkovForEachSVResult
///
#include "gen/GetPseudorangeNoiseGaussMarkovForEachSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeNoiseGaussMarkovForEachSVResult::CmdName = "GetPseudorangeNoiseGaussMarkovForEachSVResult";
    const char* const GetPseudorangeNoiseGaussMarkovForEachSVResult::Documentation = "Result of GetPseudorangeNoiseGaussMarkovForEachSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeNoiseGaussMarkovForEachSVResult);


    GetPseudorangeNoiseGaussMarkovForEachSVResult::GetPseudorangeNoiseGaussMarkovForEachSVResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeNoiseGaussMarkovForEachSVResult::GetPseudorangeNoiseGaussMarkovForEachSVResult(CommandBasePtr relatedCommand, const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    GetPseudorangeNoiseGaussMarkovForEachSVResultPtr GetPseudorangeNoiseGaussMarkovForEachSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int process, const std::vector<bool>& enabled, const std::vector<double>& sigma, const std::vector<double>& time, const std::vector<int>& seed)
    {
      return GetPseudorangeNoiseGaussMarkovForEachSVResultPtr(new GetPseudorangeNoiseGaussMarkovForEachSVResult(relatedCommand, system, process, enabled, sigma, time, seed));
    }

    GetPseudorangeNoiseGaussMarkovForEachSVResultPtr GetPseudorangeNoiseGaussMarkovForEachSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeNoiseGaussMarkovForEachSVResult>(ptr);
    }

    bool GetPseudorangeNoiseGaussMarkovForEachSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
          && parse_json<std::vector<double>>::is_valid(m_values["Sigma"])
          && parse_json<std::vector<double>>::is_valid(m_values["Time"])
          && parse_json<std::vector<int>>::is_valid(m_values["Seed"])
        ;

    }

    std::string GetPseudorangeNoiseGaussMarkovForEachSVResult::documentation() const { return Documentation; }


    std::string GetPseudorangeNoiseGaussMarkovForEachSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeNoiseGaussMarkovForEachSVResult::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetPseudorangeNoiseGaussMarkovForEachSVResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseGaussMarkovForEachSVResult::sigma() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Sigma"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setSigma(const std::vector<double>& sigma)
    {
      m_values.AddMember("Sigma", parse_json<std::vector<double>>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetPseudorangeNoiseGaussMarkovForEachSVResult::time() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Time"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setTime(const std::vector<double>& time)
    {
      m_values.AddMember("Time", parse_json<std::vector<double>>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetPseudorangeNoiseGaussMarkovForEachSVResult::seed() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Seed"]);
    }

    void GetPseudorangeNoiseGaussMarkovForEachSVResult::setSeed(const std::vector<int>& seed)
    {
      m_values.AddMember("Seed", parse_json<std::vector<int>>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV
///
#include "gen/RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::CmdName = "RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV";
    const char* const RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::Documentation = "Generate new seeds for pseudorange noise Gauss-Markov process error on all satellites.";

    REGISTER_COMMAND_FACTORY(RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV);


    RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV()
      : CommandBase(CmdName)
    {}

    RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    RandomizePseudorangeNoiseGaussMarkovSeedsForAllSVPtr RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::create(const std::string& system)
    {
      return RandomizePseudorangeNoiseGaussMarkovSeedsForAllSVPtr(new RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV(system));
    }

    RandomizePseudorangeNoiseGaussMarkovSeedsForAllSVPtr RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV>(ptr);
    }

    bool RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::documentation() const { return Documentation; }


    int RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov
///
#include "gen/RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::CmdName = "RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov";
    const char* const RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::Documentation = "Please note the command RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov is deprecated since 21.3. You may use RandomizePseudorangeNoiseGaussMarkovSeedsForAllSV.\n\nGenerate new seeds for pseudorange noise Gauss-Markov process error on all satellites.";

    REGISTER_COMMAND_FACTORY(RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov);


    RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov()
      : CommandBase(CmdName)
    {}

    RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkovPtr RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::create(const std::string& system)
    {
      return RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkovPtr(new RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov(system));
    }

    RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkovPtr RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov>(ptr);
    }

    bool RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::documentation() const { return Documentation; }


    int RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RandomizeSeedsForAllSatellitesPseudorangeNoiseGaussMarkov::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetEphemerisErrorForSV
///
#include "gen/SetEphemerisErrorForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetEphemerisErrorForSV::CmdName = "SetEphemerisErrorForSV";
    const char* const SetEphemerisErrorForSV::Documentation = "Set the satellite ephemeris error.";

    REGISTER_COMMAND_FACTORY(SetEphemerisErrorForSV);


    SetEphemerisErrorForSV::SetEphemerisErrorForSV()
      : CommandBase(CmdName)
    {}

    SetEphemerisErrorForSV::SetEphemerisErrorForSV(const std::string& system, int svId, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setOrbit(orbit);
      setDeltaAf0(deltaAf0);
      setDeltaAf1(deltaAf1);
    }


    SetEphemerisErrorForSVPtr SetEphemerisErrorForSV::create(const std::string& system, int svId, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
    {
      return SetEphemerisErrorForSVPtr(new SetEphemerisErrorForSV(system, svId, orbit, deltaAf0, deltaAf1));
    }

    SetEphemerisErrorForSVPtr SetEphemerisErrorForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetEphemerisErrorForSV>(ptr);
    }

    bool SetEphemerisErrorForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::RIC>::is_valid(m_values["Orbit"])
          && parse_json<double>::is_valid(m_values["DeltaAf0"])
          && parse_json<double>::is_valid(m_values["DeltaAf1"])
        ;

    }

    std::string SetEphemerisErrorForSV::documentation() const { return Documentation; }


    int SetEphemerisErrorForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetEphemerisErrorForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetEphemerisErrorForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetEphemerisErrorForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetEphemerisErrorForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::RIC SetEphemerisErrorForSV::orbit() const
    {
      return parse_json<Sdx::RIC>::parse(m_values["Orbit"]);
    }

    void SetEphemerisErrorForSV::setOrbit(const Sdx::RIC& orbit)
    {
      m_values.AddMember("Orbit", parse_json<Sdx::RIC>::format(orbit, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetEphemerisErrorForSV::deltaAf0() const
    {
      return parse_json<double>::parse(m_values["DeltaAf0"]);
    }

    void SetEphemerisErrorForSV::setDeltaAf0(double deltaAf0)
    {
      m_values.AddMember("DeltaAf0", parse_json<double>::format(deltaAf0, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetEphemerisErrorForSV::deltaAf1() const
    {
      return parse_json<double>::parse(m_values["DeltaAf1"]);
    }

    void SetEphemerisErrorForSV::setDeltaAf1(double deltaAf1)
    {
      m_values.AddMember("DeltaAf1", parse_json<double>::format(deltaAf1, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisErrorForSV
///
#include "gen/GetEphemerisErrorForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisErrorForSV::CmdName = "GetEphemerisErrorForSV";
    const char* const GetEphemerisErrorForSV::Documentation = "Get the satellite ephemeris error.";

    REGISTER_COMMAND_FACTORY(GetEphemerisErrorForSV);


    GetEphemerisErrorForSV::GetEphemerisErrorForSV()
      : CommandBase(CmdName)
    {}

    GetEphemerisErrorForSV::GetEphemerisErrorForSV(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    GetEphemerisErrorForSVPtr GetEphemerisErrorForSV::create(const std::string& system, int svId)
    {
      return GetEphemerisErrorForSVPtr(new GetEphemerisErrorForSV(system, svId));
    }

    GetEphemerisErrorForSVPtr GetEphemerisErrorForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisErrorForSV>(ptr);
    }

    bool GetEphemerisErrorForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetEphemerisErrorForSV::documentation() const { return Documentation; }


    int GetEphemerisErrorForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetEphemerisErrorForSV::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisErrorForSV::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisErrorForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisErrorForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetEphemerisErrorForSVResult
///
#include "gen/GetEphemerisErrorForSVResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetEphemerisErrorForSVResult::CmdName = "GetEphemerisErrorForSVResult";
    const char* const GetEphemerisErrorForSVResult::Documentation = "Result of GetEphemerisErrorForSV";

    REGISTER_COMMAND_RESULT_FACTORY(GetEphemerisErrorForSVResult);


    GetEphemerisErrorForSVResult::GetEphemerisErrorForSVResult()
      : CommandResult(CmdName)
    {}

    GetEphemerisErrorForSVResult::GetEphemerisErrorForSVResult(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setOrbit(orbit);
      setDeltaAf0(deltaAf0);
      setDeltaAf1(deltaAf1);
    }


    GetEphemerisErrorForSVResultPtr GetEphemerisErrorForSVResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
    {
      return GetEphemerisErrorForSVResultPtr(new GetEphemerisErrorForSVResult(relatedCommand, system, svId, orbit, deltaAf0, deltaAf1));
    }

    GetEphemerisErrorForSVResultPtr GetEphemerisErrorForSVResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetEphemerisErrorForSVResult>(ptr);
    }

    bool GetEphemerisErrorForSVResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::RIC>::is_valid(m_values["Orbit"])
          && parse_json<double>::is_valid(m_values["DeltaAf0"])
          && parse_json<double>::is_valid(m_values["DeltaAf1"])
        ;

    }

    std::string GetEphemerisErrorForSVResult::documentation() const { return Documentation; }


    std::string GetEphemerisErrorForSVResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetEphemerisErrorForSVResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetEphemerisErrorForSVResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetEphemerisErrorForSVResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::RIC GetEphemerisErrorForSVResult::orbit() const
    {
      return parse_json<Sdx::RIC>::parse(m_values["Orbit"]);
    }

    void GetEphemerisErrorForSVResult::setOrbit(const Sdx::RIC& orbit)
    {
      m_values.AddMember("Orbit", parse_json<Sdx::RIC>::format(orbit, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetEphemerisErrorForSVResult::deltaAf0() const
    {
      return parse_json<double>::parse(m_values["DeltaAf0"]);
    }

    void GetEphemerisErrorForSVResult::setDeltaAf0(double deltaAf0)
    {
      m_values.AddMember("DeltaAf0", parse_json<double>::format(deltaAf0, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetEphemerisErrorForSVResult::deltaAf1() const
    {
      return parse_json<double>::parse(m_values["DeltaAf1"]);
    }

    void GetEphemerisErrorForSVResult::setDeltaAf1(double deltaAf1)
    {
      m_values.AddMember("DeltaAf1", parse_json<double>::format(deltaAf1, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetUsingVelocityInSbasMessage25
///
#include "gen/SetUsingVelocityInSbasMessage25.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetUsingVelocityInSbasMessage25::CmdName = "SetUsingVelocityInSbasMessage25";
    const char* const SetUsingVelocityInSbasMessage25::Documentation = "Set whether SBAS message 25 should send velocity corrections";

    REGISTER_COMMAND_FACTORY(SetUsingVelocityInSbasMessage25);


    SetUsingVelocityInSbasMessage25::SetUsingVelocityInSbasMessage25()
      : CommandBase(CmdName)
    {}

    SetUsingVelocityInSbasMessage25::SetUsingVelocityInSbasMessage25(bool useVelocity)
      : CommandBase(CmdName)
    {

      setUseVelocity(useVelocity);
    }


    SetUsingVelocityInSbasMessage25Ptr SetUsingVelocityInSbasMessage25::create(bool useVelocity)
    {
      return SetUsingVelocityInSbasMessage25Ptr(new SetUsingVelocityInSbasMessage25(useVelocity));
    }

    SetUsingVelocityInSbasMessage25Ptr SetUsingVelocityInSbasMessage25::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetUsingVelocityInSbasMessage25>(ptr);
    }

    bool SetUsingVelocityInSbasMessage25::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["UseVelocity"])
        ;

    }

    std::string SetUsingVelocityInSbasMessage25::documentation() const { return Documentation; }


    int SetUsingVelocityInSbasMessage25::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool SetUsingVelocityInSbasMessage25::useVelocity() const
    {
      return parse_json<bool>::parse(m_values["UseVelocity"]);
    }

    void SetUsingVelocityInSbasMessage25::setUseVelocity(bool useVelocity)
    {
      m_values.AddMember("UseVelocity", parse_json<bool>::format(useVelocity, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsUsingVelocityInSbasMessage25
///
#include "gen/IsUsingVelocityInSbasMessage25.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsUsingVelocityInSbasMessage25::CmdName = "IsUsingVelocityInSbasMessage25";
    const char* const IsUsingVelocityInSbasMessage25::Documentation = "Get whether SBAS message 25 should send velocity corrections";

    REGISTER_COMMAND_FACTORY(IsUsingVelocityInSbasMessage25);


    IsUsingVelocityInSbasMessage25::IsUsingVelocityInSbasMessage25()
      : CommandBase(CmdName)
    {

    }


    IsUsingVelocityInSbasMessage25Ptr IsUsingVelocityInSbasMessage25::create()
    {
      return IsUsingVelocityInSbasMessage25Ptr(new IsUsingVelocityInSbasMessage25());
    }

    IsUsingVelocityInSbasMessage25Ptr IsUsingVelocityInSbasMessage25::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsUsingVelocityInSbasMessage25>(ptr);
    }

    bool IsUsingVelocityInSbasMessage25::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsUsingVelocityInSbasMessage25::documentation() const { return Documentation; }


    int IsUsingVelocityInSbasMessage25::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsUsingVelocityInSbasMessage25Result
///
#include "gen/IsUsingVelocityInSbasMessage25Result.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsUsingVelocityInSbasMessage25Result::CmdName = "IsUsingVelocityInSbasMessage25Result";
    const char* const IsUsingVelocityInSbasMessage25Result::Documentation = "Result of IsUsingVelocityInSbasMessage25";

    REGISTER_COMMAND_RESULT_FACTORY(IsUsingVelocityInSbasMessage25Result);


    IsUsingVelocityInSbasMessage25Result::IsUsingVelocityInSbasMessage25Result()
      : CommandResult(CmdName)
    {}

    IsUsingVelocityInSbasMessage25Result::IsUsingVelocityInSbasMessage25Result(CommandBasePtr relatedCommand, bool useVelocity)
      : CommandResult(CmdName, relatedCommand)
    {

      setUseVelocity(useVelocity);
    }


    IsUsingVelocityInSbasMessage25ResultPtr IsUsingVelocityInSbasMessage25Result::create(CommandBasePtr relatedCommand, bool useVelocity)
    {
      return IsUsingVelocityInSbasMessage25ResultPtr(new IsUsingVelocityInSbasMessage25Result(relatedCommand, useVelocity));
    }

    IsUsingVelocityInSbasMessage25ResultPtr IsUsingVelocityInSbasMessage25Result::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsUsingVelocityInSbasMessage25Result>(ptr);
    }

    bool IsUsingVelocityInSbasMessage25Result::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["UseVelocity"])
        ;

    }

    std::string IsUsingVelocityInSbasMessage25Result::documentation() const { return Documentation; }


    bool IsUsingVelocityInSbasMessage25Result::useVelocity() const
    {
      return parse_json<bool>::parse(m_values["UseVelocity"]);
    }

    void IsUsingVelocityInSbasMessage25Result::setUseVelocity(bool useVelocity)
    {
      m_values.AddMember("UseVelocity", parse_json<bool>::format(useVelocity, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ForceSVGeo
///
#include "gen/ForceSVGeo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ForceSVGeo::CmdName = "ForceSVGeo";
    const char* const ForceSVGeo::Documentation = "Set whether a satellite is geostationary";

    REGISTER_COMMAND_FACTORY(ForceSVGeo);


    ForceSVGeo::ForceSVGeo()
      : CommandBase(CmdName)
    {}

    ForceSVGeo::ForceSVGeo(const std::string& system, int svId, bool isGeo, double longitude)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
      setIsGeo(isGeo);
      setLongitude(longitude);
    }


    ForceSVGeoPtr ForceSVGeo::create(const std::string& system, int svId, bool isGeo, double longitude)
    {
      return ForceSVGeoPtr(new ForceSVGeo(system, svId, isGeo, longitude));
    }

    ForceSVGeoPtr ForceSVGeo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ForceSVGeo>(ptr);
    }

    bool ForceSVGeo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsGeo"])
          && parse_json<double>::is_valid(m_values["Longitude"])
        ;

    }

    std::string ForceSVGeo::documentation() const { return Documentation; }


    int ForceSVGeo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ForceSVGeo::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void ForceSVGeo::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int ForceSVGeo::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void ForceSVGeo::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ForceSVGeo::isGeo() const
    {
      return parse_json<bool>::parse(m_values["IsGeo"]);
    }

    void ForceSVGeo::setIsGeo(bool isGeo)
    {
      m_values.AddMember("IsGeo", parse_json<bool>::format(isGeo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double ForceSVGeo::longitude() const
    {
      return parse_json<double>::parse(m_values["Longitude"]);
    }

    void ForceSVGeo::setLongitude(double longitude)
    {
      m_values.AddMember("Longitude", parse_json<double>::format(longitude, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSVForcedGeo
///
#include "gen/IsSVForcedGeo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSVForcedGeo::CmdName = "IsSVForcedGeo";
    const char* const IsSVForcedGeo::Documentation = "Get whether a satellite is geostationary";

    REGISTER_COMMAND_FACTORY(IsSVForcedGeo);


    IsSVForcedGeo::IsSVForcedGeo()
      : CommandBase(CmdName)
    {}

    IsSVForcedGeo::IsSVForcedGeo(const std::string& system, int svId)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setSvId(svId);
    }


    IsSVForcedGeoPtr IsSVForcedGeo::create(const std::string& system, int svId)
    {
      return IsSVForcedGeoPtr(new IsSVForcedGeo(system, svId));
    }

    IsSVForcedGeoPtr IsSVForcedGeo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSVForcedGeo>(ptr);
    }

    bool IsSVForcedGeo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsSVForcedGeo::documentation() const { return Documentation; }


    int IsSVForcedGeo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSVForcedGeo::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSVForcedGeo::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSVForcedGeo::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSVForcedGeo::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSVForcedGeoResult
///
#include "gen/IsSVForcedGeoResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSVForcedGeoResult::CmdName = "IsSVForcedGeoResult";
    const char* const IsSVForcedGeoResult::Documentation = "Result of IsSVForcedGeo";

    REGISTER_COMMAND_RESULT_FACTORY(IsSVForcedGeoResult);


    IsSVForcedGeoResult::IsSVForcedGeoResult()
      : CommandResult(CmdName)
    {}

    IsSVForcedGeoResult::IsSVForcedGeoResult(CommandBasePtr relatedCommand, const std::string& system, int svId, bool isGeo, double longitude)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setSvId(svId);
      setIsGeo(isGeo);
      setLongitude(longitude);
    }


    IsSVForcedGeoResultPtr IsSVForcedGeoResult::create(CommandBasePtr relatedCommand, const std::string& system, int svId, bool isGeo, double longitude)
    {
      return IsSVForcedGeoResultPtr(new IsSVForcedGeoResult(relatedCommand, system, svId, isGeo, longitude));
    }

    IsSVForcedGeoResultPtr IsSVForcedGeoResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSVForcedGeoResult>(ptr);
    }

    bool IsSVForcedGeoResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsGeo"])
          && parse_json<double>::is_valid(m_values["Longitude"])
        ;

    }

    std::string IsSVForcedGeoResult::documentation() const { return Documentation; }


    std::string IsSVForcedGeoResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSVForcedGeoResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSVForcedGeoResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsSVForcedGeoResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSVForcedGeoResult::isGeo() const
    {
      return parse_json<bool>::parse(m_values["IsGeo"]);
    }

    void IsSVForcedGeoResult::setIsGeo(bool isGeo)
    {
      m_values.AddMember("IsGeo", parse_json<bool>::format(isGeo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double IsSVForcedGeoResult::longitude() const
    {
      return parse_json<double>::parse(m_values["Longitude"]);
    }

    void IsSVForcedGeoResult::setLongitude(double longitude)
    {
      m_values.AddMember("Longitude", parse_json<double>::format(longitude, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSbasFastCorrectionsFor
///
#include "gen/EnableSbasFastCorrectionsFor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSbasFastCorrectionsFor::CmdName = "EnableSbasFastCorrectionsFor";
    const char* const EnableSbasFastCorrectionsFor::Documentation = "Set whether pseudorange errors for this constellation should be compensated in SBAS fast corrections";

    REGISTER_COMMAND_FACTORY(EnableSbasFastCorrectionsFor);


    EnableSbasFastCorrectionsFor::EnableSbasFastCorrectionsFor()
      : CommandBase(CmdName)
    {}

    EnableSbasFastCorrectionsFor::EnableSbasFastCorrectionsFor(const std::string& system, bool isEnabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setIsEnabled(isEnabled);
    }


    EnableSbasFastCorrectionsForPtr EnableSbasFastCorrectionsFor::create(const std::string& system, bool isEnabled)
    {
      return EnableSbasFastCorrectionsForPtr(new EnableSbasFastCorrectionsFor(system, isEnabled));
    }

    EnableSbasFastCorrectionsForPtr EnableSbasFastCorrectionsFor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSbasFastCorrectionsFor>(ptr);
    }

    bool EnableSbasFastCorrectionsFor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string EnableSbasFastCorrectionsFor::documentation() const { return Documentation; }


    int EnableSbasFastCorrectionsFor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EnableSbasFastCorrectionsFor::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableSbasFastCorrectionsFor::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableSbasFastCorrectionsFor::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void EnableSbasFastCorrectionsFor::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSbasFastCorrectionsEnabledFor
///
#include "gen/IsSbasFastCorrectionsEnabledFor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSbasFastCorrectionsEnabledFor::CmdName = "IsSbasFastCorrectionsEnabledFor";
    const char* const IsSbasFastCorrectionsEnabledFor::Documentation = "Get whether pseudorange errors for this constellation should be compensated in SBAS fast corrections";

    REGISTER_COMMAND_FACTORY(IsSbasFastCorrectionsEnabledFor);


    IsSbasFastCorrectionsEnabledFor::IsSbasFastCorrectionsEnabledFor()
      : CommandBase(CmdName)
    {}

    IsSbasFastCorrectionsEnabledFor::IsSbasFastCorrectionsEnabledFor(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsSbasFastCorrectionsEnabledForPtr IsSbasFastCorrectionsEnabledFor::create(const std::string& system)
    {
      return IsSbasFastCorrectionsEnabledForPtr(new IsSbasFastCorrectionsEnabledFor(system));
    }

    IsSbasFastCorrectionsEnabledForPtr IsSbasFastCorrectionsEnabledFor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSbasFastCorrectionsEnabledFor>(ptr);
    }

    bool IsSbasFastCorrectionsEnabledFor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsSbasFastCorrectionsEnabledFor::documentation() const { return Documentation; }


    int IsSbasFastCorrectionsEnabledFor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSbasFastCorrectionsEnabledFor::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSbasFastCorrectionsEnabledFor::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSbasFastCorrectionsEnabledForResult
///
#include "gen/IsSbasFastCorrectionsEnabledForResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSbasFastCorrectionsEnabledForResult::CmdName = "IsSbasFastCorrectionsEnabledForResult";
    const char* const IsSbasFastCorrectionsEnabledForResult::Documentation = "Result of IsSbasFastCorrectionsEnabledFor";

    REGISTER_COMMAND_RESULT_FACTORY(IsSbasFastCorrectionsEnabledForResult);


    IsSbasFastCorrectionsEnabledForResult::IsSbasFastCorrectionsEnabledForResult()
      : CommandResult(CmdName)
    {}

    IsSbasFastCorrectionsEnabledForResult::IsSbasFastCorrectionsEnabledForResult(CommandBasePtr relatedCommand, const std::string& system, bool isEnabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setIsEnabled(isEnabled);
    }


    IsSbasFastCorrectionsEnabledForResultPtr IsSbasFastCorrectionsEnabledForResult::create(CommandBasePtr relatedCommand, const std::string& system, bool isEnabled)
    {
      return IsSbasFastCorrectionsEnabledForResultPtr(new IsSbasFastCorrectionsEnabledForResult(relatedCommand, system, isEnabled));
    }

    IsSbasFastCorrectionsEnabledForResultPtr IsSbasFastCorrectionsEnabledForResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSbasFastCorrectionsEnabledForResult>(ptr);
    }

    bool IsSbasFastCorrectionsEnabledForResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string IsSbasFastCorrectionsEnabledForResult::documentation() const { return Documentation; }


    std::string IsSbasFastCorrectionsEnabledForResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSbasFastCorrectionsEnabledForResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSbasFastCorrectionsEnabledForResult::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void IsSbasFastCorrectionsEnabledForResult::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ApplyDelayInSbas
///
#include "gen/ApplyDelayInSbas.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ApplyDelayInSbas::CmdName = "ApplyDelayInSbas";
    const char* const ApplyDelayInSbas::Documentation = "Set whether the ionospheric offsets grid should be used for SBAS corrections in message 26";

    REGISTER_COMMAND_FACTORY(ApplyDelayInSbas);


    ApplyDelayInSbas::ApplyDelayInSbas()
      : CommandBase(CmdName)
    {}

    ApplyDelayInSbas::ApplyDelayInSbas(bool isEnabled)
      : CommandBase(CmdName)
    {

      setIsEnabled(isEnabled);
    }


    ApplyDelayInSbasPtr ApplyDelayInSbas::create(bool isEnabled)
    {
      return ApplyDelayInSbasPtr(new ApplyDelayInSbas(isEnabled));
    }

    ApplyDelayInSbasPtr ApplyDelayInSbas::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ApplyDelayInSbas>(ptr);
    }

    bool ApplyDelayInSbas::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string ApplyDelayInSbas::documentation() const { return Documentation; }


    int ApplyDelayInSbas::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ApplyDelayInSbas::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void ApplyDelayInSbas::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsDelayAppliedInSbas
///
#include "gen/IsDelayAppliedInSbas.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsDelayAppliedInSbas::CmdName = "IsDelayAppliedInSbas";
    const char* const IsDelayAppliedInSbas::Documentation = "Get whether the ionospheric offsets grid should be used for SBAS corrections in message 26";

    REGISTER_COMMAND_FACTORY(IsDelayAppliedInSbas);


    IsDelayAppliedInSbas::IsDelayAppliedInSbas()
      : CommandBase(CmdName)
    {

    }


    IsDelayAppliedInSbasPtr IsDelayAppliedInSbas::create()
    {
      return IsDelayAppliedInSbasPtr(new IsDelayAppliedInSbas());
    }

    IsDelayAppliedInSbasPtr IsDelayAppliedInSbas::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsDelayAppliedInSbas>(ptr);
    }

    bool IsDelayAppliedInSbas::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsDelayAppliedInSbas::documentation() const { return Documentation; }


    int IsDelayAppliedInSbas::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsDelayAppliedInSbasResult
///
#include "gen/IsDelayAppliedInSbasResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsDelayAppliedInSbasResult::CmdName = "IsDelayAppliedInSbasResult";
    const char* const IsDelayAppliedInSbasResult::Documentation = "Result of IsDelayAppliedInSbas";

    REGISTER_COMMAND_RESULT_FACTORY(IsDelayAppliedInSbasResult);


    IsDelayAppliedInSbasResult::IsDelayAppliedInSbasResult()
      : CommandResult(CmdName)
    {}

    IsDelayAppliedInSbasResult::IsDelayAppliedInSbasResult(CommandBasePtr relatedCommand, bool isEnabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsEnabled(isEnabled);
    }


    IsDelayAppliedInSbasResultPtr IsDelayAppliedInSbasResult::create(CommandBasePtr relatedCommand, bool isEnabled)
    {
      return IsDelayAppliedInSbasResultPtr(new IsDelayAppliedInSbasResult(relatedCommand, isEnabled));
    }

    IsDelayAppliedInSbasResultPtr IsDelayAppliedInSbasResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsDelayAppliedInSbasResult>(ptr);
    }

    bool IsDelayAppliedInSbasResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string IsDelayAppliedInSbasResult::documentation() const { return Documentation; }


    bool IsDelayAppliedInSbasResult::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void IsDelayAppliedInSbasResult::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableIonoOffset
///
#include "gen/EnableIonoOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableIonoOffset::CmdName = "EnableIonoOffset";
    const char* const EnableIonoOffset::Documentation = "Set whether the ionospheric offsets grid should be applied to the ionosphere";

    REGISTER_COMMAND_FACTORY(EnableIonoOffset);


    EnableIonoOffset::EnableIonoOffset()
      : CommandBase(CmdName)
    {}

    EnableIonoOffset::EnableIonoOffset(bool isEnabled)
      : CommandBase(CmdName)
    {

      setIsEnabled(isEnabled);
    }


    EnableIonoOffsetPtr EnableIonoOffset::create(bool isEnabled)
    {
      return EnableIonoOffsetPtr(new EnableIonoOffset(isEnabled));
    }

    EnableIonoOffsetPtr EnableIonoOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableIonoOffset>(ptr);
    }

    bool EnableIonoOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string EnableIonoOffset::documentation() const { return Documentation; }


    int EnableIonoOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool EnableIonoOffset::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void EnableIonoOffset::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsIonoOffsetEnabled
///
#include "gen/IsIonoOffsetEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIonoOffsetEnabled::CmdName = "IsIonoOffsetEnabled";
    const char* const IsIonoOffsetEnabled::Documentation = "Get whether the ionospheric offsets grid should be applied to the ionosphere";

    REGISTER_COMMAND_FACTORY(IsIonoOffsetEnabled);


    IsIonoOffsetEnabled::IsIonoOffsetEnabled()
      : CommandBase(CmdName)
    {

    }


    IsIonoOffsetEnabledPtr IsIonoOffsetEnabled::create()
    {
      return IsIonoOffsetEnabledPtr(new IsIonoOffsetEnabled());
    }

    IsIonoOffsetEnabledPtr IsIonoOffsetEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIonoOffsetEnabled>(ptr);
    }

    bool IsIonoOffsetEnabled::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsIonoOffsetEnabled::documentation() const { return Documentation; }


    int IsIonoOffsetEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of IsIonoOffsetEnabledResult
///
#include "gen/IsIonoOffsetEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsIonoOffsetEnabledResult::CmdName = "IsIonoOffsetEnabledResult";
    const char* const IsIonoOffsetEnabledResult::Documentation = "Result of IsIonoOffsetEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsIonoOffsetEnabledResult);


    IsIonoOffsetEnabledResult::IsIonoOffsetEnabledResult()
      : CommandResult(CmdName)
    {}

    IsIonoOffsetEnabledResult::IsIonoOffsetEnabledResult(CommandBasePtr relatedCommand, bool isEnabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsEnabled(isEnabled);
    }


    IsIonoOffsetEnabledResultPtr IsIonoOffsetEnabledResult::create(CommandBasePtr relatedCommand, bool isEnabled)
    {
      return IsIonoOffsetEnabledResultPtr(new IsIonoOffsetEnabledResult(relatedCommand, isEnabled));
    }

    IsIonoOffsetEnabledResultPtr IsIonoOffsetEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsIonoOffsetEnabledResult>(ptr);
    }

    bool IsIonoOffsetEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string IsIonoOffsetEnabledResult::documentation() const { return Documentation; }


    bool IsIonoOffsetEnabledResult::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void IsIonoOffsetEnabledResult::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSbasLongTermCorrectionsFor
///
#include "gen/EnableSbasLongTermCorrectionsFor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSbasLongTermCorrectionsFor::CmdName = "EnableSbasLongTermCorrectionsFor";
    const char* const EnableSbasLongTermCorrectionsFor::Documentation = "Set whether ephemeris errors for this constellation should be compensated in SBAS long term corrections";

    REGISTER_COMMAND_FACTORY(EnableSbasLongTermCorrectionsFor);


    EnableSbasLongTermCorrectionsFor::EnableSbasLongTermCorrectionsFor()
      : CommandBase(CmdName)
    {}

    EnableSbasLongTermCorrectionsFor::EnableSbasLongTermCorrectionsFor(const std::string& system, bool isEnabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setIsEnabled(isEnabled);
    }


    EnableSbasLongTermCorrectionsForPtr EnableSbasLongTermCorrectionsFor::create(const std::string& system, bool isEnabled)
    {
      return EnableSbasLongTermCorrectionsForPtr(new EnableSbasLongTermCorrectionsFor(system, isEnabled));
    }

    EnableSbasLongTermCorrectionsForPtr EnableSbasLongTermCorrectionsFor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSbasLongTermCorrectionsFor>(ptr);
    }

    bool EnableSbasLongTermCorrectionsFor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string EnableSbasLongTermCorrectionsFor::documentation() const { return Documentation; }


    int EnableSbasLongTermCorrectionsFor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EnableSbasLongTermCorrectionsFor::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableSbasLongTermCorrectionsFor::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableSbasLongTermCorrectionsFor::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void EnableSbasLongTermCorrectionsFor::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSbasLongTermCorrectionsEnabledFor
///
#include "gen/IsSbasLongTermCorrectionsEnabledFor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSbasLongTermCorrectionsEnabledFor::CmdName = "IsSbasLongTermCorrectionsEnabledFor";
    const char* const IsSbasLongTermCorrectionsEnabledFor::Documentation = "Get whether ephemeris errors for this constellation should be compensated in SBAS long term corrections";

    REGISTER_COMMAND_FACTORY(IsSbasLongTermCorrectionsEnabledFor);


    IsSbasLongTermCorrectionsEnabledFor::IsSbasLongTermCorrectionsEnabledFor()
      : CommandBase(CmdName)
    {}

    IsSbasLongTermCorrectionsEnabledFor::IsSbasLongTermCorrectionsEnabledFor(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsSbasLongTermCorrectionsEnabledForPtr IsSbasLongTermCorrectionsEnabledFor::create(const std::string& system)
    {
      return IsSbasLongTermCorrectionsEnabledForPtr(new IsSbasLongTermCorrectionsEnabledFor(system));
    }

    IsSbasLongTermCorrectionsEnabledForPtr IsSbasLongTermCorrectionsEnabledFor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSbasLongTermCorrectionsEnabledFor>(ptr);
    }

    bool IsSbasLongTermCorrectionsEnabledFor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsSbasLongTermCorrectionsEnabledFor::documentation() const { return Documentation; }


    int IsSbasLongTermCorrectionsEnabledFor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSbasLongTermCorrectionsEnabledFor::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSbasLongTermCorrectionsEnabledFor::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSbasLongTermCorrectionsEnabledForResult
///
#include "gen/IsSbasLongTermCorrectionsEnabledForResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSbasLongTermCorrectionsEnabledForResult::CmdName = "IsSbasLongTermCorrectionsEnabledForResult";
    const char* const IsSbasLongTermCorrectionsEnabledForResult::Documentation = "Result of IsSbasLongTermCorrectionsEnabledFor";

    REGISTER_COMMAND_RESULT_FACTORY(IsSbasLongTermCorrectionsEnabledForResult);


    IsSbasLongTermCorrectionsEnabledForResult::IsSbasLongTermCorrectionsEnabledForResult()
      : CommandResult(CmdName)
    {}

    IsSbasLongTermCorrectionsEnabledForResult::IsSbasLongTermCorrectionsEnabledForResult(CommandBasePtr relatedCommand, const std::string& system, bool isEnabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setIsEnabled(isEnabled);
    }


    IsSbasLongTermCorrectionsEnabledForResultPtr IsSbasLongTermCorrectionsEnabledForResult::create(CommandBasePtr relatedCommand, const std::string& system, bool isEnabled)
    {
      return IsSbasLongTermCorrectionsEnabledForResultPtr(new IsSbasLongTermCorrectionsEnabledForResult(relatedCommand, system, isEnabled));
    }

    IsSbasLongTermCorrectionsEnabledForResultPtr IsSbasLongTermCorrectionsEnabledForResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSbasLongTermCorrectionsEnabledForResult>(ptr);
    }

    bool IsSbasLongTermCorrectionsEnabledForResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["IsEnabled"])
        ;

    }

    std::string IsSbasLongTermCorrectionsEnabledForResult::documentation() const { return Documentation; }


    std::string IsSbasLongTermCorrectionsEnabledForResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSbasLongTermCorrectionsEnabledForResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSbasLongTermCorrectionsEnabledForResult::isEnabled() const
    {
      return parse_json<bool>::parse(m_values["IsEnabled"]);
    }

    void IsSbasLongTermCorrectionsEnabledForResult::setIsEnabled(bool isEnabled)
    {
      m_values.AddMember("IsEnabled", parse_json<bool>::format(isEnabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsUraIndexForSV
///
#include "gen/SetGpsUraIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsUraIndexForSV::CmdName = "SetGpsUraIndexForSV";
    const char* const SetGpsUraIndexForSV::Documentation = "Set the ura index of a GPS satellite";

    REGISTER_COMMAND_FACTORY(SetGpsUraIndexForSV);


    SetGpsUraIndexForSV::SetGpsUraIndexForSV()
      : CommandBase(CmdName)
    {}

    SetGpsUraIndexForSV::SetGpsUraIndexForSV(int svId, int urai)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
    }


    SetGpsUraIndexForSVPtr SetGpsUraIndexForSV::create(int svId, int urai)
    {
      return SetGpsUraIndexForSVPtr(new SetGpsUraIndexForSV(svId, urai));
    }

    SetGpsUraIndexForSVPtr SetGpsUraIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsUraIndexForSV>(ptr);
    }

    bool SetGpsUraIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
        ;

    }

    std::string SetGpsUraIndexForSV::documentation() const { return Documentation; }


    int SetGpsUraIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGpsUraIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGpsUraIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsUraIndexForSV::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetGpsUraIndexForSV::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouUraIndexForSV
///
#include "gen/SetBeiDouUraIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouUraIndexForSV::CmdName = "SetBeiDouUraIndexForSV";
    const char* const SetBeiDouUraIndexForSV::Documentation = "Set the ura index of a BeiDou satellite";

    REGISTER_COMMAND_FACTORY(SetBeiDouUraIndexForSV);


    SetBeiDouUraIndexForSV::SetBeiDouUraIndexForSV()
      : CommandBase(CmdName)
    {}

    SetBeiDouUraIndexForSV::SetBeiDouUraIndexForSV(int svId, int urai)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
    }


    SetBeiDouUraIndexForSVPtr SetBeiDouUraIndexForSV::create(int svId, int urai)
    {
      return SetBeiDouUraIndexForSVPtr(new SetBeiDouUraIndexForSV(svId, urai));
    }

    SetBeiDouUraIndexForSVPtr SetBeiDouUraIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouUraIndexForSV>(ptr);
    }

    bool SetBeiDouUraIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
        ;

    }

    std::string SetBeiDouUraIndexForSV::documentation() const { return Documentation; }


    int SetBeiDouUraIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetBeiDouUraIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetBeiDouUraIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouUraIndexForSV::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetBeiDouUraIndexForSV::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssUraIndexForSV
///
#include "gen/SetQzssUraIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssUraIndexForSV::CmdName = "SetQzssUraIndexForSV";
    const char* const SetQzssUraIndexForSV::Documentation = "Set the URA index of a QZSS satellite";

    REGISTER_COMMAND_FACTORY(SetQzssUraIndexForSV);


    SetQzssUraIndexForSV::SetQzssUraIndexForSV()
      : CommandBase(CmdName)
    {}

    SetQzssUraIndexForSV::SetQzssUraIndexForSV(int svId, int urai)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
    }


    SetQzssUraIndexForSVPtr SetQzssUraIndexForSV::create(int svId, int urai)
    {
      return SetQzssUraIndexForSVPtr(new SetQzssUraIndexForSV(svId, urai));
    }

    SetQzssUraIndexForSVPtr SetQzssUraIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssUraIndexForSV>(ptr);
    }

    bool SetQzssUraIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
        ;

    }

    std::string SetQzssUraIndexForSV::documentation() const { return Documentation; }


    int SetQzssUraIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetQzssUraIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssUraIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssUraIndexForSV::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetQzssUraIndexForSV::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssUraIndex
///
#include "gen/SetQzssUraIndex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssUraIndex::CmdName = "SetQzssUraIndex";
    const char* const SetQzssUraIndex::Documentation = "Please note the command SetQzssUraIndex is deprecated since 21.3. You may use SetQzssUraIndexForSV.\n\nSet the URA index of a QZSS satellite";

    REGISTER_COMMAND_FACTORY(SetQzssUraIndex);


    SetQzssUraIndex::SetQzssUraIndex()
      : CommandBase(CmdName)
    {}

    SetQzssUraIndex::SetQzssUraIndex(int svId, int urai)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
    }


    SetQzssUraIndexPtr SetQzssUraIndex::create(int svId, int urai)
    {
      return SetQzssUraIndexPtr(new SetQzssUraIndex(svId, urai));
    }

    SetQzssUraIndexPtr SetQzssUraIndex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssUraIndex>(ptr);
    }

    bool SetQzssUraIndex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
        ;

    }

    std::string SetQzssUraIndex::documentation() const { return Documentation; }


    int SetQzssUraIndex::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetQzssUraIndex::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssUraIndex::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssUraIndex::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetQzssUraIndex::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICUraIndexForSV
///
#include "gen/SetNavICUraIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICUraIndexForSV::CmdName = "SetNavICUraIndexForSV";
    const char* const SetNavICUraIndexForSV::Documentation = "Set the URA index of a NavIC satellite";

    REGISTER_COMMAND_FACTORY(SetNavICUraIndexForSV);


    SetNavICUraIndexForSV::SetNavICUraIndexForSV()
      : CommandBase(CmdName)
    {}

    SetNavICUraIndexForSV::SetNavICUraIndexForSV(int svId, int urai)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
    }


    SetNavICUraIndexForSVPtr SetNavICUraIndexForSV::create(int svId, int urai)
    {
      return SetNavICUraIndexForSVPtr(new SetNavICUraIndexForSV(svId, urai));
    }

    SetNavICUraIndexForSVPtr SetNavICUraIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICUraIndexForSV>(ptr);
    }

    bool SetNavICUraIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
        ;

    }

    std::string SetNavICUraIndexForSV::documentation() const { return Documentation; }


    int SetNavICUraIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetNavICUraIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICUraIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetNavICUraIndexForSV::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetNavICUraIndexForSV::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetNavICUraIndex
///
#include "gen/SetNavICUraIndex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetNavICUraIndex::CmdName = "SetNavICUraIndex";
    const char* const SetNavICUraIndex::Documentation = "Please note the command SetNavICUraIndex is deprecated since 21.3. You may use SetNavICUraIndexForSV.\n\nSet the URA index of a NavIC satellite";

    REGISTER_COMMAND_FACTORY(SetNavICUraIndex);


    SetNavICUraIndex::SetNavICUraIndex()
      : CommandBase(CmdName)
    {}

    SetNavICUraIndex::SetNavICUraIndex(int svId, int urai)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setUrai(urai);
    }


    SetNavICUraIndexPtr SetNavICUraIndex::create(int svId, int urai)
    {
      return SetNavICUraIndexPtr(new SetNavICUraIndex(svId, urai));
    }

    SetNavICUraIndexPtr SetNavICUraIndex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetNavICUraIndex>(ptr);
    }

    bool SetNavICUraIndex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Urai"])
        ;

    }

    std::string SetNavICUraIndex::documentation() const { return Documentation; }


    int SetNavICUraIndex::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetNavICUraIndex::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetNavICUraIndex::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetNavICUraIndex::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetNavICUraIndex::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSisaE1E5aIndexForSV
///
#include "gen/SetGalileoSisaE1E5aIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSisaE1E5aIndexForSV::CmdName = "SetGalileoSisaE1E5aIndexForSV";
    const char* const SetGalileoSisaE1E5aIndexForSV::Documentation = "Set the SISA(E1,E5a) index of a Galileo satellite";

    REGISTER_COMMAND_FACTORY(SetGalileoSisaE1E5aIndexForSV);


    SetGalileoSisaE1E5aIndexForSV::SetGalileoSisaE1E5aIndexForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoSisaE1E5aIndexForSV::SetGalileoSisaE1E5aIndexForSV(int svId, int sisai)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSisai(sisai);
    }


    SetGalileoSisaE1E5aIndexForSVPtr SetGalileoSisaE1E5aIndexForSV::create(int svId, int sisai)
    {
      return SetGalileoSisaE1E5aIndexForSVPtr(new SetGalileoSisaE1E5aIndexForSV(svId, sisai));
    }

    SetGalileoSisaE1E5aIndexForSVPtr SetGalileoSisaE1E5aIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSisaE1E5aIndexForSV>(ptr);
    }

    bool SetGalileoSisaE1E5aIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Sisai"])
        ;

    }

    std::string SetGalileoSisaE1E5aIndexForSV::documentation() const { return Documentation; }


    int SetGalileoSisaE1E5aIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGalileoSisaE1E5aIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoSisaE1E5aIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoSisaE1E5aIndexForSV::sisai() const
    {
      return parse_json<int>::parse(m_values["Sisai"]);
    }

    void SetGalileoSisaE1E5aIndexForSV::setSisai(int sisai)
    {
      m_values.AddMember("Sisai", parse_json<int>::format(sisai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSisaE1E5bIndexForSV
///
#include "gen/SetGalileoSisaE1E5bIndexForSV.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSisaE1E5bIndexForSV::CmdName = "SetGalileoSisaE1E5bIndexForSV";
    const char* const SetGalileoSisaE1E5bIndexForSV::Documentation = "Set the SISA(E1,E5b) index of a Galileo satellite";

    REGISTER_COMMAND_FACTORY(SetGalileoSisaE1E5bIndexForSV);


    SetGalileoSisaE1E5bIndexForSV::SetGalileoSisaE1E5bIndexForSV()
      : CommandBase(CmdName)
    {}

    SetGalileoSisaE1E5bIndexForSV::SetGalileoSisaE1E5bIndexForSV(int svId, int sisai)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setSisai(sisai);
    }


    SetGalileoSisaE1E5bIndexForSVPtr SetGalileoSisaE1E5bIndexForSV::create(int svId, int sisai)
    {
      return SetGalileoSisaE1E5bIndexForSVPtr(new SetGalileoSisaE1E5bIndexForSV(svId, sisai));
    }

    SetGalileoSisaE1E5bIndexForSVPtr SetGalileoSisaE1E5bIndexForSV::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSisaE1E5bIndexForSV>(ptr);
    }

    bool SetGalileoSisaE1E5bIndexForSV::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["Sisai"])
        ;

    }

    std::string SetGalileoSisaE1E5bIndexForSV::documentation() const { return Documentation; }


    int SetGalileoSisaE1E5bIndexForSV::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGalileoSisaE1E5bIndexForSV::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetGalileoSisaE1E5bIndexForSV::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoSisaE1E5bIndexForSV::sisai() const
    {
      return parse_json<int>::parse(m_values["Sisai"]);
    }

    void SetGalileoSisaE1E5bIndexForSV::setSisai(int sisai)
    {
      m_values.AddMember("Sisai", parse_json<int>::format(sisai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPilotCW
///
#include "gen/SetPilotCW.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPilotCW::CmdName = "SetPilotCW";
    const char* const SetPilotCW::Documentation = "Set CW pilot added to signal";

    REGISTER_COMMAND_FACTORY(SetPilotCW);


    SetPilotCW::SetPilotCW()
      : CommandBase(CmdName)
    {}

    SetPilotCW::SetPilotCW(bool enabled, int outputIdx, double centralFreqOffset, double power, const std::string& pilotId)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setOutputIdx(outputIdx);
      setCentralFreqOffset(centralFreqOffset);
      setPower(power);
      setPilotId(pilotId);
    }


    SetPilotCWPtr SetPilotCW::create(bool enabled, int outputIdx, double centralFreqOffset, double power, const std::string& pilotId)
    {
      return SetPilotCWPtr(new SetPilotCW(enabled, outputIdx, centralFreqOffset, power, pilotId));
    }

    SetPilotCWPtr SetPilotCW::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPilotCW>(ptr);
    }

    bool SetPilotCW::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["OutputIdx"])
          && parse_json<double>::is_valid(m_values["CentralFreqOffset"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["PilotId"])
        ;

    }

    std::string SetPilotCW::documentation() const { return Documentation; }


    int SetPilotCW::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetPilotCW::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPilotCW::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPilotCW::outputIdx() const
    {
      return parse_json<int>::parse(m_values["OutputIdx"]);
    }

    void SetPilotCW::setOutputIdx(int outputIdx)
    {
      m_values.AddMember("OutputIdx", parse_json<int>::format(outputIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPilotCW::centralFreqOffset() const
    {
      return parse_json<double>::parse(m_values["CentralFreqOffset"]);
    }

    void SetPilotCW::setCentralFreqOffset(double centralFreqOffset)
    {
      m_values.AddMember("CentralFreqOffset", parse_json<double>::format(centralFreqOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPilotCW::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetPilotCW::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetPilotCW::pilotId() const
    {
      return parse_json<std::string>::parse(m_values["PilotId"]);
    }

    void SetPilotCW::setPilotId(const std::string& pilotId)
    {
      m_values.AddMember("PilotId", parse_json<std::string>::format(pilotId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPilotPRN
///
#include "gen/SetPilotPRN.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPilotPRN::CmdName = "SetPilotPRN";
    const char* const SetPilotPRN::Documentation = "Set PRN pilot added to signal";

    REGISTER_COMMAND_FACTORY(SetPilotPRN);


    SetPilotPRN::SetPilotPRN()
      : CommandBase(CmdName)
    {}

    SetPilotPRN::SetPilotPRN(bool enabled, int outputIdx, double centralFreqOffset, double power, int prn, const std::string& type, const std::string& pilotId)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setOutputIdx(outputIdx);
      setCentralFreqOffset(centralFreqOffset);
      setPower(power);
      setPrn(prn);
      setType(type);
      setPilotId(pilotId);
    }


    SetPilotPRNPtr SetPilotPRN::create(bool enabled, int outputIdx, double centralFreqOffset, double power, int prn, const std::string& type, const std::string& pilotId)
    {
      return SetPilotPRNPtr(new SetPilotPRN(enabled, outputIdx, centralFreqOffset, power, prn, type, pilotId));
    }

    SetPilotPRNPtr SetPilotPRN::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPilotPRN>(ptr);
    }

    bool SetPilotPRN::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<int>::is_valid(m_values["OutputIdx"])
          && parse_json<double>::is_valid(m_values["CentralFreqOffset"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["PilotId"])
        ;

    }

    std::string SetPilotPRN::documentation() const { return Documentation; }


    int SetPilotPRN::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    bool SetPilotPRN::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetPilotPRN::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPilotPRN::outputIdx() const
    {
      return parse_json<int>::parse(m_values["OutputIdx"]);
    }

    void SetPilotPRN::setOutputIdx(int outputIdx)
    {
      m_values.AddMember("OutputIdx", parse_json<int>::format(outputIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPilotPRN::centralFreqOffset() const
    {
      return parse_json<double>::parse(m_values["CentralFreqOffset"]);
    }

    void SetPilotPRN::setCentralFreqOffset(double centralFreqOffset)
    {
      m_values.AddMember("CentralFreqOffset", parse_json<double>::format(centralFreqOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPilotPRN::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetPilotPRN::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPilotPRN::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetPilotPRN::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetPilotPRN::type() const
    {
      return parse_json<std::string>::parse(m_values["Type"]);
    }

    void SetPilotPRN::setType(const std::string& type)
    {
      m_values.AddMember("Type", parse_json<std::string>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetPilotPRN::pilotId() const
    {
      return parse_json<std::string>::parse(m_values["PilotId"]);
    }

    void SetPilotPRN::setPilotId(const std::string& pilotId)
    {
      m_values.AddMember("PilotId", parse_json<std::string>::format(pilotId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of CalibratePilotOutput
///
#include "gen/CalibratePilotOutput.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const CalibratePilotOutput::CmdName = "CalibratePilotOutput";
    const char* const CalibratePilotOutput::Documentation = "Calibrate a pilot output";

    REGISTER_COMMAND_FACTORY(CalibratePilotOutput);


    CalibratePilotOutput::CalibratePilotOutput()
      : CommandBase(CmdName)
    {}

    CalibratePilotOutput::CalibratePilotOutput(int outputIdx, double power, double time, double carrierPhase)
      : CommandBase(CmdName)
    {

      setOutputIdx(outputIdx);
      setPower(power);
      setTime(time);
      setCarrierPhase(carrierPhase);
    }


    CalibratePilotOutputPtr CalibratePilotOutput::create(int outputIdx, double power, double time, double carrierPhase)
    {
      return CalibratePilotOutputPtr(new CalibratePilotOutput(outputIdx, power, time, carrierPhase));
    }

    CalibratePilotOutputPtr CalibratePilotOutput::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<CalibratePilotOutput>(ptr);
    }

    bool CalibratePilotOutput::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["OutputIdx"])
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<double>::is_valid(m_values["Time"])
          && parse_json<double>::is_valid(m_values["CarrierPhase"])
        ;

    }

    std::string CalibratePilotOutput::documentation() const { return Documentation; }


    int CalibratePilotOutput::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    int CalibratePilotOutput::outputIdx() const
    {
      return parse_json<int>::parse(m_values["OutputIdx"]);
    }

    void CalibratePilotOutput::setOutputIdx(int outputIdx)
    {
      m_values.AddMember("OutputIdx", parse_json<int>::format(outputIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double CalibratePilotOutput::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void CalibratePilotOutput::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double CalibratePilotOutput::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void CalibratePilotOutput::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double CalibratePilotOutput::carrierPhase() const
    {
      return parse_json<double>::parse(m_values["CarrierPhase"]);
    }

    void CalibratePilotOutput::setCarrierPhase(double carrierPhase)
    {
      m_values.AddMember("CarrierPhase", parse_json<double>::format(carrierPhase, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllPilots
///
#include "gen/RemoveAllPilots.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllPilots::CmdName = "RemoveAllPilots";
    const char* const RemoveAllPilots::Documentation = "Remove all pilots on all outputs";

    REGISTER_COMMAND_FACTORY(RemoveAllPilots);


    RemoveAllPilots::RemoveAllPilots()
      : CommandBase(CmdName)
    {

    }


    RemoveAllPilotsPtr RemoveAllPilots::create()
    {
      return RemoveAllPilotsPtr(new RemoveAllPilots());
    }

    RemoveAllPilotsPtr RemoveAllPilots::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllPilots>(ptr);
    }

    bool RemoveAllPilots::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllPilots::documentation() const { return Documentation; }


    int RemoveAllPilots::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of SetRFOutputOffsets
///
#include "gen/SetRFOutputOffsets.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetRFOutputOffsets::CmdName = "SetRFOutputOffsets";
    const char* const SetRFOutputOffsets::Documentation = "Change modulation offsets of one RF output";

    REGISTER_COMMAND_FACTORY(SetRFOutputOffsets);


    SetRFOutputOffsets::SetRFOutputOffsets()
      : CommandBase(CmdName)
    {}

    SetRFOutputOffsets::SetRFOutputOffsets(int outputIdx, double powerOffset, double timeOffset, double phaseOffset)
      : CommandBase(CmdName)
    {

      setOutputIdx(outputIdx);
      setPowerOffset(powerOffset);
      setTimeOffset(timeOffset);
      setPhaseOffset(phaseOffset);
    }


    SetRFOutputOffsetsPtr SetRFOutputOffsets::create(int outputIdx, double powerOffset, double timeOffset, double phaseOffset)
    {
      return SetRFOutputOffsetsPtr(new SetRFOutputOffsets(outputIdx, powerOffset, timeOffset, phaseOffset));
    }

    SetRFOutputOffsetsPtr SetRFOutputOffsets::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetRFOutputOffsets>(ptr);
    }

    bool SetRFOutputOffsets::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["OutputIdx"])
          && parse_json<double>::is_valid(m_values["PowerOffset"])
          && parse_json<double>::is_valid(m_values["TimeOffset"])
          && parse_json<double>::is_valid(m_values["PhaseOffset"])
        ;

    }

    std::string SetRFOutputOffsets::documentation() const { return Documentation; }


    int SetRFOutputOffsets::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    int SetRFOutputOffsets::outputIdx() const
    {
      return parse_json<int>::parse(m_values["OutputIdx"]);
    }

    void SetRFOutputOffsets::setOutputIdx(int outputIdx)
    {
      m_values.AddMember("OutputIdx", parse_json<int>::format(outputIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetRFOutputOffsets::powerOffset() const
    {
      return parse_json<double>::parse(m_values["PowerOffset"]);
    }

    void SetRFOutputOffsets::setPowerOffset(double powerOffset)
    {
      m_values.AddMember("PowerOffset", parse_json<double>::format(powerOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetRFOutputOffsets::timeOffset() const
    {
      return parse_json<double>::parse(m_values["TimeOffset"]);
    }

    void SetRFOutputOffsets::setTimeOffset(double timeOffset)
    {
      m_values.AddMember("TimeOffset", parse_json<double>::format(timeOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetRFOutputOffsets::phaseOffset() const
    {
      return parse_json<double>::parse(m_values["PhaseOffset"]);
    }

    void SetRFOutputOffsets::setPhaseOffset(double phaseOffset)
    {
      m_values.AddMember("PhaseOffset", parse_json<double>::format(phaseOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsTrajectoryCompleted
///
#include "gen/IsTrajectoryCompleted.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTrajectoryCompleted::CmdName = "IsTrajectoryCompleted";
    const char* const IsTrajectoryCompleted::Documentation = "Returns whether the vehicle trajectory was completed.\nFor fixed, circular and earth-orbiting spacecraft, this will always return false.\nFor track playback and vehicle simulation, this will return true once the vehicle will reach the last position in the track/route.\nThe value is unreliable for HIL trajectories.";

    REGISTER_COMMAND_FACTORY(IsTrajectoryCompleted);


    IsTrajectoryCompleted::IsTrajectoryCompleted()
      : CommandBase(CmdName)
    {

    }


    IsTrajectoryCompletedPtr IsTrajectoryCompleted::create()
    {
      return IsTrajectoryCompletedPtr(new IsTrajectoryCompleted());
    }

    IsTrajectoryCompletedPtr IsTrajectoryCompleted::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTrajectoryCompleted>(ptr);
    }

    bool IsTrajectoryCompleted::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string IsTrajectoryCompleted::documentation() const { return Documentation; }


    int IsTrajectoryCompleted::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of IsTrajectoryCompletedResult
///
#include "gen/IsTrajectoryCompletedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsTrajectoryCompletedResult::CmdName = "IsTrajectoryCompletedResult";
    const char* const IsTrajectoryCompletedResult::Documentation = "Result of IsTrajectoryCompleted";

    REGISTER_COMMAND_RESULT_FACTORY(IsTrajectoryCompletedResult);


    IsTrajectoryCompletedResult::IsTrajectoryCompletedResult()
      : CommandResult(CmdName)
    {}

    IsTrajectoryCompletedResult::IsTrajectoryCompletedResult(CommandBasePtr relatedCommand, bool isCompleted)
      : CommandResult(CmdName, relatedCommand)
    {

      setIsCompleted(isCompleted);
    }


    IsTrajectoryCompletedResultPtr IsTrajectoryCompletedResult::create(CommandBasePtr relatedCommand, bool isCompleted)
    {
      return IsTrajectoryCompletedResultPtr(new IsTrajectoryCompletedResult(relatedCommand, isCompleted));
    }

    IsTrajectoryCompletedResultPtr IsTrajectoryCompletedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsTrajectoryCompletedResult>(ptr);
    }

    bool IsTrajectoryCompletedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["IsCompleted"])
        ;

    }

    std::string IsTrajectoryCompletedResult::documentation() const { return Documentation; }


    bool IsTrajectoryCompletedResult::isCompleted() const
    {
      return parse_json<bool>::parse(m_values["IsCompleted"]);
    }

    void IsTrajectoryCompletedResult::setIsCompleted(bool isCompleted)
    {
      m_values.AddMember("IsCompleted", parse_json<bool>::format(isCompleted, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridError
///
#include "gen/SetIonoGridError.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridError::CmdName = "SetIonoGridError";
    const char* const SetIonoGridError::Documentation = "Set the error offset for a ionospheric grid point";

    REGISTER_COMMAND_FACTORY(SetIonoGridError);


    SetIonoGridError::SetIonoGridError()
      : CommandBase(CmdName)
    {}

    SetIonoGridError::SetIonoGridError(int band, int point, double error)
      : CommandBase(CmdName)
    {

      setBand(band);
      setPoint(point);
      setError(error);
    }


    SetIonoGridErrorPtr SetIonoGridError::create(int band, int point, double error)
    {
      return SetIonoGridErrorPtr(new SetIonoGridError(band, point, error));
    }

    SetIonoGridErrorPtr SetIonoGridError::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridError>(ptr);
    }

    bool SetIonoGridError::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<double>::is_valid(m_values["Error"])
        ;

    }

    std::string SetIonoGridError::documentation() const { return Documentation; }


    int SetIonoGridError::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoGridError::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void SetIonoGridError::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridError::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void SetIonoGridError::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetIonoGridError::error() const
    {
      return parse_json<double>::parse(m_values["Error"]);
    }

    void SetIonoGridError::setError(double error)
    {
      m_values.AddMember("Error", parse_json<double>::format(error, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridError
///
#include "gen/GetIonoGridError.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridError::CmdName = "GetIonoGridError";
    const char* const GetIonoGridError::Documentation = "Get the error offset for a ionospheric grid point";

    REGISTER_COMMAND_FACTORY(GetIonoGridError);


    GetIonoGridError::GetIonoGridError()
      : CommandBase(CmdName)
    {}

    GetIonoGridError::GetIonoGridError(int band, int point)
      : CommandBase(CmdName)
    {

      setBand(band);
      setPoint(point);
    }


    GetIonoGridErrorPtr GetIonoGridError::create(int band, int point)
    {
      return GetIonoGridErrorPtr(new GetIonoGridError(band, point));
    }

    GetIonoGridErrorPtr GetIonoGridError::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridError>(ptr);
    }

    bool GetIonoGridError::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
        ;

    }

    std::string GetIonoGridError::documentation() const { return Documentation; }


    int GetIonoGridError::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoGridError::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridError::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridError::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridError::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridErrorResult
///
#include "gen/GetIonoGridErrorResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridErrorResult::CmdName = "GetIonoGridErrorResult";
    const char* const GetIonoGridErrorResult::Documentation = "Result of GetIonoGridError";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridErrorResult);


    GetIonoGridErrorResult::GetIonoGridErrorResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridErrorResult::GetIonoGridErrorResult(CommandBasePtr relatedCommand, int band, int point, double error)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setPoint(point);
      setError(error);
    }


    GetIonoGridErrorResultPtr GetIonoGridErrorResult::create(CommandBasePtr relatedCommand, int band, int point, double error)
    {
      return GetIonoGridErrorResultPtr(new GetIonoGridErrorResult(relatedCommand, band, point, error));
    }

    GetIonoGridErrorResultPtr GetIonoGridErrorResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridErrorResult>(ptr);
    }

    bool GetIonoGridErrorResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<double>::is_valid(m_values["Error"])
        ;

    }

    std::string GetIonoGridErrorResult::documentation() const { return Documentation; }


    int GetIonoGridErrorResult::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridErrorResult::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridErrorResult::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridErrorResult::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetIonoGridErrorResult::error() const
    {
      return parse_json<double>::parse(m_values["Error"]);
    }

    void GetIonoGridErrorResult::setError(double error)
    {
      m_values.AddMember("Error", parse_json<double>::format(error, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridGIVEI
///
#include "gen/SetIonoGridGIVEI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridGIVEI::CmdName = "SetIonoGridGIVEI";
    const char* const SetIonoGridGIVEI::Documentation = "Set the GIVEI for a ionospheric grid point";

    REGISTER_COMMAND_FACTORY(SetIonoGridGIVEI);


    SetIonoGridGIVEI::SetIonoGridGIVEI()
      : CommandBase(CmdName)
    {}

    SetIonoGridGIVEI::SetIonoGridGIVEI(int band, int point, int giveI, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setBand(band);
      setPoint(point);
      setGiveI(giveI);
      setServiceProvider(serviceProvider);
    }


    SetIonoGridGIVEIPtr SetIonoGridGIVEI::create(int band, int point, int giveI, const Sdx::optional<std::string>& serviceProvider)
    {
      return SetIonoGridGIVEIPtr(new SetIonoGridGIVEI(band, point, giveI, serviceProvider));
    }

    SetIonoGridGIVEIPtr SetIonoGridGIVEI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridGIVEI>(ptr);
    }

    bool SetIonoGridGIVEI::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<int>::is_valid(m_values["GiveI"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string SetIonoGridGIVEI::documentation() const { return Documentation; }


    int SetIonoGridGIVEI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetIonoGridGIVEI::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void SetIonoGridGIVEI::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridGIVEI::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void SetIonoGridGIVEI::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridGIVEI::giveI() const
    {
      return parse_json<int>::parse(m_values["GiveI"]);
    }

    void SetIonoGridGIVEI::setGiveI(int giveI)
    {
      m_values.AddMember("GiveI", parse_json<int>::format(giveI, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetIonoGridGIVEI::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void SetIonoGridGIVEI::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridGIVEI
///
#include "gen/GetIonoGridGIVEI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridGIVEI::CmdName = "GetIonoGridGIVEI";
    const char* const GetIonoGridGIVEI::Documentation = "Get the GIVEI for a ionospheric grid point";

    REGISTER_COMMAND_FACTORY(GetIonoGridGIVEI);


    GetIonoGridGIVEI::GetIonoGridGIVEI()
      : CommandBase(CmdName)
    {}

    GetIonoGridGIVEI::GetIonoGridGIVEI(int band, int point, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setBand(band);
      setPoint(point);
      setServiceProvider(serviceProvider);
    }


    GetIonoGridGIVEIPtr GetIonoGridGIVEI::create(int band, int point, const Sdx::optional<std::string>& serviceProvider)
    {
      return GetIonoGridGIVEIPtr(new GetIonoGridGIVEI(band, point, serviceProvider));
    }

    GetIonoGridGIVEIPtr GetIonoGridGIVEI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridGIVEI>(ptr);
    }

    bool GetIonoGridGIVEI::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridGIVEI::documentation() const { return Documentation; }


    int GetIonoGridGIVEI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetIonoGridGIVEI::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridGIVEI::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridGIVEI::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridGIVEI::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetIonoGridGIVEI::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridGIVEI::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridGIVEIResult
///
#include "gen/GetIonoGridGIVEIResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridGIVEIResult::CmdName = "GetIonoGridGIVEIResult";
    const char* const GetIonoGridGIVEIResult::Documentation = "Result of GetIonoGridGIVEI";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridGIVEIResult);


    GetIonoGridGIVEIResult::GetIonoGridGIVEIResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridGIVEIResult::GetIonoGridGIVEIResult(CommandBasePtr relatedCommand, int band, int point, int giveI, const Sdx::optional<std::string>& serviceProvider)
      : CommandResult(CmdName, relatedCommand)
    {

      setBand(band);
      setPoint(point);
      setGiveI(giveI);
      setServiceProvider(serviceProvider);
    }


    GetIonoGridGIVEIResultPtr GetIonoGridGIVEIResult::create(CommandBasePtr relatedCommand, int band, int point, int giveI, const Sdx::optional<std::string>& serviceProvider)
    {
      return GetIonoGridGIVEIResultPtr(new GetIonoGridGIVEIResult(relatedCommand, band, point, giveI, serviceProvider));
    }

    GetIonoGridGIVEIResultPtr GetIonoGridGIVEIResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridGIVEIResult>(ptr);
    }

    bool GetIonoGridGIVEIResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<int>::is_valid(m_values["GiveI"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridGIVEIResult::documentation() const { return Documentation; }


    int GetIonoGridGIVEIResult::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridGIVEIResult::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridGIVEIResult::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridGIVEIResult::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridGIVEIResult::giveI() const
    {
      return parse_json<int>::parse(m_values["GiveI"]);
    }

    void GetIonoGridGIVEIResult::setGiveI(int giveI)
    {
      m_values.AddMember("GiveI", parse_json<int>::format(giveI, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetIonoGridGIVEIResult::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridGIVEIResult::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridErrorAll
///
#include "gen/SetIonoGridErrorAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridErrorAll::CmdName = "SetIonoGridErrorAll";
    const char* const SetIonoGridErrorAll::Documentation = "Set Error offsets in the ionospheric grid.  The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(SetIonoGridErrorAll);


    SetIonoGridErrorAll::SetIonoGridErrorAll()
      : CommandBase(CmdName)
    {}

    SetIonoGridErrorAll::SetIonoGridErrorAll(const std::vector<std::vector<double>>& grid)
      : CommandBase(CmdName)
    {

      setGrid(grid);
    }


    SetIonoGridErrorAllPtr SetIonoGridErrorAll::create(const std::vector<std::vector<double>>& grid)
    {
      return SetIonoGridErrorAllPtr(new SetIonoGridErrorAll(grid));
    }

    SetIonoGridErrorAllPtr SetIonoGridErrorAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridErrorAll>(ptr);
    }

    bool SetIonoGridErrorAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Grid"])
        ;

    }

    std::string SetIonoGridErrorAll::documentation() const { return Documentation; }


    int SetIonoGridErrorAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetIonoGridErrorAll::grid() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Grid"]);
    }

    void SetIonoGridErrorAll::setGrid(const std::vector<std::vector<double>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<double>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridErrorAll
///
#include "gen/GetIonoGridErrorAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridErrorAll::CmdName = "GetIonoGridErrorAll";
    const char* const GetIonoGridErrorAll::Documentation = "Get Error offsets in the ionospheric grid.  The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(GetIonoGridErrorAll);


    GetIonoGridErrorAll::GetIonoGridErrorAll()
      : CommandBase(CmdName)
    {

    }


    GetIonoGridErrorAllPtr GetIonoGridErrorAll::create()
    {
      return GetIonoGridErrorAllPtr(new GetIonoGridErrorAll());
    }

    GetIonoGridErrorAllPtr GetIonoGridErrorAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridErrorAll>(ptr);
    }

    bool GetIonoGridErrorAll::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetIonoGridErrorAll::documentation() const { return Documentation; }


    int GetIonoGridErrorAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetIonoGridErrorAllResult
///
#include "gen/GetIonoGridErrorAllResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridErrorAllResult::CmdName = "GetIonoGridErrorAllResult";
    const char* const GetIonoGridErrorAllResult::Documentation = "Result of GetIonoGridErrorAll";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridErrorAllResult);


    GetIonoGridErrorAllResult::GetIonoGridErrorAllResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridErrorAllResult::GetIonoGridErrorAllResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& grid)
      : CommandResult(CmdName, relatedCommand)
    {

      setGrid(grid);
    }


    GetIonoGridErrorAllResultPtr GetIonoGridErrorAllResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& grid)
    {
      return GetIonoGridErrorAllResultPtr(new GetIonoGridErrorAllResult(relatedCommand, grid));
    }

    GetIonoGridErrorAllResultPtr GetIonoGridErrorAllResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridErrorAllResult>(ptr);
    }

    bool GetIonoGridErrorAllResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Grid"])
        ;

    }

    std::string GetIonoGridErrorAllResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetIonoGridErrorAllResult::grid() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Grid"]);
    }

    void GetIonoGridErrorAllResult::setGrid(const std::vector<std::vector<double>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<double>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridGIVEIAll
///
#include "gen/SetIonoGridGIVEIAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridGIVEIAll::CmdName = "SetIonoGridGIVEIAll";
    const char* const SetIonoGridGIVEIAll::Documentation = "Set GIVEI in the ionospheric grid.  The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(SetIonoGridGIVEIAll);


    SetIonoGridGIVEIAll::SetIonoGridGIVEIAll()
      : CommandBase(CmdName)
    {}

    SetIonoGridGIVEIAll::SetIonoGridGIVEIAll(const std::vector<std::vector<int>>& grid, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setGrid(grid);
      setServiceProvider(serviceProvider);
    }


    SetIonoGridGIVEIAllPtr SetIonoGridGIVEIAll::create(const std::vector<std::vector<int>>& grid, const Sdx::optional<std::string>& serviceProvider)
    {
      return SetIonoGridGIVEIAllPtr(new SetIonoGridGIVEIAll(grid, serviceProvider));
    }

    SetIonoGridGIVEIAllPtr SetIonoGridGIVEIAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridGIVEIAll>(ptr);
    }

    bool SetIonoGridGIVEIAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<int>>>::is_valid(m_values["Grid"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string SetIonoGridGIVEIAll::documentation() const { return Documentation; }


    int SetIonoGridGIVEIAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<int>> SetIonoGridGIVEIAll::grid() const
    {
      return parse_json<std::vector<std::vector<int>>>::parse(m_values["Grid"]);
    }

    void SetIonoGridGIVEIAll::setGrid(const std::vector<std::vector<int>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<int>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> SetIonoGridGIVEIAll::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void SetIonoGridGIVEIAll::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridGIVEIAll
///
#include "gen/GetIonoGridGIVEIAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridGIVEIAll::CmdName = "GetIonoGridGIVEIAll";
    const char* const GetIonoGridGIVEIAll::Documentation = "Get GIVEI in the ionospheric grid.  The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(GetIonoGridGIVEIAll);


    GetIonoGridGIVEIAll::GetIonoGridGIVEIAll(const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
    }


    GetIonoGridGIVEIAllPtr GetIonoGridGIVEIAll::create(const Sdx::optional<std::string>& serviceProvider)
    {
      return GetIonoGridGIVEIAllPtr(new GetIonoGridGIVEIAll(serviceProvider));
    }

    GetIonoGridGIVEIAllPtr GetIonoGridGIVEIAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridGIVEIAll>(ptr);
    }

    bool GetIonoGridGIVEIAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridGIVEIAll::documentation() const { return Documentation; }


    int GetIonoGridGIVEIAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    Sdx::optional<std::string> GetIonoGridGIVEIAll::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridGIVEIAll::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridGIVEIAllResult
///
#include "gen/GetIonoGridGIVEIAllResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridGIVEIAllResult::CmdName = "GetIonoGridGIVEIAllResult";
    const char* const GetIonoGridGIVEIAllResult::Documentation = "Result of GetIonoGridGIVEIAll";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridGIVEIAllResult);


    GetIonoGridGIVEIAllResult::GetIonoGridGIVEIAllResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridGIVEIAllResult::GetIonoGridGIVEIAllResult(CommandBasePtr relatedCommand, const std::vector<std::vector<int>>& grid, const Sdx::optional<std::string>& serviceProvider)
      : CommandResult(CmdName, relatedCommand)
    {

      setGrid(grid);
      setServiceProvider(serviceProvider);
    }


    GetIonoGridGIVEIAllResultPtr GetIonoGridGIVEIAllResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<int>>& grid, const Sdx::optional<std::string>& serviceProvider)
    {
      return GetIonoGridGIVEIAllResultPtr(new GetIonoGridGIVEIAllResult(relatedCommand, grid, serviceProvider));
    }

    GetIonoGridGIVEIAllResultPtr GetIonoGridGIVEIAllResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridGIVEIAllResult>(ptr);
    }

    bool GetIonoGridGIVEIAllResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<int>>>::is_valid(m_values["Grid"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridGIVEIAllResult::documentation() const { return Documentation; }


    std::vector<std::vector<int>> GetIonoGridGIVEIAllResult::grid() const
    {
      return parse_json<std::vector<std::vector<int>>>::parse(m_values["Grid"]);
    }

    void GetIonoGridGIVEIAllResult::setGrid(const std::vector<std::vector<int>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<int>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> GetIonoGridGIVEIAllResult::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridGIVEIAllResult::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridMask
///
#include "gen/SetIonoGridMask.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridMask::CmdName = "SetIonoGridMask";
    const char* const SetIonoGridMask::Documentation = "Set the flag for a ionospheric grid point in the SBAS message 18 mask";

    REGISTER_COMMAND_FACTORY(SetIonoGridMask);


    SetIonoGridMask::SetIonoGridMask()
      : CommandBase(CmdName)
    {}

    SetIonoGridMask::SetIonoGridMask(const std::string& serviceProvider, int band, int point, bool flag)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setBand(band);
      setPoint(point);
      setFlag(flag);
    }


    SetIonoGridMaskPtr SetIonoGridMask::create(const std::string& serviceProvider, int band, int point, bool flag)
    {
      return SetIonoGridMaskPtr(new SetIonoGridMask(serviceProvider, band, point, flag));
    }

    SetIonoGridMaskPtr SetIonoGridMask::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridMask>(ptr);
    }

    bool SetIonoGridMask::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<bool>::is_valid(m_values["Flag"])
        ;

    }

    std::string SetIonoGridMask::documentation() const { return Documentation; }


    int SetIonoGridMask::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetIonoGridMask::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void SetIonoGridMask::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridMask::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void SetIonoGridMask::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetIonoGridMask::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void SetIonoGridMask::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetIonoGridMask::flag() const
    {
      return parse_json<bool>::parse(m_values["Flag"]);
    }

    void SetIonoGridMask::setFlag(bool flag)
    {
      m_values.AddMember("Flag", parse_json<bool>::format(flag, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridMask
///
#include "gen/GetIonoGridMask.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridMask::CmdName = "GetIonoGridMask";
    const char* const GetIonoGridMask::Documentation = "Get the flag for a ionospheric grid point in the SBAS message 18 mask";

    REGISTER_COMMAND_FACTORY(GetIonoGridMask);


    GetIonoGridMask::GetIonoGridMask()
      : CommandBase(CmdName)
    {}

    GetIonoGridMask::GetIonoGridMask(const std::string& serviceProvider, int band, int point)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setBand(band);
      setPoint(point);
    }


    GetIonoGridMaskPtr GetIonoGridMask::create(const std::string& serviceProvider, int band, int point)
    {
      return GetIonoGridMaskPtr(new GetIonoGridMask(serviceProvider, band, point));
    }

    GetIonoGridMaskPtr GetIonoGridMask::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridMask>(ptr);
    }

    bool GetIonoGridMask::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
        ;

    }

    std::string GetIonoGridMask::documentation() const { return Documentation; }


    int GetIonoGridMask::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIonoGridMask::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridMask::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridMask::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridMask::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridMask::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridMask::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridMaskResult
///
#include "gen/GetIonoGridMaskResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridMaskResult::CmdName = "GetIonoGridMaskResult";
    const char* const GetIonoGridMaskResult::Documentation = "Result of GetIonoGridMask";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridMaskResult);


    GetIonoGridMaskResult::GetIonoGridMaskResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridMaskResult::GetIonoGridMaskResult(CommandBasePtr relatedCommand, const std::string& serviceProvider, int band, int point, bool flag)
      : CommandResult(CmdName, relatedCommand)
    {

      setServiceProvider(serviceProvider);
      setBand(band);
      setPoint(point);
      setFlag(flag);
    }


    GetIonoGridMaskResultPtr GetIonoGridMaskResult::create(CommandBasePtr relatedCommand, const std::string& serviceProvider, int band, int point, bool flag)
    {
      return GetIonoGridMaskResultPtr(new GetIonoGridMaskResult(relatedCommand, serviceProvider, band, point, flag));
    }

    GetIonoGridMaskResultPtr GetIonoGridMaskResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridMaskResult>(ptr);
    }

    bool GetIonoGridMaskResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<int>::is_valid(m_values["Band"])
          && parse_json<int>::is_valid(m_values["Point"])
          && parse_json<bool>::is_valid(m_values["Flag"])
        ;

    }

    std::string GetIonoGridMaskResult::documentation() const { return Documentation; }


    std::string GetIonoGridMaskResult::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridMaskResult::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridMaskResult::band() const
    {
      return parse_json<int>::parse(m_values["Band"]);
    }

    void GetIonoGridMaskResult::setBand(int band)
    {
      m_values.AddMember("Band", parse_json<int>::format(band, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetIonoGridMaskResult::point() const
    {
      return parse_json<int>::parse(m_values["Point"]);
    }

    void GetIonoGridMaskResult::setPoint(int point)
    {
      m_values.AddMember("Point", parse_json<int>::format(point, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetIonoGridMaskResult::flag() const
    {
      return parse_json<bool>::parse(m_values["Flag"]);
    }

    void GetIonoGridMaskResult::setFlag(bool flag)
    {
      m_values.AddMember("Flag", parse_json<bool>::format(flag, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetIonoGridMaskAll
///
#include "gen/SetIonoGridMaskAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetIonoGridMaskAll::CmdName = "SetIonoGridMaskAll";
    const char* const SetIonoGridMaskAll::Documentation = "Set Mask flags in the ionospheric grid for a given service provider. The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(SetIonoGridMaskAll);


    SetIonoGridMaskAll::SetIonoGridMaskAll()
      : CommandBase(CmdName)
    {}

    SetIonoGridMaskAll::SetIonoGridMaskAll(const std::string& serviceProvider, const std::vector<std::vector<bool>>& grid)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setGrid(grid);
    }


    SetIonoGridMaskAllPtr SetIonoGridMaskAll::create(const std::string& serviceProvider, const std::vector<std::vector<bool>>& grid)
    {
      return SetIonoGridMaskAllPtr(new SetIonoGridMaskAll(serviceProvider, grid));
    }

    SetIonoGridMaskAllPtr SetIonoGridMaskAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetIonoGridMaskAll>(ptr);
    }

    bool SetIonoGridMaskAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<std::vector<std::vector<bool>>>::is_valid(m_values["Grid"])
        ;

    }

    std::string SetIonoGridMaskAll::documentation() const { return Documentation; }


    int SetIonoGridMaskAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetIonoGridMaskAll::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void SetIonoGridMaskAll::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<bool>> SetIonoGridMaskAll::grid() const
    {
      return parse_json<std::vector<std::vector<bool>>>::parse(m_values["Grid"]);
    }

    void SetIonoGridMaskAll::setGrid(const std::vector<std::vector<bool>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<bool>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridMaskAll
///
#include "gen/GetIonoGridMaskAll.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridMaskAll::CmdName = "GetIonoGridMaskAll";
    const char* const GetIonoGridMaskAll::Documentation = "Get Mask flags in the ionospheric grid for a given service provider. The array is zero based, the index 0 in a band array is for the IGP with an index 1, etc.";

    REGISTER_COMMAND_FACTORY(GetIonoGridMaskAll);


    GetIonoGridMaskAll::GetIonoGridMaskAll()
      : CommandBase(CmdName)
    {}

    GetIonoGridMaskAll::GetIonoGridMaskAll(const std::string& serviceProvider)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
    }


    GetIonoGridMaskAllPtr GetIonoGridMaskAll::create(const std::string& serviceProvider)
    {
      return GetIonoGridMaskAllPtr(new GetIonoGridMaskAll(serviceProvider));
    }

    GetIonoGridMaskAllPtr GetIonoGridMaskAll::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridMaskAll>(ptr);
    }

    bool GetIonoGridMaskAll::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string GetIonoGridMaskAll::documentation() const { return Documentation; }


    int GetIonoGridMaskAll::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetIonoGridMaskAll::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridMaskAll::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetIonoGridMaskAllResult
///
#include "gen/GetIonoGridMaskAllResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetIonoGridMaskAllResult::CmdName = "GetIonoGridMaskAllResult";
    const char* const GetIonoGridMaskAllResult::Documentation = "Result of GetIonoGridMaskAll";

    REGISTER_COMMAND_RESULT_FACTORY(GetIonoGridMaskAllResult);


    GetIonoGridMaskAllResult::GetIonoGridMaskAllResult()
      : CommandResult(CmdName)
    {}

    GetIonoGridMaskAllResult::GetIonoGridMaskAllResult(CommandBasePtr relatedCommand, const std::string& serviceProvider, const std::vector<std::vector<bool>>& grid)
      : CommandResult(CmdName, relatedCommand)
    {

      setServiceProvider(serviceProvider);
      setGrid(grid);
    }


    GetIonoGridMaskAllResultPtr GetIonoGridMaskAllResult::create(CommandBasePtr relatedCommand, const std::string& serviceProvider, const std::vector<std::vector<bool>>& grid)
    {
      return GetIonoGridMaskAllResultPtr(new GetIonoGridMaskAllResult(relatedCommand, serviceProvider, grid));
    }

    GetIonoGridMaskAllResultPtr GetIonoGridMaskAllResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetIonoGridMaskAllResult>(ptr);
    }

    bool GetIonoGridMaskAllResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<std::vector<std::vector<bool>>>::is_valid(m_values["Grid"])
        ;

    }

    std::string GetIonoGridMaskAllResult::documentation() const { return Documentation; }


    std::string GetIonoGridMaskAllResult::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void GetIonoGridMaskAllResult::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::vector<bool>> GetIonoGridMaskAllResult::grid() const
    {
      return parse_json<std::vector<std::vector<bool>>>::parse(m_values["Grid"]);
    }

    void GetIonoGridMaskAllResult::setGrid(const std::vector<std::vector<bool>>& grid)
    {
      m_values.AddMember("Grid", parse_json<std::vector<std::vector<bool>>>::format(grid, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportIonoGridErrors
///
#include "gen/ImportIonoGridErrors.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportIonoGridErrors::CmdName = "ImportIonoGridErrors";
    const char* const ImportIonoGridErrors::Documentation = "Import ionospheric grid errors.";

    REGISTER_COMMAND_FACTORY(ImportIonoGridErrors);


    ImportIonoGridErrors::ImportIonoGridErrors()
      : CommandBase(CmdName)
    {}

    ImportIonoGridErrors::ImportIonoGridErrors(bool overwriting, const std::string& path)
      : CommandBase(CmdName)
    {

      setOverwriting(overwriting);
      setPath(path);
    }


    ImportIonoGridErrorsPtr ImportIonoGridErrors::create(bool overwriting, const std::string& path)
    {
      return ImportIonoGridErrorsPtr(new ImportIonoGridErrors(overwriting, path));
    }

    ImportIonoGridErrorsPtr ImportIonoGridErrors::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportIonoGridErrors>(ptr);
    }

    bool ImportIonoGridErrors::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportIonoGridErrors::documentation() const { return Documentation; }


    int ImportIonoGridErrors::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ImportIonoGridErrors::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ImportIonoGridErrors::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportIonoGridErrors::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportIonoGridErrors::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportIonoGridGIVEI
///
#include "gen/ImportIonoGridGIVEI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportIonoGridGIVEI::CmdName = "ImportIonoGridGIVEI";
    const char* const ImportIonoGridGIVEI::Documentation = "Import ionospheric grid GIVEI.";

    REGISTER_COMMAND_FACTORY(ImportIonoGridGIVEI);


    ImportIonoGridGIVEI::ImportIonoGridGIVEI()
      : CommandBase(CmdName)
    {}

    ImportIonoGridGIVEI::ImportIonoGridGIVEI(bool overwriting, const std::string& path, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setOverwriting(overwriting);
      setPath(path);
      setServiceProvider(serviceProvider);
    }


    ImportIonoGridGIVEIPtr ImportIonoGridGIVEI::create(bool overwriting, const std::string& path, const Sdx::optional<std::string>& serviceProvider)
    {
      return ImportIonoGridGIVEIPtr(new ImportIonoGridGIVEI(overwriting, path, serviceProvider));
    }

    ImportIonoGridGIVEIPtr ImportIonoGridGIVEI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportIonoGridGIVEI>(ptr);
    }

    bool ImportIonoGridGIVEI::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string ImportIonoGridGIVEI::documentation() const { return Documentation; }


    int ImportIonoGridGIVEI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ImportIonoGridGIVEI::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ImportIonoGridGIVEI::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportIonoGridGIVEI::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportIonoGridGIVEI::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ImportIonoGridGIVEI::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void ImportIonoGridGIVEI::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ImportIonoGridMask
///
#include "gen/ImportIonoGridMask.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ImportIonoGridMask::CmdName = "ImportIonoGridMask";
    const char* const ImportIonoGridMask::Documentation = "Import ionospheric grid mask for a giver service provider.";

    REGISTER_COMMAND_FACTORY(ImportIonoGridMask);


    ImportIonoGridMask::ImportIonoGridMask()
      : CommandBase(CmdName)
    {}

    ImportIonoGridMask::ImportIonoGridMask(const std::string& serviceProvider, bool overwriting, const std::string& path)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setOverwriting(overwriting);
      setPath(path);
    }


    ImportIonoGridMaskPtr ImportIonoGridMask::create(const std::string& serviceProvider, bool overwriting, const std::string& path)
    {
      return ImportIonoGridMaskPtr(new ImportIonoGridMask(serviceProvider, overwriting, path));
    }

    ImportIonoGridMaskPtr ImportIonoGridMask::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ImportIonoGridMask>(ptr);
    }

    bool ImportIonoGridMask::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ImportIonoGridMask::documentation() const { return Documentation; }


    int ImportIonoGridMask::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ImportIonoGridMask::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void ImportIonoGridMask::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ImportIonoGridMask::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ImportIonoGridMask::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ImportIonoGridMask::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ImportIonoGridMask::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportIonoGridErrors
///
#include "gen/ExportIonoGridErrors.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportIonoGridErrors::CmdName = "ExportIonoGridErrors";
    const char* const ExportIonoGridErrors::Documentation = "Export ionospheric grid errors.";

    REGISTER_COMMAND_FACTORY(ExportIonoGridErrors);


    ExportIonoGridErrors::ExportIonoGridErrors()
      : CommandBase(CmdName)
    {}

    ExportIonoGridErrors::ExportIonoGridErrors(bool overwriting, const std::string& path)
      : CommandBase(CmdName)
    {

      setOverwriting(overwriting);
      setPath(path);
    }


    ExportIonoGridErrorsPtr ExportIonoGridErrors::create(bool overwriting, const std::string& path)
    {
      return ExportIonoGridErrorsPtr(new ExportIonoGridErrors(overwriting, path));
    }

    ExportIonoGridErrorsPtr ExportIonoGridErrors::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportIonoGridErrors>(ptr);
    }

    bool ExportIonoGridErrors::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ExportIonoGridErrors::documentation() const { return Documentation; }


    int ExportIonoGridErrors::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ExportIonoGridErrors::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportIonoGridErrors::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportIonoGridErrors::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ExportIonoGridErrors::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportIonoGridGIVEI
///
#include "gen/ExportIonoGridGIVEI.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportIonoGridGIVEI::CmdName = "ExportIonoGridGIVEI";
    const char* const ExportIonoGridGIVEI::Documentation = "Export ionospheric grid GIVEI.";

    REGISTER_COMMAND_FACTORY(ExportIonoGridGIVEI);


    ExportIonoGridGIVEI::ExportIonoGridGIVEI()
      : CommandBase(CmdName)
    {}

    ExportIonoGridGIVEI::ExportIonoGridGIVEI(bool overwriting, const std::string& path, const Sdx::optional<std::string>& serviceProvider)
      : CommandBase(CmdName)
    {

      setOverwriting(overwriting);
      setPath(path);
      setServiceProvider(serviceProvider);
    }


    ExportIonoGridGIVEIPtr ExportIonoGridGIVEI::create(bool overwriting, const std::string& path, const Sdx::optional<std::string>& serviceProvider)
    {
      return ExportIonoGridGIVEIPtr(new ExportIonoGridGIVEI(overwriting, path, serviceProvider));
    }

    ExportIonoGridGIVEIPtr ExportIonoGridGIVEI::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportIonoGridGIVEI>(ptr);
    }

    bool ExportIonoGridGIVEI::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<Sdx::optional<std::string>>::is_valid(m_values["ServiceProvider"])
        ;

    }

    std::string ExportIonoGridGIVEI::documentation() const { return Documentation; }


    int ExportIonoGridGIVEI::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    bool ExportIonoGridGIVEI::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportIonoGridGIVEI::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportIonoGridGIVEI::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ExportIonoGridGIVEI::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<std::string> ExportIonoGridGIVEI::serviceProvider() const
    {
      return parse_json<Sdx::optional<std::string>>::parse(m_values["ServiceProvider"]);
    }

    void ExportIonoGridGIVEI::setServiceProvider(const Sdx::optional<std::string>& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<Sdx::optional<std::string>>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ExportIonoGridMask
///
#include "gen/ExportIonoGridMask.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ExportIonoGridMask::CmdName = "ExportIonoGridMask";
    const char* const ExportIonoGridMask::Documentation = "Export ionospheric grid mask for a given service provider.";

    REGISTER_COMMAND_FACTORY(ExportIonoGridMask);


    ExportIonoGridMask::ExportIonoGridMask()
      : CommandBase(CmdName)
    {}

    ExportIonoGridMask::ExportIonoGridMask(const std::string& serviceProvider, bool overwriting, const std::string& path)
      : CommandBase(CmdName)
    {

      setServiceProvider(serviceProvider);
      setOverwriting(overwriting);
      setPath(path);
    }


    ExportIonoGridMaskPtr ExportIonoGridMask::create(const std::string& serviceProvider, bool overwriting, const std::string& path)
    {
      return ExportIonoGridMaskPtr(new ExportIonoGridMask(serviceProvider, overwriting, path));
    }

    ExportIonoGridMaskPtr ExportIonoGridMask::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ExportIonoGridMask>(ptr);
    }

    bool ExportIonoGridMask::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["ServiceProvider"])
          && parse_json<bool>::is_valid(m_values["Overwriting"])
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string ExportIonoGridMask::documentation() const { return Documentation; }


    int ExportIonoGridMask::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ExportIonoGridMask::serviceProvider() const
    {
      return parse_json<std::string>::parse(m_values["ServiceProvider"]);
    }

    void ExportIonoGridMask::setServiceProvider(const std::string& serviceProvider)
    {
      m_values.AddMember("ServiceProvider", parse_json<std::string>::format(serviceProvider, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool ExportIonoGridMask::overwriting() const
    {
      return parse_json<bool>::parse(m_values["Overwriting"]);
    }

    void ExportIonoGridMask::setOverwriting(bool overwriting)
    {
      m_values.AddMember("Overwriting", parse_json<bool>::format(overwriting, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ExportIonoGridMask::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void ExportIonoGridMask::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetConfigPaths
///
#include "gen/GetConfigPaths.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigPaths::CmdName = "GetConfigPaths";
    const char* const GetConfigPaths::Documentation = "Returns a list of paths for all the files in the Configurations folder.";

    REGISTER_COMMAND_FACTORY(GetConfigPaths);


    GetConfigPaths::GetConfigPaths()
      : CommandBase(CmdName)
    {

    }


    GetConfigPathsPtr GetConfigPaths::create()
    {
      return GetConfigPathsPtr(new GetConfigPaths());
    }

    GetConfigPathsPtr GetConfigPaths::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigPaths>(ptr);
    }

    bool GetConfigPaths::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetConfigPaths::documentation() const { return Documentation; }


    int GetConfigPaths::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetConfigPathsResult
///
#include "gen/GetConfigPathsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetConfigPathsResult::CmdName = "GetConfigPathsResult";
    const char* const GetConfigPathsResult::Documentation = "Result of GetConfigPaths";

    REGISTER_COMMAND_RESULT_FACTORY(GetConfigPathsResult);


    GetConfigPathsResult::GetConfigPathsResult()
      : CommandResult(CmdName)
    {}

    GetConfigPathsResult::GetConfigPathsResult(CommandBasePtr relatedCommand, const std::vector<std::string>& paths)
      : CommandResult(CmdName, relatedCommand)
    {

      setPaths(paths);
    }


    GetConfigPathsResultPtr GetConfigPathsResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& paths)
    {
      return GetConfigPathsResultPtr(new GetConfigPathsResult(relatedCommand, paths));
    }

    GetConfigPathsResultPtr GetConfigPathsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetConfigPathsResult>(ptr);
    }

    bool GetConfigPathsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Paths"])
        ;

    }

    std::string GetConfigPathsResult::documentation() const { return Documentation; }


    std::vector<std::string> GetConfigPathsResult::paths() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Paths"]);
    }

    void GetConfigPathsResult::setPaths(const std::vector<std::string>& paths)
    {
      m_values.AddMember("Paths", parse_json<std::vector<std::string>>::format(paths, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPps0GpsTime
///
#include "gen/SetPps0GpsTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPps0GpsTime::CmdName = "SetPps0GpsTime";
    const char* const SetPps0GpsTime::Documentation = "Set the 0th PPS' date time";

    REGISTER_COMMAND_FACTORY(SetPps0GpsTime);


    SetPps0GpsTime::SetPps0GpsTime()
      : CommandBase(CmdName)
    {}

    SetPps0GpsTime::SetPps0GpsTime(const Sdx::DateTime& gpsTime)
      : CommandBase(CmdName)
    {

      setGpsTime(gpsTime);
    }


    SetPps0GpsTimePtr SetPps0GpsTime::create(const Sdx::DateTime& gpsTime)
    {
      return SetPps0GpsTimePtr(new SetPps0GpsTime(gpsTime));
    }

    SetPps0GpsTimePtr SetPps0GpsTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPps0GpsTime>(ptr);
    }

    bool SetPps0GpsTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::DateTime>::is_valid(m_values["GpsTime"])
        ;

    }

    std::string SetPps0GpsTime::documentation() const { return Documentation; }


    int SetPps0GpsTime::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    Sdx::DateTime SetPps0GpsTime::gpsTime() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["GpsTime"]);
    }

    void SetPps0GpsTime::setGpsTime(const Sdx::DateTime& gpsTime)
    {
      m_values.AddMember("GpsTime", parse_json<Sdx::DateTime>::format(gpsTime, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetOfficialLeapSecond
///
#include "gen/GetOfficialLeapSecond.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetOfficialLeapSecond::CmdName = "GetOfficialLeapSecond";
    const char* const GetOfficialLeapSecond::Documentation = "Returns the official leap second for a given date";

    REGISTER_COMMAND_FACTORY(GetOfficialLeapSecond);


    GetOfficialLeapSecond::GetOfficialLeapSecond()
      : CommandBase(CmdName)
    {}

    GetOfficialLeapSecond::GetOfficialLeapSecond(const Sdx::DateTime& date)
      : CommandBase(CmdName)
    {

      setDate(date);
    }


    GetOfficialLeapSecondPtr GetOfficialLeapSecond::create(const Sdx::DateTime& date)
    {
      return GetOfficialLeapSecondPtr(new GetOfficialLeapSecond(date));
    }

    GetOfficialLeapSecondPtr GetOfficialLeapSecond::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetOfficialLeapSecond>(ptr);
    }

    bool GetOfficialLeapSecond::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::DateTime>::is_valid(m_values["Date"])
        ;

    }

    std::string GetOfficialLeapSecond::documentation() const { return Documentation; }


    int GetOfficialLeapSecond::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    Sdx::DateTime GetOfficialLeapSecond::date() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Date"]);
    }

    void GetOfficialLeapSecond::setDate(const Sdx::DateTime& date)
    {
      m_values.AddMember("Date", parse_json<Sdx::DateTime>::format(date, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetOfficialLeapSecondResult
///
#include "gen/GetOfficialLeapSecondResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetOfficialLeapSecondResult::CmdName = "GetOfficialLeapSecondResult";
    const char* const GetOfficialLeapSecondResult::Documentation = "Result of GetOfficialLeapSecond";

    REGISTER_COMMAND_RESULT_FACTORY(GetOfficialLeapSecondResult);


    GetOfficialLeapSecondResult::GetOfficialLeapSecondResult()
      : CommandResult(CmdName)
    {}

    GetOfficialLeapSecondResult::GetOfficialLeapSecondResult(CommandBasePtr relatedCommand, int leapSecond)
      : CommandResult(CmdName, relatedCommand)
    {

      setLeapSecond(leapSecond);
    }


    GetOfficialLeapSecondResultPtr GetOfficialLeapSecondResult::create(CommandBasePtr relatedCommand, int leapSecond)
    {
      return GetOfficialLeapSecondResultPtr(new GetOfficialLeapSecondResult(relatedCommand, leapSecond));
    }

    GetOfficialLeapSecondResultPtr GetOfficialLeapSecondResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetOfficialLeapSecondResult>(ptr);
    }

    bool GetOfficialLeapSecondResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["LeapSecond"])
        ;

    }

    std::string GetOfficialLeapSecondResult::documentation() const { return Documentation; }


    int GetOfficialLeapSecondResult::leapSecond() const
    {
      return parse_json<int>::parse(m_values["LeapSecond"]);
    }

    void GetOfficialLeapSecondResult::setLeapSecond(int leapSecond)
    {
      m_values.AddMember("LeapSecond", parse_json<int>::format(leapSecond, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetLastLeapSecondDate
///
#include "gen/GetLastLeapSecondDate.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLastLeapSecondDate::CmdName = "GetLastLeapSecondDate";
    const char* const GetLastLeapSecondDate::Documentation = "Returns the last known leap second date";

    REGISTER_COMMAND_FACTORY(GetLastLeapSecondDate);


    GetLastLeapSecondDate::GetLastLeapSecondDate()
      : CommandBase(CmdName)
    {

    }


    GetLastLeapSecondDatePtr GetLastLeapSecondDate::create()
    {
      return GetLastLeapSecondDatePtr(new GetLastLeapSecondDate());
    }

    GetLastLeapSecondDatePtr GetLastLeapSecondDate::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLastLeapSecondDate>(ptr);
    }

    bool GetLastLeapSecondDate::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetLastLeapSecondDate::documentation() const { return Documentation; }


    int GetLastLeapSecondDate::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetLastLeapSecondDateResult
///
#include "gen/GetLastLeapSecondDateResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetLastLeapSecondDateResult::CmdName = "GetLastLeapSecondDateResult";
    const char* const GetLastLeapSecondDateResult::Documentation = "Result of GetLastLeapSecondDate";

    REGISTER_COMMAND_RESULT_FACTORY(GetLastLeapSecondDateResult);


    GetLastLeapSecondDateResult::GetLastLeapSecondDateResult()
      : CommandResult(CmdName)
    {}

    GetLastLeapSecondDateResult::GetLastLeapSecondDateResult(CommandBasePtr relatedCommand, const Sdx::Date& date)
      : CommandResult(CmdName, relatedCommand)
    {

      setDate(date);
    }


    GetLastLeapSecondDateResultPtr GetLastLeapSecondDateResult::create(CommandBasePtr relatedCommand, const Sdx::Date& date)
    {
      return GetLastLeapSecondDateResultPtr(new GetLastLeapSecondDateResult(relatedCommand, date));
    }

    GetLastLeapSecondDateResultPtr GetLastLeapSecondDateResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetLastLeapSecondDateResult>(ptr);
    }

    bool GetLastLeapSecondDateResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<Sdx::Date>::is_valid(m_values["Date"])
        ;

    }

    std::string GetLastLeapSecondDateResult::documentation() const { return Documentation; }


    Sdx::Date GetLastLeapSecondDateResult::date() const
    {
      return parse_json<Sdx::Date>::parse(m_values["Date"]);
    }

    void GetLastLeapSecondDateResult::setDate(const Sdx::Date& date)
    {
      m_values.AddMember("Date", parse_json<Sdx::Date>::format(date, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWFAntennaGain
///
#include "gen/SetWFAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWFAntennaGain::CmdName = "SetWFAntennaGain";
    const char* const SetWFAntennaGain::Documentation = "Set The CRPA LNA gain";

    REGISTER_COMMAND_FACTORY(SetWFAntennaGain);


    SetWFAntennaGain::SetWFAntennaGain()
      : CommandBase(CmdName)
    {}

    SetWFAntennaGain::SetWFAntennaGain(int gain)
      : CommandBase(CmdName)
    {

      setGain(gain);
    }


    SetWFAntennaGainPtr SetWFAntennaGain::create(int gain)
    {
      return SetWFAntennaGainPtr(new SetWFAntennaGain(gain));
    }

    SetWFAntennaGainPtr SetWFAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWFAntennaGain>(ptr);
    }

    bool SetWFAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Gain"])
        ;

    }

    std::string SetWFAntennaGain::documentation() const { return Documentation; }


    int SetWFAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetWFAntennaGain::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void SetWFAntennaGain::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetWFAntennaGain
///
#include "gen/GetWFAntennaGain.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaGain::CmdName = "GetWFAntennaGain";
    const char* const GetWFAntennaGain::Documentation = "Get The CRPA LNA gain";

    REGISTER_COMMAND_FACTORY(GetWFAntennaGain);


    GetWFAntennaGain::GetWFAntennaGain()
      : CommandBase(CmdName)
    {

    }


    GetWFAntennaGainPtr GetWFAntennaGain::create()
    {
      return GetWFAntennaGainPtr(new GetWFAntennaGain());
    }

    GetWFAntennaGainPtr GetWFAntennaGain::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaGain>(ptr);
    }

    bool GetWFAntennaGain::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetWFAntennaGain::documentation() const { return Documentation; }


    int GetWFAntennaGain::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetWFAntennaGainResult
///
#include "gen/GetWFAntennaGainResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetWFAntennaGainResult::CmdName = "GetWFAntennaGainResult";
    const char* const GetWFAntennaGainResult::Documentation = "Result of GetWFAntennaGain";

    REGISTER_COMMAND_RESULT_FACTORY(GetWFAntennaGainResult);


    GetWFAntennaGainResult::GetWFAntennaGainResult()
      : CommandResult(CmdName)
    {}

    GetWFAntennaGainResult::GetWFAntennaGainResult(CommandBasePtr relatedCommand, int gain)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
    }


    GetWFAntennaGainResultPtr GetWFAntennaGainResult::create(CommandBasePtr relatedCommand, int gain)
    {
      return GetWFAntennaGainResultPtr(new GetWFAntennaGainResult(relatedCommand, gain));
    }

    GetWFAntennaGainResultPtr GetWFAntennaGainResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetWFAntennaGainResult>(ptr);
    }

    bool GetWFAntennaGainResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Gain"])
        ;

    }

    std::string GetWFAntennaGainResult::documentation() const { return Documentation; }


    int GetWFAntennaGainResult::gain() const
    {
      return parse_json<int>::parse(m_values["Gain"]);
    }

    void GetWFAntennaGainResult::setGain(int gain)
    {
      m_values.AddMember("Gain", parse_json<int>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddCustomSignal
///
#include "gen/AddCustomSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddCustomSignal::CmdName = "AddCustomSignal";
    const char* const AddCustomSignal::Documentation = "Adds a custom signal";

    REGISTER_COMMAND_FACTORY(AddCustomSignal);


    AddCustomSignal::AddCustomSignal()
      : CommandBase(CmdName)
    {}

    AddCustomSignal::AddCustomSignal(const std::string& path, const std::string& id)
      : CommandBase(CmdName)
    {

      setPath(path);
      setId(id);
    }


    AddCustomSignalPtr AddCustomSignal::create(const std::string& path, const std::string& id)
    {
      return AddCustomSignalPtr(new AddCustomSignal(path, id));
    }

    AddCustomSignalPtr AddCustomSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddCustomSignal>(ptr);
    }

    bool AddCustomSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string AddCustomSignal::documentation() const { return Documentation; }


    int AddCustomSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddCustomSignal::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void AddCustomSignal::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddCustomSignal::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void AddCustomSignal::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveCustomSignal
///
#include "gen/RemoveCustomSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveCustomSignal::CmdName = "RemoveCustomSignal";
    const char* const RemoveCustomSignal::Documentation = "Removes the custom signal with the given ID";

    REGISTER_COMMAND_FACTORY(RemoveCustomSignal);


    RemoveCustomSignal::RemoveCustomSignal()
      : CommandBase(CmdName)
    {}

    RemoveCustomSignal::RemoveCustomSignal(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveCustomSignalPtr RemoveCustomSignal::create(const std::string& id)
    {
      return RemoveCustomSignalPtr(new RemoveCustomSignal(id));
    }

    RemoveCustomSignalPtr RemoveCustomSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveCustomSignal>(ptr);
    }

    bool RemoveCustomSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveCustomSignal::documentation() const { return Documentation; }


    int RemoveCustomSignal::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveCustomSignal::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveCustomSignal::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllCustomSignals
///
#include "gen/RemoveAllCustomSignals.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllCustomSignals::CmdName = "RemoveAllCustomSignals";
    const char* const RemoveAllCustomSignals::Documentation = "Removes all the custom signals";

    REGISTER_COMMAND_FACTORY(RemoveAllCustomSignals);


    RemoveAllCustomSignals::RemoveAllCustomSignals()
      : CommandBase(CmdName)
    {

    }


    RemoveAllCustomSignalsPtr RemoveAllCustomSignals::create()
    {
      return RemoveAllCustomSignalsPtr(new RemoveAllCustomSignals());
    }

    RemoveAllCustomSignalsPtr RemoveAllCustomSignals::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllCustomSignals>(ptr);
    }

    bool RemoveAllCustomSignals::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string RemoveAllCustomSignals::documentation() const { return Documentation; }


    int RemoveAllCustomSignals::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of ChangeCustomSignalColor
///
#include "gen/ChangeCustomSignalColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeCustomSignalColor::CmdName = "ChangeCustomSignalColor";
    const char* const ChangeCustomSignalColor::Documentation = "Changes the custom signal color";

    REGISTER_COMMAND_FACTORY(ChangeCustomSignalColor);


    ChangeCustomSignalColor::ChangeCustomSignalColor()
      : CommandBase(CmdName)
    {}

    ChangeCustomSignalColor::ChangeCustomSignalColor(const std::string& color, const std::string& id)
      : CommandBase(CmdName)
    {

      setColor(color);
      setId(id);
    }


    ChangeCustomSignalColorPtr ChangeCustomSignalColor::create(const std::string& color, const std::string& id)
    {
      return ChangeCustomSignalColorPtr(new ChangeCustomSignalColor(color, id));
    }

    ChangeCustomSignalColorPtr ChangeCustomSignalColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeCustomSignalColor>(ptr);
    }

    bool ChangeCustomSignalColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ChangeCustomSignalColor::documentation() const { return Documentation; }


    int ChangeCustomSignalColor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ChangeCustomSignalColor::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void ChangeCustomSignalColor::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeCustomSignalColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeCustomSignalColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllSpoofTxID
///
#include "gen/GetAllSpoofTxID.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSpoofTxID::CmdName = "GetAllSpoofTxID";
    const char* const GetAllSpoofTxID::Documentation = "Get the ID of all spoofer transmitters.";

    REGISTER_COMMAND_FACTORY(GetAllSpoofTxID);


    GetAllSpoofTxID::GetAllSpoofTxID()
      : CommandBase(CmdName)
    {

    }


    GetAllSpoofTxIDPtr GetAllSpoofTxID::create()
    {
      return GetAllSpoofTxIDPtr(new GetAllSpoofTxID());
    }

    GetAllSpoofTxIDPtr GetAllSpoofTxID::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSpoofTxID>(ptr);
    }

    bool GetAllSpoofTxID::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetAllSpoofTxID::documentation() const { return Documentation; }


    int GetAllSpoofTxID::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }

  }
}


///
/// Definition of GetAllSpoofTxIDResult
///
#include "gen/GetAllSpoofTxIDResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllSpoofTxIDResult::CmdName = "GetAllSpoofTxIDResult";
    const char* const GetAllSpoofTxIDResult::Documentation = "Result of GetAllSpoofTxID";

    REGISTER_COMMAND_RESULT_FACTORY(GetAllSpoofTxIDResult);


    GetAllSpoofTxIDResult::GetAllSpoofTxIDResult()
      : CommandResult(CmdName)
    {}

    GetAllSpoofTxIDResult::GetAllSpoofTxIDResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetAllSpoofTxIDResultPtr GetAllSpoofTxIDResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetAllSpoofTxIDResultPtr(new GetAllSpoofTxIDResult(relatedCommand, ids));
    }

    GetAllSpoofTxIDResultPtr GetAllSpoofTxIDResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllSpoofTxIDResult>(ptr);
    }

    bool GetAllSpoofTxIDResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetAllSpoofTxIDResult::documentation() const { return Documentation; }


    std::vector<std::string> GetAllSpoofTxIDResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetAllSpoofTxIDResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of AddSpoofTx
///
#include "gen/AddSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const AddSpoofTx::CmdName = "AddSpoofTx";
    const char* const AddSpoofTx::Documentation = "Set a spoofer transmitter. For set : the transmitter Id parameter is not set (empty string),\nSkydel will assign a unique Id to the transmitter. If the Id is set and already used by Skydel, the\ncommand will fail.";

    REGISTER_COMMAND_FACTORY(AddSpoofTx);


    AddSpoofTx::AddSpoofTx()
      : CommandBase(CmdName)
    {}

    AddSpoofTx::AddSpoofTx(const std::string& usualName, bool enabled, const std::string& address, int instanceId, const std::string& id)
      : CommandBase(CmdName)
    {

      setUsualName(usualName);
      setEnabled(enabled);
      setAddress(address);
      setInstanceId(instanceId);
      setId(id);
    }


    AddSpoofTxPtr AddSpoofTx::create(const std::string& usualName, bool enabled, const std::string& address, int instanceId, const std::string& id)
    {
      return AddSpoofTxPtr(new AddSpoofTx(usualName, enabled, address, instanceId, id));
    }

    AddSpoofTxPtr AddSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<AddSpoofTx>(ptr);
    }

    bool AddSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<int>::is_valid(m_values["InstanceId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string AddSpoofTx::documentation() const { return Documentation; }


    int AddSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string AddSpoofTx::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void AddSpoofTx::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool AddSpoofTx::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void AddSpoofTx::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddSpoofTx::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void AddSpoofTx::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int AddSpoofTx::instanceId() const
    {
      return parse_json<int>::parse(m_values["InstanceId"]);
    }

    void AddSpoofTx::setInstanceId(int instanceId)
    {
      m_values.AddMember("InstanceId", parse_json<int>::format(instanceId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string AddSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void AddSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTx
///
#include "gen/GetSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTx::CmdName = "GetSpoofTx";
    const char* const GetSpoofTx::Documentation = "Get a spoofer transmitter. For set : the transmitter Id parameter is not set (empty string),\nSkydel will assign a unique Id to the transmitter. If the Id is set and already used by Skydel, the\ncommand will fail.";

    REGISTER_COMMAND_FACTORY(GetSpoofTx);


    GetSpoofTx::GetSpoofTx()
      : CommandBase(CmdName)
    {}

    GetSpoofTx::GetSpoofTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxPtr GetSpoofTx::create(const std::string& id)
    {
      return GetSpoofTxPtr(new GetSpoofTx(id));
    }

    GetSpoofTxPtr GetSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTx>(ptr);
    }

    bool GetSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTx::documentation() const { return Documentation; }


    int GetSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxResult
///
#include "gen/GetSpoofTxResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxResult::CmdName = "GetSpoofTxResult";
    const char* const GetSpoofTxResult::Documentation = "Result of GetSpoofTx";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxResult);


    GetSpoofTxResult::GetSpoofTxResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxResult::GetSpoofTxResult(CommandBasePtr relatedCommand, const std::string& usualName, bool enabled, const std::string& address, int instanceId, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setUsualName(usualName);
      setEnabled(enabled);
      setAddress(address);
      setInstanceId(instanceId);
      setId(id);
    }


    GetSpoofTxResultPtr GetSpoofTxResult::create(CommandBasePtr relatedCommand, const std::string& usualName, bool enabled, const std::string& address, int instanceId, const std::string& id)
    {
      return GetSpoofTxResultPtr(new GetSpoofTxResult(relatedCommand, usualName, enabled, address, instanceId, id));
    }

    GetSpoofTxResultPtr GetSpoofTxResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxResult>(ptr);
    }

    bool GetSpoofTxResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<int>::is_valid(m_values["InstanceId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxResult::documentation() const { return Documentation; }


    std::string GetSpoofTxResult::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void GetSpoofTxResult::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetSpoofTxResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetSpoofTxResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxResult::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void GetSpoofTxResult::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSpoofTxResult::instanceId() const
    {
      return parse_json<int>::parse(m_values["InstanceId"]);
    }

    void GetSpoofTxResult::setInstanceId(int instanceId)
    {
      m_values.AddMember("InstanceId", parse_json<int>::format(instanceId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveSpoofTx
///
#include "gen/RemoveSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveSpoofTx::CmdName = "RemoveSpoofTx";
    const char* const RemoveSpoofTx::Documentation = "Removes the spoofer transmitter. See EnableSpoofTx if all you want is to\ndisable the interference temporarily.";

    REGISTER_COMMAND_FACTORY(RemoveSpoofTx);


    RemoveSpoofTx::RemoveSpoofTx()
      : CommandBase(CmdName)
    {}

    RemoveSpoofTx::RemoveSpoofTx(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveSpoofTxPtr RemoveSpoofTx::create(const std::string& id)
    {
      return RemoveSpoofTxPtr(new RemoveSpoofTx(id));
    }

    RemoveSpoofTxPtr RemoveSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveSpoofTx>(ptr);
    }

    bool RemoveSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveSpoofTx::documentation() const { return Documentation; }


    int RemoveSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RenameSpoofTx
///
#include "gen/RenameSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RenameSpoofTx::CmdName = "RenameSpoofTx";
    const char* const RenameSpoofTx::Documentation = "Rename a spoofer.";

    REGISTER_COMMAND_FACTORY(RenameSpoofTx);


    RenameSpoofTx::RenameSpoofTx()
      : CommandBase(CmdName)
    {}

    RenameSpoofTx::RenameSpoofTx(const std::string& usualName, const std::string& id)
      : CommandBase(CmdName)
    {

      setUsualName(usualName);
      setId(id);
    }


    RenameSpoofTxPtr RenameSpoofTx::create(const std::string& usualName, const std::string& id)
    {
      return RenameSpoofTxPtr(new RenameSpoofTx(usualName, id));
    }

    RenameSpoofTxPtr RenameSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RenameSpoofTx>(ptr);
    }

    bool RenameSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["UsualName"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RenameSpoofTx::documentation() const { return Documentation; }


    int RenameSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RenameSpoofTx::usualName() const
    {
      return parse_json<std::string>::parse(m_values["UsualName"]);
    }

    void RenameSpoofTx::setUsualName(const std::string& usualName)
    {
      m_values.AddMember("UsualName", parse_json<std::string>::format(usualName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RenameSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RenameSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ChangeSpoofTxColor
///
#include "gen/ChangeSpoofTxColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ChangeSpoofTxColor::CmdName = "ChangeSpoofTxColor";
    const char* const ChangeSpoofTxColor::Documentation = "Set a spoofer color in spectrums";

    REGISTER_COMMAND_FACTORY(ChangeSpoofTxColor);


    ChangeSpoofTxColor::ChangeSpoofTxColor()
      : CommandBase(CmdName)
    {}

    ChangeSpoofTxColor::ChangeSpoofTxColor(const std::string& color, const std::string& id)
      : CommandBase(CmdName)
    {

      setColor(color);
      setId(id);
    }


    ChangeSpoofTxColorPtr ChangeSpoofTxColor::create(const std::string& color, const std::string& id)
    {
      return ChangeSpoofTxColorPtr(new ChangeSpoofTxColor(color, id));
    }

    ChangeSpoofTxColorPtr ChangeSpoofTxColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ChangeSpoofTxColor>(ptr);
    }

    bool ChangeSpoofTxColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ChangeSpoofTxColor::documentation() const { return Documentation; }


    int ChangeSpoofTxColor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string ChangeSpoofTxColor::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void ChangeSpoofTxColor::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ChangeSpoofTxColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ChangeSpoofTxColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxColor
///
#include "gen/GetSpoofTxColor.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxColor::CmdName = "GetSpoofTxColor";
    const char* const GetSpoofTxColor::Documentation = "Get a spoofer color in spectrums";

    REGISTER_COMMAND_FACTORY(GetSpoofTxColor);


    GetSpoofTxColor::GetSpoofTxColor()
      : CommandBase(CmdName)
    {}

    GetSpoofTxColor::GetSpoofTxColor(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxColorPtr GetSpoofTxColor::create(const std::string& id)
    {
      return GetSpoofTxColorPtr(new GetSpoofTxColor(id));
    }

    GetSpoofTxColorPtr GetSpoofTxColor::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxColor>(ptr);
    }

    bool GetSpoofTxColor::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxColor::documentation() const { return Documentation; }


    int GetSpoofTxColor::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxColor::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxColor::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxColorResult
///
#include "gen/GetSpoofTxColorResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxColorResult::CmdName = "GetSpoofTxColorResult";
    const char* const GetSpoofTxColorResult::Documentation = "Result of GetSpoofTxColor";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxColorResult);


    GetSpoofTxColorResult::GetSpoofTxColorResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxColorResult::GetSpoofTxColorResult(CommandBasePtr relatedCommand, const std::string& color, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setColor(color);
      setId(id);
    }


    GetSpoofTxColorResultPtr GetSpoofTxColorResult::create(CommandBasePtr relatedCommand, const std::string& color, const std::string& id)
    {
      return GetSpoofTxColorResultPtr(new GetSpoofTxColorResult(relatedCommand, color, id));
    }

    GetSpoofTxColorResultPtr GetSpoofTxColorResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxColorResult>(ptr);
    }

    bool GetSpoofTxColorResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Color"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxColorResult::documentation() const { return Documentation; }


    std::string GetSpoofTxColorResult::color() const
    {
      return parse_json<std::string>::parse(m_values["Color"]);
    }

    void GetSpoofTxColorResult::setColor(const std::string& color)
    {
      m_values.AddMember("Color", parse_json<std::string>::format(color, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxColorResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxColorResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSpoofTx
///
#include "gen/EnableSpoofTx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSpoofTx::CmdName = "EnableSpoofTx";
    const char* const EnableSpoofTx::Documentation = "Enable/Disable the spoofer.";

    REGISTER_COMMAND_FACTORY(EnableSpoofTx);


    EnableSpoofTx::EnableSpoofTx()
      : CommandBase(CmdName)
    {}

    EnableSpoofTx::EnableSpoofTx(bool enabled, const std::string& id)
      : CommandBase(CmdName)
    {

      setEnabled(enabled);
      setId(id);
    }


    EnableSpoofTxPtr EnableSpoofTx::create(bool enabled, const std::string& id)
    {
      return EnableSpoofTxPtr(new EnableSpoofTx(enabled, id));
    }

    EnableSpoofTxPtr EnableSpoofTx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSpoofTx>(ptr);
    }

    bool EnableSpoofTx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string EnableSpoofTx::documentation() const { return Documentation; }


    int EnableSpoofTx::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool EnableSpoofTx::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSpoofTx::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableSpoofTx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void EnableSpoofTx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxIgnorePropagationLoss
///
#include "gen/SetSpoofTxIgnorePropagationLoss.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxIgnorePropagationLoss::CmdName = "SetSpoofTxIgnorePropagationLoss";
    const char* const SetSpoofTxIgnorePropagationLoss::Documentation = "Set whether a spoofer should ignore propagation loss or not.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxIgnorePropagationLoss);


    SetSpoofTxIgnorePropagationLoss::SetSpoofTxIgnorePropagationLoss()
      : CommandBase(CmdName)
    {}

    SetSpoofTxIgnorePropagationLoss::SetSpoofTxIgnorePropagationLoss(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetSpoofTxIgnorePropagationLossPtr SetSpoofTxIgnorePropagationLoss::create(bool ignore, const std::string& id)
    {
      return SetSpoofTxIgnorePropagationLossPtr(new SetSpoofTxIgnorePropagationLoss(ignore, id));
    }

    SetSpoofTxIgnorePropagationLossPtr SetSpoofTxIgnorePropagationLoss::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxIgnorePropagationLoss>(ptr);
    }

    bool SetSpoofTxIgnorePropagationLoss::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxIgnorePropagationLoss::documentation() const { return Documentation; }


    int SetSpoofTxIgnorePropagationLoss::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool SetSpoofTxIgnorePropagationLoss::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetSpoofTxIgnorePropagationLoss::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxIgnorePropagationLoss::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxIgnorePropagationLoss::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxIgnoreRxAntennaPatterns
///
#include "gen/SetSpoofTxIgnoreRxAntennaPatterns.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxIgnoreRxAntennaPatterns::CmdName = "SetSpoofTxIgnoreRxAntennaPatterns";
    const char* const SetSpoofTxIgnoreRxAntennaPatterns::Documentation = "Set whether a spoofer should ignore the receiver's antenna patterns (gain and phase).";

    REGISTER_COMMAND_FACTORY(SetSpoofTxIgnoreRxAntennaPatterns);


    SetSpoofTxIgnoreRxAntennaPatterns::SetSpoofTxIgnoreRxAntennaPatterns()
      : CommandBase(CmdName)
    {}

    SetSpoofTxIgnoreRxAntennaPatterns::SetSpoofTxIgnoreRxAntennaPatterns(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetSpoofTxIgnoreRxAntennaPatternsPtr SetSpoofTxIgnoreRxAntennaPatterns::create(bool ignore, const std::string& id)
    {
      return SetSpoofTxIgnoreRxAntennaPatternsPtr(new SetSpoofTxIgnoreRxAntennaPatterns(ignore, id));
    }

    SetSpoofTxIgnoreRxAntennaPatternsPtr SetSpoofTxIgnoreRxAntennaPatterns::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxIgnoreRxAntennaPatterns>(ptr);
    }

    bool SetSpoofTxIgnoreRxAntennaPatterns::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxIgnoreRxAntennaPatterns::documentation() const { return Documentation; }


    int SetSpoofTxIgnoreRxAntennaPatterns::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool SetSpoofTxIgnoreRxAntennaPatterns::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetSpoofTxIgnoreRxAntennaPatterns::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxIgnoreRxAntennaPatterns::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxIgnoreRxAntennaPatterns::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxIgnoreRxAntennaGainPattern
///
#include "gen/SetSpoofTxIgnoreRxAntennaGainPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxIgnoreRxAntennaGainPattern::CmdName = "SetSpoofTxIgnoreRxAntennaGainPattern";
    const char* const SetSpoofTxIgnoreRxAntennaGainPattern::Documentation = "Set whether a spoofer should ignore the receiver's antenna gain pattern.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxIgnoreRxAntennaGainPattern);


    SetSpoofTxIgnoreRxAntennaGainPattern::SetSpoofTxIgnoreRxAntennaGainPattern()
      : CommandBase(CmdName)
    {}

    SetSpoofTxIgnoreRxAntennaGainPattern::SetSpoofTxIgnoreRxAntennaGainPattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetSpoofTxIgnoreRxAntennaGainPatternPtr SetSpoofTxIgnoreRxAntennaGainPattern::create(bool ignore, const std::string& id)
    {
      return SetSpoofTxIgnoreRxAntennaGainPatternPtr(new SetSpoofTxIgnoreRxAntennaGainPattern(ignore, id));
    }

    SetSpoofTxIgnoreRxAntennaGainPatternPtr SetSpoofTxIgnoreRxAntennaGainPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxIgnoreRxAntennaGainPattern>(ptr);
    }

    bool SetSpoofTxIgnoreRxAntennaGainPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxIgnoreRxAntennaGainPattern::documentation() const { return Documentation; }


    int SetSpoofTxIgnoreRxAntennaGainPattern::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool SetSpoofTxIgnoreRxAntennaGainPattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetSpoofTxIgnoreRxAntennaGainPattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxIgnoreRxAntennaGainPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxIgnoreRxAntennaGainPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpoofTxIgnoreRxAntennaGainPattern
///
#include "gen/IsSpoofTxIgnoreRxAntennaGainPattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpoofTxIgnoreRxAntennaGainPattern::CmdName = "IsSpoofTxIgnoreRxAntennaGainPattern";
    const char* const IsSpoofTxIgnoreRxAntennaGainPattern::Documentation = "Get whether a spoofer ignore the receiver's antenna gain pattern.";

    REGISTER_COMMAND_FACTORY(IsSpoofTxIgnoreRxAntennaGainPattern);


    IsSpoofTxIgnoreRxAntennaGainPattern::IsSpoofTxIgnoreRxAntennaGainPattern()
      : CommandBase(CmdName)
    {}

    IsSpoofTxIgnoreRxAntennaGainPattern::IsSpoofTxIgnoreRxAntennaGainPattern(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsSpoofTxIgnoreRxAntennaGainPatternPtr IsSpoofTxIgnoreRxAntennaGainPattern::create(const std::string& id)
    {
      return IsSpoofTxIgnoreRxAntennaGainPatternPtr(new IsSpoofTxIgnoreRxAntennaGainPattern(id));
    }

    IsSpoofTxIgnoreRxAntennaGainPatternPtr IsSpoofTxIgnoreRxAntennaGainPattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpoofTxIgnoreRxAntennaGainPattern>(ptr);
    }

    bool IsSpoofTxIgnoreRxAntennaGainPattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsSpoofTxIgnoreRxAntennaGainPattern::documentation() const { return Documentation; }


    int IsSpoofTxIgnoreRxAntennaGainPattern::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSpoofTxIgnoreRxAntennaGainPattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsSpoofTxIgnoreRxAntennaGainPattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpoofTxIgnoreRxAntennaGainPatternResult
///
#include "gen/IsSpoofTxIgnoreRxAntennaGainPatternResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpoofTxIgnoreRxAntennaGainPatternResult::CmdName = "IsSpoofTxIgnoreRxAntennaGainPatternResult";
    const char* const IsSpoofTxIgnoreRxAntennaGainPatternResult::Documentation = "Result of IsSpoofTxIgnoreRxAntennaGainPattern";

    REGISTER_COMMAND_RESULT_FACTORY(IsSpoofTxIgnoreRxAntennaGainPatternResult);


    IsSpoofTxIgnoreRxAntennaGainPatternResult::IsSpoofTxIgnoreRxAntennaGainPatternResult()
      : CommandResult(CmdName)
    {}

    IsSpoofTxIgnoreRxAntennaGainPatternResult::IsSpoofTxIgnoreRxAntennaGainPatternResult(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setIgnore(ignore);
      setId(id);
    }


    IsSpoofTxIgnoreRxAntennaGainPatternResultPtr IsSpoofTxIgnoreRxAntennaGainPatternResult::create(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
    {
      return IsSpoofTxIgnoreRxAntennaGainPatternResultPtr(new IsSpoofTxIgnoreRxAntennaGainPatternResult(relatedCommand, ignore, id));
    }

    IsSpoofTxIgnoreRxAntennaGainPatternResultPtr IsSpoofTxIgnoreRxAntennaGainPatternResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpoofTxIgnoreRxAntennaGainPatternResult>(ptr);
    }

    bool IsSpoofTxIgnoreRxAntennaGainPatternResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsSpoofTxIgnoreRxAntennaGainPatternResult::documentation() const { return Documentation; }


    bool IsSpoofTxIgnoreRxAntennaGainPatternResult::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void IsSpoofTxIgnoreRxAntennaGainPatternResult::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsSpoofTxIgnoreRxAntennaGainPatternResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsSpoofTxIgnoreRxAntennaGainPatternResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxIgnoreRxAntennaPhasePattern
///
#include "gen/SetSpoofTxIgnoreRxAntennaPhasePattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxIgnoreRxAntennaPhasePattern::CmdName = "SetSpoofTxIgnoreRxAntennaPhasePattern";
    const char* const SetSpoofTxIgnoreRxAntennaPhasePattern::Documentation = "Set whether a spoofer should ignore the receiver's antenna phase pattern.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxIgnoreRxAntennaPhasePattern);


    SetSpoofTxIgnoreRxAntennaPhasePattern::SetSpoofTxIgnoreRxAntennaPhasePattern()
      : CommandBase(CmdName)
    {}

    SetSpoofTxIgnoreRxAntennaPhasePattern::SetSpoofTxIgnoreRxAntennaPhasePattern(bool ignore, const std::string& id)
      : CommandBase(CmdName)
    {

      setIgnore(ignore);
      setId(id);
    }


    SetSpoofTxIgnoreRxAntennaPhasePatternPtr SetSpoofTxIgnoreRxAntennaPhasePattern::create(bool ignore, const std::string& id)
    {
      return SetSpoofTxIgnoreRxAntennaPhasePatternPtr(new SetSpoofTxIgnoreRxAntennaPhasePattern(ignore, id));
    }

    SetSpoofTxIgnoreRxAntennaPhasePatternPtr SetSpoofTxIgnoreRxAntennaPhasePattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxIgnoreRxAntennaPhasePattern>(ptr);
    }

    bool SetSpoofTxIgnoreRxAntennaPhasePattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxIgnoreRxAntennaPhasePattern::documentation() const { return Documentation; }


    int SetSpoofTxIgnoreRxAntennaPhasePattern::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    bool SetSpoofTxIgnoreRxAntennaPhasePattern::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void SetSpoofTxIgnoreRxAntennaPhasePattern::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxIgnoreRxAntennaPhasePattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxIgnoreRxAntennaPhasePattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpoofTxIgnoreRxAntennaPhasePattern
///
#include "gen/IsSpoofTxIgnoreRxAntennaPhasePattern.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpoofTxIgnoreRxAntennaPhasePattern::CmdName = "IsSpoofTxIgnoreRxAntennaPhasePattern";
    const char* const IsSpoofTxIgnoreRxAntennaPhasePattern::Documentation = "Get whether a spoofer ignore the receiver's antenna phase pattern.";

    REGISTER_COMMAND_FACTORY(IsSpoofTxIgnoreRxAntennaPhasePattern);


    IsSpoofTxIgnoreRxAntennaPhasePattern::IsSpoofTxIgnoreRxAntennaPhasePattern()
      : CommandBase(CmdName)
    {}

    IsSpoofTxIgnoreRxAntennaPhasePattern::IsSpoofTxIgnoreRxAntennaPhasePattern(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    IsSpoofTxIgnoreRxAntennaPhasePatternPtr IsSpoofTxIgnoreRxAntennaPhasePattern::create(const std::string& id)
    {
      return IsSpoofTxIgnoreRxAntennaPhasePatternPtr(new IsSpoofTxIgnoreRxAntennaPhasePattern(id));
    }

    IsSpoofTxIgnoreRxAntennaPhasePatternPtr IsSpoofTxIgnoreRxAntennaPhasePattern::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpoofTxIgnoreRxAntennaPhasePattern>(ptr);
    }

    bool IsSpoofTxIgnoreRxAntennaPhasePattern::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsSpoofTxIgnoreRxAntennaPhasePattern::documentation() const { return Documentation; }


    int IsSpoofTxIgnoreRxAntennaPhasePattern::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSpoofTxIgnoreRxAntennaPhasePattern::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsSpoofTxIgnoreRxAntennaPhasePattern::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSpoofTxIgnoreRxAntennaPhasePatternResult
///
#include "gen/IsSpoofTxIgnoreRxAntennaPhasePatternResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSpoofTxIgnoreRxAntennaPhasePatternResult::CmdName = "IsSpoofTxIgnoreRxAntennaPhasePatternResult";
    const char* const IsSpoofTxIgnoreRxAntennaPhasePatternResult::Documentation = "Result of IsSpoofTxIgnoreRxAntennaPhasePattern";

    REGISTER_COMMAND_RESULT_FACTORY(IsSpoofTxIgnoreRxAntennaPhasePatternResult);


    IsSpoofTxIgnoreRxAntennaPhasePatternResult::IsSpoofTxIgnoreRxAntennaPhasePatternResult()
      : CommandResult(CmdName)
    {}

    IsSpoofTxIgnoreRxAntennaPhasePatternResult::IsSpoofTxIgnoreRxAntennaPhasePatternResult(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setIgnore(ignore);
      setId(id);
    }


    IsSpoofTxIgnoreRxAntennaPhasePatternResultPtr IsSpoofTxIgnoreRxAntennaPhasePatternResult::create(CommandBasePtr relatedCommand, bool ignore, const std::string& id)
    {
      return IsSpoofTxIgnoreRxAntennaPhasePatternResultPtr(new IsSpoofTxIgnoreRxAntennaPhasePatternResult(relatedCommand, ignore, id));
    }

    IsSpoofTxIgnoreRxAntennaPhasePatternResultPtr IsSpoofTxIgnoreRxAntennaPhasePatternResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSpoofTxIgnoreRxAntennaPhasePatternResult>(ptr);
    }

    bool IsSpoofTxIgnoreRxAntennaPhasePatternResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["Ignore"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string IsSpoofTxIgnoreRxAntennaPhasePatternResult::documentation() const { return Documentation; }


    bool IsSpoofTxIgnoreRxAntennaPhasePatternResult::ignore() const
    {
      return parse_json<bool>::parse(m_values["Ignore"]);
    }

    void IsSpoofTxIgnoreRxAntennaPhasePatternResult::setIgnore(bool ignore)
    {
      m_values.AddMember("Ignore", parse_json<bool>::format(ignore, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsSpoofTxIgnoreRxAntennaPhasePatternResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void IsSpoofTxIgnoreRxAntennaPhasePatternResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxFix
///
#include "gen/SetSpoofTxFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxFix::CmdName = "SetSpoofTxFix";
    const char* const SetSpoofTxFix::Documentation = "Set spoofer transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(SetSpoofTxFix);


    SetSpoofTxFix::SetSpoofTxFix()
      : CommandBase(CmdName)
    {}

    SetSpoofTxFix::SetSpoofTxFix(double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetSpoofTxFixPtr SetSpoofTxFix::create(double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
    {
      return SetSpoofTxFixPtr(new SetSpoofTxFix(lat, lon, alt, yaw, pitch, roll, id));
    }

    SetSpoofTxFixPtr SetSpoofTxFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxFix>(ptr);
    }

    bool SetSpoofTxFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxFix::documentation() const { return Documentation; }


    int SetSpoofTxFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSpoofTxFix::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetSpoofTxFix::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetSpoofTxFix::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetSpoofTxFix::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetSpoofTxFix::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetSpoofTxFix::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFix::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetSpoofTxFix::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxFix::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxFix::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxFix
///
#include "gen/GetSpoofTxFix.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxFix::CmdName = "GetSpoofTxFix";
    const char* const GetSpoofTxFix::Documentation = "Get spoofer transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(GetSpoofTxFix);


    GetSpoofTxFix::GetSpoofTxFix()
      : CommandBase(CmdName)
    {}

    GetSpoofTxFix::GetSpoofTxFix(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxFixPtr GetSpoofTxFix::create(const std::string& id)
    {
      return GetSpoofTxFixPtr(new GetSpoofTxFix(id));
    }

    GetSpoofTxFixPtr GetSpoofTxFix::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxFix>(ptr);
    }

    bool GetSpoofTxFix::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxFix::documentation() const { return Documentation; }


    int GetSpoofTxFix::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxFix::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxFix::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxFixResult
///
#include "gen/GetSpoofTxFixResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxFixResult::CmdName = "GetSpoofTxFixResult";
    const char* const GetSpoofTxFixResult::Documentation = "Result of GetSpoofTxFix";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxFixResult);


    GetSpoofTxFixResult::GetSpoofTxFixResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxFixResult::GetSpoofTxFixResult(CommandBasePtr relatedCommand, double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetSpoofTxFixResultPtr GetSpoofTxFixResult::create(CommandBasePtr relatedCommand, double lat, double lon, double alt, double yaw, double pitch, double roll, const std::string& id)
    {
      return GetSpoofTxFixResultPtr(new GetSpoofTxFixResult(relatedCommand, lat, lon, alt, yaw, pitch, roll, id));
    }

    GetSpoofTxFixResultPtr GetSpoofTxFixResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxFixResult>(ptr);
    }

    bool GetSpoofTxFixResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxFixResult::documentation() const { return Documentation; }


    double GetSpoofTxFixResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetSpoofTxFixResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetSpoofTxFixResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetSpoofTxFixResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetSpoofTxFixResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetSpoofTxFixResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetSpoofTxFixResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxFixResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxFixResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxFixEcef
///
#include "gen/SetSpoofTxFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxFixEcef::CmdName = "SetSpoofTxFixEcef";
    const char* const SetSpoofTxFixEcef::Documentation = "Set spoofer transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(SetSpoofTxFixEcef);


    SetSpoofTxFixEcef::SetSpoofTxFixEcef()
      : CommandBase(CmdName)
    {}

    SetSpoofTxFixEcef::SetSpoofTxFixEcef(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetSpoofTxFixEcefPtr SetSpoofTxFixEcef::create(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return SetSpoofTxFixEcefPtr(new SetSpoofTxFixEcef(x, y, z, yaw, pitch, roll, id));
    }

    SetSpoofTxFixEcefPtr SetSpoofTxFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxFixEcef>(ptr);
    }

    bool SetSpoofTxFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxFixEcef::documentation() const { return Documentation; }


    int SetSpoofTxFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSpoofTxFixEcef::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetSpoofTxFixEcef::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetSpoofTxFixEcef::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetSpoofTxFixEcef::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetSpoofTxFixEcef::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetSpoofTxFixEcef::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxFixEcef::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetSpoofTxFixEcef::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxFixEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxFixEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxFixEcef
///
#include "gen/GetSpoofTxFixEcef.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxFixEcef::CmdName = "GetSpoofTxFixEcef";
    const char* const GetSpoofTxFixEcef::Documentation = "Get spoofer transmitter static position and orientation";

    REGISTER_COMMAND_FACTORY(GetSpoofTxFixEcef);


    GetSpoofTxFixEcef::GetSpoofTxFixEcef()
      : CommandBase(CmdName)
    {}

    GetSpoofTxFixEcef::GetSpoofTxFixEcef(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxFixEcefPtr GetSpoofTxFixEcef::create(const std::string& id)
    {
      return GetSpoofTxFixEcefPtr(new GetSpoofTxFixEcef(id));
    }

    GetSpoofTxFixEcefPtr GetSpoofTxFixEcef::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxFixEcef>(ptr);
    }

    bool GetSpoofTxFixEcef::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxFixEcef::documentation() const { return Documentation; }


    int GetSpoofTxFixEcef::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxFixEcef::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxFixEcef::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxFixEcefResult
///
#include "gen/GetSpoofTxFixEcefResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxFixEcefResult::CmdName = "GetSpoofTxFixEcefResult";
    const char* const GetSpoofTxFixEcefResult::Documentation = "Result of GetSpoofTxFixEcef";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxFixEcefResult);


    GetSpoofTxFixEcefResult::GetSpoofTxFixEcefResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxFixEcefResult::GetSpoofTxFixEcefResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetSpoofTxFixEcefResultPtr GetSpoofTxFixEcefResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return GetSpoofTxFixEcefResultPtr(new GetSpoofTxFixEcefResult(relatedCommand, x, y, z, yaw, pitch, roll, id));
    }

    GetSpoofTxFixEcefResultPtr GetSpoofTxFixEcefResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxFixEcefResult>(ptr);
    }

    bool GetSpoofTxFixEcefResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxFixEcefResult::documentation() const { return Documentation; }


    double GetSpoofTxFixEcefResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetSpoofTxFixEcefResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetSpoofTxFixEcefResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetSpoofTxFixEcefResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetSpoofTxFixEcefResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetSpoofTxFixEcefResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxFixEcefResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetSpoofTxFixEcefResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxFixEcefResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxFixEcefResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxCircular
///
#include "gen/SetSpoofTxCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxCircular::CmdName = "SetSpoofTxCircular";
    const char* const SetSpoofTxCircular::Documentation = "Set spoofer transmitter circular trajectory";

    REGISTER_COMMAND_FACTORY(SetSpoofTxCircular);


    SetSpoofTxCircular::SetSpoofTxCircular()
      : CommandBase(CmdName)
    {}

    SetSpoofTxCircular::SetSpoofTxCircular(double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
      : CommandBase(CmdName)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setId(id);
      setOriginAngle(originAngle);
    }


    SetSpoofTxCircularPtr SetSpoofTxCircular::create(double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
    {
      return SetSpoofTxCircularPtr(new SetSpoofTxCircular(lat, lon, alt, radius, speed, clockwise, id, originAngle));
    }

    SetSpoofTxCircularPtr SetSpoofTxCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxCircular>(ptr);
    }

    bool SetSpoofTxCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string SetSpoofTxCircular::documentation() const { return Documentation; }


    int SetSpoofTxCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSpoofTxCircular::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void SetSpoofTxCircular::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxCircular::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void SetSpoofTxCircular::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxCircular::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void SetSpoofTxCircular::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxCircular::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void SetSpoofTxCircular::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxCircular::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void SetSpoofTxCircular::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSpoofTxCircular::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void SetSpoofTxCircular::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxCircular::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxCircular::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> SetSpoofTxCircular::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void SetSpoofTxCircular::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxCircular
///
#include "gen/GetSpoofTxCircular.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxCircular::CmdName = "GetSpoofTxCircular";
    const char* const GetSpoofTxCircular::Documentation = "Get spoofer transmitter circular trajectory";

    REGISTER_COMMAND_FACTORY(GetSpoofTxCircular);


    GetSpoofTxCircular::GetSpoofTxCircular()
      : CommandBase(CmdName)
    {}

    GetSpoofTxCircular::GetSpoofTxCircular(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxCircularPtr GetSpoofTxCircular::create(const std::string& id)
    {
      return GetSpoofTxCircularPtr(new GetSpoofTxCircular(id));
    }

    GetSpoofTxCircularPtr GetSpoofTxCircular::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxCircular>(ptr);
    }

    bool GetSpoofTxCircular::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxCircular::documentation() const { return Documentation; }


    int GetSpoofTxCircular::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxCircular::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxCircular::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxCircularResult
///
#include "gen/GetSpoofTxCircularResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxCircularResult::CmdName = "GetSpoofTxCircularResult";
    const char* const GetSpoofTxCircularResult::Documentation = "Result of GetSpoofTxCircular";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxCircularResult);


    GetSpoofTxCircularResult::GetSpoofTxCircularResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxCircularResult::GetSpoofTxCircularResult(CommandBasePtr relatedCommand, double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
      : CommandResult(CmdName, relatedCommand)
    {

      setLat(lat);
      setLon(lon);
      setAlt(alt);
      setRadius(radius);
      setSpeed(speed);
      setClockwise(clockwise);
      setId(id);
      setOriginAngle(originAngle);
    }


    GetSpoofTxCircularResultPtr GetSpoofTxCircularResult::create(CommandBasePtr relatedCommand, double lat, double lon, double alt, double radius, double speed, bool clockwise, const std::string& id, const Sdx::optional<double>& originAngle)
    {
      return GetSpoofTxCircularResultPtr(new GetSpoofTxCircularResult(relatedCommand, lat, lon, alt, radius, speed, clockwise, id, originAngle));
    }

    GetSpoofTxCircularResultPtr GetSpoofTxCircularResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxCircularResult>(ptr);
    }

    bool GetSpoofTxCircularResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Lat"])
          && parse_json<double>::is_valid(m_values["Lon"])
          && parse_json<double>::is_valid(m_values["Alt"])
          && parse_json<double>::is_valid(m_values["Radius"])
          && parse_json<double>::is_valid(m_values["Speed"])
          && parse_json<bool>::is_valid(m_values["Clockwise"])
          && parse_json<std::string>::is_valid(m_values["Id"])
          && parse_json<Sdx::optional<double>>::is_valid(m_values["OriginAngle"])
        ;

    }

    std::string GetSpoofTxCircularResult::documentation() const { return Documentation; }


    double GetSpoofTxCircularResult::lat() const
    {
      return parse_json<double>::parse(m_values["Lat"]);
    }

    void GetSpoofTxCircularResult::setLat(double lat)
    {
      m_values.AddMember("Lat", parse_json<double>::format(lat, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxCircularResult::lon() const
    {
      return parse_json<double>::parse(m_values["Lon"]);
    }

    void GetSpoofTxCircularResult::setLon(double lon)
    {
      m_values.AddMember("Lon", parse_json<double>::format(lon, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxCircularResult::alt() const
    {
      return parse_json<double>::parse(m_values["Alt"]);
    }

    void GetSpoofTxCircularResult::setAlt(double alt)
    {
      m_values.AddMember("Alt", parse_json<double>::format(alt, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxCircularResult::radius() const
    {
      return parse_json<double>::parse(m_values["Radius"]);
    }

    void GetSpoofTxCircularResult::setRadius(double radius)
    {
      m_values.AddMember("Radius", parse_json<double>::format(radius, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxCircularResult::speed() const
    {
      return parse_json<double>::parse(m_values["Speed"]);
    }

    void GetSpoofTxCircularResult::setSpeed(double speed)
    {
      m_values.AddMember("Speed", parse_json<double>::format(speed, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetSpoofTxCircularResult::clockwise() const
    {
      return parse_json<bool>::parse(m_values["Clockwise"]);
    }

    void GetSpoofTxCircularResult::setClockwise(bool clockwise)
    {
      m_values.AddMember("Clockwise", parse_json<bool>::format(clockwise, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxCircularResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxCircularResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::optional<double> GetSpoofTxCircularResult::originAngle() const
    {
      return parse_json<Sdx::optional<double>>::parse(m_values["OriginAngle"]);
    }

    void GetSpoofTxCircularResult::setOriginAngle(const Sdx::optional<double>& originAngle)
    {
      m_values.AddMember("OriginAngle", parse_json<Sdx::optional<double>>::format(originAngle, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxHil
///
#include "gen/SetSpoofTxHil.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxHil::CmdName = "SetSpoofTxHil";
    const char* const SetSpoofTxHil::Documentation = "Set spoofer transmitter HIL trajectory";

    REGISTER_COMMAND_FACTORY(SetSpoofTxHil);


    SetSpoofTxHil::SetSpoofTxHil()
      : CommandBase(CmdName)
    {}

    SetSpoofTxHil::SetSpoofTxHil(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    SetSpoofTxHilPtr SetSpoofTxHil::create(const std::string& id)
    {
      return SetSpoofTxHilPtr(new SetSpoofTxHil(id));
    }

    SetSpoofTxHilPtr SetSpoofTxHil::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxHil>(ptr);
    }

    bool SetSpoofTxHil::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxHil::documentation() const { return Documentation; }


    int SetSpoofTxHil::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSpoofTxHil::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxHil::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxTrajectory
///
#include "gen/GetSpoofTxTrajectory.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxTrajectory::CmdName = "GetSpoofTxTrajectory";
    const char* const GetSpoofTxTrajectory::Documentation = "Get spoofer transmitter trajectory";

    REGISTER_COMMAND_FACTORY(GetSpoofTxTrajectory);


    GetSpoofTxTrajectory::GetSpoofTxTrajectory()
      : CommandBase(CmdName)
    {}

    GetSpoofTxTrajectory::GetSpoofTxTrajectory(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxTrajectoryPtr GetSpoofTxTrajectory::create(const std::string& id)
    {
      return GetSpoofTxTrajectoryPtr(new GetSpoofTxTrajectory(id));
    }

    GetSpoofTxTrajectoryPtr GetSpoofTxTrajectory::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxTrajectory>(ptr);
    }

    bool GetSpoofTxTrajectory::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxTrajectory::documentation() const { return Documentation; }


    int GetSpoofTxTrajectory::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxTrajectory::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxTrajectory::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxTrajectoryResult
///
#include "gen/GetSpoofTxTrajectoryResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxTrajectoryResult::CmdName = "GetSpoofTxTrajectoryResult";
    const char* const GetSpoofTxTrajectoryResult::Documentation = "Result of GetSpoofTxTrajectory";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxTrajectoryResult);


    GetSpoofTxTrajectoryResult::GetSpoofTxTrajectoryResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxTrajectoryResult::GetSpoofTxTrajectoryResult(CommandBasePtr relatedCommand, const std::string& trajectoryType, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setTrajectoryType(trajectoryType);
      setId(id);
    }


    GetSpoofTxTrajectoryResultPtr GetSpoofTxTrajectoryResult::create(CommandBasePtr relatedCommand, const std::string& trajectoryType, const std::string& id)
    {
      return GetSpoofTxTrajectoryResultPtr(new GetSpoofTxTrajectoryResult(relatedCommand, trajectoryType, id));
    }

    GetSpoofTxTrajectoryResultPtr GetSpoofTxTrajectoryResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxTrajectoryResult>(ptr);
    }

    bool GetSpoofTxTrajectoryResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["TrajectoryType"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxTrajectoryResult::documentation() const { return Documentation; }


    std::string GetSpoofTxTrajectoryResult::trajectoryType() const
    {
      return parse_json<std::string>::parse(m_values["TrajectoryType"]);
    }

    void GetSpoofTxTrajectoryResult::setTrajectoryType(const std::string& trajectoryType)
    {
      m_values.AddMember("TrajectoryType", parse_json<std::string>::format(trajectoryType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxTrajectoryResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxTrajectoryResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxAntenna
///
#include "gen/SetSpoofTxAntenna.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxAntenna::CmdName = "SetSpoofTxAntenna";
    const char* const SetSpoofTxAntenna::Documentation = "Set transmitter antenna pattern.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxAntenna);


    SetSpoofTxAntenna::SetSpoofTxAntenna()
      : CommandBase(CmdName)
    {}

    SetSpoofTxAntenna::SetSpoofTxAntenna(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
      : CommandBase(CmdName)
    {

      setGain(gain);
      setType(type);
      setId(id);
    }


    SetSpoofTxAntennaPtr SetSpoofTxAntenna::create(const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
    {
      return SetSpoofTxAntennaPtr(new SetSpoofTxAntenna(gain, type, id));
    }

    SetSpoofTxAntennaPtr SetSpoofTxAntenna::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxAntenna>(ptr);
    }

    bool SetSpoofTxAntenna::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxAntenna::documentation() const { return Documentation; }


    int SetSpoofTxAntenna::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::vector<double>> SetSpoofTxAntenna::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void SetSpoofTxAntenna::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType SetSpoofTxAntenna::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void SetSpoofTxAntenna::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxAntenna::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxAntenna::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxAntenna
///
#include "gen/GetSpoofTxAntenna.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxAntenna::CmdName = "GetSpoofTxAntenna";
    const char* const GetSpoofTxAntenna::Documentation = "Get transmitter antenna pattern.";

    REGISTER_COMMAND_FACTORY(GetSpoofTxAntenna);


    GetSpoofTxAntenna::GetSpoofTxAntenna()
      : CommandBase(CmdName)
    {}

    GetSpoofTxAntenna::GetSpoofTxAntenna(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxAntennaPtr GetSpoofTxAntenna::create(const std::string& id)
    {
      return GetSpoofTxAntennaPtr(new GetSpoofTxAntenna(id));
    }

    GetSpoofTxAntennaPtr GetSpoofTxAntenna::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxAntenna>(ptr);
    }

    bool GetSpoofTxAntenna::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxAntenna::documentation() const { return Documentation; }


    int GetSpoofTxAntenna::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxAntenna::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxAntenna::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxAntennaResult
///
#include "gen/GetSpoofTxAntennaResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxAntennaResult::CmdName = "GetSpoofTxAntennaResult";
    const char* const GetSpoofTxAntennaResult::Documentation = "Result of GetSpoofTxAntenna";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxAntennaResult);


    GetSpoofTxAntennaResult::GetSpoofTxAntennaResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxAntennaResult::GetSpoofTxAntennaResult(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setGain(gain);
      setType(type);
      setId(id);
    }


    GetSpoofTxAntennaResultPtr GetSpoofTxAntennaResult::create(CommandBasePtr relatedCommand, const std::vector<std::vector<double>>& gain, const Sdx::AntennaPatternType& type, const std::string& id)
    {
      return GetSpoofTxAntennaResultPtr(new GetSpoofTxAntennaResult(relatedCommand, gain, type, id));
    }

    GetSpoofTxAntennaResultPtr GetSpoofTxAntennaResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxAntennaResult>(ptr);
    }

    bool GetSpoofTxAntennaResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::vector<double>>>::is_valid(m_values["Gain"])
          && parse_json<Sdx::AntennaPatternType>::is_valid(m_values["Type"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxAntennaResult::documentation() const { return Documentation; }


    std::vector<std::vector<double>> GetSpoofTxAntennaResult::gain() const
    {
      return parse_json<std::vector<std::vector<double>>>::parse(m_values["Gain"]);
    }

    void GetSpoofTxAntennaResult::setGain(const std::vector<std::vector<double>>& gain)
    {
      m_values.AddMember("Gain", parse_json<std::vector<std::vector<double>>>::format(gain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::AntennaPatternType GetSpoofTxAntennaResult::type() const
    {
      return parse_json<Sdx::AntennaPatternType>::parse(m_values["Type"]);
    }

    void GetSpoofTxAntennaResult::setType(const Sdx::AntennaPatternType& type)
    {
      m_values.AddMember("Type", parse_json<Sdx::AntennaPatternType>::format(type, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxAntennaResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxAntennaResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxAntennaOffset
///
#include "gen/SetSpoofTxAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxAntennaOffset::CmdName = "SetSpoofTxAntennaOffset";
    const char* const SetSpoofTxAntennaOffset::Documentation = "Set antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the transmitter trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxAntennaOffset);


    SetSpoofTxAntennaOffset::SetSpoofTxAntennaOffset()
      : CommandBase(CmdName)
    {}

    SetSpoofTxAntennaOffset::SetSpoofTxAntennaOffset(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandBase(CmdName)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    SetSpoofTxAntennaOffsetPtr SetSpoofTxAntennaOffset::create(double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return SetSpoofTxAntennaOffsetPtr(new SetSpoofTxAntennaOffset(x, y, z, yaw, pitch, roll, id));
    }

    SetSpoofTxAntennaOffsetPtr SetSpoofTxAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxAntennaOffset>(ptr);
    }

    bool SetSpoofTxAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxAntennaOffset::documentation() const { return Documentation; }


    int SetSpoofTxAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    double SetSpoofTxAntennaOffset::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void SetSpoofTxAntennaOffset::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void SetSpoofTxAntennaOffset::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void SetSpoofTxAntennaOffset::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void SetSpoofTxAntennaOffset::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void SetSpoofTxAntennaOffset::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSpoofTxAntennaOffset::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void SetSpoofTxAntennaOffset::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxAntennaOffset::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxAntennaOffset::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxAntennaOffset
///
#include "gen/GetSpoofTxAntennaOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxAntennaOffset::CmdName = "GetSpoofTxAntennaOffset";
    const char* const GetSpoofTxAntennaOffset::Documentation = "Get antenna offset and orientation relative to body frame.\nThe origin of the body frame follows the transmitter trajectory.\nWhen the body yaw/pitch/roll are zeros, the body X-axis is pointing north\n                         Y-axis is pointing east\n                         Z-axis is pointing down\nThe antenna Yaw is rotating around Z-axis. Pitch is rotating around Y-axis and\nthe Roll is rotating arond the X-axis of the body frame.";

    REGISTER_COMMAND_FACTORY(GetSpoofTxAntennaOffset);


    GetSpoofTxAntennaOffset::GetSpoofTxAntennaOffset()
      : CommandBase(CmdName)
    {}

    GetSpoofTxAntennaOffset::GetSpoofTxAntennaOffset(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxAntennaOffsetPtr GetSpoofTxAntennaOffset::create(const std::string& id)
    {
      return GetSpoofTxAntennaOffsetPtr(new GetSpoofTxAntennaOffset(id));
    }

    GetSpoofTxAntennaOffsetPtr GetSpoofTxAntennaOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxAntennaOffset>(ptr);
    }

    bool GetSpoofTxAntennaOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxAntennaOffset::documentation() const { return Documentation; }


    int GetSpoofTxAntennaOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxAntennaOffset::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxAntennaOffset::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxAntennaOffsetResult
///
#include "gen/GetSpoofTxAntennaOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxAntennaOffsetResult::CmdName = "GetSpoofTxAntennaOffsetResult";
    const char* const GetSpoofTxAntennaOffsetResult::Documentation = "Result of GetSpoofTxAntennaOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxAntennaOffsetResult);


    GetSpoofTxAntennaOffsetResult::GetSpoofTxAntennaOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxAntennaOffsetResult::GetSpoofTxAntennaOffsetResult(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setX(x);
      setY(y);
      setZ(z);
      setYaw(yaw);
      setPitch(pitch);
      setRoll(roll);
      setId(id);
    }


    GetSpoofTxAntennaOffsetResultPtr GetSpoofTxAntennaOffsetResult::create(CommandBasePtr relatedCommand, double x, double y, double z, double yaw, double pitch, double roll, const std::string& id)
    {
      return GetSpoofTxAntennaOffsetResultPtr(new GetSpoofTxAntennaOffsetResult(relatedCommand, x, y, z, yaw, pitch, roll, id));
    }

    GetSpoofTxAntennaOffsetResultPtr GetSpoofTxAntennaOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxAntennaOffsetResult>(ptr);
    }

    bool GetSpoofTxAntennaOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["X"])
          && parse_json<double>::is_valid(m_values["Y"])
          && parse_json<double>::is_valid(m_values["Z"])
          && parse_json<double>::is_valid(m_values["Yaw"])
          && parse_json<double>::is_valid(m_values["Pitch"])
          && parse_json<double>::is_valid(m_values["Roll"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxAntennaOffsetResult::documentation() const { return Documentation; }


    double GetSpoofTxAntennaOffsetResult::x() const
    {
      return parse_json<double>::parse(m_values["X"]);
    }

    void GetSpoofTxAntennaOffsetResult::setX(double x)
    {
      m_values.AddMember("X", parse_json<double>::format(x, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::y() const
    {
      return parse_json<double>::parse(m_values["Y"]);
    }

    void GetSpoofTxAntennaOffsetResult::setY(double y)
    {
      m_values.AddMember("Y", parse_json<double>::format(y, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::z() const
    {
      return parse_json<double>::parse(m_values["Z"]);
    }

    void GetSpoofTxAntennaOffsetResult::setZ(double z)
    {
      m_values.AddMember("Z", parse_json<double>::format(z, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::yaw() const
    {
      return parse_json<double>::parse(m_values["Yaw"]);
    }

    void GetSpoofTxAntennaOffsetResult::setYaw(double yaw)
    {
      m_values.AddMember("Yaw", parse_json<double>::format(yaw, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::pitch() const
    {
      return parse_json<double>::parse(m_values["Pitch"]);
    }

    void GetSpoofTxAntennaOffsetResult::setPitch(double pitch)
    {
      m_values.AddMember("Pitch", parse_json<double>::format(pitch, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSpoofTxAntennaOffsetResult::roll() const
    {
      return parse_json<double>::parse(m_values["Roll"]);
    }

    void GetSpoofTxAntennaOffsetResult::setRoll(double roll)
    {
      m_values.AddMember("Roll", parse_json<double>::format(roll, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxAntennaOffsetResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxAntennaOffsetResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxRemoteAddress
///
#include "gen/SetSpoofTxRemoteAddress.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxRemoteAddress::CmdName = "SetSpoofTxRemoteAddress";
    const char* const SetSpoofTxRemoteAddress::Documentation = "Set the address of the spoofer instance that will\ngenerate the signal for this spoofer transmitter.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxRemoteAddress);


    SetSpoofTxRemoteAddress::SetSpoofTxRemoteAddress()
      : CommandBase(CmdName)
    {}

    SetSpoofTxRemoteAddress::SetSpoofTxRemoteAddress(const std::string& address, int instanceId, const std::string& id)
      : CommandBase(CmdName)
    {

      setAddress(address);
      setInstanceId(instanceId);
      setId(id);
    }


    SetSpoofTxRemoteAddressPtr SetSpoofTxRemoteAddress::create(const std::string& address, int instanceId, const std::string& id)
    {
      return SetSpoofTxRemoteAddressPtr(new SetSpoofTxRemoteAddress(address, instanceId, id));
    }

    SetSpoofTxRemoteAddressPtr SetSpoofTxRemoteAddress::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxRemoteAddress>(ptr);
    }

    bool SetSpoofTxRemoteAddress::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<int>::is_valid(m_values["InstanceId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxRemoteAddress::documentation() const { return Documentation; }


    int SetSpoofTxRemoteAddress::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSpoofTxRemoteAddress::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void SetSpoofTxRemoteAddress::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSpoofTxRemoteAddress::instanceId() const
    {
      return parse_json<int>::parse(m_values["InstanceId"]);
    }

    void SetSpoofTxRemoteAddress::setInstanceId(int instanceId)
    {
      m_values.AddMember("InstanceId", parse_json<int>::format(instanceId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxRemoteAddress::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxRemoteAddress::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxRemoteAddress
///
#include "gen/GetSpoofTxRemoteAddress.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxRemoteAddress::CmdName = "GetSpoofTxRemoteAddress";
    const char* const GetSpoofTxRemoteAddress::Documentation = "Get the address of the spoofer instance that will\ngenerate the signal for this spoofer transmitter.";

    REGISTER_COMMAND_FACTORY(GetSpoofTxRemoteAddress);


    GetSpoofTxRemoteAddress::GetSpoofTxRemoteAddress()
      : CommandBase(CmdName)
    {}

    GetSpoofTxRemoteAddress::GetSpoofTxRemoteAddress(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetSpoofTxRemoteAddressPtr GetSpoofTxRemoteAddress::create(const std::string& id)
    {
      return GetSpoofTxRemoteAddressPtr(new GetSpoofTxRemoteAddress(id));
    }

    GetSpoofTxRemoteAddressPtr GetSpoofTxRemoteAddress::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxRemoteAddress>(ptr);
    }

    bool GetSpoofTxRemoteAddress::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxRemoteAddress::documentation() const { return Documentation; }


    int GetSpoofTxRemoteAddress::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSpoofTxRemoteAddress::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxRemoteAddress::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSpoofTxRemoteAddressResult
///
#include "gen/GetSpoofTxRemoteAddressResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSpoofTxRemoteAddressResult::CmdName = "GetSpoofTxRemoteAddressResult";
    const char* const GetSpoofTxRemoteAddressResult::Documentation = "Result of GetSpoofTxRemoteAddress";

    REGISTER_COMMAND_RESULT_FACTORY(GetSpoofTxRemoteAddressResult);


    GetSpoofTxRemoteAddressResult::GetSpoofTxRemoteAddressResult()
      : CommandResult(CmdName)
    {}

    GetSpoofTxRemoteAddressResult::GetSpoofTxRemoteAddressResult(CommandBasePtr relatedCommand, const std::string& address, int instanceId, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setAddress(address);
      setInstanceId(instanceId);
      setId(id);
    }


    GetSpoofTxRemoteAddressResultPtr GetSpoofTxRemoteAddressResult::create(CommandBasePtr relatedCommand, const std::string& address, int instanceId, const std::string& id)
    {
      return GetSpoofTxRemoteAddressResultPtr(new GetSpoofTxRemoteAddressResult(relatedCommand, address, instanceId, id));
    }

    GetSpoofTxRemoteAddressResultPtr GetSpoofTxRemoteAddressResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSpoofTxRemoteAddressResult>(ptr);
    }

    bool GetSpoofTxRemoteAddressResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Address"])
          && parse_json<int>::is_valid(m_values["InstanceId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetSpoofTxRemoteAddressResult::documentation() const { return Documentation; }


    std::string GetSpoofTxRemoteAddressResult::address() const
    {
      return parse_json<std::string>::parse(m_values["Address"]);
    }

    void GetSpoofTxRemoteAddressResult::setAddress(const std::string& address)
    {
      m_values.AddMember("Address", parse_json<std::string>::format(address, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSpoofTxRemoteAddressResult::instanceId() const
    {
      return parse_json<int>::parse(m_values["InstanceId"]);
    }

    void GetSpoofTxRemoteAddressResult::setInstanceId(int instanceId)
    {
      m_values.AddMember("InstanceId", parse_json<int>::format(instanceId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSpoofTxRemoteAddressResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetSpoofTxRemoteAddressResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxRefPower
///
#include "gen/SetSpoofTxRefPower.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxRefPower::CmdName = "SetSpoofTxRefPower";
    const char* const SetSpoofTxRefPower::Documentation = "Set the spoofing transmitter reference power.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxRefPower);


    SetSpoofTxRefPower::SetSpoofTxRefPower()
      : CommandBase(CmdName)
    {}

    SetSpoofTxRefPower::SetSpoofTxRefPower(double power, const std::string& id)
      : CommandBase(CmdName)
    {

      setPower(power);
      setId(id);
    }


    SetSpoofTxRefPowerPtr SetSpoofTxRefPower::create(double power, const std::string& id)
    {
      return SetSpoofTxRefPowerPtr(new SetSpoofTxRefPower(power, id));
    }

    SetSpoofTxRefPowerPtr SetSpoofTxRefPower::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxRefPower>(ptr);
    }

    bool SetSpoofTxRefPower::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["Power"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxRefPower::documentation() const { return Documentation; }


    int SetSpoofTxRefPower::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    double SetSpoofTxRefPower::power() const
    {
      return parse_json<double>::parse(m_values["Power"]);
    }

    void SetSpoofTxRefPower::setPower(double power)
    {
      m_values.AddMember("Power", parse_json<double>::format(power, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxRefPower::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxRefPower::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearSpoofTxGpuIdx
///
#include "gen/ClearSpoofTxGpuIdx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearSpoofTxGpuIdx::CmdName = "ClearSpoofTxGpuIdx";
    const char* const ClearSpoofTxGpuIdx::Documentation = "Reset the spoofer's signal GPU index to default.";

    REGISTER_COMMAND_FACTORY(ClearSpoofTxGpuIdx);


    ClearSpoofTxGpuIdx::ClearSpoofTxGpuIdx()
      : CommandBase(CmdName)
    {}

    ClearSpoofTxGpuIdx::ClearSpoofTxGpuIdx(int signalId, const std::string& id)
      : CommandBase(CmdName)
    {

      setSignalId(signalId);
      setId(id);
    }


    ClearSpoofTxGpuIdxPtr ClearSpoofTxGpuIdx::create(int signalId, const std::string& id)
    {
      return ClearSpoofTxGpuIdxPtr(new ClearSpoofTxGpuIdx(signalId, id));
    }

    ClearSpoofTxGpuIdxPtr ClearSpoofTxGpuIdx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearSpoofTxGpuIdx>(ptr);
    }

    bool ClearSpoofTxGpuIdx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SignalId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string ClearSpoofTxGpuIdx::documentation() const { return Documentation; }


    int ClearSpoofTxGpuIdx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ClearSpoofTxGpuIdx::signalId() const
    {
      return parse_json<int>::parse(m_values["SignalId"]);
    }

    void ClearSpoofTxGpuIdx::setSignalId(int signalId)
    {
      m_values.AddMember("SignalId", parse_json<int>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string ClearSpoofTxGpuIdx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void ClearSpoofTxGpuIdx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSpoofTxGpuIdx
///
#include "gen/SetSpoofTxGpuIdx.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSpoofTxGpuIdx::CmdName = "SetSpoofTxGpuIdx";
    const char* const SetSpoofTxGpuIdx::Documentation = "Set the GPU index on which this spoofer signal will be modulated.";

    REGISTER_COMMAND_FACTORY(SetSpoofTxGpuIdx);


    SetSpoofTxGpuIdx::SetSpoofTxGpuIdx()
      : CommandBase(CmdName)
    {}

    SetSpoofTxGpuIdx::SetSpoofTxGpuIdx(int gpuIdx, int signalId, const std::string& id)
      : CommandBase(CmdName)
    {

      setGpuIdx(gpuIdx);
      setSignalId(signalId);
      setId(id);
    }


    SetSpoofTxGpuIdxPtr SetSpoofTxGpuIdx::create(int gpuIdx, int signalId, const std::string& id)
    {
      return SetSpoofTxGpuIdxPtr(new SetSpoofTxGpuIdx(gpuIdx, signalId, id));
    }

    SetSpoofTxGpuIdxPtr SetSpoofTxGpuIdx::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSpoofTxGpuIdx>(ptr);
    }

    bool SetSpoofTxGpuIdx::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["GpuIdx"])
          && parse_json<int>::is_valid(m_values["SignalId"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetSpoofTxGpuIdx::documentation() const { return Documentation; }


    int SetSpoofTxGpuIdx::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetSpoofTxGpuIdx::gpuIdx() const
    {
      return parse_json<int>::parse(m_values["GpuIdx"]);
    }

    void SetSpoofTxGpuIdx::setGpuIdx(int gpuIdx)
    {
      m_values.AddMember("GpuIdx", parse_json<int>::format(gpuIdx, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSpoofTxGpuIdx::signalId() const
    {
      return parse_json<int>::parse(m_values["SignalId"]);
    }

    void SetSpoofTxGpuIdx::setSignalId(int signalId)
    {
      m_values.AddMember("SignalId", parse_json<int>::format(signalId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSpoofTxGpuIdx::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetSpoofTxGpuIdx::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetExternalChannelsPath
///
#include "gen/SetExternalChannelsPath.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetExternalChannelsPath::CmdName = "SetExternalChannelsPath";
    const char* const SetExternalChannelsPath::Documentation = "Set external channels path.";

    REGISTER_COMMAND_FACTORY(SetExternalChannelsPath);


    SetExternalChannelsPath::SetExternalChannelsPath()
      : CommandBase(CmdName)
    {}

    SetExternalChannelsPath::SetExternalChannelsPath(const std::string& path)
      : CommandBase(CmdName)
    {

      setPath(path);
    }


    SetExternalChannelsPathPtr SetExternalChannelsPath::create(const std::string& path)
    {
      return SetExternalChannelsPathPtr(new SetExternalChannelsPath(path));
    }

    SetExternalChannelsPathPtr SetExternalChannelsPath::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetExternalChannelsPath>(ptr);
    }

    bool SetExternalChannelsPath::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Path"])
        ;

    }

    std::string SetExternalChannelsPath::documentation() const { return Documentation; }


    int SetExternalChannelsPath::executePermission() const
    {
      return EXECUTE_IF_NO_CONFIG | EXECUTE_IF_IDLE;
    }


    std::string SetExternalChannelsPath::path() const
    {
      return parse_json<std::string>::parse(m_values["Path"]);
    }

    void SetExternalChannelsPath::setPath(const std::string& path)
    {
      m_values.AddMember("Path", parse_json<std::string>::format(path, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVIDsOfPrn
///
#include "gen/GetSVIDsOfPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVIDsOfPrn::CmdName = "GetSVIDsOfPrn";
    const char* const GetSVIDsOfPrn::Documentation = "Mapping PRN to the corresponding SV ID. Get a list of SV IDs based on a specific signal. Accepted signal keys: \"GPS_L1_CA\", \"GPS_L1C\", \"GPS_L2C\", \"GPS_L5\", \"GLONASS_G1\", \"GLONASS_G2\", \"GALILEO_E1\", \"GALILEO_E5a\", \"GALILEO_E5b\", \"GALILEO_E6\", \"BEIDOU_B1\", \"BEIDOU_B2\", \"BEIDOU_B1C\", \"BEIDOU_B2a\", \"SBAS_L1\", \"SBAS_L5\", \"QZSS_L1_CA\", \"QZSS_L1C\", \"QZSS_L5\", \"QZSS_L1S\", \"QZSS_L5S\", \"NAVIC_L5\", \"CS1\", \"CS2\", \"CS3\", \"CS4\", \"CS5\", \"CS6\", \"CS7\", \"CS8\", \"SIGNAL_COUNT\"";

    REGISTER_COMMAND_FACTORY(GetSVIDsOfPrn);


    GetSVIDsOfPrn::GetSVIDsOfPrn()
      : CommandBase(CmdName)
    {}

    GetSVIDsOfPrn::GetSVIDsOfPrn(const std::string& signal, int prn)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setPrn(prn);
    }


    GetSVIDsOfPrnPtr GetSVIDsOfPrn::create(const std::string& signal, int prn)
    {
      return GetSVIDsOfPrnPtr(new GetSVIDsOfPrn(signal, prn));
    }

    GetSVIDsOfPrnPtr GetSVIDsOfPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVIDsOfPrn>(ptr);
    }

    bool GetSVIDsOfPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetSVIDsOfPrn::documentation() const { return Documentation; }


    int GetSVIDsOfPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSVIDsOfPrn::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetSVIDsOfPrn::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVIDsOfPrn::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSVIDsOfPrn::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVIDsOfPrnResult
///
#include "gen/GetSVIDsOfPrnResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVIDsOfPrnResult::CmdName = "GetSVIDsOfPrnResult";
    const char* const GetSVIDsOfPrnResult::Documentation = "Result of GetSVIDsOfPrn";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVIDsOfPrnResult);


    GetSVIDsOfPrnResult::GetSVIDsOfPrnResult()
      : CommandResult(CmdName)
    {}

    GetSVIDsOfPrnResult::GetSVIDsOfPrnResult(CommandBasePtr relatedCommand, const std::string& signal, int prn, const std::vector<int>& svIdList)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setPrn(prn);
      setSvIdList(svIdList);
    }


    GetSVIDsOfPrnResultPtr GetSVIDsOfPrnResult::create(CommandBasePtr relatedCommand, const std::string& signal, int prn, const std::vector<int>& svIdList)
    {
      return GetSVIDsOfPrnResultPtr(new GetSVIDsOfPrnResult(relatedCommand, signal, prn, svIdList));
    }

    GetSVIDsOfPrnResultPtr GetSVIDsOfPrnResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVIDsOfPrnResult>(ptr);
    }

    bool GetSVIDsOfPrnResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::vector<int>>::is_valid(m_values["SvIdList"])
        ;

    }

    std::string GetSVIDsOfPrnResult::documentation() const { return Documentation; }


    std::string GetSVIDsOfPrnResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetSVIDsOfPrnResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSVIDsOfPrnResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSVIDsOfPrnResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<int> GetSVIDsOfPrnResult::svIdList() const
    {
      return parse_json<std::vector<int>>::parse(m_values["SvIdList"]);
    }

    void GetSVIDsOfPrnResult::setSvIdList(const std::vector<int>& svIdList)
    {
      m_values.AddMember("SvIdList", parse_json<std::vector<int>>::format(svIdList, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssL1SAugmentation
///
#include "gen/SetQzssL1SAugmentation.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssL1SAugmentation::CmdName = "SetQzssL1SAugmentation";
    const char* const SetQzssL1SAugmentation::Documentation = "Set Add an augmentation to the L1S navigation messages.";

    REGISTER_COMMAND_FACTORY(SetQzssL1SAugmentation);


    SetQzssL1SAugmentation::SetQzssL1SAugmentation()
      : CommandBase(CmdName)
    {}

    SetQzssL1SAugmentation::SetQzssL1SAugmentation(const std::string& system, int prn, bool augmentIOD, bool augmentPRC, double prc, const std::string& id)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setAugmentIOD(augmentIOD);
      setAugmentPRC(augmentPRC);
      setPrc(prc);
      setId(id);
    }


    SetQzssL1SAugmentationPtr SetQzssL1SAugmentation::create(const std::string& system, int prn, bool augmentIOD, bool augmentPRC, double prc, const std::string& id)
    {
      return SetQzssL1SAugmentationPtr(new SetQzssL1SAugmentation(system, prn, augmentIOD, augmentPRC, prc, id));
    }

    SetQzssL1SAugmentationPtr SetQzssL1SAugmentation::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssL1SAugmentation>(ptr);
    }

    bool SetQzssL1SAugmentation::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["AugmentIOD"])
          && parse_json<bool>::is_valid(m_values["AugmentPRC"])
          && parse_json<double>::is_valid(m_values["Prc"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetQzssL1SAugmentation::documentation() const { return Documentation; }


    int SetQzssL1SAugmentation::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetQzssL1SAugmentation::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetQzssL1SAugmentation::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetQzssL1SAugmentation::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetQzssL1SAugmentation::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL1SAugmentation::augmentIOD() const
    {
      return parse_json<bool>::parse(m_values["AugmentIOD"]);
    }

    void SetQzssL1SAugmentation::setAugmentIOD(bool augmentIOD)
    {
      m_values.AddMember("AugmentIOD", parse_json<bool>::format(augmentIOD, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssL1SAugmentation::augmentPRC() const
    {
      return parse_json<bool>::parse(m_values["AugmentPRC"]);
    }

    void SetQzssL1SAugmentation::setAugmentPRC(bool augmentPRC)
    {
      m_values.AddMember("AugmentPRC", parse_json<bool>::format(augmentPRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssL1SAugmentation::prc() const
    {
      return parse_json<double>::parse(m_values["Prc"]);
    }

    void SetQzssL1SAugmentation::setPrc(double prc)
    {
      m_values.AddMember("Prc", parse_json<double>::format(prc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetQzssL1SAugmentation::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetQzssL1SAugmentation::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1SAugmentation
///
#include "gen/GetQzssL1SAugmentation.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SAugmentation::CmdName = "GetQzssL1SAugmentation";
    const char* const GetQzssL1SAugmentation::Documentation = "Get Add an augmentation to the L1S navigation messages.";

    REGISTER_COMMAND_FACTORY(GetQzssL1SAugmentation);


    GetQzssL1SAugmentation::GetQzssL1SAugmentation()
      : CommandBase(CmdName)
    {}

    GetQzssL1SAugmentation::GetQzssL1SAugmentation(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetQzssL1SAugmentationPtr GetQzssL1SAugmentation::create(const std::string& id)
    {
      return GetQzssL1SAugmentationPtr(new GetQzssL1SAugmentation(id));
    }

    GetQzssL1SAugmentationPtr GetQzssL1SAugmentation::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SAugmentation>(ptr);
    }

    bool GetQzssL1SAugmentation::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetQzssL1SAugmentation::documentation() const { return Documentation; }


    int GetQzssL1SAugmentation::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssL1SAugmentation::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetQzssL1SAugmentation::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1SAugmentationResult
///
#include "gen/GetQzssL1SAugmentationResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SAugmentationResult::CmdName = "GetQzssL1SAugmentationResult";
    const char* const GetQzssL1SAugmentationResult::Documentation = "Result of GetQzssL1SAugmentation";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1SAugmentationResult);


    GetQzssL1SAugmentationResult::GetQzssL1SAugmentationResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1SAugmentationResult::GetQzssL1SAugmentationResult(CommandBasePtr relatedCommand, const std::string& system, int prn, bool augmentIOD, bool augmentPRC, double prc, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setAugmentIOD(augmentIOD);
      setAugmentPRC(augmentPRC);
      setPrc(prc);
      setId(id);
    }


    GetQzssL1SAugmentationResultPtr GetQzssL1SAugmentationResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, bool augmentIOD, bool augmentPRC, double prc, const std::string& id)
    {
      return GetQzssL1SAugmentationResultPtr(new GetQzssL1SAugmentationResult(relatedCommand, system, prn, augmentIOD, augmentPRC, prc, id));
    }

    GetQzssL1SAugmentationResultPtr GetQzssL1SAugmentationResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SAugmentationResult>(ptr);
    }

    bool GetQzssL1SAugmentationResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["AugmentIOD"])
          && parse_json<bool>::is_valid(m_values["AugmentPRC"])
          && parse_json<double>::is_valid(m_values["Prc"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetQzssL1SAugmentationResult::documentation() const { return Documentation; }


    std::string GetQzssL1SAugmentationResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetQzssL1SAugmentationResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssL1SAugmentationResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetQzssL1SAugmentationResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL1SAugmentationResult::augmentIOD() const
    {
      return parse_json<bool>::parse(m_values["AugmentIOD"]);
    }

    void GetQzssL1SAugmentationResult::setAugmentIOD(bool augmentIOD)
    {
      m_values.AddMember("AugmentIOD", parse_json<bool>::format(augmentIOD, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL1SAugmentationResult::augmentPRC() const
    {
      return parse_json<bool>::parse(m_values["AugmentPRC"]);
    }

    void GetQzssL1SAugmentationResult::setAugmentPRC(bool augmentPRC)
    {
      m_values.AddMember("AugmentPRC", parse_json<bool>::format(augmentPRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssL1SAugmentationResult::prc() const
    {
      return parse_json<double>::parse(m_values["Prc"]);
    }

    void GetQzssL1SAugmentationResult::setPrc(double prc)
    {
      m_values.AddMember("Prc", parse_json<double>::format(prc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssL1SAugmentationResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetQzssL1SAugmentationResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveQzssL1SAugmentation
///
#include "gen/RemoveQzssL1SAugmentation.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveQzssL1SAugmentation::CmdName = "RemoveQzssL1SAugmentation";
    const char* const RemoveQzssL1SAugmentation::Documentation = "Removes a QZSS L1S augmentation.";

    REGISTER_COMMAND_FACTORY(RemoveQzssL1SAugmentation);


    RemoveQzssL1SAugmentation::RemoveQzssL1SAugmentation()
      : CommandBase(CmdName)
    {}

    RemoveQzssL1SAugmentation::RemoveQzssL1SAugmentation(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveQzssL1SAugmentationPtr RemoveQzssL1SAugmentation::create(const std::string& id)
    {
      return RemoveQzssL1SAugmentationPtr(new RemoveQzssL1SAugmentation(id));
    }

    RemoveQzssL1SAugmentationPtr RemoveQzssL1SAugmentation::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveQzssL1SAugmentation>(ptr);
    }

    bool RemoveQzssL1SAugmentation::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveQzssL1SAugmentation::documentation() const { return Documentation; }


    int RemoveQzssL1SAugmentation::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveQzssL1SAugmentation::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveQzssL1SAugmentation::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearQzssL1SAugmentations
///
#include "gen/ClearQzssL1SAugmentations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearQzssL1SAugmentations::CmdName = "ClearQzssL1SAugmentations";
    const char* const ClearQzssL1SAugmentations::Documentation = "Clears all QZSS L1S augmentations.";

    REGISTER_COMMAND_FACTORY(ClearQzssL1SAugmentations);


    ClearQzssL1SAugmentations::ClearQzssL1SAugmentations()
      : CommandBase(CmdName)
    {

    }


    ClearQzssL1SAugmentationsPtr ClearQzssL1SAugmentations::create()
    {
      return ClearQzssL1SAugmentationsPtr(new ClearQzssL1SAugmentations());
    }

    ClearQzssL1SAugmentationsPtr ClearQzssL1SAugmentations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearQzssL1SAugmentations>(ptr);
    }

    bool ClearQzssL1SAugmentations::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearQzssL1SAugmentations::documentation() const { return Documentation; }


    int ClearQzssL1SAugmentations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetQzssL1SAugmentations
///
#include "gen/GetQzssL1SAugmentations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SAugmentations::CmdName = "GetQzssL1SAugmentations";
    const char* const GetQzssL1SAugmentations::Documentation = "Get all QZSS L1S augmentation's IDs.";

    REGISTER_COMMAND_FACTORY(GetQzssL1SAugmentations);


    GetQzssL1SAugmentations::GetQzssL1SAugmentations()
      : CommandBase(CmdName)
    {

    }


    GetQzssL1SAugmentationsPtr GetQzssL1SAugmentations::create()
    {
      return GetQzssL1SAugmentationsPtr(new GetQzssL1SAugmentations());
    }

    GetQzssL1SAugmentationsPtr GetQzssL1SAugmentations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SAugmentations>(ptr);
    }

    bool GetQzssL1SAugmentations::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetQzssL1SAugmentations::documentation() const { return Documentation; }


    int GetQzssL1SAugmentations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetQzssL1SAugmentationsResult
///
#include "gen/GetQzssL1SAugmentationsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SAugmentationsResult::CmdName = "GetQzssL1SAugmentationsResult";
    const char* const GetQzssL1SAugmentationsResult::Documentation = "Result of GetQzssL1SAugmentations";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1SAugmentationsResult);


    GetQzssL1SAugmentationsResult::GetQzssL1SAugmentationsResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1SAugmentationsResult::GetQzssL1SAugmentationsResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetQzssL1SAugmentationsResultPtr GetQzssL1SAugmentationsResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetQzssL1SAugmentationsResultPtr(new GetQzssL1SAugmentationsResult(relatedCommand, ids));
    }

    GetQzssL1SAugmentationsResultPtr GetQzssL1SAugmentationsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SAugmentationsResult>(ptr);
    }

    bool GetQzssL1SAugmentationsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetQzssL1SAugmentationsResult::documentation() const { return Documentation; }


    std::vector<std::string> GetQzssL1SAugmentationsResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetQzssL1SAugmentationsResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetWavefrontJamCalibrationState
///
#include "gen/SetWavefrontJamCalibrationState.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetWavefrontJamCalibrationState::CmdName = "SetWavefrontJamCalibrationState";
    const char* const SetWavefrontJamCalibrationState::Documentation = "Set whether the JAM Calibration output is transmitting.";

    REGISTER_COMMAND_FACTORY(SetWavefrontJamCalibrationState);


    SetWavefrontJamCalibrationState::SetWavefrontJamCalibrationState()
      : CommandBase(CmdName)
    {}

    SetWavefrontJamCalibrationState::SetWavefrontJamCalibrationState(bool state)
      : CommandBase(CmdName)
    {

      setState(state);
    }


    SetWavefrontJamCalibrationStatePtr SetWavefrontJamCalibrationState::create(bool state)
    {
      return SetWavefrontJamCalibrationStatePtr(new SetWavefrontJamCalibrationState(state));
    }

    SetWavefrontJamCalibrationStatePtr SetWavefrontJamCalibrationState::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetWavefrontJamCalibrationState>(ptr);
    }

    bool SetWavefrontJamCalibrationState::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<bool>::is_valid(m_values["State"])
        ;

    }

    std::string SetWavefrontJamCalibrationState::documentation() const { return Documentation; }


    int SetWavefrontJamCalibrationState::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    bool SetWavefrontJamCalibrationState::state() const
    {
      return parse_json<bool>::parse(m_values["State"]);
    }

    void SetWavefrontJamCalibrationState::setState(bool state)
    {
      m_values.AddMember("State", parse_json<bool>::format(state, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssSatMotionFixed
///
#include "gen/SetQzssSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssSatMotionFixed::CmdName = "SetQzssSatMotionFixed";
    const char* const SetQzssSatMotionFixed::Documentation = "Please note the command QzssSatMotionFixed is deprecated since 20.9. You may use SatMotionFixed.\n\nIf IsFixed is set to true, the satellite will not move during the simulation and keep its initial position calculated at the beginning of the simulation.";

    REGISTER_COMMAND_FACTORY(SetQzssSatMotionFixed);


    SetQzssSatMotionFixed::SetQzssSatMotionFixed()
      : CommandBase(CmdName)
    {}

    SetQzssSatMotionFixed::SetQzssSatMotionFixed(int svId, bool isFixed)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setIsFixed(isFixed);
    }


    SetQzssSatMotionFixedPtr SetQzssSatMotionFixed::create(int svId, bool isFixed)
    {
      return SetQzssSatMotionFixedPtr(new SetQzssSatMotionFixed(svId, isFixed));
    }

    SetQzssSatMotionFixedPtr SetQzssSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssSatMotionFixed>(ptr);
    }

    bool SetQzssSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string SetQzssSatMotionFixed::documentation() const { return Documentation; }


    int SetQzssSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssSatMotionFixed::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssSatMotionFixed::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetQzssSatMotionFixed::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void SetQzssSatMotionFixed::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsQzssSatMotionFixed
///
#include "gen/IsQzssSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsQzssSatMotionFixed::CmdName = "IsQzssSatMotionFixed";
    const char* const IsQzssSatMotionFixed::Documentation = "Please note the command QzssSatMotionFixed is deprecated since 20.9. You may use SatMotionFixed.\n\nTells if the satellite is fixed (True) or not fixed (false).";

    REGISTER_COMMAND_FACTORY(IsQzssSatMotionFixed);


    IsQzssSatMotionFixed::IsQzssSatMotionFixed()
      : CommandBase(CmdName)
    {}

    IsQzssSatMotionFixed::IsQzssSatMotionFixed(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    IsQzssSatMotionFixedPtr IsQzssSatMotionFixed::create(int svId)
    {
      return IsQzssSatMotionFixedPtr(new IsQzssSatMotionFixed(svId));
    }

    IsQzssSatMotionFixedPtr IsQzssSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsQzssSatMotionFixed>(ptr);
    }

    bool IsQzssSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string IsQzssSatMotionFixed::documentation() const { return Documentation; }


    int IsQzssSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int IsQzssSatMotionFixed::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsQzssSatMotionFixed::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsQzssSatMotionFixedResult
///
#include "gen/IsQzssSatMotionFixedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsQzssSatMotionFixedResult::CmdName = "IsQzssSatMotionFixedResult";
    const char* const IsQzssSatMotionFixedResult::Documentation = "Result of IsQzssSatMotionFixed";

    REGISTER_COMMAND_RESULT_FACTORY(IsQzssSatMotionFixedResult);


    IsQzssSatMotionFixedResult::IsQzssSatMotionFixedResult()
      : CommandResult(CmdName)
    {}

    IsQzssSatMotionFixedResult::IsQzssSatMotionFixedResult(CommandBasePtr relatedCommand, int svId, bool isFixed)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setIsFixed(isFixed);
    }


    IsQzssSatMotionFixedResultPtr IsQzssSatMotionFixedResult::create(CommandBasePtr relatedCommand, int svId, bool isFixed)
    {
      return IsQzssSatMotionFixedResultPtr(new IsQzssSatMotionFixedResult(relatedCommand, svId, isFixed));
    }

    IsQzssSatMotionFixedResultPtr IsQzssSatMotionFixedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsQzssSatMotionFixedResult>(ptr);
    }

    bool IsQzssSatMotionFixedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string IsQzssSatMotionFixedResult::documentation() const { return Documentation; }


    int IsQzssSatMotionFixedResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void IsQzssSatMotionFixedResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsQzssSatMotionFixedResult::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void IsQzssSatMotionFixedResult::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssEphemerisReferenceTime
///
#include "gen/SetQzssEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssEphemerisReferenceTime::CmdName = "SetQzssEphemerisReferenceTime";
    const char* const SetQzssEphemerisReferenceTime::Documentation = "Please note the command QzssEphemerisReferenceTime is deprecated since 20.9. You may use EphemerisReferenceTimeForSV.\n\nSet the QZSS ephemeris reference time";

    REGISTER_COMMAND_FACTORY(SetQzssEphemerisReferenceTime);


    SetQzssEphemerisReferenceTime::SetQzssEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    SetQzssEphemerisReferenceTime::SetQzssEphemerisReferenceTime(int svId, const Sdx::DateTime& time)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setTime(time);
    }


    SetQzssEphemerisReferenceTimePtr SetQzssEphemerisReferenceTime::create(int svId, const Sdx::DateTime& time)
    {
      return SetQzssEphemerisReferenceTimePtr(new SetQzssEphemerisReferenceTime(svId, time));
    }

    SetQzssEphemerisReferenceTimePtr SetQzssEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssEphemerisReferenceTime>(ptr);
    }

    bool SetQzssEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string SetQzssEphemerisReferenceTime::documentation() const { return Documentation; }


    int SetQzssEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssEphemerisReferenceTime::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssEphemerisReferenceTime::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetQzssEphemerisReferenceTime::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void SetQzssEphemerisReferenceTime::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisReferenceTime
///
#include "gen/GetQzssEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisReferenceTime::CmdName = "GetQzssEphemerisReferenceTime";
    const char* const GetQzssEphemerisReferenceTime::Documentation = "Please note the command QzssEphemerisReferenceTime is deprecated since 20.9. You may use EphemerisReferenceTimeForSV.\n\nGet the QZSS ephemeris reference time";

    REGISTER_COMMAND_FACTORY(GetQzssEphemerisReferenceTime);


    GetQzssEphemerisReferenceTime::GetQzssEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    GetQzssEphemerisReferenceTime::GetQzssEphemerisReferenceTime(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssEphemerisReferenceTimePtr GetQzssEphemerisReferenceTime::create(int svId)
    {
      return GetQzssEphemerisReferenceTimePtr(new GetQzssEphemerisReferenceTime(svId));
    }

    GetQzssEphemerisReferenceTimePtr GetQzssEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisReferenceTime>(ptr);
    }

    bool GetQzssEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssEphemerisReferenceTime::documentation() const { return Documentation; }


    int GetQzssEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssEphemerisReferenceTime::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphemerisReferenceTime::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssEphemerisReferenceTimeResult
///
#include "gen/GetQzssEphemerisReferenceTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssEphemerisReferenceTimeResult::CmdName = "GetQzssEphemerisReferenceTimeResult";
    const char* const GetQzssEphemerisReferenceTimeResult::Documentation = "Result of GetQzssEphemerisReferenceTime";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssEphemerisReferenceTimeResult);


    GetQzssEphemerisReferenceTimeResult::GetQzssEphemerisReferenceTimeResult()
      : CommandResult(CmdName)
    {}

    GetQzssEphemerisReferenceTimeResult::GetQzssEphemerisReferenceTimeResult(CommandBasePtr relatedCommand, int svId, const Sdx::DateTime& time)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setTime(time);
    }


    GetQzssEphemerisReferenceTimeResultPtr GetQzssEphemerisReferenceTimeResult::create(CommandBasePtr relatedCommand, int svId, const Sdx::DateTime& time)
    {
      return GetQzssEphemerisReferenceTimeResultPtr(new GetQzssEphemerisReferenceTimeResult(relatedCommand, svId, time));
    }

    GetQzssEphemerisReferenceTimeResultPtr GetQzssEphemerisReferenceTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssEphemerisReferenceTimeResult>(ptr);
    }

    bool GetQzssEphemerisReferenceTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string GetQzssEphemerisReferenceTimeResult::documentation() const { return Documentation; }


    int GetQzssEphemerisReferenceTimeResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssEphemerisReferenceTimeResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime GetQzssEphemerisReferenceTimeResult::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void GetQzssEphemerisReferenceTimeResult::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssPerturbations
///
#include "gen/SetQzssPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssPerturbations::CmdName = "SetQzssPerturbations";
    const char* const SetQzssPerturbations::Documentation = "Please note the command QzssPerturbations is deprecated since 20.9. You may use Perturbations.\n\nSet QZSS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc)";

    REGISTER_COMMAND_FACTORY(SetQzssPerturbations);


    SetQzssPerturbations::SetQzssPerturbations()
      : CommandBase(CmdName)
    {}

    SetQzssPerturbations::SetQzssPerturbations(int svId, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetQzssPerturbationsPtr SetQzssPerturbations::create(int svId, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return SetQzssPerturbationsPtr(new SetQzssPerturbations(svId, crs, crc, cis, cic, cus, cuc));
    }

    SetQzssPerturbationsPtr SetQzssPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssPerturbations>(ptr);
    }

    bool SetQzssPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetQzssPerturbations::documentation() const { return Documentation; }


    int SetQzssPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetQzssPerturbations::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetQzssPerturbations::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssPerturbations::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void SetQzssPerturbations::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssPerturbations::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void SetQzssPerturbations::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssPerturbations::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void SetQzssPerturbations::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssPerturbations::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void SetQzssPerturbations::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssPerturbations::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void SetQzssPerturbations::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetQzssPerturbations::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void SetQzssPerturbations::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssPerturbations
///
#include "gen/GetQzssPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssPerturbations::CmdName = "GetQzssPerturbations";
    const char* const GetQzssPerturbations::Documentation = "Please note the command QzssPerturbations is deprecated since 20.9. You may use Perturbations.\n\nGet QZSS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc)";

    REGISTER_COMMAND_FACTORY(GetQzssPerturbations);


    GetQzssPerturbations::GetQzssPerturbations()
      : CommandBase(CmdName)
    {}

    GetQzssPerturbations::GetQzssPerturbations(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssPerturbationsPtr GetQzssPerturbations::create(int svId)
    {
      return GetQzssPerturbationsPtr(new GetQzssPerturbations(svId));
    }

    GetQzssPerturbationsPtr GetQzssPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssPerturbations>(ptr);
    }

    bool GetQzssPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssPerturbations::documentation() const { return Documentation; }


    int GetQzssPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssPerturbations::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssPerturbations::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssPerturbationsResult
///
#include "gen/GetQzssPerturbationsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssPerturbationsResult::CmdName = "GetQzssPerturbationsResult";
    const char* const GetQzssPerturbationsResult::Documentation = "Result of GetQzssPerturbations";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssPerturbationsResult);


    GetQzssPerturbationsResult::GetQzssPerturbationsResult()
      : CommandResult(CmdName)
    {}

    GetQzssPerturbationsResult::GetQzssPerturbationsResult(CommandBasePtr relatedCommand, int svId, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetQzssPerturbationsResultPtr GetQzssPerturbationsResult::create(CommandBasePtr relatedCommand, int svId, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return GetQzssPerturbationsResultPtr(new GetQzssPerturbationsResult(relatedCommand, svId, crs, crc, cis, cic, cus, cuc));
    }

    GetQzssPerturbationsResultPtr GetQzssPerturbationsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssPerturbationsResult>(ptr);
    }

    bool GetQzssPerturbationsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetQzssPerturbationsResult::documentation() const { return Documentation; }


    int GetQzssPerturbationsResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssPerturbationsResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssPerturbationsResult::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void GetQzssPerturbationsResult::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssPerturbationsResult::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void GetQzssPerturbationsResult::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssPerturbationsResult::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void GetQzssPerturbationsResult::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssPerturbationsResult::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void GetQzssPerturbationsResult::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssPerturbationsResult::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void GetQzssPerturbationsResult::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetQzssPerturbationsResult::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void GetQzssPerturbationsResult::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetQzssPerturbationsForAllSat
///
#include "gen/SetQzssPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetQzssPerturbationsForAllSat::CmdName = "SetQzssPerturbationsForAllSat";
    const char* const SetQzssPerturbationsForAllSat::Documentation = "Please note the command QzssPerturbationsForAllSat is deprecated since 20.9. You may use PerturbationsForAllSat.\n\nSet QZSS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites.\nAll parameters are zero based index (index 0 => SV ID 1, index 1 => SV ID 2, etc)";

    REGISTER_COMMAND_FACTORY(SetQzssPerturbationsForAllSat);


    SetQzssPerturbationsForAllSat::SetQzssPerturbationsForAllSat()
      : CommandBase(CmdName)
    {}

    SetQzssPerturbationsForAllSat::SetQzssPerturbationsForAllSat(const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandBase(CmdName)
    {

      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetQzssPerturbationsForAllSatPtr SetQzssPerturbationsForAllSat::create(const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return SetQzssPerturbationsForAllSatPtr(new SetQzssPerturbationsForAllSat(crs, crc, cis, cic, cus, cuc));
    }

    SetQzssPerturbationsForAllSatPtr SetQzssPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetQzssPerturbationsForAllSat>(ptr);
    }

    bool SetQzssPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetQzssPerturbationsForAllSat::documentation() const { return Documentation; }


    int SetQzssPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<double> SetQzssPerturbationsForAllSat::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void SetQzssPerturbationsForAllSat::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetQzssPerturbationsForAllSat::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void SetQzssPerturbationsForAllSat::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetQzssPerturbationsForAllSat::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void SetQzssPerturbationsForAllSat::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetQzssPerturbationsForAllSat::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void SetQzssPerturbationsForAllSat::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetQzssPerturbationsForAllSat::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void SetQzssPerturbationsForAllSat::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetQzssPerturbationsForAllSat::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void SetQzssPerturbationsForAllSat::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssPerturbationsForAllSat
///
#include "gen/GetQzssPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssPerturbationsForAllSat::CmdName = "GetQzssPerturbationsForAllSat";
    const char* const GetQzssPerturbationsForAllSat::Documentation = "Please note the command QzssPerturbationsForAllSat is deprecated since 20.9. You may use PerturbationsForAllSat.\n\nGet QZSS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites.\nAll parameters are zero based index (index 0 => SV ID 1, index 1 => SV ID 2, etc)";

    REGISTER_COMMAND_FACTORY(GetQzssPerturbationsForAllSat);


    GetQzssPerturbationsForAllSat::GetQzssPerturbationsForAllSat()
      : CommandBase(CmdName)
    {

    }


    GetQzssPerturbationsForAllSatPtr GetQzssPerturbationsForAllSat::create()
    {
      return GetQzssPerturbationsForAllSatPtr(new GetQzssPerturbationsForAllSat());
    }

    GetQzssPerturbationsForAllSatPtr GetQzssPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssPerturbationsForAllSat>(ptr);
    }

    bool GetQzssPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetQzssPerturbationsForAllSat::documentation() const { return Documentation; }


    int GetQzssPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetQzssPerturbationsForAllSatResult
///
#include "gen/GetQzssPerturbationsForAllSatResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssPerturbationsForAllSatResult::CmdName = "GetQzssPerturbationsForAllSatResult";
    const char* const GetQzssPerturbationsForAllSatResult::Documentation = "Result of GetQzssPerturbationsForAllSat";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssPerturbationsForAllSatResult);


    GetQzssPerturbationsForAllSatResult::GetQzssPerturbationsForAllSatResult()
      : CommandResult(CmdName)
    {}

    GetQzssPerturbationsForAllSatResult::GetQzssPerturbationsForAllSatResult(CommandBasePtr relatedCommand, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetQzssPerturbationsForAllSatResultPtr GetQzssPerturbationsForAllSatResult::create(CommandBasePtr relatedCommand, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return GetQzssPerturbationsForAllSatResultPtr(new GetQzssPerturbationsForAllSatResult(relatedCommand, crs, crc, cis, cic, cus, cuc));
    }

    GetQzssPerturbationsForAllSatResultPtr GetQzssPerturbationsForAllSatResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssPerturbationsForAllSatResult>(ptr);
    }

    bool GetQzssPerturbationsForAllSatResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetQzssPerturbationsForAllSatResult::documentation() const { return Documentation; }


    std::vector<double> GetQzssPerturbationsForAllSatResult::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void GetQzssPerturbationsForAllSatResult::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetQzssPerturbationsForAllSatResult::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void GetQzssPerturbationsForAllSatResult::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetQzssPerturbationsForAllSatResult::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void GetQzssPerturbationsForAllSatResult::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetQzssPerturbationsForAllSatResult::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void GetQzssPerturbationsForAllSatResult::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetQzssPerturbationsForAllSatResult::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void GetQzssPerturbationsForAllSatResult::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetQzssPerturbationsForAllSatResult::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void GetQzssPerturbationsForAllSatResult::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetQzssPerturbations
///
#include "gen/ResetQzssPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetQzssPerturbations::CmdName = "ResetQzssPerturbations";
    const char* const ResetQzssPerturbations::Documentation = "Please note the command ResetQzssPerturbations is deprecated since 20.9. You may use ResetPerturbations.\n\nSet QZSS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) to zero";

    REGISTER_COMMAND_FACTORY(ResetQzssPerturbations);


    ResetQzssPerturbations::ResetQzssPerturbations()
      : CommandBase(CmdName)
    {}

    ResetQzssPerturbations::ResetQzssPerturbations(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    ResetQzssPerturbationsPtr ResetQzssPerturbations::create(int svId)
    {
      return ResetQzssPerturbationsPtr(new ResetQzssPerturbations(svId));
    }

    ResetQzssPerturbationsPtr ResetQzssPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetQzssPerturbations>(ptr);
    }

    bool ResetQzssPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string ResetQzssPerturbations::documentation() const { return Documentation; }


    int ResetQzssPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ResetQzssPerturbations::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void ResetQzssPerturbations::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableRF
///
#include "gen/EnableRF.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableRF::CmdName = "EnableRF";
    const char* const EnableRF::Documentation = "Please note the command EnableRF is deprecated since 21.3. You may use EnableRFOutputForSV.\n\nEnable (or disable) RF output for specified satellite PRN. Use PRN 0 to enabled/disable all satellites.";

    REGISTER_COMMAND_FACTORY(EnableRF);


    EnableRF::EnableRF()
      : CommandBase(CmdName)
    {}

    EnableRF::EnableRF(const std::string& system, int prn, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setEnabled(enabled);
    }


    EnableRFPtr EnableRF::create(const std::string& system, int prn, bool enabled)
    {
      return EnableRFPtr(new EnableRF(system, prn, enabled));
    }

    EnableRFPtr EnableRF::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableRF>(ptr);
    }

    bool EnableRF::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableRF::documentation() const { return Documentation; }


    int EnableRF::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableRF::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableRF::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnableRF::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void EnableRF::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableRF::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableRF::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFEnabled
///
#include "gen/IsRFEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFEnabled::CmdName = "IsRFEnabled";
    const char* const IsRFEnabled::Documentation = "Please note the command EnableRF is deprecated since 21.3. You may use EnableRFOutputForSV.\n\nTells if the RF is enabled or disabled for the specified satellite.";

    REGISTER_COMMAND_FACTORY(IsRFEnabled);


    IsRFEnabled::IsRFEnabled()
      : CommandBase(CmdName)
    {}

    IsRFEnabled::IsRFEnabled(const std::string& system, int prn)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
    }


    IsRFEnabledPtr IsRFEnabled::create(const std::string& system, int prn)
    {
      return IsRFEnabledPtr(new IsRFEnabled(system, prn));
    }

    IsRFEnabledPtr IsRFEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFEnabled>(ptr);
    }

    bool IsRFEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string IsRFEnabled::documentation() const { return Documentation; }


    int IsRFEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsRFEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsRFEnabled::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsRFEnabled::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsRFEnabledResult
///
#include "gen/IsRFEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsRFEnabledResult::CmdName = "IsRFEnabledResult";
    const char* const IsRFEnabledResult::Documentation = "Result of IsRFEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsRFEnabledResult);


    IsRFEnabledResult::IsRFEnabledResult()
      : CommandResult(CmdName)
    {}

    IsRFEnabledResult::IsRFEnabledResult(CommandBasePtr relatedCommand, const std::string& system, int prn, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setEnabled(enabled);
    }


    IsRFEnabledResultPtr IsRFEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, bool enabled)
    {
      return IsRFEnabledResultPtr(new IsRFEnabledResult(relatedCommand, system, prn, enabled));
    }

    IsRFEnabledResultPtr IsRFEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsRFEnabledResult>(ptr);
    }

    bool IsRFEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsRFEnabledResult::documentation() const { return Documentation; }


    std::string IsRFEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsRFEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsRFEnabledResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsRFEnabledResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsRFEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsRFEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableRFForEachPrn
///
#include "gen/EnableRFForEachPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableRFForEachPrn::CmdName = "EnableRFForEachPrn";
    const char* const EnableRFForEachPrn::Documentation = "Please note the command EnableRFForEachPrn is deprecated since 21.3. You may use EnableRFOutputForEachSV.\n\nEnable (or disable) RF for each satellite individually.";

    REGISTER_COMMAND_FACTORY(EnableRFForEachPrn);


    EnableRFForEachPrn::EnableRFForEachPrn()
      : CommandBase(CmdName)
    {}

    EnableRFForEachPrn::EnableRFForEachPrn(const std::string& system, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    EnableRFForEachPrnPtr EnableRFForEachPrn::create(const std::string& system, const std::vector<bool>& enabled)
    {
      return EnableRFForEachPrnPtr(new EnableRFForEachPrn(system, enabled));
    }

    EnableRFForEachPrnPtr EnableRFForEachPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableRFForEachPrn>(ptr);
    }

    bool EnableRFForEachPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableRFForEachPrn::documentation() const { return Documentation; }


    int EnableRFForEachPrn::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableRFForEachPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableRFForEachPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableRFForEachPrn::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableRFForEachPrn::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetRFEnabledForEachPrn
///
#include "gen/GetRFEnabledForEachPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetRFEnabledForEachPrn::CmdName = "GetRFEnabledForEachPrn";
    const char* const GetRFEnabledForEachPrn::Documentation = "Please note the command EnableRFForEachPrn is deprecated since 21.3. You may use EnableRFOutputForEachSV.\n\nTells if the RF is enabled or disabled for each satellite.";

    REGISTER_COMMAND_FACTORY(GetRFEnabledForEachPrn);


    GetRFEnabledForEachPrn::GetRFEnabledForEachPrn()
      : CommandBase(CmdName)
    {}

    GetRFEnabledForEachPrn::GetRFEnabledForEachPrn(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetRFEnabledForEachPrnPtr GetRFEnabledForEachPrn::create(const std::string& system)
    {
      return GetRFEnabledForEachPrnPtr(new GetRFEnabledForEachPrn(system));
    }

    GetRFEnabledForEachPrnPtr GetRFEnabledForEachPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetRFEnabledForEachPrn>(ptr);
    }

    bool GetRFEnabledForEachPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetRFEnabledForEachPrn::documentation() const { return Documentation; }


    int GetRFEnabledForEachPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetRFEnabledForEachPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetRFEnabledForEachPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetRFEnabledForEachPrnResult
///
#include "gen/GetRFEnabledForEachPrnResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetRFEnabledForEachPrnResult::CmdName = "GetRFEnabledForEachPrnResult";
    const char* const GetRFEnabledForEachPrnResult::Documentation = "Result of GetRFEnabledForEachPrn";

    REGISTER_COMMAND_RESULT_FACTORY(GetRFEnabledForEachPrnResult);


    GetRFEnabledForEachPrnResult::GetRFEnabledForEachPrnResult()
      : CommandResult(CmdName)
    {}

    GetRFEnabledForEachPrnResult::GetRFEnabledForEachPrnResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    GetRFEnabledForEachPrnResultPtr GetRFEnabledForEachPrnResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
    {
      return GetRFEnabledForEachPrnResultPtr(new GetRFEnabledForEachPrnResult(relatedCommand, system, enabled));
    }

    GetRFEnabledForEachPrnResultPtr GetRFEnabledForEachPrnResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetRFEnabledForEachPrnResult>(ptr);
    }

    bool GetRFEnabledForEachPrnResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string GetRFEnabledForEachPrnResult::documentation() const { return Documentation; }


    std::string GetRFEnabledForEachPrnResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetRFEnabledForEachPrnResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetRFEnabledForEachPrnResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetRFEnabledForEachPrnResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSignal
///
#include "gen/EnableSignal.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSignal::CmdName = "EnableSignal";
    const char* const EnableSignal::Documentation = "Please note the command EnableSignal is deprecated since 21.3. You may use EnableSignalForSV.\n\nEnable (or disable) signal for specified satellite. Use PRN 0 to enabled/disable all satellites.\nQZSS uses SVID instead of PRN.\nAllowed signal keys: \"L1CA\", \"L1C\", \"L1P\", \"L1M\", \"L2C\", \"L2P\", \"L2M\", \"L5\",\n                     \"G1\", \"G2\", \"E1\", \"E5a\", \"E5b\", \"B1\", \"B2\", \"B1C\", \"B2a\",\n                     \"SBAS\", \"QZSSL1CA\", \"QZSSL1C\", \"QZSSL5\", \"QZSSL1S\", \"QZSSL5S\",\n                     \"NAVICL5\"";

    REGISTER_COMMAND_FACTORY(EnableSignal);


    EnableSignal::EnableSignal()
      : CommandBase(CmdName)
    {}

    EnableSignal::EnableSignal(int prn, const std::string& signal, bool enabled)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSignal(signal);
      setEnabled(enabled);
    }


    EnableSignalPtr EnableSignal::create(int prn, const std::string& signal, bool enabled)
    {
      return EnableSignalPtr(new EnableSignal(prn, signal, enabled));
    }

    EnableSignalPtr EnableSignal::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSignal>(ptr);
    }

    bool EnableSignal::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSignal::documentation() const { return Documentation; }


    int EnableSignal::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int EnableSignal::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void EnableSignal::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableSignal::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnableSignal::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableSignal::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableSignal::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabled
///
#include "gen/IsSignalEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabled::CmdName = "IsSignalEnabled";
    const char* const IsSignalEnabled::Documentation = "Please note the command EnableSignal is deprecated since 21.3. You may use EnableSignalForSV.\n\nTells if the signal is enabled or disabled. See EnableSignal description for allowed signals.";

    REGISTER_COMMAND_FACTORY(IsSignalEnabled);


    IsSignalEnabled::IsSignalEnabled()
      : CommandBase(CmdName)
    {}

    IsSignalEnabled::IsSignalEnabled(int prn, const std::string& signal)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSignal(signal);
    }


    IsSignalEnabledPtr IsSignalEnabled::create(int prn, const std::string& signal)
    {
      return IsSignalEnabledPtr(new IsSignalEnabled(prn, signal));
    }

    IsSignalEnabledPtr IsSignalEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabled>(ptr);
    }

    bool IsSignalEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string IsSignalEnabled::documentation() const { return Documentation; }


    int IsSignalEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int IsSignalEnabled::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsSignalEnabled::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsSignalEnabled::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabled::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSignalEnabledResult
///
#include "gen/IsSignalEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSignalEnabledResult::CmdName = "IsSignalEnabledResult";
    const char* const IsSignalEnabledResult::Documentation = "Result of IsSignalEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsSignalEnabledResult);


    IsSignalEnabledResult::IsSignalEnabledResult()
      : CommandResult(CmdName)
    {}

    IsSignalEnabledResult::IsSignalEnabledResult(CommandBasePtr relatedCommand, int prn, const std::string& signal, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setSignal(signal);
      setEnabled(enabled);
    }


    IsSignalEnabledResultPtr IsSignalEnabledResult::create(CommandBasePtr relatedCommand, int prn, const std::string& signal, bool enabled)
    {
      return IsSignalEnabledResultPtr(new IsSignalEnabledResult(relatedCommand, prn, signal, enabled));
    }

    IsSignalEnabledResultPtr IsSignalEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSignalEnabledResult>(ptr);
    }

    bool IsSignalEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsSignalEnabledResult::documentation() const { return Documentation; }


    int IsSignalEnabledResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsSignalEnabledResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsSignalEnabledResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsSignalEnabledResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSignalEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsSignalEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableSignalForEachPrn
///
#include "gen/EnableSignalForEachPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableSignalForEachPrn::CmdName = "EnableSignalForEachPrn";
    const char* const EnableSignalForEachPrn::Documentation = "Please note the command EnableSignalForEachPrn is deprecated since 21.3. You may use EnableSignalForEachSV.\n\nEnable (or disable) signal for each satellite individually.\nAllowed signal keys: \"L1CA\", \"L1C\", \"L1P\", \"L1M\", \"L2C\", \"L2P\", \"L2M\", \"L5\",\n                     \"G1\", \"G2\", \"E1\", \"E5a\", \"E5b\", \"B1\", \"B2\", \"B1C\", \"B2a\",\n                     \"SBASL1\", \"QZSSL1CA\", \"QZSSL1C\", \"QZSSL5\", \"QZSSL1S\", \"QZSSL5S\",\n                     \"NAVICL5\"";

    REGISTER_COMMAND_FACTORY(EnableSignalForEachPrn);


    EnableSignalForEachPrn::EnableSignalForEachPrn()
      : CommandBase(CmdName)
    {}

    EnableSignalForEachPrn::EnableSignalForEachPrn(const std::string& signal, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    EnableSignalForEachPrnPtr EnableSignalForEachPrn::create(const std::string& signal, const std::vector<bool>& enabled)
    {
      return EnableSignalForEachPrnPtr(new EnableSignalForEachPrn(signal, enabled));
    }

    EnableSignalForEachPrnPtr EnableSignalForEachPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableSignalForEachPrn>(ptr);
    }

    bool EnableSignalForEachPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableSignalForEachPrn::documentation() const { return Documentation; }


    int EnableSignalForEachPrn::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableSignalForEachPrn::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnableSignalForEachPrn::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableSignalForEachPrn::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableSignalForEachPrn::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSignalEnabledForEachPrn
///
#include "gen/GetSignalEnabledForEachPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSignalEnabledForEachPrn::CmdName = "GetSignalEnabledForEachPrn";
    const char* const GetSignalEnabledForEachPrn::Documentation = "Please note the command EnableSignalForEachPrn is deprecated since 21.3. You may use EnableSignalForEachSV.\n\nTells if the signal is enabled or disabled for each satellite. See EnableSignalForEachPrn description for allowed signals.";

    REGISTER_COMMAND_FACTORY(GetSignalEnabledForEachPrn);


    GetSignalEnabledForEachPrn::GetSignalEnabledForEachPrn()
      : CommandBase(CmdName)
    {}

    GetSignalEnabledForEachPrn::GetSignalEnabledForEachPrn(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetSignalEnabledForEachPrnPtr GetSignalEnabledForEachPrn::create(const std::string& signal)
    {
      return GetSignalEnabledForEachPrnPtr(new GetSignalEnabledForEachPrn(signal));
    }

    GetSignalEnabledForEachPrnPtr GetSignalEnabledForEachPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSignalEnabledForEachPrn>(ptr);
    }

    bool GetSignalEnabledForEachPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetSignalEnabledForEachPrn::documentation() const { return Documentation; }


    int GetSignalEnabledForEachPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSignalEnabledForEachPrn::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetSignalEnabledForEachPrn::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSignalEnabledForEachPrnResult
///
#include "gen/GetSignalEnabledForEachPrnResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSignalEnabledForEachPrnResult::CmdName = "GetSignalEnabledForEachPrnResult";
    const char* const GetSignalEnabledForEachPrnResult::Documentation = "Result of GetSignalEnabledForEachPrn";

    REGISTER_COMMAND_RESULT_FACTORY(GetSignalEnabledForEachPrnResult);


    GetSignalEnabledForEachPrnResult::GetSignalEnabledForEachPrnResult()
      : CommandResult(CmdName)
    {}

    GetSignalEnabledForEachPrnResult::GetSignalEnabledForEachPrnResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    GetSignalEnabledForEachPrnResultPtr GetSignalEnabledForEachPrnResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
    {
      return GetSignalEnabledForEachPrnResultPtr(new GetSignalEnabledForEachPrnResult(relatedCommand, signal, enabled));
    }

    GetSignalEnabledForEachPrnResultPtr GetSignalEnabledForEachPrnResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSignalEnabledForEachPrnResult>(ptr);
    }

    bool GetSignalEnabledForEachPrnResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string GetSignalEnabledForEachPrnResult::documentation() const { return Documentation; }


    std::string GetSignalEnabledForEachPrnResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetSignalEnabledForEachPrnResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetSignalEnabledForEachPrnResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetSignalEnabledForEachPrnResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatMotionFixed
///
#include "gen/SetGpsSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatMotionFixed::CmdName = "SetGpsSatMotionFixed";
    const char* const SetGpsSatMotionFixed::Documentation = "Please note the command GpsSatMotionFixed is deprecated since 21.3. You may use SatMotionFixed.\n\nIf IsFixed is set to true, the satellite will not move during the simulation and keep its initial position calculated at the beginning of the simulation.";

    REGISTER_COMMAND_FACTORY(SetGpsSatMotionFixed);


    SetGpsSatMotionFixed::SetGpsSatMotionFixed()
      : CommandBase(CmdName)
    {}

    SetGpsSatMotionFixed::SetGpsSatMotionFixed(int prn, bool isFixed)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setIsFixed(isFixed);
    }


    SetGpsSatMotionFixedPtr SetGpsSatMotionFixed::create(int prn, bool isFixed)
    {
      return SetGpsSatMotionFixedPtr(new SetGpsSatMotionFixed(prn, isFixed));
    }

    SetGpsSatMotionFixedPtr SetGpsSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatMotionFixed>(ptr);
    }

    bool SetGpsSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string SetGpsSatMotionFixed::documentation() const { return Documentation; }


    int SetGpsSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsSatMotionFixed::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatMotionFixed::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsSatMotionFixed::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void SetGpsSatMotionFixed::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsGpsSatMotionFixed
///
#include "gen/IsGpsSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsGpsSatMotionFixed::CmdName = "IsGpsSatMotionFixed";
    const char* const IsGpsSatMotionFixed::Documentation = "Please note the command GpsSatMotionFixed is deprecated since 21.3. You may use SatMotionFixed.\n\nTells if the satellite is fixed (True) or not fixed (false).";

    REGISTER_COMMAND_FACTORY(IsGpsSatMotionFixed);


    IsGpsSatMotionFixed::IsGpsSatMotionFixed()
      : CommandBase(CmdName)
    {}

    IsGpsSatMotionFixed::IsGpsSatMotionFixed(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    IsGpsSatMotionFixedPtr IsGpsSatMotionFixed::create(int prn)
    {
      return IsGpsSatMotionFixedPtr(new IsGpsSatMotionFixed(prn));
    }

    IsGpsSatMotionFixedPtr IsGpsSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsGpsSatMotionFixed>(ptr);
    }

    bool IsGpsSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string IsGpsSatMotionFixed::documentation() const { return Documentation; }


    int IsGpsSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int IsGpsSatMotionFixed::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsGpsSatMotionFixed::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsGpsSatMotionFixedResult
///
#include "gen/IsGpsSatMotionFixedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsGpsSatMotionFixedResult::CmdName = "IsGpsSatMotionFixedResult";
    const char* const IsGpsSatMotionFixedResult::Documentation = "Result of IsGpsSatMotionFixed";

    REGISTER_COMMAND_RESULT_FACTORY(IsGpsSatMotionFixedResult);


    IsGpsSatMotionFixedResult::IsGpsSatMotionFixedResult()
      : CommandResult(CmdName)
    {}

    IsGpsSatMotionFixedResult::IsGpsSatMotionFixedResult(CommandBasePtr relatedCommand, int prn, bool isFixed)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setIsFixed(isFixed);
    }


    IsGpsSatMotionFixedResultPtr IsGpsSatMotionFixedResult::create(CommandBasePtr relatedCommand, int prn, bool isFixed)
    {
      return IsGpsSatMotionFixedResultPtr(new IsGpsSatMotionFixedResult(relatedCommand, prn, isFixed));
    }

    IsGpsSatMotionFixedResultPtr IsGpsSatMotionFixedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsGpsSatMotionFixedResult>(ptr);
    }

    bool IsGpsSatMotionFixedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string IsGpsSatMotionFixedResult::documentation() const { return Documentation; }


    int IsGpsSatMotionFixedResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsGpsSatMotionFixedResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsGpsSatMotionFixedResult::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void IsGpsSatMotionFixedResult::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSatMotionFixed
///
#include "gen/SetGalileoSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSatMotionFixed::CmdName = "SetGalileoSatMotionFixed";
    const char* const SetGalileoSatMotionFixed::Documentation = "Please note the command GalileoSatMotionFixed is deprecated since 21.3. You may use SatMotionFixed.\n\nIf IsFixed is set to true, the satellite will not move during the simulation and keep its initial position calculated at the beginning of the simulation.";

    REGISTER_COMMAND_FACTORY(SetGalileoSatMotionFixed);


    SetGalileoSatMotionFixed::SetGalileoSatMotionFixed()
      : CommandBase(CmdName)
    {}

    SetGalileoSatMotionFixed::SetGalileoSatMotionFixed(int prn, bool isFixed)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setIsFixed(isFixed);
    }


    SetGalileoSatMotionFixedPtr SetGalileoSatMotionFixed::create(int prn, bool isFixed)
    {
      return SetGalileoSatMotionFixedPtr(new SetGalileoSatMotionFixed(prn, isFixed));
    }

    SetGalileoSatMotionFixedPtr SetGalileoSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSatMotionFixed>(ptr);
    }

    bool SetGalileoSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string SetGalileoSatMotionFixed::documentation() const { return Documentation; }


    int SetGalileoSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGalileoSatMotionFixed::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoSatMotionFixed::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGalileoSatMotionFixed::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void SetGalileoSatMotionFixed::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsGalileoSatMotionFixed
///
#include "gen/IsGalileoSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsGalileoSatMotionFixed::CmdName = "IsGalileoSatMotionFixed";
    const char* const IsGalileoSatMotionFixed::Documentation = "Please note the command GalileoSatMotionFixed is deprecated since 21.3. You may use SatMotionFixed.\n\nTells if the satellite is fixed (True) or not fixed (false).";

    REGISTER_COMMAND_FACTORY(IsGalileoSatMotionFixed);


    IsGalileoSatMotionFixed::IsGalileoSatMotionFixed()
      : CommandBase(CmdName)
    {}

    IsGalileoSatMotionFixed::IsGalileoSatMotionFixed(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    IsGalileoSatMotionFixedPtr IsGalileoSatMotionFixed::create(int prn)
    {
      return IsGalileoSatMotionFixedPtr(new IsGalileoSatMotionFixed(prn));
    }

    IsGalileoSatMotionFixedPtr IsGalileoSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsGalileoSatMotionFixed>(ptr);
    }

    bool IsGalileoSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string IsGalileoSatMotionFixed::documentation() const { return Documentation; }


    int IsGalileoSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int IsGalileoSatMotionFixed::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsGalileoSatMotionFixed::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsGalileoSatMotionFixedResult
///
#include "gen/IsGalileoSatMotionFixedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsGalileoSatMotionFixedResult::CmdName = "IsGalileoSatMotionFixedResult";
    const char* const IsGalileoSatMotionFixedResult::Documentation = "Result of IsGalileoSatMotionFixed";

    REGISTER_COMMAND_RESULT_FACTORY(IsGalileoSatMotionFixedResult);


    IsGalileoSatMotionFixedResult::IsGalileoSatMotionFixedResult()
      : CommandResult(CmdName)
    {}

    IsGalileoSatMotionFixedResult::IsGalileoSatMotionFixedResult(CommandBasePtr relatedCommand, int prn, bool isFixed)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setIsFixed(isFixed);
    }


    IsGalileoSatMotionFixedResultPtr IsGalileoSatMotionFixedResult::create(CommandBasePtr relatedCommand, int prn, bool isFixed)
    {
      return IsGalileoSatMotionFixedResultPtr(new IsGalileoSatMotionFixedResult(relatedCommand, prn, isFixed));
    }

    IsGalileoSatMotionFixedResultPtr IsGalileoSatMotionFixedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsGalileoSatMotionFixedResult>(ptr);
    }

    bool IsGalileoSatMotionFixedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string IsGalileoSatMotionFixedResult::documentation() const { return Documentation; }


    int IsGalileoSatMotionFixedResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsGalileoSatMotionFixedResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsGalileoSatMotionFixedResult::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void IsGalileoSatMotionFixedResult::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouSatMotionFixed
///
#include "gen/SetBeiDouSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouSatMotionFixed::CmdName = "SetBeiDouSatMotionFixed";
    const char* const SetBeiDouSatMotionFixed::Documentation = "Please note the command BeiDouSatMotionFixed is deprecated since 21.3. You may use SatMotionFixed.\n\nIf IsFixed is set to true, the satellite will not move during the simulation and keep its initial position calculated at the beginning of the simulation.";

    REGISTER_COMMAND_FACTORY(SetBeiDouSatMotionFixed);


    SetBeiDouSatMotionFixed::SetBeiDouSatMotionFixed()
      : CommandBase(CmdName)
    {}

    SetBeiDouSatMotionFixed::SetBeiDouSatMotionFixed(int prn, bool isFixed)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setIsFixed(isFixed);
    }


    SetBeiDouSatMotionFixedPtr SetBeiDouSatMotionFixed::create(int prn, bool isFixed)
    {
      return SetBeiDouSatMotionFixedPtr(new SetBeiDouSatMotionFixed(prn, isFixed));
    }

    SetBeiDouSatMotionFixedPtr SetBeiDouSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouSatMotionFixed>(ptr);
    }

    bool SetBeiDouSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string SetBeiDouSatMotionFixed::documentation() const { return Documentation; }


    int SetBeiDouSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetBeiDouSatMotionFixed::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouSatMotionFixed::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetBeiDouSatMotionFixed::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void SetBeiDouSatMotionFixed::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsBeiDouSatMotionFixed
///
#include "gen/IsBeiDouSatMotionFixed.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsBeiDouSatMotionFixed::CmdName = "IsBeiDouSatMotionFixed";
    const char* const IsBeiDouSatMotionFixed::Documentation = "Please note the command BeiDouSatMotionFixed is deprecated since 21.3. You may use SatMotionFixed.\n\nTells if the satellite is fixed (True) or not fixed (false).";

    REGISTER_COMMAND_FACTORY(IsBeiDouSatMotionFixed);


    IsBeiDouSatMotionFixed::IsBeiDouSatMotionFixed()
      : CommandBase(CmdName)
    {}

    IsBeiDouSatMotionFixed::IsBeiDouSatMotionFixed(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    IsBeiDouSatMotionFixedPtr IsBeiDouSatMotionFixed::create(int prn)
    {
      return IsBeiDouSatMotionFixedPtr(new IsBeiDouSatMotionFixed(prn));
    }

    IsBeiDouSatMotionFixedPtr IsBeiDouSatMotionFixed::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsBeiDouSatMotionFixed>(ptr);
    }

    bool IsBeiDouSatMotionFixed::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string IsBeiDouSatMotionFixed::documentation() const { return Documentation; }


    int IsBeiDouSatMotionFixed::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int IsBeiDouSatMotionFixed::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsBeiDouSatMotionFixed::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsBeiDouSatMotionFixedResult
///
#include "gen/IsBeiDouSatMotionFixedResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsBeiDouSatMotionFixedResult::CmdName = "IsBeiDouSatMotionFixedResult";
    const char* const IsBeiDouSatMotionFixedResult::Documentation = "Result of IsBeiDouSatMotionFixed";

    REGISTER_COMMAND_RESULT_FACTORY(IsBeiDouSatMotionFixedResult);


    IsBeiDouSatMotionFixedResult::IsBeiDouSatMotionFixedResult()
      : CommandResult(CmdName)
    {}

    IsBeiDouSatMotionFixedResult::IsBeiDouSatMotionFixedResult(CommandBasePtr relatedCommand, int prn, bool isFixed)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setIsFixed(isFixed);
    }


    IsBeiDouSatMotionFixedResultPtr IsBeiDouSatMotionFixedResult::create(CommandBasePtr relatedCommand, int prn, bool isFixed)
    {
      return IsBeiDouSatMotionFixedResultPtr(new IsBeiDouSatMotionFixedResult(relatedCommand, prn, isFixed));
    }

    IsBeiDouSatMotionFixedResultPtr IsBeiDouSatMotionFixedResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsBeiDouSatMotionFixedResult>(ptr);
    }

    bool IsBeiDouSatMotionFixedResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["IsFixed"])
        ;

    }

    std::string IsBeiDouSatMotionFixedResult::documentation() const { return Documentation; }


    int IsBeiDouSatMotionFixedResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsBeiDouSatMotionFixedResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsBeiDouSatMotionFixedResult::isFixed() const
    {
      return parse_json<bool>::parse(m_values["IsFixed"]);
    }

    void IsBeiDouSatMotionFixedResult::setIsFixed(bool isFixed)
    {
      m_values.AddMember("IsFixed", parse_json<bool>::format(isFixed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphemerisReferenceTime
///
#include "gen/SetGpsEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphemerisReferenceTime::CmdName = "SetGpsEphemerisReferenceTime";
    const char* const SetGpsEphemerisReferenceTime::Documentation = "Please note the command GpsEphemerisReferenceTime is deprecated since 21.3. You may use EphemerisReferenceTimeForSV.\n\nSet the GPS ephemeris reference time";

    REGISTER_COMMAND_FACTORY(SetGpsEphemerisReferenceTime);


    SetGpsEphemerisReferenceTime::SetGpsEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    SetGpsEphemerisReferenceTime::SetGpsEphemerisReferenceTime(int prn, const Sdx::DateTime& time)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setTime(time);
    }


    SetGpsEphemerisReferenceTimePtr SetGpsEphemerisReferenceTime::create(int prn, const Sdx::DateTime& time)
    {
      return SetGpsEphemerisReferenceTimePtr(new SetGpsEphemerisReferenceTime(prn, time));
    }

    SetGpsEphemerisReferenceTimePtr SetGpsEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphemerisReferenceTime>(ptr);
    }

    bool SetGpsEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string SetGpsEphemerisReferenceTime::documentation() const { return Documentation; }


    int SetGpsEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsEphemerisReferenceTime::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsEphemerisReferenceTime::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetGpsEphemerisReferenceTime::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void SetGpsEphemerisReferenceTime::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisReferenceTime
///
#include "gen/GetGpsEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisReferenceTime::CmdName = "GetGpsEphemerisReferenceTime";
    const char* const GetGpsEphemerisReferenceTime::Documentation = "Please note the command GpsEphemerisReferenceTime is deprecated since 21.3. You may use EphemerisReferenceTimeForSV.\n\nGet the GPS ephemeris reference time";

    REGISTER_COMMAND_FACTORY(GetGpsEphemerisReferenceTime);


    GetGpsEphemerisReferenceTime::GetGpsEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    GetGpsEphemerisReferenceTime::GetGpsEphemerisReferenceTime(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsEphemerisReferenceTimePtr GetGpsEphemerisReferenceTime::create(int prn)
    {
      return GetGpsEphemerisReferenceTimePtr(new GetGpsEphemerisReferenceTime(prn));
    }

    GetGpsEphemerisReferenceTimePtr GetGpsEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisReferenceTime>(ptr);
    }

    bool GetGpsEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsEphemerisReferenceTime::documentation() const { return Documentation; }


    int GetGpsEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsEphemerisReferenceTime::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsEphemerisReferenceTime::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisReferenceTimeResult
///
#include "gen/GetGpsEphemerisReferenceTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisReferenceTimeResult::CmdName = "GetGpsEphemerisReferenceTimeResult";
    const char* const GetGpsEphemerisReferenceTimeResult::Documentation = "Result of GetGpsEphemerisReferenceTime";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphemerisReferenceTimeResult);


    GetGpsEphemerisReferenceTimeResult::GetGpsEphemerisReferenceTimeResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphemerisReferenceTimeResult::GetGpsEphemerisReferenceTimeResult(CommandBasePtr relatedCommand, int prn, const Sdx::DateTime& time)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setTime(time);
    }


    GetGpsEphemerisReferenceTimeResultPtr GetGpsEphemerisReferenceTimeResult::create(CommandBasePtr relatedCommand, int prn, const Sdx::DateTime& time)
    {
      return GetGpsEphemerisReferenceTimeResultPtr(new GetGpsEphemerisReferenceTimeResult(relatedCommand, prn, time));
    }

    GetGpsEphemerisReferenceTimeResultPtr GetGpsEphemerisReferenceTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisReferenceTimeResult>(ptr);
    }

    bool GetGpsEphemerisReferenceTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string GetGpsEphemerisReferenceTimeResult::documentation() const { return Documentation; }


    int GetGpsEphemerisReferenceTimeResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsEphemerisReferenceTimeResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime GetGpsEphemerisReferenceTimeResult::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void GetGpsEphemerisReferenceTimeResult::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoEphemerisReferenceTime
///
#include "gen/SetGalileoEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoEphemerisReferenceTime::CmdName = "SetGalileoEphemerisReferenceTime";
    const char* const SetGalileoEphemerisReferenceTime::Documentation = "Please note the command GalileoEphemerisReferenceTime is deprecated since 21.3. You may use EphemerisReferenceTimeForSV.\n\nSet the Galileo ephemeris reference time";

    REGISTER_COMMAND_FACTORY(SetGalileoEphemerisReferenceTime);


    SetGalileoEphemerisReferenceTime::SetGalileoEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    SetGalileoEphemerisReferenceTime::SetGalileoEphemerisReferenceTime(int prn, const Sdx::DateTime& time)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setTime(time);
    }


    SetGalileoEphemerisReferenceTimePtr SetGalileoEphemerisReferenceTime::create(int prn, const Sdx::DateTime& time)
    {
      return SetGalileoEphemerisReferenceTimePtr(new SetGalileoEphemerisReferenceTime(prn, time));
    }

    SetGalileoEphemerisReferenceTimePtr SetGalileoEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoEphemerisReferenceTime>(ptr);
    }

    bool SetGalileoEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string SetGalileoEphemerisReferenceTime::documentation() const { return Documentation; }


    int SetGalileoEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGalileoEphemerisReferenceTime::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoEphemerisReferenceTime::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetGalileoEphemerisReferenceTime::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void SetGalileoEphemerisReferenceTime::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphemerisReferenceTime
///
#include "gen/GetGalileoEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphemerisReferenceTime::CmdName = "GetGalileoEphemerisReferenceTime";
    const char* const GetGalileoEphemerisReferenceTime::Documentation = "Please note the command GalileoEphemerisReferenceTime is deprecated since 21.3. You may use EphemerisReferenceTimeForSV.\n\nGet the Galileo ephemeris reference time";

    REGISTER_COMMAND_FACTORY(GetGalileoEphemerisReferenceTime);


    GetGalileoEphemerisReferenceTime::GetGalileoEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    GetGalileoEphemerisReferenceTime::GetGalileoEphemerisReferenceTime(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGalileoEphemerisReferenceTimePtr GetGalileoEphemerisReferenceTime::create(int prn)
    {
      return GetGalileoEphemerisReferenceTimePtr(new GetGalileoEphemerisReferenceTime(prn));
    }

    GetGalileoEphemerisReferenceTimePtr GetGalileoEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphemerisReferenceTime>(ptr);
    }

    bool GetGalileoEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGalileoEphemerisReferenceTime::documentation() const { return Documentation; }


    int GetGalileoEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoEphemerisReferenceTime::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoEphemerisReferenceTime::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphemerisReferenceTimeResult
///
#include "gen/GetGalileoEphemerisReferenceTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphemerisReferenceTimeResult::CmdName = "GetGalileoEphemerisReferenceTimeResult";
    const char* const GetGalileoEphemerisReferenceTimeResult::Documentation = "Result of GetGalileoEphemerisReferenceTime";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoEphemerisReferenceTimeResult);


    GetGalileoEphemerisReferenceTimeResult::GetGalileoEphemerisReferenceTimeResult()
      : CommandResult(CmdName)
    {}

    GetGalileoEphemerisReferenceTimeResult::GetGalileoEphemerisReferenceTimeResult(CommandBasePtr relatedCommand, int prn, const Sdx::DateTime& time)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setTime(time);
    }


    GetGalileoEphemerisReferenceTimeResultPtr GetGalileoEphemerisReferenceTimeResult::create(CommandBasePtr relatedCommand, int prn, const Sdx::DateTime& time)
    {
      return GetGalileoEphemerisReferenceTimeResultPtr(new GetGalileoEphemerisReferenceTimeResult(relatedCommand, prn, time));
    }

    GetGalileoEphemerisReferenceTimeResultPtr GetGalileoEphemerisReferenceTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphemerisReferenceTimeResult>(ptr);
    }

    bool GetGalileoEphemerisReferenceTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string GetGalileoEphemerisReferenceTimeResult::documentation() const { return Documentation; }


    int GetGalileoEphemerisReferenceTimeResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoEphemerisReferenceTimeResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime GetGalileoEphemerisReferenceTimeResult::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void GetGalileoEphemerisReferenceTimeResult::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphemerisReferenceTime
///
#include "gen/SetBeiDouEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphemerisReferenceTime::CmdName = "SetBeiDouEphemerisReferenceTime";
    const char* const SetBeiDouEphemerisReferenceTime::Documentation = "Please note the command BeiDouEphemerisReferenceTime is deprecated since 21.3. You may use EphemerisReferenceTimeForSV.\n\nSet the BeiDou ephemeris reference time";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphemerisReferenceTime);


    SetBeiDouEphemerisReferenceTime::SetBeiDouEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphemerisReferenceTime::SetBeiDouEphemerisReferenceTime(int prn, const Sdx::DateTime& time)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setTime(time);
    }


    SetBeiDouEphemerisReferenceTimePtr SetBeiDouEphemerisReferenceTime::create(int prn, const Sdx::DateTime& time)
    {
      return SetBeiDouEphemerisReferenceTimePtr(new SetBeiDouEphemerisReferenceTime(prn, time));
    }

    SetBeiDouEphemerisReferenceTimePtr SetBeiDouEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphemerisReferenceTime>(ptr);
    }

    bool SetBeiDouEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string SetBeiDouEphemerisReferenceTime::documentation() const { return Documentation; }


    int SetBeiDouEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetBeiDouEphemerisReferenceTime::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouEphemerisReferenceTime::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime SetBeiDouEphemerisReferenceTime::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void SetBeiDouEphemerisReferenceTime::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisReferenceTime
///
#include "gen/GetBeiDouEphemerisReferenceTime.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisReferenceTime::CmdName = "GetBeiDouEphemerisReferenceTime";
    const char* const GetBeiDouEphemerisReferenceTime::Documentation = "Please note the command BeiDouEphemerisReferenceTime is deprecated since 21.3. You may use EphemerisReferenceTimeForSV.\n\nGet the BeiDou ephemeris reference time";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphemerisReferenceTime);


    GetBeiDouEphemerisReferenceTime::GetBeiDouEphemerisReferenceTime()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphemerisReferenceTime::GetBeiDouEphemerisReferenceTime(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouEphemerisReferenceTimePtr GetBeiDouEphemerisReferenceTime::create(int prn)
    {
      return GetBeiDouEphemerisReferenceTimePtr(new GetBeiDouEphemerisReferenceTime(prn));
    }

    GetBeiDouEphemerisReferenceTimePtr GetBeiDouEphemerisReferenceTime::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisReferenceTime>(ptr);
    }

    bool GetBeiDouEphemerisReferenceTime::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouEphemerisReferenceTime::documentation() const { return Documentation; }


    int GetBeiDouEphemerisReferenceTime::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouEphemerisReferenceTime::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouEphemerisReferenceTime::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisReferenceTimeResult
///
#include "gen/GetBeiDouEphemerisReferenceTimeResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisReferenceTimeResult::CmdName = "GetBeiDouEphemerisReferenceTimeResult";
    const char* const GetBeiDouEphemerisReferenceTimeResult::Documentation = "Result of GetBeiDouEphemerisReferenceTime";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphemerisReferenceTimeResult);


    GetBeiDouEphemerisReferenceTimeResult::GetBeiDouEphemerisReferenceTimeResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphemerisReferenceTimeResult::GetBeiDouEphemerisReferenceTimeResult(CommandBasePtr relatedCommand, int prn, const Sdx::DateTime& time)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setTime(time);
    }


    GetBeiDouEphemerisReferenceTimeResultPtr GetBeiDouEphemerisReferenceTimeResult::create(CommandBasePtr relatedCommand, int prn, const Sdx::DateTime& time)
    {
      return GetBeiDouEphemerisReferenceTimeResultPtr(new GetBeiDouEphemerisReferenceTimeResult(relatedCommand, prn, time));
    }

    GetBeiDouEphemerisReferenceTimeResultPtr GetBeiDouEphemerisReferenceTimeResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisReferenceTimeResult>(ptr);
    }

    bool GetBeiDouEphemerisReferenceTimeResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::DateTime>::is_valid(m_values["Time"])
        ;

    }

    std::string GetBeiDouEphemerisReferenceTimeResult::documentation() const { return Documentation; }


    int GetBeiDouEphemerisReferenceTimeResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouEphemerisReferenceTimeResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::DateTime GetBeiDouEphemerisReferenceTimeResult::time() const
    {
      return parse_json<Sdx::DateTime>::parse(m_values["Time"]);
    }

    void GetBeiDouEphemerisReferenceTimeResult::setTime(const Sdx::DateTime& time)
    {
      m_values.AddMember("Time", parse_json<Sdx::DateTime>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetGpsPerturbations
///
#include "gen/ResetGpsPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetGpsPerturbations::CmdName = "ResetGpsPerturbations";
    const char* const ResetGpsPerturbations::Documentation = "Please note the command ResetGpsPerturbations is deprecated since 21.3. You may use ResetPerturbations.\n\nSet GPS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) to zero";

    REGISTER_COMMAND_FACTORY(ResetGpsPerturbations);


    ResetGpsPerturbations::ResetGpsPerturbations()
      : CommandBase(CmdName)
    {}

    ResetGpsPerturbations::ResetGpsPerturbations(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    ResetGpsPerturbationsPtr ResetGpsPerturbations::create(int prn)
    {
      return ResetGpsPerturbationsPtr(new ResetGpsPerturbations(prn));
    }

    ResetGpsPerturbationsPtr ResetGpsPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetGpsPerturbations>(ptr);
    }

    bool ResetGpsPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string ResetGpsPerturbations::documentation() const { return Documentation; }


    int ResetGpsPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ResetGpsPerturbations::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void ResetGpsPerturbations::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetGalileoPerturbations
///
#include "gen/ResetGalileoPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetGalileoPerturbations::CmdName = "ResetGalileoPerturbations";
    const char* const ResetGalileoPerturbations::Documentation = "Please note the command ResetGalileoPerturbations is deprecated since 21.3. You may use ResetPerturbations.\n\nSet Galileo orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) to zero";

    REGISTER_COMMAND_FACTORY(ResetGalileoPerturbations);


    ResetGalileoPerturbations::ResetGalileoPerturbations()
      : CommandBase(CmdName)
    {}

    ResetGalileoPerturbations::ResetGalileoPerturbations(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    ResetGalileoPerturbationsPtr ResetGalileoPerturbations::create(int prn)
    {
      return ResetGalileoPerturbationsPtr(new ResetGalileoPerturbations(prn));
    }

    ResetGalileoPerturbationsPtr ResetGalileoPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetGalileoPerturbations>(ptr);
    }

    bool ResetGalileoPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string ResetGalileoPerturbations::documentation() const { return Documentation; }


    int ResetGalileoPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ResetGalileoPerturbations::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void ResetGalileoPerturbations::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ResetBeiDouPerturbations
///
#include "gen/ResetBeiDouPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ResetBeiDouPerturbations::CmdName = "ResetBeiDouPerturbations";
    const char* const ResetBeiDouPerturbations::Documentation = "Please note the command ResetBeiDouPerturbations is deprecated since 21.3. You may use ResetPerturbations.\n\nSet BeiDou orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) to zero";

    REGISTER_COMMAND_FACTORY(ResetBeiDouPerturbations);


    ResetBeiDouPerturbations::ResetBeiDouPerturbations()
      : CommandBase(CmdName)
    {}

    ResetBeiDouPerturbations::ResetBeiDouPerturbations(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    ResetBeiDouPerturbationsPtr ResetBeiDouPerturbations::create(int prn)
    {
      return ResetBeiDouPerturbationsPtr(new ResetBeiDouPerturbations(prn));
    }

    ResetBeiDouPerturbationsPtr ResetBeiDouPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ResetBeiDouPerturbations>(ptr);
    }

    bool ResetBeiDouPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string ResetBeiDouPerturbations::documentation() const { return Documentation; }


    int ResetBeiDouPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int ResetBeiDouPerturbations::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void ResetBeiDouPerturbations::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsPerturbations
///
#include "gen/SetGpsPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsPerturbations::CmdName = "SetGpsPerturbations";
    const char* const SetGpsPerturbations::Documentation = "Please note the command GpsPerturbations is deprecated since 21.3. You may use Perturbations.\n\nSet GPS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc)";

    REGISTER_COMMAND_FACTORY(SetGpsPerturbations);


    SetGpsPerturbations::SetGpsPerturbations()
      : CommandBase(CmdName)
    {}

    SetGpsPerturbations::SetGpsPerturbations(int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetGpsPerturbationsPtr SetGpsPerturbations::create(int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return SetGpsPerturbationsPtr(new SetGpsPerturbations(prn, crs, crc, cis, cic, cus, cuc));
    }

    SetGpsPerturbationsPtr SetGpsPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsPerturbations>(ptr);
    }

    bool SetGpsPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetGpsPerturbations::documentation() const { return Documentation; }


    int SetGpsPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsPerturbations::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsPerturbations::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGpsPerturbations::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void SetGpsPerturbations::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGpsPerturbations::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void SetGpsPerturbations::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGpsPerturbations::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void SetGpsPerturbations::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGpsPerturbations::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void SetGpsPerturbations::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGpsPerturbations::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void SetGpsPerturbations::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGpsPerturbations::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void SetGpsPerturbations::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsPerturbations
///
#include "gen/GetGpsPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsPerturbations::CmdName = "GetGpsPerturbations";
    const char* const GetGpsPerturbations::Documentation = "Please note the command GpsPerturbations is deprecated since 21.3. You may use Perturbations.\n\nGet GPS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc)";

    REGISTER_COMMAND_FACTORY(GetGpsPerturbations);


    GetGpsPerturbations::GetGpsPerturbations()
      : CommandBase(CmdName)
    {}

    GetGpsPerturbations::GetGpsPerturbations(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsPerturbationsPtr GetGpsPerturbations::create(int prn)
    {
      return GetGpsPerturbationsPtr(new GetGpsPerturbations(prn));
    }

    GetGpsPerturbationsPtr GetGpsPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsPerturbations>(ptr);
    }

    bool GetGpsPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsPerturbations::documentation() const { return Documentation; }


    int GetGpsPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsPerturbations::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsPerturbations::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsPerturbationsResult
///
#include "gen/GetGpsPerturbationsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsPerturbationsResult::CmdName = "GetGpsPerturbationsResult";
    const char* const GetGpsPerturbationsResult::Documentation = "Result of GetGpsPerturbations";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsPerturbationsResult);


    GetGpsPerturbationsResult::GetGpsPerturbationsResult()
      : CommandResult(CmdName)
    {}

    GetGpsPerturbationsResult::GetGpsPerturbationsResult(CommandBasePtr relatedCommand, int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetGpsPerturbationsResultPtr GetGpsPerturbationsResult::create(CommandBasePtr relatedCommand, int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return GetGpsPerturbationsResultPtr(new GetGpsPerturbationsResult(relatedCommand, prn, crs, crc, cis, cic, cus, cuc));
    }

    GetGpsPerturbationsResultPtr GetGpsPerturbationsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsPerturbationsResult>(ptr);
    }

    bool GetGpsPerturbationsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetGpsPerturbationsResult::documentation() const { return Documentation; }


    int GetGpsPerturbationsResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsPerturbationsResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGpsPerturbationsResult::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void GetGpsPerturbationsResult::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGpsPerturbationsResult::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void GetGpsPerturbationsResult::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGpsPerturbationsResult::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void GetGpsPerturbationsResult::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGpsPerturbationsResult::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void GetGpsPerturbationsResult::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGpsPerturbationsResult::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void GetGpsPerturbationsResult::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGpsPerturbationsResult::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void GetGpsPerturbationsResult::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoPerturbations
///
#include "gen/SetGalileoPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoPerturbations::CmdName = "SetGalileoPerturbations";
    const char* const SetGalileoPerturbations::Documentation = "Please note the command GalileoPerturbations is deprecated since 21.3. You may use Perturbations.\n\nSet GPS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc)";

    REGISTER_COMMAND_FACTORY(SetGalileoPerturbations);


    SetGalileoPerturbations::SetGalileoPerturbations()
      : CommandBase(CmdName)
    {}

    SetGalileoPerturbations::SetGalileoPerturbations(int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetGalileoPerturbationsPtr SetGalileoPerturbations::create(int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return SetGalileoPerturbationsPtr(new SetGalileoPerturbations(prn, crs, crc, cis, cic, cus, cuc));
    }

    SetGalileoPerturbationsPtr SetGalileoPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoPerturbations>(ptr);
    }

    bool SetGalileoPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetGalileoPerturbations::documentation() const { return Documentation; }


    int SetGalileoPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGalileoPerturbations::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoPerturbations::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGalileoPerturbations::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void SetGalileoPerturbations::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGalileoPerturbations::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void SetGalileoPerturbations::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGalileoPerturbations::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void SetGalileoPerturbations::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGalileoPerturbations::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void SetGalileoPerturbations::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGalileoPerturbations::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void SetGalileoPerturbations::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGalileoPerturbations::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void SetGalileoPerturbations::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoPerturbations
///
#include "gen/GetGalileoPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoPerturbations::CmdName = "GetGalileoPerturbations";
    const char* const GetGalileoPerturbations::Documentation = "Please note the command GalileoPerturbations is deprecated since 21.3. You may use Perturbations.\n\nGet GPS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc)";

    REGISTER_COMMAND_FACTORY(GetGalileoPerturbations);


    GetGalileoPerturbations::GetGalileoPerturbations()
      : CommandBase(CmdName)
    {}

    GetGalileoPerturbations::GetGalileoPerturbations(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGalileoPerturbationsPtr GetGalileoPerturbations::create(int prn)
    {
      return GetGalileoPerturbationsPtr(new GetGalileoPerturbations(prn));
    }

    GetGalileoPerturbationsPtr GetGalileoPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoPerturbations>(ptr);
    }

    bool GetGalileoPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGalileoPerturbations::documentation() const { return Documentation; }


    int GetGalileoPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoPerturbations::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoPerturbations::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoPerturbationsResult
///
#include "gen/GetGalileoPerturbationsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoPerturbationsResult::CmdName = "GetGalileoPerturbationsResult";
    const char* const GetGalileoPerturbationsResult::Documentation = "Result of GetGalileoPerturbations";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoPerturbationsResult);


    GetGalileoPerturbationsResult::GetGalileoPerturbationsResult()
      : CommandResult(CmdName)
    {}

    GetGalileoPerturbationsResult::GetGalileoPerturbationsResult(CommandBasePtr relatedCommand, int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetGalileoPerturbationsResultPtr GetGalileoPerturbationsResult::create(CommandBasePtr relatedCommand, int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return GetGalileoPerturbationsResultPtr(new GetGalileoPerturbationsResult(relatedCommand, prn, crs, crc, cis, cic, cus, cuc));
    }

    GetGalileoPerturbationsResultPtr GetGalileoPerturbationsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoPerturbationsResult>(ptr);
    }

    bool GetGalileoPerturbationsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetGalileoPerturbationsResult::documentation() const { return Documentation; }


    int GetGalileoPerturbationsResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoPerturbationsResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGalileoPerturbationsResult::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void GetGalileoPerturbationsResult::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGalileoPerturbationsResult::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void GetGalileoPerturbationsResult::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGalileoPerturbationsResult::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void GetGalileoPerturbationsResult::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGalileoPerturbationsResult::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void GetGalileoPerturbationsResult::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGalileoPerturbationsResult::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void GetGalileoPerturbationsResult::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGalileoPerturbationsResult::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void GetGalileoPerturbationsResult::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouPerturbations
///
#include "gen/SetBeiDouPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouPerturbations::CmdName = "SetBeiDouPerturbations";
    const char* const SetBeiDouPerturbations::Documentation = "Please note the command BeiDouPerturbations is deprecated since 21.3. You may use Perturbations.\n\nSet BeiDou orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc)";

    REGISTER_COMMAND_FACTORY(SetBeiDouPerturbations);


    SetBeiDouPerturbations::SetBeiDouPerturbations()
      : CommandBase(CmdName)
    {}

    SetBeiDouPerturbations::SetBeiDouPerturbations(int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetBeiDouPerturbationsPtr SetBeiDouPerturbations::create(int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return SetBeiDouPerturbationsPtr(new SetBeiDouPerturbations(prn, crs, crc, cis, cic, cus, cuc));
    }

    SetBeiDouPerturbationsPtr SetBeiDouPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouPerturbations>(ptr);
    }

    bool SetBeiDouPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetBeiDouPerturbations::documentation() const { return Documentation; }


    int SetBeiDouPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetBeiDouPerturbations::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouPerturbations::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetBeiDouPerturbations::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void SetBeiDouPerturbations::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetBeiDouPerturbations::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void SetBeiDouPerturbations::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetBeiDouPerturbations::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void SetBeiDouPerturbations::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetBeiDouPerturbations::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void SetBeiDouPerturbations::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetBeiDouPerturbations::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void SetBeiDouPerturbations::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetBeiDouPerturbations::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void SetBeiDouPerturbations::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouPerturbations
///
#include "gen/GetBeiDouPerturbations.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouPerturbations::CmdName = "GetBeiDouPerturbations";
    const char* const GetBeiDouPerturbations::Documentation = "Please note the command BeiDouPerturbations is deprecated since 21.3. You may use Perturbations.\n\nGet BeiDou orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc)";

    REGISTER_COMMAND_FACTORY(GetBeiDouPerturbations);


    GetBeiDouPerturbations::GetBeiDouPerturbations()
      : CommandBase(CmdName)
    {}

    GetBeiDouPerturbations::GetBeiDouPerturbations(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouPerturbationsPtr GetBeiDouPerturbations::create(int prn)
    {
      return GetBeiDouPerturbationsPtr(new GetBeiDouPerturbations(prn));
    }

    GetBeiDouPerturbationsPtr GetBeiDouPerturbations::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouPerturbations>(ptr);
    }

    bool GetBeiDouPerturbations::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouPerturbations::documentation() const { return Documentation; }


    int GetBeiDouPerturbations::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouPerturbations::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouPerturbations::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouPerturbationsResult
///
#include "gen/GetBeiDouPerturbationsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouPerturbationsResult::CmdName = "GetBeiDouPerturbationsResult";
    const char* const GetBeiDouPerturbationsResult::Documentation = "Result of GetBeiDouPerturbations";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouPerturbationsResult);


    GetBeiDouPerturbationsResult::GetBeiDouPerturbationsResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouPerturbationsResult::GetBeiDouPerturbationsResult(CommandBasePtr relatedCommand, int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetBeiDouPerturbationsResultPtr GetBeiDouPerturbationsResult::create(CommandBasePtr relatedCommand, int prn, double crs, double crc, double cis, double cic, double cus, double cuc)
    {
      return GetBeiDouPerturbationsResultPtr(new GetBeiDouPerturbationsResult(relatedCommand, prn, crs, crc, cis, cic, cus, cuc));
    }

    GetBeiDouPerturbationsResultPtr GetBeiDouPerturbationsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouPerturbationsResult>(ptr);
    }

    bool GetBeiDouPerturbationsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<double>::is_valid(m_values["Crs"])
          && parse_json<double>::is_valid(m_values["Crc"])
          && parse_json<double>::is_valid(m_values["Cis"])
          && parse_json<double>::is_valid(m_values["Cic"])
          && parse_json<double>::is_valid(m_values["Cus"])
          && parse_json<double>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetBeiDouPerturbationsResult::documentation() const { return Documentation; }


    int GetBeiDouPerturbationsResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouPerturbationsResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetBeiDouPerturbationsResult::crs() const
    {
      return parse_json<double>::parse(m_values["Crs"]);
    }

    void GetBeiDouPerturbationsResult::setCrs(double crs)
    {
      m_values.AddMember("Crs", parse_json<double>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetBeiDouPerturbationsResult::crc() const
    {
      return parse_json<double>::parse(m_values["Crc"]);
    }

    void GetBeiDouPerturbationsResult::setCrc(double crc)
    {
      m_values.AddMember("Crc", parse_json<double>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetBeiDouPerturbationsResult::cis() const
    {
      return parse_json<double>::parse(m_values["Cis"]);
    }

    void GetBeiDouPerturbationsResult::setCis(double cis)
    {
      m_values.AddMember("Cis", parse_json<double>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetBeiDouPerturbationsResult::cic() const
    {
      return parse_json<double>::parse(m_values["Cic"]);
    }

    void GetBeiDouPerturbationsResult::setCic(double cic)
    {
      m_values.AddMember("Cic", parse_json<double>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetBeiDouPerturbationsResult::cus() const
    {
      return parse_json<double>::parse(m_values["Cus"]);
    }

    void GetBeiDouPerturbationsResult::setCus(double cus)
    {
      m_values.AddMember("Cus", parse_json<double>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetBeiDouPerturbationsResult::cuc() const
    {
      return parse_json<double>::parse(m_values["Cuc"]);
    }

    void GetBeiDouPerturbationsResult::setCuc(double cuc)
    {
      m_values.AddMember("Cuc", parse_json<double>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsPerturbationsForAllSat
///
#include "gen/SetGpsPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsPerturbationsForAllSat::CmdName = "SetGpsPerturbationsForAllSat";
    const char* const SetGpsPerturbationsForAllSat::Documentation = "Please note the command GpsPerturbationsForAllSat is deprecated since 21.3. You may use PerturbationsForAllSat.\n\nSet GPS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites.\nAll parameters are zero based index (index 0 => PRN 1, index 1 => PRN 2, etc)";

    REGISTER_COMMAND_FACTORY(SetGpsPerturbationsForAllSat);


    SetGpsPerturbationsForAllSat::SetGpsPerturbationsForAllSat()
      : CommandBase(CmdName)
    {}

    SetGpsPerturbationsForAllSat::SetGpsPerturbationsForAllSat(const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandBase(CmdName)
    {

      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetGpsPerturbationsForAllSatPtr SetGpsPerturbationsForAllSat::create(const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return SetGpsPerturbationsForAllSatPtr(new SetGpsPerturbationsForAllSat(crs, crc, cis, cic, cus, cuc));
    }

    SetGpsPerturbationsForAllSatPtr SetGpsPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsPerturbationsForAllSat>(ptr);
    }

    bool SetGpsPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetGpsPerturbationsForAllSat::documentation() const { return Documentation; }


    int SetGpsPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<double> SetGpsPerturbationsForAllSat::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void SetGpsPerturbationsForAllSat::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGpsPerturbationsForAllSat::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void SetGpsPerturbationsForAllSat::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGpsPerturbationsForAllSat::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void SetGpsPerturbationsForAllSat::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGpsPerturbationsForAllSat::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void SetGpsPerturbationsForAllSat::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGpsPerturbationsForAllSat::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void SetGpsPerturbationsForAllSat::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGpsPerturbationsForAllSat::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void SetGpsPerturbationsForAllSat::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsPerturbationsForAllSat
///
#include "gen/GetGpsPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsPerturbationsForAllSat::CmdName = "GetGpsPerturbationsForAllSat";
    const char* const GetGpsPerturbationsForAllSat::Documentation = "Please note the command GpsPerturbationsForAllSat is deprecated since 21.3. You may use PerturbationsForAllSat.\n\nGet GPS orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites.\nAll parameters are zero based index (index 0 => PRN 1, index 1 => PRN 2, etc)";

    REGISTER_COMMAND_FACTORY(GetGpsPerturbationsForAllSat);


    GetGpsPerturbationsForAllSat::GetGpsPerturbationsForAllSat()
      : CommandBase(CmdName)
    {

    }


    GetGpsPerturbationsForAllSatPtr GetGpsPerturbationsForAllSat::create()
    {
      return GetGpsPerturbationsForAllSatPtr(new GetGpsPerturbationsForAllSat());
    }

    GetGpsPerturbationsForAllSatPtr GetGpsPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsPerturbationsForAllSat>(ptr);
    }

    bool GetGpsPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGpsPerturbationsForAllSat::documentation() const { return Documentation; }


    int GetGpsPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsPerturbationsForAllSatResult
///
#include "gen/GetGpsPerturbationsForAllSatResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsPerturbationsForAllSatResult::CmdName = "GetGpsPerturbationsForAllSatResult";
    const char* const GetGpsPerturbationsForAllSatResult::Documentation = "Result of GetGpsPerturbationsForAllSat";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsPerturbationsForAllSatResult);


    GetGpsPerturbationsForAllSatResult::GetGpsPerturbationsForAllSatResult()
      : CommandResult(CmdName)
    {}

    GetGpsPerturbationsForAllSatResult::GetGpsPerturbationsForAllSatResult(CommandBasePtr relatedCommand, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetGpsPerturbationsForAllSatResultPtr GetGpsPerturbationsForAllSatResult::create(CommandBasePtr relatedCommand, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return GetGpsPerturbationsForAllSatResultPtr(new GetGpsPerturbationsForAllSatResult(relatedCommand, crs, crc, cis, cic, cus, cuc));
    }

    GetGpsPerturbationsForAllSatResultPtr GetGpsPerturbationsForAllSatResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsPerturbationsForAllSatResult>(ptr);
    }

    bool GetGpsPerturbationsForAllSatResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetGpsPerturbationsForAllSatResult::documentation() const { return Documentation; }


    std::vector<double> GetGpsPerturbationsForAllSatResult::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void GetGpsPerturbationsForAllSatResult::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGpsPerturbationsForAllSatResult::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void GetGpsPerturbationsForAllSatResult::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGpsPerturbationsForAllSatResult::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void GetGpsPerturbationsForAllSatResult::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGpsPerturbationsForAllSatResult::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void GetGpsPerturbationsForAllSatResult::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGpsPerturbationsForAllSatResult::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void GetGpsPerturbationsForAllSatResult::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGpsPerturbationsForAllSatResult::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void GetGpsPerturbationsForAllSatResult::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoPerturbationsForAllSat
///
#include "gen/SetGalileoPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoPerturbationsForAllSat::CmdName = "SetGalileoPerturbationsForAllSat";
    const char* const SetGalileoPerturbationsForAllSat::Documentation = "Please note the command GalileoPerturbationsForAllSat is deprecated since 21.3. You may use PerturbationsForAllSat.\n\nSet Galileo orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites.\nAll parameters are zero based index (index 0 => PRN 1, index 1 => PRN 2, etc)";

    REGISTER_COMMAND_FACTORY(SetGalileoPerturbationsForAllSat);


    SetGalileoPerturbationsForAllSat::SetGalileoPerturbationsForAllSat()
      : CommandBase(CmdName)
    {}

    SetGalileoPerturbationsForAllSat::SetGalileoPerturbationsForAllSat(const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandBase(CmdName)
    {

      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetGalileoPerturbationsForAllSatPtr SetGalileoPerturbationsForAllSat::create(const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return SetGalileoPerturbationsForAllSatPtr(new SetGalileoPerturbationsForAllSat(crs, crc, cis, cic, cus, cuc));
    }

    SetGalileoPerturbationsForAllSatPtr SetGalileoPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoPerturbationsForAllSat>(ptr);
    }

    bool SetGalileoPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetGalileoPerturbationsForAllSat::documentation() const { return Documentation; }


    int SetGalileoPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<double> SetGalileoPerturbationsForAllSat::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void SetGalileoPerturbationsForAllSat::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGalileoPerturbationsForAllSat::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void SetGalileoPerturbationsForAllSat::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGalileoPerturbationsForAllSat::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void SetGalileoPerturbationsForAllSat::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGalileoPerturbationsForAllSat::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void SetGalileoPerturbationsForAllSat::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGalileoPerturbationsForAllSat::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void SetGalileoPerturbationsForAllSat::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetGalileoPerturbationsForAllSat::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void SetGalileoPerturbationsForAllSat::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoPerturbationsForAllSat
///
#include "gen/GetGalileoPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoPerturbationsForAllSat::CmdName = "GetGalileoPerturbationsForAllSat";
    const char* const GetGalileoPerturbationsForAllSat::Documentation = "Please note the command GalileoPerturbationsForAllSat is deprecated since 21.3. You may use PerturbationsForAllSat.\n\nGet Galileo orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites.\nAll parameters are zero based index (index 0 => PRN 1, index 1 => PRN 2, etc)";

    REGISTER_COMMAND_FACTORY(GetGalileoPerturbationsForAllSat);


    GetGalileoPerturbationsForAllSat::GetGalileoPerturbationsForAllSat()
      : CommandBase(CmdName)
    {

    }


    GetGalileoPerturbationsForAllSatPtr GetGalileoPerturbationsForAllSat::create()
    {
      return GetGalileoPerturbationsForAllSatPtr(new GetGalileoPerturbationsForAllSat());
    }

    GetGalileoPerturbationsForAllSatPtr GetGalileoPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoPerturbationsForAllSat>(ptr);
    }

    bool GetGalileoPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetGalileoPerturbationsForAllSat::documentation() const { return Documentation; }


    int GetGalileoPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGalileoPerturbationsForAllSatResult
///
#include "gen/GetGalileoPerturbationsForAllSatResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoPerturbationsForAllSatResult::CmdName = "GetGalileoPerturbationsForAllSatResult";
    const char* const GetGalileoPerturbationsForAllSatResult::Documentation = "Result of GetGalileoPerturbationsForAllSat";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoPerturbationsForAllSatResult);


    GetGalileoPerturbationsForAllSatResult::GetGalileoPerturbationsForAllSatResult()
      : CommandResult(CmdName)
    {}

    GetGalileoPerturbationsForAllSatResult::GetGalileoPerturbationsForAllSatResult(CommandBasePtr relatedCommand, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetGalileoPerturbationsForAllSatResultPtr GetGalileoPerturbationsForAllSatResult::create(CommandBasePtr relatedCommand, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return GetGalileoPerturbationsForAllSatResultPtr(new GetGalileoPerturbationsForAllSatResult(relatedCommand, crs, crc, cis, cic, cus, cuc));
    }

    GetGalileoPerturbationsForAllSatResultPtr GetGalileoPerturbationsForAllSatResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoPerturbationsForAllSatResult>(ptr);
    }

    bool GetGalileoPerturbationsForAllSatResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetGalileoPerturbationsForAllSatResult::documentation() const { return Documentation; }


    std::vector<double> GetGalileoPerturbationsForAllSatResult::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void GetGalileoPerturbationsForAllSatResult::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGalileoPerturbationsForAllSatResult::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void GetGalileoPerturbationsForAllSatResult::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGalileoPerturbationsForAllSatResult::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void GetGalileoPerturbationsForAllSatResult::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGalileoPerturbationsForAllSatResult::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void GetGalileoPerturbationsForAllSatResult::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGalileoPerturbationsForAllSatResult::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void GetGalileoPerturbationsForAllSatResult::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetGalileoPerturbationsForAllSatResult::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void GetGalileoPerturbationsForAllSatResult::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouPerturbationsForAllSat
///
#include "gen/SetBeiDouPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouPerturbationsForAllSat::CmdName = "SetBeiDouPerturbationsForAllSat";
    const char* const SetBeiDouPerturbationsForAllSat::Documentation = "Please note the command BeiDouPerturbationsForAllSat is deprecated since 21.3. You may use PerturbationsForAllSat.\n\nSet BeiDou orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites.\nAll parameters are zero based index (index 0 => PRN 1, index 1 => PRN 2, etc)";

    REGISTER_COMMAND_FACTORY(SetBeiDouPerturbationsForAllSat);


    SetBeiDouPerturbationsForAllSat::SetBeiDouPerturbationsForAllSat()
      : CommandBase(CmdName)
    {}

    SetBeiDouPerturbationsForAllSat::SetBeiDouPerturbationsForAllSat(const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandBase(CmdName)
    {

      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    SetBeiDouPerturbationsForAllSatPtr SetBeiDouPerturbationsForAllSat::create(const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return SetBeiDouPerturbationsForAllSatPtr(new SetBeiDouPerturbationsForAllSat(crs, crc, cis, cic, cus, cuc));
    }

    SetBeiDouPerturbationsForAllSatPtr SetBeiDouPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouPerturbationsForAllSat>(ptr);
    }

    bool SetBeiDouPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string SetBeiDouPerturbationsForAllSat::documentation() const { return Documentation; }


    int SetBeiDouPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<double> SetBeiDouPerturbationsForAllSat::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void SetBeiDouPerturbationsForAllSat::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetBeiDouPerturbationsForAllSat::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void SetBeiDouPerturbationsForAllSat::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetBeiDouPerturbationsForAllSat::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void SetBeiDouPerturbationsForAllSat::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetBeiDouPerturbationsForAllSat::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void SetBeiDouPerturbationsForAllSat::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetBeiDouPerturbationsForAllSat::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void SetBeiDouPerturbationsForAllSat::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> SetBeiDouPerturbationsForAllSat::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void SetBeiDouPerturbationsForAllSat::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouPerturbationsForAllSat
///
#include "gen/GetBeiDouPerturbationsForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouPerturbationsForAllSat::CmdName = "GetBeiDouPerturbationsForAllSat";
    const char* const GetBeiDouPerturbationsForAllSat::Documentation = "Please note the command BeiDouPerturbationsForAllSat is deprecated since 21.3. You may use PerturbationsForAllSat.\n\nGet BeiDou orbit perturbations (Crs, Crc, Cis, Cic, Cus and Cuc) for all satellites.\nAll parameters are zero based index (index 0 => PRN 1, index 1 => PRN 2, etc)";

    REGISTER_COMMAND_FACTORY(GetBeiDouPerturbationsForAllSat);


    GetBeiDouPerturbationsForAllSat::GetBeiDouPerturbationsForAllSat()
      : CommandBase(CmdName)
    {

    }


    GetBeiDouPerturbationsForAllSatPtr GetBeiDouPerturbationsForAllSat::create()
    {
      return GetBeiDouPerturbationsForAllSatPtr(new GetBeiDouPerturbationsForAllSat());
    }

    GetBeiDouPerturbationsForAllSatPtr GetBeiDouPerturbationsForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouPerturbationsForAllSat>(ptr);
    }

    bool GetBeiDouPerturbationsForAllSat::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string GetBeiDouPerturbationsForAllSat::documentation() const { return Documentation; }


    int GetBeiDouPerturbationsForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetBeiDouPerturbationsForAllSatResult
///
#include "gen/GetBeiDouPerturbationsForAllSatResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouPerturbationsForAllSatResult::CmdName = "GetBeiDouPerturbationsForAllSatResult";
    const char* const GetBeiDouPerturbationsForAllSatResult::Documentation = "Result of GetBeiDouPerturbationsForAllSat";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouPerturbationsForAllSatResult);


    GetBeiDouPerturbationsForAllSatResult::GetBeiDouPerturbationsForAllSatResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouPerturbationsForAllSatResult::GetBeiDouPerturbationsForAllSatResult(CommandBasePtr relatedCommand, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
      : CommandResult(CmdName, relatedCommand)
    {

      setCrs(crs);
      setCrc(crc);
      setCis(cis);
      setCic(cic);
      setCus(cus);
      setCuc(cuc);
    }


    GetBeiDouPerturbationsForAllSatResultPtr GetBeiDouPerturbationsForAllSatResult::create(CommandBasePtr relatedCommand, const std::vector<double>& crs, const std::vector<double>& crc, const std::vector<double>& cis, const std::vector<double>& cic, const std::vector<double>& cus, const std::vector<double>& cuc)
    {
      return GetBeiDouPerturbationsForAllSatResultPtr(new GetBeiDouPerturbationsForAllSatResult(relatedCommand, crs, crc, cis, cic, cus, cuc));
    }

    GetBeiDouPerturbationsForAllSatResultPtr GetBeiDouPerturbationsForAllSatResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouPerturbationsForAllSatResult>(ptr);
    }

    bool GetBeiDouPerturbationsForAllSatResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<double>>::is_valid(m_values["Crs"])
          && parse_json<std::vector<double>>::is_valid(m_values["Crc"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cis"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cic"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cus"])
          && parse_json<std::vector<double>>::is_valid(m_values["Cuc"])
        ;

    }

    std::string GetBeiDouPerturbationsForAllSatResult::documentation() const { return Documentation; }


    std::vector<double> GetBeiDouPerturbationsForAllSatResult::crs() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crs"]);
    }

    void GetBeiDouPerturbationsForAllSatResult::setCrs(const std::vector<double>& crs)
    {
      m_values.AddMember("Crs", parse_json<std::vector<double>>::format(crs, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetBeiDouPerturbationsForAllSatResult::crc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Crc"]);
    }

    void GetBeiDouPerturbationsForAllSatResult::setCrc(const std::vector<double>& crc)
    {
      m_values.AddMember("Crc", parse_json<std::vector<double>>::format(crc, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetBeiDouPerturbationsForAllSatResult::cis() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cis"]);
    }

    void GetBeiDouPerturbationsForAllSatResult::setCis(const std::vector<double>& cis)
    {
      m_values.AddMember("Cis", parse_json<std::vector<double>>::format(cis, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetBeiDouPerturbationsForAllSatResult::cic() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cic"]);
    }

    void GetBeiDouPerturbationsForAllSatResult::setCic(const std::vector<double>& cic)
    {
      m_values.AddMember("Cic", parse_json<std::vector<double>>::format(cic, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetBeiDouPerturbationsForAllSatResult::cus() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cus"]);
    }

    void GetBeiDouPerturbationsForAllSatResult::setCus(const std::vector<double>& cus)
    {
      m_values.AddMember("Cus", parse_json<std::vector<double>>::format(cus, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<double> GetBeiDouPerturbationsForAllSatResult::cuc() const
    {
      return parse_json<std::vector<double>>::parse(m_values["Cuc"]);
    }

    void GetBeiDouPerturbationsForAllSatResult::setCuc(const std::vector<double>& cuc)
    {
      m_values.AddMember("Cuc", parse_json<std::vector<double>>::format(cuc, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetMultipath
///
#include "gen/SetMultipath.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetMultipath::CmdName = "SetMultipath";
    const char* const SetMultipath::Documentation = "Please note the command SetMultipath is deprecated since 21.3. You may use SetMultipathForSV.\n\nAdd or update signal echo (multipath). Offsets (power loss, pseudorange, Doppler and carrier phase) are all relative to line-of-sight signal.\nIf Id is not set, or unknown to Skydel, a new echo will be added. Otherwise, existing echo will be updated.";

    REGISTER_COMMAND_FACTORY(SetMultipath);


    SetMultipath::SetMultipath()
      : CommandBase(CmdName)
    {}

    SetMultipath::SetMultipath(int prn, const std::string& system, const std::string& signal, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSystem(system);
      setSignal(signal);
      setPowerLoss(powerLoss);
      setPseudorange(pseudorange);
      setDoppler(doppler);
      setCarrierPhase(carrierPhase);
      setEcho(echo);
      setId(id);
    }


    SetMultipathPtr SetMultipath::create(int prn, const std::string& system, const std::string& signal, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo, const std::string& id)
    {
      return SetMultipathPtr(new SetMultipath(prn, system, signal, powerLoss, pseudorange, doppler, carrierPhase, echo, id));
    }

    SetMultipathPtr SetMultipath::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetMultipath>(ptr);
    }

    bool SetMultipath::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<double>::is_valid(m_values["PowerLoss"])
          && parse_json<double>::is_valid(m_values["Pseudorange"])
          && parse_json<double>::is_valid(m_values["Doppler"])
          && parse_json<double>::is_valid(m_values["CarrierPhase"])
          && parse_json<int>::is_valid(m_values["Echo"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetMultipath::documentation() const { return Documentation; }


    int SetMultipath::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetMultipath::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetMultipath::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMultipath::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetMultipath::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMultipath::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void SetMultipath::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipath::powerLoss() const
    {
      return parse_json<double>::parse(m_values["PowerLoss"]);
    }

    void SetMultipath::setPowerLoss(double powerLoss)
    {
      m_values.AddMember("PowerLoss", parse_json<double>::format(powerLoss, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipath::pseudorange() const
    {
      return parse_json<double>::parse(m_values["Pseudorange"]);
    }

    void SetMultipath::setPseudorange(double pseudorange)
    {
      m_values.AddMember("Pseudorange", parse_json<double>::format(pseudorange, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipath::doppler() const
    {
      return parse_json<double>::parse(m_values["Doppler"]);
    }

    void SetMultipath::setDoppler(double doppler)
    {
      m_values.AddMember("Doppler", parse_json<double>::format(doppler, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetMultipath::carrierPhase() const
    {
      return parse_json<double>::parse(m_values["CarrierPhase"]);
    }

    void SetMultipath::setCarrierPhase(double carrierPhase)
    {
      m_values.AddMember("CarrierPhase", parse_json<double>::format(carrierPhase, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetMultipath::echo() const
    {
      return parse_json<int>::parse(m_values["Echo"]);
    }

    void SetMultipath::setEcho(int echo)
    {
      m_values.AddMember("Echo", parse_json<int>::format(echo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetMultipath::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetMultipath::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMultipath
///
#include "gen/GetMultipath.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMultipath::CmdName = "GetMultipath";
    const char* const GetMultipath::Documentation = "Please note the command GetMultipath is deprecated since 21.3. You may use GetMultipathForID.\n\nGet multipath infos for the specified multipath ID.";

    REGISTER_COMMAND_FACTORY(GetMultipath);


    GetMultipath::GetMultipath()
      : CommandBase(CmdName)
    {}

    GetMultipath::GetMultipath(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetMultipathPtr GetMultipath::create(const std::string& id)
    {
      return GetMultipathPtr(new GetMultipath(id));
    }

    GetMultipathPtr GetMultipath::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMultipath>(ptr);
    }

    bool GetMultipath::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMultipath::documentation() const { return Documentation; }


    int GetMultipath::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMultipath::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMultipath::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMultipathResult
///
#include "gen/GetMultipathResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMultipathResult::CmdName = "GetMultipathResult";
    const char* const GetMultipathResult::Documentation = "Result of GetMultipathResult.";

    REGISTER_COMMAND_RESULT_FACTORY(GetMultipathResult);


    GetMultipathResult::GetMultipathResult()
      : CommandResult(CmdName)
    {}

    GetMultipathResult::GetMultipathResult(CommandBasePtr relatedCommand, int prn, const std::string& system, const std::string& signal, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setSystem(system);
      setSignal(signal);
      setPowerLoss(powerLoss);
      setPseudorange(pseudorange);
      setDoppler(doppler);
      setCarrierPhase(carrierPhase);
      setEcho(echo);
      setId(id);
    }


    GetMultipathResultPtr GetMultipathResult::create(CommandBasePtr relatedCommand, int prn, const std::string& system, const std::string& signal, double powerLoss, double pseudorange, double doppler, double carrierPhase, int echo, const std::string& id)
    {
      return GetMultipathResultPtr(new GetMultipathResult(relatedCommand, prn, system, signal, powerLoss, pseudorange, doppler, carrierPhase, echo, id));
    }

    GetMultipathResultPtr GetMultipathResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMultipathResult>(ptr);
    }

    bool GetMultipathResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<double>::is_valid(m_values["PowerLoss"])
          && parse_json<double>::is_valid(m_values["Pseudorange"])
          && parse_json<double>::is_valid(m_values["Doppler"])
          && parse_json<double>::is_valid(m_values["CarrierPhase"])
          && parse_json<int>::is_valid(m_values["Echo"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetMultipathResult::documentation() const { return Documentation; }


    int GetMultipathResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetMultipathResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMultipathResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetMultipathResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMultipathResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetMultipathResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathResult::powerLoss() const
    {
      return parse_json<double>::parse(m_values["PowerLoss"]);
    }

    void GetMultipathResult::setPowerLoss(double powerLoss)
    {
      m_values.AddMember("PowerLoss", parse_json<double>::format(powerLoss, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathResult::pseudorange() const
    {
      return parse_json<double>::parse(m_values["Pseudorange"]);
    }

    void GetMultipathResult::setPseudorange(double pseudorange)
    {
      m_values.AddMember("Pseudorange", parse_json<double>::format(pseudorange, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathResult::doppler() const
    {
      return parse_json<double>::parse(m_values["Doppler"]);
    }

    void GetMultipathResult::setDoppler(double doppler)
    {
      m_values.AddMember("Doppler", parse_json<double>::format(doppler, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetMultipathResult::carrierPhase() const
    {
      return parse_json<double>::parse(m_values["CarrierPhase"]);
    }

    void GetMultipathResult::setCarrierPhase(double carrierPhase)
    {
      m_values.AddMember("CarrierPhase", parse_json<double>::format(carrierPhase, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMultipathResult::echo() const
    {
      return parse_json<int>::parse(m_values["Echo"]);
    }

    void GetMultipathResult::setEcho(int echo)
    {
      m_values.AddMember("Echo", parse_json<int>::format(echo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetMultipathResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetMultipathResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveAllMultipathForPrn
///
#include "gen/RemoveAllMultipathForPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveAllMultipathForPrn::CmdName = "RemoveAllMultipathForPrn";
    const char* const RemoveAllMultipathForPrn::Documentation = "Please note the command RemoveAllMultipathForPrn is deprecated since 21.3. You may use RemoveAllMultipathForSV.\n\nDisable all multipath for the specified satellite.";

    REGISTER_COMMAND_FACTORY(RemoveAllMultipathForPrn);


    RemoveAllMultipathForPrn::RemoveAllMultipathForPrn()
      : CommandBase(CmdName)
    {}

    RemoveAllMultipathForPrn::RemoveAllMultipathForPrn(int prn, const std::string& system, bool reset)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSystem(system);
      setReset(reset);
    }


    RemoveAllMultipathForPrnPtr RemoveAllMultipathForPrn::create(int prn, const std::string& system, bool reset)
    {
      return RemoveAllMultipathForPrnPtr(new RemoveAllMultipathForPrn(prn, system, reset));
    }

    RemoveAllMultipathForPrnPtr RemoveAllMultipathForPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveAllMultipathForPrn>(ptr);
    }

    bool RemoveAllMultipathForPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["Reset"])
        ;

    }

    std::string RemoveAllMultipathForPrn::documentation() const { return Documentation; }


    int RemoveAllMultipathForPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int RemoveAllMultipathForPrn::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void RemoveAllMultipathForPrn::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string RemoveAllMultipathForPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void RemoveAllMultipathForPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool RemoveAllMultipathForPrn::reset() const
    {
      return parse_json<bool>::parse(m_values["Reset"]);
    }

    void RemoveAllMultipathForPrn::setReset(bool reset)
    {
      m_values.AddMember("Reset", parse_json<bool>::format(reset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetAllMultipathForPrn
///
#include "gen/GetAllMultipathForPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetAllMultipathForPrn::CmdName = "GetAllMultipathForPrn";
    const char* const GetAllMultipathForPrn::Documentation = "Please note the command GetAllMultipathForPrn is deprecated since 21.3. You may use GetAllMultipathForSV.\n\nGet all multipath ID for the specified satellite of the constellation.";

    REGISTER_COMMAND_FACTORY(GetAllMultipathForPrn);


    GetAllMultipathForPrn::GetAllMultipathForPrn()
      : CommandBase(CmdName)
    {}

    GetAllMultipathForPrn::GetAllMultipathForPrn(const std::string& system, int prn)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
    }


    GetAllMultipathForPrnPtr GetAllMultipathForPrn::create(const std::string& system, int prn)
    {
      return GetAllMultipathForPrnPtr(new GetAllMultipathForPrn(system, prn));
    }

    GetAllMultipathForPrnPtr GetAllMultipathForPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetAllMultipathForPrn>(ptr);
    }

    bool GetAllMultipathForPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetAllMultipathForPrn::documentation() const { return Documentation; }


    int GetAllMultipathForPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetAllMultipathForPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetAllMultipathForPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetAllMultipathForPrn::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetAllMultipathForPrn::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnablePrn
///
#include "gen/EnablePrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnablePrn::CmdName = "EnablePrn";
    const char* const EnablePrn::Documentation = "Please note the command EnablePrn is deprecated since 21.3. You may use EnableSV.\n\nSet  enabled or disabled satellite for this constellation.";

    REGISTER_COMMAND_FACTORY(EnablePrn);


    EnablePrn::EnablePrn()
      : CommandBase(CmdName)
    {}

    EnablePrn::EnablePrn(const std::string& system, int prn, bool enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setEnabled(enabled);
    }


    EnablePrnPtr EnablePrn::create(const std::string& system, int prn, bool enabled)
    {
      return EnablePrnPtr(new EnablePrn(system, prn, enabled));
    }

    EnablePrnPtr EnablePrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnablePrn>(ptr);
    }

    bool EnablePrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnablePrn::documentation() const { return Documentation; }


    int EnablePrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EnablePrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnablePrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int EnablePrn::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void EnablePrn::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnablePrn::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnablePrn::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPrnEnabled
///
#include "gen/IsPrnEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPrnEnabled::CmdName = "IsPrnEnabled";
    const char* const IsPrnEnabled::Documentation = "Please note the command EnablePrn is deprecated since 21.3. You may use EnableSV.\n\nGet  enabled or disabled satellite for this constellation.";

    REGISTER_COMMAND_FACTORY(IsPrnEnabled);


    IsPrnEnabled::IsPrnEnabled()
      : CommandBase(CmdName)
    {}

    IsPrnEnabled::IsPrnEnabled(const std::string& system, int prn)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
    }


    IsPrnEnabledPtr IsPrnEnabled::create(const std::string& system, int prn)
    {
      return IsPrnEnabledPtr(new IsPrnEnabled(system, prn));
    }

    IsPrnEnabledPtr IsPrnEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPrnEnabled>(ptr);
    }

    bool IsPrnEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string IsPrnEnabled::documentation() const { return Documentation; }


    int IsPrnEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsPrnEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsPrnEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsPrnEnabled::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsPrnEnabled::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPrnEnabledResult
///
#include "gen/IsPrnEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPrnEnabledResult::CmdName = "IsPrnEnabledResult";
    const char* const IsPrnEnabledResult::Documentation = "Result of IsPrnEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsPrnEnabledResult);


    IsPrnEnabledResult::IsPrnEnabledResult()
      : CommandResult(CmdName)
    {}

    IsPrnEnabledResult::IsPrnEnabledResult(CommandBasePtr relatedCommand, const std::string& system, int prn, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setEnabled(enabled);
    }


    IsPrnEnabledResultPtr IsPrnEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, bool enabled)
    {
      return IsPrnEnabledResultPtr(new IsPrnEnabledResult(relatedCommand, system, prn, enabled));
    }

    IsPrnEnabledResultPtr IsPrnEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPrnEnabledResult>(ptr);
    }

    bool IsPrnEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsPrnEnabledResult::documentation() const { return Documentation; }


    std::string IsPrnEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsPrnEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsPrnEnabledResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsPrnEnabledResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsPrnEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsPrnEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnablePrns
///
#include "gen/EnablePrns.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnablePrns::CmdName = "EnablePrns";
    const char* const EnablePrns::Documentation = "Please note the command PrnsEnabled is deprecated since 21.3. You may use EnableEachSV.\n\nSet  enabled or disabled satellites for this constellation.";

    REGISTER_COMMAND_FACTORY(EnablePrns);


    EnablePrns::EnablePrns()
      : CommandBase(CmdName)
    {}

    EnablePrns::EnablePrns(const std::string& system, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    EnablePrnsPtr EnablePrns::create(const std::string& system, const std::vector<bool>& enabled)
    {
      return EnablePrnsPtr(new EnablePrns(system, enabled));
    }

    EnablePrnsPtr EnablePrns::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnablePrns>(ptr);
    }

    bool EnablePrns::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnablePrns::documentation() const { return Documentation; }


    int EnablePrns::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string EnablePrns::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnablePrns::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnablePrns::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnablePrns::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnsEnabled
///
#include "gen/GetPrnsEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnsEnabled::CmdName = "GetPrnsEnabled";
    const char* const GetPrnsEnabled::Documentation = "Please note the command PrnsEnabled is deprecated since 21.3. You may use EnableEachSV.\n\nGet  enabled or disabled satellites for this constellation.";

    REGISTER_COMMAND_FACTORY(GetPrnsEnabled);


    GetPrnsEnabled::GetPrnsEnabled()
      : CommandBase(CmdName)
    {}

    GetPrnsEnabled::GetPrnsEnabled(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetPrnsEnabledPtr GetPrnsEnabled::create(const std::string& system)
    {
      return GetPrnsEnabledPtr(new GetPrnsEnabled(system));
    }

    GetPrnsEnabledPtr GetPrnsEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnsEnabled>(ptr);
    }

    bool GetPrnsEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetPrnsEnabled::documentation() const { return Documentation; }


    int GetPrnsEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPrnsEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPrnsEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPrnsEnabledResult
///
#include "gen/GetPrnsEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPrnsEnabledResult::CmdName = "GetPrnsEnabledResult";
    const char* const GetPrnsEnabledResult::Documentation = "Result of GetPrnsEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(GetPrnsEnabledResult);


    GetPrnsEnabledResult::GetPrnsEnabledResult()
      : CommandResult(CmdName)
    {}

    GetPrnsEnabledResult::GetPrnsEnabledResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    GetPrnsEnabledResultPtr GetPrnsEnabledResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
    {
      return GetPrnsEnabledResultPtr(new GetPrnsEnabledResult(relatedCommand, system, enabled));
    }

    GetPrnsEnabledResultPtr GetPrnsEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPrnsEnabledResult>(ptr);
    }

    bool GetPrnsEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string GetPrnsEnabledResult::documentation() const { return Documentation; }


    std::string GetPrnsEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPrnsEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetPrnsEnabledResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetPrnsEnabledResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphemerisDoubleParam
///
#include "gen/SetGpsEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphemerisDoubleParam::CmdName = "SetGpsEphemerisDoubleParam";
    const char* const SetGpsEphemerisDoubleParam::Documentation = "Please note the command GpsEphemerisDoubleParam is deprecated since 21.3. You may use GpsEphDoubleParamForSV.\n\nSet various parameters in the GPS ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"IscL1Ca\"         sec\n  \"IscL2C\"          sec\n  \"IscL5I5\"         sec\n  \"IscL5Q5\"         sec\n  \"IscL1CP\"         sec\n  \"IscL1CD\"         sec";

    REGISTER_COMMAND_FACTORY(SetGpsEphemerisDoubleParam);


    SetGpsEphemerisDoubleParam::SetGpsEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    SetGpsEphemerisDoubleParam::SetGpsEphemerisDoubleParam(int prn, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    SetGpsEphemerisDoubleParamPtr SetGpsEphemerisDoubleParam::create(int prn, const std::string& paramName, double val)
    {
      return SetGpsEphemerisDoubleParamPtr(new SetGpsEphemerisDoubleParam(prn, paramName, val));
    }

    SetGpsEphemerisDoubleParamPtr SetGpsEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphemerisDoubleParam>(ptr);
    }

    bool SetGpsEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGpsEphemerisDoubleParam::documentation() const { return Documentation; }


    int SetGpsEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsEphemerisDoubleParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsEphemerisDoubleParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGpsEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGpsEphemerisDoubleParam::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetGpsEphemerisDoubleParam::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisDoubleParam
///
#include "gen/GetGpsEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisDoubleParam::CmdName = "GetGpsEphemerisDoubleParam";
    const char* const GetGpsEphemerisDoubleParam::Documentation = "Please note the command GpsEphemerisDoubleParam is deprecated since 21.3. You may use GpsEphDoubleParamForSV.\n\nGet various parameters in the GPS ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"IscL1Ca\"         sec\n  \"IscL2C\"          sec\n  \"IscL5I5\"         sec\n  \"IscL5Q5\"         sec\n  \"IscL1CP\"         sec\n  \"IscL1CD\"         sec";

    REGISTER_COMMAND_FACTORY(GetGpsEphemerisDoubleParam);


    GetGpsEphemerisDoubleParam::GetGpsEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    GetGpsEphemerisDoubleParam::GetGpsEphemerisDoubleParam(int prn, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
    }


    GetGpsEphemerisDoubleParamPtr GetGpsEphemerisDoubleParam::create(int prn, const std::string& paramName)
    {
      return GetGpsEphemerisDoubleParamPtr(new GetGpsEphemerisDoubleParam(prn, paramName));
    }

    GetGpsEphemerisDoubleParamPtr GetGpsEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisDoubleParam>(ptr);
    }

    bool GetGpsEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGpsEphemerisDoubleParam::documentation() const { return Documentation; }


    int GetGpsEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsEphemerisDoubleParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsEphemerisDoubleParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisDoubleParamResult
///
#include "gen/GetGpsEphemerisDoubleParamResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisDoubleParamResult::CmdName = "GetGpsEphemerisDoubleParamResult";
    const char* const GetGpsEphemerisDoubleParamResult::Documentation = "Result of GetGpsEphemerisDoubleParam";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphemerisDoubleParamResult);


    GetGpsEphemerisDoubleParamResult::GetGpsEphemerisDoubleParamResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphemerisDoubleParamResult::GetGpsEphemerisDoubleParamResult(CommandBasePtr relatedCommand, int prn, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    GetGpsEphemerisDoubleParamResultPtr GetGpsEphemerisDoubleParamResult::create(CommandBasePtr relatedCommand, int prn, const std::string& paramName, double val)
    {
      return GetGpsEphemerisDoubleParamResultPtr(new GetGpsEphemerisDoubleParamResult(relatedCommand, prn, paramName, val));
    }

    GetGpsEphemerisDoubleParamResultPtr GetGpsEphemerisDoubleParamResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisDoubleParamResult>(ptr);
    }

    bool GetGpsEphemerisDoubleParamResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGpsEphemerisDoubleParamResult::documentation() const { return Documentation; }


    int GetGpsEphemerisDoubleParamResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsEphemerisDoubleParamResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphemerisDoubleParamResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphemerisDoubleParamResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGpsEphemerisDoubleParamResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetGpsEphemerisDoubleParamResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoEphemerisDoubleParam
///
#include "gen/SetGalileoEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoEphemerisDoubleParam::CmdName = "SetGalileoEphemerisDoubleParam";
    const char* const SetGalileoEphemerisDoubleParam::Documentation = "Please note the command GalileoEphemerisDoubleParam is deprecated since 21.3. You may use GalileoEphDoubleParamForSV.\n\nSet various parameters in the Galileo ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"BgdE1E5a\"        ns\n  \"BgdE1E5b\"        ns";

    REGISTER_COMMAND_FACTORY(SetGalileoEphemerisDoubleParam);


    SetGalileoEphemerisDoubleParam::SetGalileoEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    SetGalileoEphemerisDoubleParam::SetGalileoEphemerisDoubleParam(int prn, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    SetGalileoEphemerisDoubleParamPtr SetGalileoEphemerisDoubleParam::create(int prn, const std::string& paramName, double val)
    {
      return SetGalileoEphemerisDoubleParamPtr(new SetGalileoEphemerisDoubleParam(prn, paramName, val));
    }

    SetGalileoEphemerisDoubleParamPtr SetGalileoEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoEphemerisDoubleParam>(ptr);
    }

    bool SetGalileoEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGalileoEphemerisDoubleParam::documentation() const { return Documentation; }


    int SetGalileoEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGalileoEphemerisDoubleParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoEphemerisDoubleParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGalileoEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGalileoEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGalileoEphemerisDoubleParam::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetGalileoEphemerisDoubleParam::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphemerisDoubleParam
///
#include "gen/GetGalileoEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphemerisDoubleParam::CmdName = "GetGalileoEphemerisDoubleParam";
    const char* const GetGalileoEphemerisDoubleParam::Documentation = "Please note the command GalileoEphemerisDoubleParam is deprecated since 21.3. You may use GalileoEphDoubleParamForSV.\n\nGet various parameters in the Galileo ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd\"             sec\n  \"BgdE1E5a\"        ns\n  \"BgdE1E5b\"        ns";

    REGISTER_COMMAND_FACTORY(GetGalileoEphemerisDoubleParam);


    GetGalileoEphemerisDoubleParam::GetGalileoEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    GetGalileoEphemerisDoubleParam::GetGalileoEphemerisDoubleParam(int prn, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
    }


    GetGalileoEphemerisDoubleParamPtr GetGalileoEphemerisDoubleParam::create(int prn, const std::string& paramName)
    {
      return GetGalileoEphemerisDoubleParamPtr(new GetGalileoEphemerisDoubleParam(prn, paramName));
    }

    GetGalileoEphemerisDoubleParamPtr GetGalileoEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphemerisDoubleParam>(ptr);
    }

    bool GetGalileoEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGalileoEphemerisDoubleParam::documentation() const { return Documentation; }


    int GetGalileoEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoEphemerisDoubleParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoEphemerisDoubleParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoEphemerisDoubleParamResult
///
#include "gen/GetGalileoEphemerisDoubleParamResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoEphemerisDoubleParamResult::CmdName = "GetGalileoEphemerisDoubleParamResult";
    const char* const GetGalileoEphemerisDoubleParamResult::Documentation = "Result of GetGalileoEphemerisDoubleParam";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoEphemerisDoubleParamResult);


    GetGalileoEphemerisDoubleParamResult::GetGalileoEphemerisDoubleParamResult()
      : CommandResult(CmdName)
    {}

    GetGalileoEphemerisDoubleParamResult::GetGalileoEphemerisDoubleParamResult(CommandBasePtr relatedCommand, int prn, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    GetGalileoEphemerisDoubleParamResultPtr GetGalileoEphemerisDoubleParamResult::create(CommandBasePtr relatedCommand, int prn, const std::string& paramName, double val)
    {
      return GetGalileoEphemerisDoubleParamResultPtr(new GetGalileoEphemerisDoubleParamResult(relatedCommand, prn, paramName, val));
    }

    GetGalileoEphemerisDoubleParamResultPtr GetGalileoEphemerisDoubleParamResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoEphemerisDoubleParamResult>(ptr);
    }

    bool GetGalileoEphemerisDoubleParamResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGalileoEphemerisDoubleParamResult::documentation() const { return Documentation; }


    int GetGalileoEphemerisDoubleParamResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoEphemerisDoubleParamResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoEphemerisDoubleParamResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGalileoEphemerisDoubleParamResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGalileoEphemerisDoubleParamResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetGalileoEphemerisDoubleParamResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphemerisDoubleParam
///
#include "gen/SetBeiDouEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphemerisDoubleParam::CmdName = "SetBeiDouEphemerisDoubleParam";
    const char* const SetBeiDouEphemerisDoubleParam::Documentation = "Please note the command BeiDouEphemerisDoubleParam is deprecated since 21.3. You may use BeiDouEphDoubleParamForSV.\n\nSet various parameters in the BeiDou ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd1\"            sec\n  \"Tgd2\"            sec\n  \"TgdB1Cp\"         sec\n  \"TgdB2Ap\"         sec";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphemerisDoubleParam);


    SetBeiDouEphemerisDoubleParam::SetBeiDouEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphemerisDoubleParam::SetBeiDouEphemerisDoubleParam(int prn, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    SetBeiDouEphemerisDoubleParamPtr SetBeiDouEphemerisDoubleParam::create(int prn, const std::string& paramName, double val)
    {
      return SetBeiDouEphemerisDoubleParamPtr(new SetBeiDouEphemerisDoubleParam(prn, paramName, val));
    }

    SetBeiDouEphemerisDoubleParamPtr SetBeiDouEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphemerisDoubleParam>(ptr);
    }

    bool SetBeiDouEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetBeiDouEphemerisDoubleParam::documentation() const { return Documentation; }


    int SetBeiDouEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetBeiDouEphemerisDoubleParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouEphemerisDoubleParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetBeiDouEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetBeiDouEphemerisDoubleParam::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetBeiDouEphemerisDoubleParam::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisDoubleParam
///
#include "gen/GetBeiDouEphemerisDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisDoubleParam::CmdName = "GetBeiDouEphemerisDoubleParam";
    const char* const GetBeiDouEphemerisDoubleParam::Documentation = "Please note the command BeiDouEphemerisDoubleParam is deprecated since 21.3. You may use BeiDouEphDoubleParamForSV.\n\nGet various parameters in the BeiDou ephemeris\n\n  ParamName         Unit\n  \"ClockBias\"       sec\n  \"ClockDrift\"      sec/sec\n  \"ClockDriftRate\"  sec/sec^2\n  \"Crs\"             meter\n  \"Crc\"             meter\n  \"Cis\"             rad\n  \"Cic\"             rad\n  \"Cus\"             rad\n  \"Cuc\"             rad\n  \"DeltaN\"          rad/sec\n  \"M0\"              rad\n  \"Eccentricity\"    -\n  \"SqrtA\"           sqrt(meter)\n  \"BigOmega\"        rad\n  \"I0\"              rad\n  \"LittleOmega\"     rad\n  \"BigOmegaDot\"     rad/sec\n  \"Idot\"            rad/sec\n  \"Accuracy\"        meter\n  \"Adot\"            meters/sec\n  \"DeltaN0dot\"      rad/sec^2\n  \"Tgd1\"            sec\n  \"Tgd2\"            sec\n  \"TgdB1Cp\"         sec\n  \"TgdB2Ap\"         sec";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphemerisDoubleParam);


    GetBeiDouEphemerisDoubleParam::GetBeiDouEphemerisDoubleParam()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphemerisDoubleParam::GetBeiDouEphemerisDoubleParam(int prn, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
    }


    GetBeiDouEphemerisDoubleParamPtr GetBeiDouEphemerisDoubleParam::create(int prn, const std::string& paramName)
    {
      return GetBeiDouEphemerisDoubleParamPtr(new GetBeiDouEphemerisDoubleParam(prn, paramName));
    }

    GetBeiDouEphemerisDoubleParamPtr GetBeiDouEphemerisDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisDoubleParam>(ptr);
    }

    bool GetBeiDouEphemerisDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetBeiDouEphemerisDoubleParam::documentation() const { return Documentation; }


    int GetBeiDouEphemerisDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouEphemerisDoubleParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouEphemerisDoubleParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphemerisDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphemerisDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisDoubleParamResult
///
#include "gen/GetBeiDouEphemerisDoubleParamResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisDoubleParamResult::CmdName = "GetBeiDouEphemerisDoubleParamResult";
    const char* const GetBeiDouEphemerisDoubleParamResult::Documentation = "Result of GetBeiDouEphemerisDoubleParam";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphemerisDoubleParamResult);


    GetBeiDouEphemerisDoubleParamResult::GetBeiDouEphemerisDoubleParamResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphemerisDoubleParamResult::GetBeiDouEphemerisDoubleParamResult(CommandBasePtr relatedCommand, int prn, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    GetBeiDouEphemerisDoubleParamResultPtr GetBeiDouEphemerisDoubleParamResult::create(CommandBasePtr relatedCommand, int prn, const std::string& paramName, double val)
    {
      return GetBeiDouEphemerisDoubleParamResultPtr(new GetBeiDouEphemerisDoubleParamResult(relatedCommand, prn, paramName, val));
    }

    GetBeiDouEphemerisDoubleParamResultPtr GetBeiDouEphemerisDoubleParamResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisDoubleParamResult>(ptr);
    }

    bool GetBeiDouEphemerisDoubleParamResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetBeiDouEphemerisDoubleParamResult::documentation() const { return Documentation; }


    int GetBeiDouEphemerisDoubleParamResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouEphemerisDoubleParamResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphemerisDoubleParamResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphemerisDoubleParamResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetBeiDouEphemerisDoubleParamResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetBeiDouEphemerisDoubleParamResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassDoubleParam
///
#include "gen/SetGlonassDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassDoubleParam::CmdName = "SetGlonassDoubleParam";
    const char* const SetGlonassDoubleParam::Documentation = "Please note the command GlonassDoubleParam is deprecated since 21.3. You may use GlonassEphDoubleParamForSV.\n\nSet various parameters for GLONASS\n\n  ParamName       Unit               Range          Description\n  \"TauC\"          sec                +/- 1          GLONASS time scale correction to UTC(SU) time\n  \"TauGps\"        day                +/- 1.9x10^-3  Correction to GPS time relative to GLONASS time\n  \"TauN\"          sec                +/- 1.9x10^-3  Coarse value of satellite time correction to GLONASS time\n  \"TLambda\"       sec                0..44100       Time of the first ascending node passage\n  \"Lambda\"        semicircle         +/- 1          Longitude of the first ascending node\n  \"DeltaI\"        semicircle         +/- 0.067      Correction to the mean value of inclination\n  \"Omega\"         semicircle         +/- 1          Argument of perigee\n  \"Eccentricity\"  -                  0..0.03        Eccentricity\n  \"DeltaT\"        sec/orb. period    +/- 3.6x10^3   Correction to the mean value of Draconian period\n  \"DeltaTRate\"    sec/orb. period^2  +/- 2^-8       Rate of change of Draconian period";

    REGISTER_COMMAND_FACTORY(SetGlonassDoubleParam);


    SetGlonassDoubleParam::SetGlonassDoubleParam()
      : CommandBase(CmdName)
    {}

    SetGlonassDoubleParam::SetGlonassDoubleParam(int prn, const std::string& paramName, double val)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    SetGlonassDoubleParamPtr SetGlonassDoubleParam::create(int prn, const std::string& paramName, double val)
    {
      return SetGlonassDoubleParamPtr(new SetGlonassDoubleParam(prn, paramName, val));
    }

    SetGlonassDoubleParamPtr SetGlonassDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassDoubleParam>(ptr);
    }

    bool SetGlonassDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGlonassDoubleParam::documentation() const { return Documentation; }


    int SetGlonassDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGlonassDoubleParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGlonassDoubleParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGlonassDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGlonassDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetGlonassDoubleParam::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void SetGlonassDoubleParam::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassDoubleParam
///
#include "gen/GetGlonassDoubleParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassDoubleParam::CmdName = "GetGlonassDoubleParam";
    const char* const GetGlonassDoubleParam::Documentation = "Please note the command GlonassDoubleParam is deprecated since 21.3. You may use GlonassEphDoubleParamForSV.\n\nGet various parameters for GLONASS\n\n  ParamName       Unit               Range          Description\n  \"TauC\"          sec                +/- 1          GLONASS time scale correction to UTC(SU) time\n  \"TauGps\"        day                +/- 1.9x10^-3  Correction to GPS time relative to GLONASS time\n  \"TauN\"          sec                +/- 1.9x10^-3  Coarse value of satellite time correction to GLONASS time\n  \"TLambda\"       sec                0..44100       Time of the first ascending node passage\n  \"Lambda\"        semicircle         +/- 1          Longitude of the first ascending node\n  \"DeltaI\"        semicircle         +/- 0.067      Correction to the mean value of inclination\n  \"Omega\"         semicircle         +/- 1          Argument of perigee\n  \"Eccentricity\"  -                  0..0.03        Eccentricity\n  \"DeltaT\"        sec/orb. period    +/- 3.6x10^3   Correction to the mean value of Draconian period\n  \"DeltaTRate\"    sec/orb. period^2  +/- 2^-8       Rate of change of Draconian period";

    REGISTER_COMMAND_FACTORY(GetGlonassDoubleParam);


    GetGlonassDoubleParam::GetGlonassDoubleParam()
      : CommandBase(CmdName)
    {}

    GetGlonassDoubleParam::GetGlonassDoubleParam(int prn, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
    }


    GetGlonassDoubleParamPtr GetGlonassDoubleParam::create(int prn, const std::string& paramName)
    {
      return GetGlonassDoubleParamPtr(new GetGlonassDoubleParam(prn, paramName));
    }

    GetGlonassDoubleParamPtr GetGlonassDoubleParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassDoubleParam>(ptr);
    }

    bool GetGlonassDoubleParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGlonassDoubleParam::documentation() const { return Documentation; }


    int GetGlonassDoubleParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassDoubleParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGlonassDoubleParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGlonassDoubleParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassDoubleParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassDoubleParamResult
///
#include "gen/GetGlonassDoubleParamResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassDoubleParamResult::CmdName = "GetGlonassDoubleParamResult";
    const char* const GetGlonassDoubleParamResult::Documentation = "Result of GetGlonassDoubleParam";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassDoubleParamResult);


    GetGlonassDoubleParamResult::GetGlonassDoubleParamResult()
      : CommandResult(CmdName)
    {}

    GetGlonassDoubleParamResult::GetGlonassDoubleParamResult(CommandBasePtr relatedCommand, int prn, const std::string& paramName, double val)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    GetGlonassDoubleParamResultPtr GetGlonassDoubleParamResult::create(CommandBasePtr relatedCommand, int prn, const std::string& paramName, double val)
    {
      return GetGlonassDoubleParamResultPtr(new GetGlonassDoubleParamResult(relatedCommand, prn, paramName, val));
    }

    GetGlonassDoubleParamResultPtr GetGlonassDoubleParamResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassDoubleParamResult>(ptr);
    }

    bool GetGlonassDoubleParamResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<double>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGlonassDoubleParamResult::documentation() const { return Documentation; }


    int GetGlonassDoubleParamResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGlonassDoubleParamResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGlonassDoubleParamResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGlonassDoubleParamResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetGlonassDoubleParamResult::val() const
    {
      return parse_json<double>::parse(m_values["Val"]);
    }

    void GetGlonassDoubleParamResult::setVal(double val)
    {
      m_values.AddMember("Val", parse_json<double>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassSatelliteEphemerisHealthFlag
///
#include "gen/SetGlonassSatelliteEphemerisHealthFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassSatelliteEphemerisHealthFlag::CmdName = "SetGlonassSatelliteEphemerisHealthFlag";
    const char* const SetGlonassSatelliteEphemerisHealthFlag::Documentation = "Please note the command GlonassSatelliteEphemerisHealthFlag is deprecated since 21.3. You may use GlonassEphemerisHealthFlagForSV.\n\nSet GLONASS satellite Ephemeris Health Flag Bn(ln)";

    REGISTER_COMMAND_FACTORY(SetGlonassSatelliteEphemerisHealthFlag);


    SetGlonassSatelliteEphemerisHealthFlag::SetGlonassSatelliteEphemerisHealthFlag()
      : CommandBase(CmdName)
    {}

    SetGlonassSatelliteEphemerisHealthFlag::SetGlonassSatelliteEphemerisHealthFlag(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetGlonassSatelliteEphemerisHealthFlagPtr SetGlonassSatelliteEphemerisHealthFlag::create(int prn, bool health)
    {
      return SetGlonassSatelliteEphemerisHealthFlagPtr(new SetGlonassSatelliteEphemerisHealthFlag(prn, health));
    }

    SetGlonassSatelliteEphemerisHealthFlagPtr SetGlonassSatelliteEphemerisHealthFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassSatelliteEphemerisHealthFlag>(ptr);
    }

    bool SetGlonassSatelliteEphemerisHealthFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGlonassSatelliteEphemerisHealthFlag::documentation() const { return Documentation; }


    int SetGlonassSatelliteEphemerisHealthFlag::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGlonassSatelliteEphemerisHealthFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGlonassSatelliteEphemerisHealthFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGlonassSatelliteEphemerisHealthFlag::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGlonassSatelliteEphemerisHealthFlag::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassSatelliteEphemerisHealthFlag
///
#include "gen/GetGlonassSatelliteEphemerisHealthFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassSatelliteEphemerisHealthFlag::CmdName = "GetGlonassSatelliteEphemerisHealthFlag";
    const char* const GetGlonassSatelliteEphemerisHealthFlag::Documentation = "Please note the command GlonassSatelliteEphemerisHealthFlag is deprecated since 21.3. You may use GlonassEphemerisHealthFlagForSV.\n\nGet GLONASS satellite Ephemeris Health Flag Bn(ln)";

    REGISTER_COMMAND_FACTORY(GetGlonassSatelliteEphemerisHealthFlag);


    GetGlonassSatelliteEphemerisHealthFlag::GetGlonassSatelliteEphemerisHealthFlag()
      : CommandBase(CmdName)
    {}

    GetGlonassSatelliteEphemerisHealthFlag::GetGlonassSatelliteEphemerisHealthFlag(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGlonassSatelliteEphemerisHealthFlagPtr GetGlonassSatelliteEphemerisHealthFlag::create(int prn)
    {
      return GetGlonassSatelliteEphemerisHealthFlagPtr(new GetGlonassSatelliteEphemerisHealthFlag(prn));
    }

    GetGlonassSatelliteEphemerisHealthFlagPtr GetGlonassSatelliteEphemerisHealthFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassSatelliteEphemerisHealthFlag>(ptr);
    }

    bool GetGlonassSatelliteEphemerisHealthFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGlonassSatelliteEphemerisHealthFlag::documentation() const { return Documentation; }


    int GetGlonassSatelliteEphemerisHealthFlag::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassSatelliteEphemerisHealthFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGlonassSatelliteEphemerisHealthFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassSatelliteEphemerisHealthFlagResult
///
#include "gen/GetGlonassSatelliteEphemerisHealthFlagResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassSatelliteEphemerisHealthFlagResult::CmdName = "GetGlonassSatelliteEphemerisHealthFlagResult";
    const char* const GetGlonassSatelliteEphemerisHealthFlagResult::Documentation = "Result of GetGlonassSatelliteEphemerisHealthFlag";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassSatelliteEphemerisHealthFlagResult);


    GetGlonassSatelliteEphemerisHealthFlagResult::GetGlonassSatelliteEphemerisHealthFlagResult()
      : CommandResult(CmdName)
    {}

    GetGlonassSatelliteEphemerisHealthFlagResult::GetGlonassSatelliteEphemerisHealthFlagResult(CommandBasePtr relatedCommand, int prn, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetGlonassSatelliteEphemerisHealthFlagResultPtr GetGlonassSatelliteEphemerisHealthFlagResult::create(CommandBasePtr relatedCommand, int prn, bool health)
    {
      return GetGlonassSatelliteEphemerisHealthFlagResultPtr(new GetGlonassSatelliteEphemerisHealthFlagResult(relatedCommand, prn, health));
    }

    GetGlonassSatelliteEphemerisHealthFlagResultPtr GetGlonassSatelliteEphemerisHealthFlagResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassSatelliteEphemerisHealthFlagResult>(ptr);
    }

    bool GetGlonassSatelliteEphemerisHealthFlagResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGlonassSatelliteEphemerisHealthFlagResult::documentation() const { return Documentation; }


    int GetGlonassSatelliteEphemerisHealthFlagResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGlonassSatelliteEphemerisHealthFlagResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGlonassSatelliteEphemerisHealthFlagResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGlonassSatelliteEphemerisHealthFlagResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGlonassSatelliteAlmanacUnhealthyFlag
///
#include "gen/SetGlonassSatelliteAlmanacUnhealthyFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGlonassSatelliteAlmanacUnhealthyFlag::CmdName = "SetGlonassSatelliteAlmanacUnhealthyFlag";
    const char* const SetGlonassSatelliteAlmanacUnhealthyFlag::Documentation = "Please note the command GlonassSatelliteAlmanacUnhealthyFlag is deprecated since 21.3. You may use GlonassAlmanacUnhealthyFlagForSV.\n\nSet GLONASS satellite Almanac Unhealthy Flag Cn";

    REGISTER_COMMAND_FACTORY(SetGlonassSatelliteAlmanacUnhealthyFlag);


    SetGlonassSatelliteAlmanacUnhealthyFlag::SetGlonassSatelliteAlmanacUnhealthyFlag()
      : CommandBase(CmdName)
    {}

    SetGlonassSatelliteAlmanacUnhealthyFlag::SetGlonassSatelliteAlmanacUnhealthyFlag(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetGlonassSatelliteAlmanacUnhealthyFlagPtr SetGlonassSatelliteAlmanacUnhealthyFlag::create(int prn, bool health)
    {
      return SetGlonassSatelliteAlmanacUnhealthyFlagPtr(new SetGlonassSatelliteAlmanacUnhealthyFlag(prn, health));
    }

    SetGlonassSatelliteAlmanacUnhealthyFlagPtr SetGlonassSatelliteAlmanacUnhealthyFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGlonassSatelliteAlmanacUnhealthyFlag>(ptr);
    }

    bool SetGlonassSatelliteAlmanacUnhealthyFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGlonassSatelliteAlmanacUnhealthyFlag::documentation() const { return Documentation; }


    int SetGlonassSatelliteAlmanacUnhealthyFlag::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGlonassSatelliteAlmanacUnhealthyFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGlonassSatelliteAlmanacUnhealthyFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGlonassSatelliteAlmanacUnhealthyFlag::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGlonassSatelliteAlmanacUnhealthyFlag::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassSatelliteAlmanacUnhealthyFlag
///
#include "gen/GetGlonassSatelliteAlmanacUnhealthyFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassSatelliteAlmanacUnhealthyFlag::CmdName = "GetGlonassSatelliteAlmanacUnhealthyFlag";
    const char* const GetGlonassSatelliteAlmanacUnhealthyFlag::Documentation = "Please note the command GlonassSatelliteAlmanacUnhealthyFlag is deprecated since 21.3. You may use GlonassAlmanacUnhealthyFlagForSV.\n\nGet GLONASS satellite Almanac Unhealthy Flag Cn";

    REGISTER_COMMAND_FACTORY(GetGlonassSatelliteAlmanacUnhealthyFlag);


    GetGlonassSatelliteAlmanacUnhealthyFlag::GetGlonassSatelliteAlmanacUnhealthyFlag()
      : CommandBase(CmdName)
    {}

    GetGlonassSatelliteAlmanacUnhealthyFlag::GetGlonassSatelliteAlmanacUnhealthyFlag(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGlonassSatelliteAlmanacUnhealthyFlagPtr GetGlonassSatelliteAlmanacUnhealthyFlag::create(int prn)
    {
      return GetGlonassSatelliteAlmanacUnhealthyFlagPtr(new GetGlonassSatelliteAlmanacUnhealthyFlag(prn));
    }

    GetGlonassSatelliteAlmanacUnhealthyFlagPtr GetGlonassSatelliteAlmanacUnhealthyFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassSatelliteAlmanacUnhealthyFlag>(ptr);
    }

    bool GetGlonassSatelliteAlmanacUnhealthyFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGlonassSatelliteAlmanacUnhealthyFlag::documentation() const { return Documentation; }


    int GetGlonassSatelliteAlmanacUnhealthyFlag::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassSatelliteAlmanacUnhealthyFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGlonassSatelliteAlmanacUnhealthyFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassSatelliteAlmanacUnhealthyFlagResult
///
#include "gen/GetGlonassSatelliteAlmanacUnhealthyFlagResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassSatelliteAlmanacUnhealthyFlagResult::CmdName = "GetGlonassSatelliteAlmanacUnhealthyFlagResult";
    const char* const GetGlonassSatelliteAlmanacUnhealthyFlagResult::Documentation = "Result of GetGlonassSatelliteAlmanacUnhealthyFlag";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassSatelliteAlmanacUnhealthyFlagResult);


    GetGlonassSatelliteAlmanacUnhealthyFlagResult::GetGlonassSatelliteAlmanacUnhealthyFlagResult()
      : CommandResult(CmdName)
    {}

    GetGlonassSatelliteAlmanacUnhealthyFlagResult::GetGlonassSatelliteAlmanacUnhealthyFlagResult(CommandBasePtr relatedCommand, int prn, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetGlonassSatelliteAlmanacUnhealthyFlagResultPtr GetGlonassSatelliteAlmanacUnhealthyFlagResult::create(CommandBasePtr relatedCommand, int prn, bool health)
    {
      return GetGlonassSatelliteAlmanacUnhealthyFlagResultPtr(new GetGlonassSatelliteAlmanacUnhealthyFlagResult(relatedCommand, prn, health));
    }

    GetGlonassSatelliteAlmanacUnhealthyFlagResultPtr GetGlonassSatelliteAlmanacUnhealthyFlagResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassSatelliteAlmanacUnhealthyFlagResult>(ptr);
    }

    bool GetGlonassSatelliteAlmanacUnhealthyFlagResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGlonassSatelliteAlmanacUnhealthyFlagResult::documentation() const { return Documentation; }


    int GetGlonassSatelliteAlmanacUnhealthyFlagResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGlonassSatelliteAlmanacUnhealthyFlagResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGlonassSatelliteAlmanacUnhealthyFlagResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGlonassSatelliteAlmanacUnhealthyFlagResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSatelliteSignalHealth
///
#include "gen/SetGalileoSatelliteSignalHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSatelliteSignalHealth::CmdName = "SetGalileoSatelliteSignalHealth";
    const char* const SetGalileoSatelliteSignalHealth::Documentation = "Please note the command GalileoSatelliteSignalHealth is deprecated since 21.3. You may use GalileoSignalHealthForSV.\n\nSet Galileo signal health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(SetGalileoSatelliteSignalHealth);


    SetGalileoSatelliteSignalHealth::SetGalileoSatelliteSignalHealth()
      : CommandBase(CmdName)
    {}

    SetGalileoSatelliteSignalHealth::SetGalileoSatelliteSignalHealth(int prn, const std::string& component, int health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setComponent(component);
      setHealth(health);
    }


    SetGalileoSatelliteSignalHealthPtr SetGalileoSatelliteSignalHealth::create(int prn, const std::string& component, int health)
    {
      return SetGalileoSatelliteSignalHealthPtr(new SetGalileoSatelliteSignalHealth(prn, component, health));
    }

    SetGalileoSatelliteSignalHealthPtr SetGalileoSatelliteSignalHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSatelliteSignalHealth>(ptr);
    }

    bool SetGalileoSatelliteSignalHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGalileoSatelliteSignalHealth::documentation() const { return Documentation; }


    int SetGalileoSatelliteSignalHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGalileoSatelliteSignalHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoSatelliteSignalHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGalileoSatelliteSignalHealth::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void SetGalileoSatelliteSignalHealth::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoSatelliteSignalHealth::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetGalileoSatelliteSignalHealth::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoSatelliteSignalHealth
///
#include "gen/GetGalileoSatelliteSignalHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoSatelliteSignalHealth::CmdName = "GetGalileoSatelliteSignalHealth";
    const char* const GetGalileoSatelliteSignalHealth::Documentation = "Please note the command GalileoSatelliteSignalHealth is deprecated since 21.3. You may use GalileoSignalHealthForSV.\n\nGet Galileo signal health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(GetGalileoSatelliteSignalHealth);


    GetGalileoSatelliteSignalHealth::GetGalileoSatelliteSignalHealth()
      : CommandBase(CmdName)
    {}

    GetGalileoSatelliteSignalHealth::GetGalileoSatelliteSignalHealth(int prn, const std::string& component)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setComponent(component);
    }


    GetGalileoSatelliteSignalHealthPtr GetGalileoSatelliteSignalHealth::create(int prn, const std::string& component)
    {
      return GetGalileoSatelliteSignalHealthPtr(new GetGalileoSatelliteSignalHealth(prn, component));
    }

    GetGalileoSatelliteSignalHealthPtr GetGalileoSatelliteSignalHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoSatelliteSignalHealth>(ptr);
    }

    bool GetGalileoSatelliteSignalHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Component"])
        ;

    }

    std::string GetGalileoSatelliteSignalHealth::documentation() const { return Documentation; }


    int GetGalileoSatelliteSignalHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoSatelliteSignalHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoSatelliteSignalHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoSatelliteSignalHealth::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoSatelliteSignalHealth::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoSatelliteSignalHealthResult
///
#include "gen/GetGalileoSatelliteSignalHealthResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoSatelliteSignalHealthResult::CmdName = "GetGalileoSatelliteSignalHealthResult";
    const char* const GetGalileoSatelliteSignalHealthResult::Documentation = "Result of GetGalileoSatelliteSignalHealth";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoSatelliteSignalHealthResult);


    GetGalileoSatelliteSignalHealthResult::GetGalileoSatelliteSignalHealthResult()
      : CommandResult(CmdName)
    {}

    GetGalileoSatelliteSignalHealthResult::GetGalileoSatelliteSignalHealthResult(CommandBasePtr relatedCommand, int prn, const std::string& component, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setComponent(component);
      setHealth(health);
    }


    GetGalileoSatelliteSignalHealthResultPtr GetGalileoSatelliteSignalHealthResult::create(CommandBasePtr relatedCommand, int prn, const std::string& component, int health)
    {
      return GetGalileoSatelliteSignalHealthResultPtr(new GetGalileoSatelliteSignalHealthResult(relatedCommand, prn, component, health));
    }

    GetGalileoSatelliteSignalHealthResultPtr GetGalileoSatelliteSignalHealthResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoSatelliteSignalHealthResult>(ptr);
    }

    bool GetGalileoSatelliteSignalHealthResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGalileoSatelliteSignalHealthResult::documentation() const { return Documentation; }


    int GetGalileoSatelliteSignalHealthResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoSatelliteSignalHealthResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoSatelliteSignalHealthResult::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoSatelliteSignalHealthResult::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoSatelliteSignalHealthResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetGalileoSatelliteSignalHealthResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSatelliteDataHealth
///
#include "gen/SetGalileoSatelliteDataHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSatelliteDataHealth::CmdName = "SetGalileoSatelliteDataHealth";
    const char* const SetGalileoSatelliteDataHealth::Documentation = "Please note the command GalileoSatelliteDataHealth is deprecated since 21.3. You may use GalileoDataHealthForSV.\n\nSet Galileo data health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(SetGalileoSatelliteDataHealth);


    SetGalileoSatelliteDataHealth::SetGalileoSatelliteDataHealth()
      : CommandBase(CmdName)
    {}

    SetGalileoSatelliteDataHealth::SetGalileoSatelliteDataHealth(int prn, const std::string& component, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setComponent(component);
      setHealth(health);
    }


    SetGalileoSatelliteDataHealthPtr SetGalileoSatelliteDataHealth::create(int prn, const std::string& component, bool health)
    {
      return SetGalileoSatelliteDataHealthPtr(new SetGalileoSatelliteDataHealth(prn, component, health));
    }

    SetGalileoSatelliteDataHealthPtr SetGalileoSatelliteDataHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSatelliteDataHealth>(ptr);
    }

    bool SetGalileoSatelliteDataHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGalileoSatelliteDataHealth::documentation() const { return Documentation; }


    int SetGalileoSatelliteDataHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGalileoSatelliteDataHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoSatelliteDataHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGalileoSatelliteDataHealth::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void SetGalileoSatelliteDataHealth::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGalileoSatelliteDataHealth::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGalileoSatelliteDataHealth::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoSatelliteDataHealth
///
#include "gen/GetGalileoSatelliteDataHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoSatelliteDataHealth::CmdName = "GetGalileoSatelliteDataHealth";
    const char* const GetGalileoSatelliteDataHealth::Documentation = "Please note the command GalileoSatelliteDataHealth is deprecated since 21.3. You may use GalileoDataHealthForSV.\n\nGet Galileo data health for I/NAV and F/NAV message";

    REGISTER_COMMAND_FACTORY(GetGalileoSatelliteDataHealth);


    GetGalileoSatelliteDataHealth::GetGalileoSatelliteDataHealth()
      : CommandBase(CmdName)
    {}

    GetGalileoSatelliteDataHealth::GetGalileoSatelliteDataHealth(int prn, const std::string& component)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setComponent(component);
    }


    GetGalileoSatelliteDataHealthPtr GetGalileoSatelliteDataHealth::create(int prn, const std::string& component)
    {
      return GetGalileoSatelliteDataHealthPtr(new GetGalileoSatelliteDataHealth(prn, component));
    }

    GetGalileoSatelliteDataHealthPtr GetGalileoSatelliteDataHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoSatelliteDataHealth>(ptr);
    }

    bool GetGalileoSatelliteDataHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Component"])
        ;

    }

    std::string GetGalileoSatelliteDataHealth::documentation() const { return Documentation; }


    int GetGalileoSatelliteDataHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoSatelliteDataHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoSatelliteDataHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoSatelliteDataHealth::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoSatelliteDataHealth::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoSatelliteDataHealthResult
///
#include "gen/GetGalileoSatelliteDataHealthResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoSatelliteDataHealthResult::CmdName = "GetGalileoSatelliteDataHealthResult";
    const char* const GetGalileoSatelliteDataHealthResult::Documentation = "Result of GetGalileoSatelliteDataHealth";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoSatelliteDataHealthResult);


    GetGalileoSatelliteDataHealthResult::GetGalileoSatelliteDataHealthResult()
      : CommandResult(CmdName)
    {}

    GetGalileoSatelliteDataHealthResult::GetGalileoSatelliteDataHealthResult(CommandBasePtr relatedCommand, int prn, const std::string& component, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setComponent(component);
      setHealth(health);
    }


    GetGalileoSatelliteDataHealthResultPtr GetGalileoSatelliteDataHealthResult::create(CommandBasePtr relatedCommand, int prn, const std::string& component, bool health)
    {
      return GetGalileoSatelliteDataHealthResultPtr(new GetGalileoSatelliteDataHealthResult(relatedCommand, prn, component, health));
    }

    GetGalileoSatelliteDataHealthResultPtr GetGalileoSatelliteDataHealthResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoSatelliteDataHealthResult>(ptr);
    }

    bool GetGalileoSatelliteDataHealthResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Component"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGalileoSatelliteDataHealthResult::documentation() const { return Documentation; }


    int GetGalileoSatelliteDataHealthResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoSatelliteDataHealthResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoSatelliteDataHealthResult::component() const
    {
      return parse_json<std::string>::parse(m_values["Component"]);
    }

    void GetGalileoSatelliteDataHealthResult::setComponent(const std::string& component)
    {
      m_values.AddMember("Component", parse_json<std::string>::format(component, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGalileoSatelliteDataHealthResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGalileoSatelliteDataHealthResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaModelToPrn
///
#include "gen/SetSVAntennaModelToPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaModelToPrn::CmdName = "SetSVAntennaModelToPrn";
    const char* const SetSVAntennaModelToPrn::Documentation = "Please note the command SVAntennaModelToPrn is deprecated since 21.3. You may use SVAntennaModelForSV.\n\nSet the antenna model used by the PRN.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaModelToPrn);


    SetSVAntennaModelToPrn::SetSVAntennaModelToPrn()
      : CommandBase(CmdName)
    {}

    SetSVAntennaModelToPrn::SetSVAntennaModelToPrn(int prn, const std::string& system, const std::string& antennaModelName)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSystem(system);
      setAntennaModelName(antennaModelName);
    }


    SetSVAntennaModelToPrnPtr SetSVAntennaModelToPrn::create(int prn, const std::string& system, const std::string& antennaModelName)
    {
      return SetSVAntennaModelToPrnPtr(new SetSVAntennaModelToPrn(prn, system, antennaModelName));
    }

    SetSVAntennaModelToPrnPtr SetSVAntennaModelToPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaModelToPrn>(ptr);
    }

    bool SetSVAntennaModelToPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
        ;

    }

    std::string SetSVAntennaModelToPrn::documentation() const { return Documentation; }


    int SetSVAntennaModelToPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetSVAntennaModelToPrn::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSVAntennaModelToPrn::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaModelToPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaModelToPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaModelToPrn::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void SetSVAntennaModelToPrn::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelToPrn
///
#include "gen/GetSVAntennaModelToPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelToPrn::CmdName = "GetSVAntennaModelToPrn";
    const char* const GetSVAntennaModelToPrn::Documentation = "Please note the command SVAntennaModelToPrn is deprecated since 21.3. You may use SVAntennaModelForSV.\n\nGet the antenna model used by the PRN.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaModelToPrn);


    GetSVAntennaModelToPrn::GetSVAntennaModelToPrn()
      : CommandBase(CmdName)
    {}

    GetSVAntennaModelToPrn::GetSVAntennaModelToPrn(int prn, const std::string& system)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSystem(system);
    }


    GetSVAntennaModelToPrnPtr GetSVAntennaModelToPrn::create(int prn, const std::string& system)
    {
      return GetSVAntennaModelToPrnPtr(new GetSVAntennaModelToPrn(prn, system));
    }

    GetSVAntennaModelToPrnPtr GetSVAntennaModelToPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelToPrn>(ptr);
    }

    bool GetSVAntennaModelToPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetSVAntennaModelToPrn::documentation() const { return Documentation; }


    int GetSVAntennaModelToPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetSVAntennaModelToPrn::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSVAntennaModelToPrn::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaModelToPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelToPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelToPrnResult
///
#include "gen/GetSVAntennaModelToPrnResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelToPrnResult::CmdName = "GetSVAntennaModelToPrnResult";
    const char* const GetSVAntennaModelToPrnResult::Documentation = "Result of GetSVAntennaModelToPrn";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaModelToPrnResult);


    GetSVAntennaModelToPrnResult::GetSVAntennaModelToPrnResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaModelToPrnResult::GetSVAntennaModelToPrnResult(CommandBasePtr relatedCommand, int prn, const std::string& system, const std::string& antennaModelName)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setSystem(system);
      setAntennaModelName(antennaModelName);
    }


    GetSVAntennaModelToPrnResultPtr GetSVAntennaModelToPrnResult::create(CommandBasePtr relatedCommand, int prn, const std::string& system, const std::string& antennaModelName)
    {
      return GetSVAntennaModelToPrnResultPtr(new GetSVAntennaModelToPrnResult(relatedCommand, prn, system, antennaModelName));
    }

    GetSVAntennaModelToPrnResultPtr GetSVAntennaModelToPrnResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelToPrnResult>(ptr);
    }

    bool GetSVAntennaModelToPrnResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::string>::is_valid(m_values["AntennaModelName"])
        ;

    }

    std::string GetSVAntennaModelToPrnResult::documentation() const { return Documentation; }


    int GetSVAntennaModelToPrnResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSVAntennaModelToPrnResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaModelToPrnResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelToPrnResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaModelToPrnResult::antennaModelName() const
    {
      return parse_json<std::string>::parse(m_values["AntennaModelName"]);
    }

    void GetSVAntennaModelToPrnResult::setAntennaModelName(const std::string& antennaModelName)
    {
      m_values.AddMember("AntennaModelName", parse_json<std::string>::format(antennaModelName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsEphemerisBoolParam
///
#include "gen/SetGpsEphemerisBoolParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsEphemerisBoolParam::CmdName = "SetGpsEphemerisBoolParam";
    const char* const SetGpsEphemerisBoolParam::Documentation = "Please note the command GpsEphemerisBoolParam is deprecated since 21.3. You may use GpsEphBoolParamForSV.\n\nSet various boolean parameters in the GPS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(SetGpsEphemerisBoolParam);


    SetGpsEphemerisBoolParam::SetGpsEphemerisBoolParam()
      : CommandBase(CmdName)
    {}

    SetGpsEphemerisBoolParam::SetGpsEphemerisBoolParam(int prn, const std::string& paramName, bool val)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    SetGpsEphemerisBoolParamPtr SetGpsEphemerisBoolParam::create(int prn, const std::string& paramName, bool val)
    {
      return SetGpsEphemerisBoolParamPtr(new SetGpsEphemerisBoolParam(prn, paramName, val));
    }

    SetGpsEphemerisBoolParamPtr SetGpsEphemerisBoolParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsEphemerisBoolParam>(ptr);
    }

    bool SetGpsEphemerisBoolParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string SetGpsEphemerisBoolParam::documentation() const { return Documentation; }


    int SetGpsEphemerisBoolParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsEphemerisBoolParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsEphemerisBoolParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetGpsEphemerisBoolParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetGpsEphemerisBoolParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsEphemerisBoolParam::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetGpsEphemerisBoolParam::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisBoolParam
///
#include "gen/GetGpsEphemerisBoolParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisBoolParam::CmdName = "GetGpsEphemerisBoolParam";
    const char* const GetGpsEphemerisBoolParam::Documentation = "Please note the command GpsEphemerisBoolParam is deprecated since 21.3. You may use GpsEphBoolParamForSV.\n\nGet various boolean parameters in the GPS ephemeris\n\n  ParamName\n\"IscL1CaAvailable\"\n\"IscL2CAvailable\"\n\"IscL5I5Available\"\n\"IscL5Q5Available\"\n\"IscL1CPAvailable\"\n\"IscL1CDAvailable\"";

    REGISTER_COMMAND_FACTORY(GetGpsEphemerisBoolParam);


    GetGpsEphemerisBoolParam::GetGpsEphemerisBoolParam()
      : CommandBase(CmdName)
    {}

    GetGpsEphemerisBoolParam::GetGpsEphemerisBoolParam(int prn, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
    }


    GetGpsEphemerisBoolParamPtr GetGpsEphemerisBoolParam::create(int prn, const std::string& paramName)
    {
      return GetGpsEphemerisBoolParamPtr(new GetGpsEphemerisBoolParam(prn, paramName));
    }

    GetGpsEphemerisBoolParamPtr GetGpsEphemerisBoolParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisBoolParam>(ptr);
    }

    bool GetGpsEphemerisBoolParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetGpsEphemerisBoolParam::documentation() const { return Documentation; }


    int GetGpsEphemerisBoolParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsEphemerisBoolParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsEphemerisBoolParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphemerisBoolParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphemerisBoolParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsEphemerisBoolParamResult
///
#include "gen/GetGpsEphemerisBoolParamResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsEphemerisBoolParamResult::CmdName = "GetGpsEphemerisBoolParamResult";
    const char* const GetGpsEphemerisBoolParamResult::Documentation = "Result of GetGpsEphemerisBoolParam";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsEphemerisBoolParamResult);


    GetGpsEphemerisBoolParamResult::GetGpsEphemerisBoolParamResult()
      : CommandResult(CmdName)
    {}

    GetGpsEphemerisBoolParamResult::GetGpsEphemerisBoolParamResult(CommandBasePtr relatedCommand, int prn, const std::string& paramName, bool val)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    GetGpsEphemerisBoolParamResultPtr GetGpsEphemerisBoolParamResult::create(CommandBasePtr relatedCommand, int prn, const std::string& paramName, bool val)
    {
      return GetGpsEphemerisBoolParamResultPtr(new GetGpsEphemerisBoolParamResult(relatedCommand, prn, paramName, val));
    }

    GetGpsEphemerisBoolParamResultPtr GetGpsEphemerisBoolParamResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsEphemerisBoolParamResult>(ptr);
    }

    bool GetGpsEphemerisBoolParamResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string GetGpsEphemerisBoolParamResult::documentation() const { return Documentation; }


    int GetGpsEphemerisBoolParamResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsEphemerisBoolParamResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsEphemerisBoolParamResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetGpsEphemerisBoolParamResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsEphemerisBoolParamResult::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void GetGpsEphemerisBoolParamResult::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouEphemerisBoolParam
///
#include "gen/SetBeiDouEphemerisBoolParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouEphemerisBoolParam::CmdName = "SetBeiDouEphemerisBoolParam";
    const char* const SetBeiDouEphemerisBoolParam::Documentation = "Please note the command BeiDouEphemerisBoolParam is deprecated since 21.3. You may use BeiDouEphBoolParamForSV.\n\nSet various boolean parameters in the BeiDou ephemeris\n\n  ParamName\n\"IscB1CdAvailable\"\n\"IscB2adAvailable\"";

    REGISTER_COMMAND_FACTORY(SetBeiDouEphemerisBoolParam);


    SetBeiDouEphemerisBoolParam::SetBeiDouEphemerisBoolParam()
      : CommandBase(CmdName)
    {}

    SetBeiDouEphemerisBoolParam::SetBeiDouEphemerisBoolParam(int prn, const std::string& paramName, bool val)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    SetBeiDouEphemerisBoolParamPtr SetBeiDouEphemerisBoolParam::create(int prn, const std::string& paramName, bool val)
    {
      return SetBeiDouEphemerisBoolParamPtr(new SetBeiDouEphemerisBoolParam(prn, paramName, val));
    }

    SetBeiDouEphemerisBoolParamPtr SetBeiDouEphemerisBoolParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouEphemerisBoolParam>(ptr);
    }

    bool SetBeiDouEphemerisBoolParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string SetBeiDouEphemerisBoolParam::documentation() const { return Documentation; }


    int SetBeiDouEphemerisBoolParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetBeiDouEphemerisBoolParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouEphemerisBoolParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetBeiDouEphemerisBoolParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void SetBeiDouEphemerisBoolParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetBeiDouEphemerisBoolParam::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void SetBeiDouEphemerisBoolParam::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisBoolParam
///
#include "gen/GetBeiDouEphemerisBoolParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisBoolParam::CmdName = "GetBeiDouEphemerisBoolParam";
    const char* const GetBeiDouEphemerisBoolParam::Documentation = "Please note the command BeiDouEphemerisBoolParam is deprecated since 21.3. You may use BeiDouEphBoolParamForSV.\n\nGet various boolean parameters in the BeiDou ephemeris\n\n  ParamName\n\"IscB1CdAvailable\"\n\"IscB2adAvailable\"";

    REGISTER_COMMAND_FACTORY(GetBeiDouEphemerisBoolParam);


    GetBeiDouEphemerisBoolParam::GetBeiDouEphemerisBoolParam()
      : CommandBase(CmdName)
    {}

    GetBeiDouEphemerisBoolParam::GetBeiDouEphemerisBoolParam(int prn, const std::string& paramName)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParamName(paramName);
    }


    GetBeiDouEphemerisBoolParamPtr GetBeiDouEphemerisBoolParam::create(int prn, const std::string& paramName)
    {
      return GetBeiDouEphemerisBoolParamPtr(new GetBeiDouEphemerisBoolParam(prn, paramName));
    }

    GetBeiDouEphemerisBoolParamPtr GetBeiDouEphemerisBoolParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisBoolParam>(ptr);
    }

    bool GetBeiDouEphemerisBoolParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
        ;

    }

    std::string GetBeiDouEphemerisBoolParam::documentation() const { return Documentation; }


    int GetBeiDouEphemerisBoolParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouEphemerisBoolParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouEphemerisBoolParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphemerisBoolParam::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphemerisBoolParam::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouEphemerisBoolParamResult
///
#include "gen/GetBeiDouEphemerisBoolParamResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouEphemerisBoolParamResult::CmdName = "GetBeiDouEphemerisBoolParamResult";
    const char* const GetBeiDouEphemerisBoolParamResult::Documentation = "Result of GetBeiDouEphemerisBoolParam";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouEphemerisBoolParamResult);


    GetBeiDouEphemerisBoolParamResult::GetBeiDouEphemerisBoolParamResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouEphemerisBoolParamResult::GetBeiDouEphemerisBoolParamResult(CommandBasePtr relatedCommand, int prn, const std::string& paramName, bool val)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setParamName(paramName);
      setVal(val);
    }


    GetBeiDouEphemerisBoolParamResultPtr GetBeiDouEphemerisBoolParamResult::create(CommandBasePtr relatedCommand, int prn, const std::string& paramName, bool val)
    {
      return GetBeiDouEphemerisBoolParamResultPtr(new GetBeiDouEphemerisBoolParamResult(relatedCommand, prn, paramName, val));
    }

    GetBeiDouEphemerisBoolParamResultPtr GetBeiDouEphemerisBoolParamResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouEphemerisBoolParamResult>(ptr);
    }

    bool GetBeiDouEphemerisBoolParamResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["ParamName"])
          && parse_json<bool>::is_valid(m_values["Val"])
        ;

    }

    std::string GetBeiDouEphemerisBoolParamResult::documentation() const { return Documentation; }


    int GetBeiDouEphemerisBoolParamResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouEphemerisBoolParamResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouEphemerisBoolParamResult::paramName() const
    {
      return parse_json<std::string>::parse(m_values["ParamName"]);
    }

    void GetBeiDouEphemerisBoolParamResult::setParamName(const std::string& paramName)
    {
      m_values.AddMember("ParamName", parse_json<std::string>::format(paramName, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouEphemerisBoolParamResult::val() const
    {
      return parse_json<bool>::parse(m_values["Val"]);
    }

    void GetBeiDouEphemerisBoolParamResult::setVal(bool val)
    {
      m_values.AddMember("Val", parse_json<bool>::format(val, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasEphemerisParams
///
#include "gen/SetSbasEphemerisParams.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasEphemerisParams::CmdName = "SetSbasEphemerisParams";
    const char* const SetSbasEphemerisParams::Documentation = "Please note the command SetSbasEphemerisParams is deprecated since 21.3. You may use SetSbasEphParamForSV.\n\nSet parameters for a SBAS satellite ephemeris (runtime modification only available for health parameter)";

    REGISTER_COMMAND_FACTORY(SetSbasEphemerisParams);


    SetSbasEphemerisParams::SetSbasEphemerisParams()
      : CommandBase(CmdName)
    {}

    SetSbasEphemerisParams::SetSbasEphemerisParams(int prn, const std::vector<Sdx::StringPair>& parameters)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParameters(parameters);
    }


    SetSbasEphemerisParamsPtr SetSbasEphemerisParams::create(int prn, const std::vector<Sdx::StringPair>& parameters)
    {
      return SetSbasEphemerisParamsPtr(new SetSbasEphemerisParams(prn, parameters));
    }

    SetSbasEphemerisParamsPtr SetSbasEphemerisParams::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasEphemerisParams>(ptr);
    }

    bool SetSbasEphemerisParams::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::vector<Sdx::StringPair>>::is_valid(m_values["Parameters"])
        ;

    }

    std::string SetSbasEphemerisParams::documentation() const { return Documentation; }


    int SetSbasEphemerisParams::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetSbasEphemerisParams::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSbasEphemerisParams::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<Sdx::StringPair> SetSbasEphemerisParams::parameters() const
    {
      return parse_json<std::vector<Sdx::StringPair>>::parse(m_values["Parameters"]);
    }

    void SetSbasEphemerisParams::setParameters(const std::vector<Sdx::StringPair>& parameters)
    {
      m_values.AddMember("Parameters", parse_json<std::vector<Sdx::StringPair>>::format(parameters, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasEphemerisParam
///
#include "gen/GetSbasEphemerisParam.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasEphemerisParam::CmdName = "GetSbasEphemerisParam";
    const char* const GetSbasEphemerisParam::Documentation = "Please note the command GetSbasEphemerisParam is deprecated since 21.3. You may use GetSbasEphParamsForSV.\n\nGet parameters for a SBAS satellite ephemeris";

    REGISTER_COMMAND_FACTORY(GetSbasEphemerisParam);


    GetSbasEphemerisParam::GetSbasEphemerisParam()
      : CommandBase(CmdName)
    {}

    GetSbasEphemerisParam::GetSbasEphemerisParam(int prn, const std::string& parameter)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setParameter(parameter);
    }


    GetSbasEphemerisParamPtr GetSbasEphemerisParam::create(int prn, const std::string& parameter)
    {
      return GetSbasEphemerisParamPtr(new GetSbasEphemerisParam(prn, parameter));
    }

    GetSbasEphemerisParamPtr GetSbasEphemerisParam::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasEphemerisParam>(ptr);
    }

    bool GetSbasEphemerisParam::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Parameter"])
        ;

    }

    std::string GetSbasEphemerisParam::documentation() const { return Documentation; }


    int GetSbasEphemerisParam::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetSbasEphemerisParam::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSbasEphemerisParam::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSbasEphemerisParam::parameter() const
    {
      return parse_json<std::string>::parse(m_values["Parameter"]);
    }

    void GetSbasEphemerisParam::setParameter(const std::string& parameter)
    {
      m_values.AddMember("Parameter", parse_json<std::string>::format(parameter, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSbasEphemerisParamResult
///
#include "gen/GetSbasEphemerisParamResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSbasEphemerisParamResult::CmdName = "GetSbasEphemerisParamResult";
    const char* const GetSbasEphemerisParamResult::Documentation = "Result of GetSbasEphemerisParam.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSbasEphemerisParamResult);


    GetSbasEphemerisParamResult::GetSbasEphemerisParamResult()
      : CommandResult(CmdName)
    {}

    GetSbasEphemerisParamResult::GetSbasEphemerisParamResult(CommandBasePtr relatedCommand, int prn, const std::string& parameter, const std::string& valueParam)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setParameter(parameter);
      setValueParam(valueParam);
    }


    GetSbasEphemerisParamResultPtr GetSbasEphemerisParamResult::create(CommandBasePtr relatedCommand, int prn, const std::string& parameter, const std::string& valueParam)
    {
      return GetSbasEphemerisParamResultPtr(new GetSbasEphemerisParamResult(relatedCommand, prn, parameter, valueParam));
    }

    GetSbasEphemerisParamResultPtr GetSbasEphemerisParamResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSbasEphemerisParamResult>(ptr);
    }

    bool GetSbasEphemerisParamResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Parameter"])
          && parse_json<std::string>::is_valid(m_values["ValueParam"])
        ;

    }

    std::string GetSbasEphemerisParamResult::documentation() const { return Documentation; }


    int GetSbasEphemerisParamResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSbasEphemerisParamResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSbasEphemerisParamResult::parameter() const
    {
      return parse_json<std::string>::parse(m_values["Parameter"]);
    }

    void GetSbasEphemerisParamResult::setParameter(const std::string& parameter)
    {
      m_values.AddMember("Parameter", parse_json<std::string>::format(parameter, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSbasEphemerisParamResult::valueParam() const
    {
      return parse_json<std::string>::parse(m_values["ValueParam"]);
    }

    void GetSbasEphemerisParamResult::setValueParam(const std::string& valueParam)
    {
      m_values.AddMember("ValueParam", parse_json<std::string>::format(valueParam, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSVConfiguration
///
#include "gen/SetGpsSVConfiguration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSVConfiguration::CmdName = "SetGpsSVConfiguration";
    const char* const SetGpsSVConfiguration::Documentation = "Please note the command GpsSVConfiguration is deprecated since 21.3. You may use GpsConfigurationCodeForSV.\n\nSet GPS SV configuration flag for one PRN";

    REGISTER_COMMAND_FACTORY(SetGpsSVConfiguration);


    SetGpsSVConfiguration::SetGpsSVConfiguration()
      : CommandBase(CmdName)
    {}

    SetGpsSVConfiguration::SetGpsSVConfiguration(int prn, int svConfig)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSvConfig(svConfig);
    }


    SetGpsSVConfigurationPtr SetGpsSVConfiguration::create(int prn, int svConfig)
    {
      return SetGpsSVConfigurationPtr(new SetGpsSVConfiguration(prn, svConfig));
    }

    SetGpsSVConfigurationPtr SetGpsSVConfiguration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSVConfiguration>(ptr);
    }

    bool SetGpsSVConfiguration::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["SvConfig"])
        ;

    }

    std::string SetGpsSVConfiguration::documentation() const { return Documentation; }


    int SetGpsSVConfiguration::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGpsSVConfiguration::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSVConfiguration::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsSVConfiguration::svConfig() const
    {
      return parse_json<int>::parse(m_values["SvConfig"]);
    }

    void SetGpsSVConfiguration::setSvConfig(int svConfig)
    {
      m_values.AddMember("SvConfig", parse_json<int>::format(svConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSVConfiguration
///
#include "gen/GetGpsSVConfiguration.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSVConfiguration::CmdName = "GetGpsSVConfiguration";
    const char* const GetGpsSVConfiguration::Documentation = "Please note the command GpsSVConfiguration is deprecated since 21.3. You may use GpsConfigurationCodeForSV.\n\nGet GPS SV configuration flag for one PRN";

    REGISTER_COMMAND_FACTORY(GetGpsSVConfiguration);


    GetGpsSVConfiguration::GetGpsSVConfiguration()
      : CommandBase(CmdName)
    {}

    GetGpsSVConfiguration::GetGpsSVConfiguration(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSVConfigurationPtr GetGpsSVConfiguration::create(int prn)
    {
      return GetGpsSVConfigurationPtr(new GetGpsSVConfiguration(prn));
    }

    GetGpsSVConfigurationPtr GetGpsSVConfiguration::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSVConfiguration>(ptr);
    }

    bool GetGpsSVConfiguration::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSVConfiguration::documentation() const { return Documentation; }


    int GetGpsSVConfiguration::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSVConfiguration::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSVConfiguration::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSVConfigurationResult
///
#include "gen/GetGpsSVConfigurationResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSVConfigurationResult::CmdName = "GetGpsSVConfigurationResult";
    const char* const GetGpsSVConfigurationResult::Documentation = "Result of GetGpsSVConfiguration";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSVConfigurationResult);


    GetGpsSVConfigurationResult::GetGpsSVConfigurationResult()
      : CommandResult(CmdName)
    {}

    GetGpsSVConfigurationResult::GetGpsSVConfigurationResult(CommandBasePtr relatedCommand, int prn, int svConfig)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setSvConfig(svConfig);
    }


    GetGpsSVConfigurationResultPtr GetGpsSVConfigurationResult::create(CommandBasePtr relatedCommand, int prn, int svConfig)
    {
      return GetGpsSVConfigurationResultPtr(new GetGpsSVConfigurationResult(relatedCommand, prn, svConfig));
    }

    GetGpsSVConfigurationResultPtr GetGpsSVConfigurationResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSVConfigurationResult>(ptr);
    }

    bool GetGpsSVConfigurationResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["SvConfig"])
        ;

    }

    std::string GetGpsSVConfigurationResult::documentation() const { return Documentation; }


    int GetGpsSVConfigurationResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSVConfigurationResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsSVConfigurationResult::svConfig() const
    {
      return parse_json<int>::parse(m_values["SvConfig"]);
    }

    void GetGpsSVConfigurationResult::setSvConfig(int svConfig)
    {
      m_values.AddMember("SvConfig", parse_json<int>::format(svConfig, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatelliteDataHealth
///
#include "gen/SetGpsSatelliteDataHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatelliteDataHealth::CmdName = "SetGpsSatelliteDataHealth";
    const char* const SetGpsSatelliteDataHealth::Documentation = "Please note the command GpsSatelliteDataHealth is deprecated since 21.3. You may use GpsDataHealthForSV.\n\nSet GPS nav data health";

    REGISTER_COMMAND_FACTORY(SetGpsSatelliteDataHealth);


    SetGpsSatelliteDataHealth::SetGpsSatelliteDataHealth()
      : CommandBase(CmdName)
    {}

    SetGpsSatelliteDataHealth::SetGpsSatelliteDataHealth(int prn, int health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetGpsSatelliteDataHealthPtr SetGpsSatelliteDataHealth::create(int prn, int health)
    {
      return SetGpsSatelliteDataHealthPtr(new SetGpsSatelliteDataHealth(prn, health));
    }

    SetGpsSatelliteDataHealthPtr SetGpsSatelliteDataHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatelliteDataHealth>(ptr);
    }

    bool SetGpsSatelliteDataHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsSatelliteDataHealth::documentation() const { return Documentation; }


    int SetGpsSatelliteDataHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSatelliteDataHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatelliteDataHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsSatelliteDataHealth::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetGpsSatelliteDataHealth::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteDataHealth
///
#include "gen/GetGpsSatelliteDataHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteDataHealth::CmdName = "GetGpsSatelliteDataHealth";
    const char* const GetGpsSatelliteDataHealth::Documentation = "Please note the command GpsSatelliteDataHealth is deprecated since 21.3. You may use GpsDataHealthForSV.\n\nGet GPS nav data health";

    REGISTER_COMMAND_FACTORY(GetGpsSatelliteDataHealth);


    GetGpsSatelliteDataHealth::GetGpsSatelliteDataHealth()
      : CommandBase(CmdName)
    {}

    GetGpsSatelliteDataHealth::GetGpsSatelliteDataHealth(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSatelliteDataHealthPtr GetGpsSatelliteDataHealth::create(int prn)
    {
      return GetGpsSatelliteDataHealthPtr(new GetGpsSatelliteDataHealth(prn));
    }

    GetGpsSatelliteDataHealthPtr GetGpsSatelliteDataHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteDataHealth>(ptr);
    }

    bool GetGpsSatelliteDataHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSatelliteDataHealth::documentation() const { return Documentation; }


    int GetGpsSatelliteDataHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSatelliteDataHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteDataHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteDataHealthResult
///
#include "gen/GetGpsSatelliteDataHealthResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteDataHealthResult::CmdName = "GetGpsSatelliteDataHealthResult";
    const char* const GetGpsSatelliteDataHealthResult::Documentation = "Result of GetGpsSatelliteDataHealth";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSatelliteDataHealthResult);


    GetGpsSatelliteDataHealthResult::GetGpsSatelliteDataHealthResult()
      : CommandResult(CmdName)
    {}

    GetGpsSatelliteDataHealthResult::GetGpsSatelliteDataHealthResult(CommandBasePtr relatedCommand, int prn, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetGpsSatelliteDataHealthResultPtr GetGpsSatelliteDataHealthResult::create(CommandBasePtr relatedCommand, int prn, int health)
    {
      return GetGpsSatelliteDataHealthResultPtr(new GetGpsSatelliteDataHealthResult(relatedCommand, prn, health));
    }

    GetGpsSatelliteDataHealthResultPtr GetGpsSatelliteDataHealthResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteDataHealthResult>(ptr);
    }

    bool GetGpsSatelliteDataHealthResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsSatelliteDataHealthResult::documentation() const { return Documentation; }


    int GetGpsSatelliteDataHealthResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteDataHealthResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsSatelliteDataHealthResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetGpsSatelliteDataHealthResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatelliteSignalHealth
///
#include "gen/SetGpsSatelliteSignalHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatelliteSignalHealth::CmdName = "SetGpsSatelliteSignalHealth";
    const char* const SetGpsSatelliteSignalHealth::Documentation = "Please note the command GpsSatelliteSignalHealth is deprecated since 21.3. You may use GpsSignalHealthForSV.\n\nSet GPS signal health";

    REGISTER_COMMAND_FACTORY(SetGpsSatelliteSignalHealth);


    SetGpsSatelliteSignalHealth::SetGpsSatelliteSignalHealth()
      : CommandBase(CmdName)
    {}

    SetGpsSatelliteSignalHealth::SetGpsSatelliteSignalHealth(int prn, int health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetGpsSatelliteSignalHealthPtr SetGpsSatelliteSignalHealth::create(int prn, int health)
    {
      return SetGpsSatelliteSignalHealthPtr(new SetGpsSatelliteSignalHealth(prn, health));
    }

    SetGpsSatelliteSignalHealthPtr SetGpsSatelliteSignalHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatelliteSignalHealth>(ptr);
    }

    bool SetGpsSatelliteSignalHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsSatelliteSignalHealth::documentation() const { return Documentation; }


    int SetGpsSatelliteSignalHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSatelliteSignalHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatelliteSignalHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsSatelliteSignalHealth::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetGpsSatelliteSignalHealth::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteSignalHealth
///
#include "gen/GetGpsSatelliteSignalHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteSignalHealth::CmdName = "GetGpsSatelliteSignalHealth";
    const char* const GetGpsSatelliteSignalHealth::Documentation = "Please note the command GpsSatelliteSignalHealth is deprecated since 21.3. You may use GpsSignalHealthForSV.\n\nGet GPS signal health";

    REGISTER_COMMAND_FACTORY(GetGpsSatelliteSignalHealth);


    GetGpsSatelliteSignalHealth::GetGpsSatelliteSignalHealth()
      : CommandBase(CmdName)
    {}

    GetGpsSatelliteSignalHealth::GetGpsSatelliteSignalHealth(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSatelliteSignalHealthPtr GetGpsSatelliteSignalHealth::create(int prn)
    {
      return GetGpsSatelliteSignalHealthPtr(new GetGpsSatelliteSignalHealth(prn));
    }

    GetGpsSatelliteSignalHealthPtr GetGpsSatelliteSignalHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteSignalHealth>(ptr);
    }

    bool GetGpsSatelliteSignalHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSatelliteSignalHealth::documentation() const { return Documentation; }


    int GetGpsSatelliteSignalHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSatelliteSignalHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteSignalHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteSignalHealthResult
///
#include "gen/GetGpsSatelliteSignalHealthResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteSignalHealthResult::CmdName = "GetGpsSatelliteSignalHealthResult";
    const char* const GetGpsSatelliteSignalHealthResult::Documentation = "Result of GetGpsSatelliteSignalHealth";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSatelliteSignalHealthResult);


    GetGpsSatelliteSignalHealthResult::GetGpsSatelliteSignalHealthResult()
      : CommandResult(CmdName)
    {}

    GetGpsSatelliteSignalHealthResult::GetGpsSatelliteSignalHealthResult(CommandBasePtr relatedCommand, int prn, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetGpsSatelliteSignalHealthResultPtr GetGpsSatelliteSignalHealthResult::create(CommandBasePtr relatedCommand, int prn, int health)
    {
      return GetGpsSatelliteSignalHealthResultPtr(new GetGpsSatelliteSignalHealthResult(relatedCommand, prn, health));
    }

    GetGpsSatelliteSignalHealthResultPtr GetGpsSatelliteSignalHealthResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteSignalHealthResult>(ptr);
    }

    bool GetGpsSatelliteSignalHealthResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsSatelliteSignalHealthResult::documentation() const { return Documentation; }


    int GetGpsSatelliteSignalHealthResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteSignalHealthResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsSatelliteSignalHealthResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetGpsSatelliteSignalHealthResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatelliteL1Health
///
#include "gen/SetGpsSatelliteL1Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatelliteL1Health::CmdName = "SetGpsSatelliteL1Health";
    const char* const SetGpsSatelliteL1Health::Documentation = "Please note the command GpsSatelliteL1Health is deprecated since 21.3. You may use GpsL1HealthForSV.\n\nSet GPS L1 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(SetGpsSatelliteL1Health);


    SetGpsSatelliteL1Health::SetGpsSatelliteL1Health()
      : CommandBase(CmdName)
    {}

    SetGpsSatelliteL1Health::SetGpsSatelliteL1Health(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetGpsSatelliteL1HealthPtr SetGpsSatelliteL1Health::create(int prn, bool health)
    {
      return SetGpsSatelliteL1HealthPtr(new SetGpsSatelliteL1Health(prn, health));
    }

    SetGpsSatelliteL1HealthPtr SetGpsSatelliteL1Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatelliteL1Health>(ptr);
    }

    bool SetGpsSatelliteL1Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsSatelliteL1Health::documentation() const { return Documentation; }


    int SetGpsSatelliteL1Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSatelliteL1Health::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatelliteL1Health::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsSatelliteL1Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsSatelliteL1Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteL1Health
///
#include "gen/GetGpsSatelliteL1Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteL1Health::CmdName = "GetGpsSatelliteL1Health";
    const char* const GetGpsSatelliteL1Health::Documentation = "Please note the command GpsSatelliteL1Health is deprecated since 21.3. You may use GpsL1HealthForSV.\n\nGet GPS L1 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(GetGpsSatelliteL1Health);


    GetGpsSatelliteL1Health::GetGpsSatelliteL1Health()
      : CommandBase(CmdName)
    {}

    GetGpsSatelliteL1Health::GetGpsSatelliteL1Health(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSatelliteL1HealthPtr GetGpsSatelliteL1Health::create(int prn)
    {
      return GetGpsSatelliteL1HealthPtr(new GetGpsSatelliteL1Health(prn));
    }

    GetGpsSatelliteL1HealthPtr GetGpsSatelliteL1Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteL1Health>(ptr);
    }

    bool GetGpsSatelliteL1Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSatelliteL1Health::documentation() const { return Documentation; }


    int GetGpsSatelliteL1Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSatelliteL1Health::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteL1Health::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteL1HealthResult
///
#include "gen/GetGpsSatelliteL1HealthResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteL1HealthResult::CmdName = "GetGpsSatelliteL1HealthResult";
    const char* const GetGpsSatelliteL1HealthResult::Documentation = "Result of GetGpsSatelliteL1Health";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSatelliteL1HealthResult);


    GetGpsSatelliteL1HealthResult::GetGpsSatelliteL1HealthResult()
      : CommandResult(CmdName)
    {}

    GetGpsSatelliteL1HealthResult::GetGpsSatelliteL1HealthResult(CommandBasePtr relatedCommand, int prn, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetGpsSatelliteL1HealthResultPtr GetGpsSatelliteL1HealthResult::create(CommandBasePtr relatedCommand, int prn, bool health)
    {
      return GetGpsSatelliteL1HealthResultPtr(new GetGpsSatelliteL1HealthResult(relatedCommand, prn, health));
    }

    GetGpsSatelliteL1HealthResultPtr GetGpsSatelliteL1HealthResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteL1HealthResult>(ptr);
    }

    bool GetGpsSatelliteL1HealthResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsSatelliteL1HealthResult::documentation() const { return Documentation; }


    int GetGpsSatelliteL1HealthResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteL1HealthResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsSatelliteL1HealthResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsSatelliteL1HealthResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatelliteL2Health
///
#include "gen/SetGpsSatelliteL2Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatelliteL2Health::CmdName = "SetGpsSatelliteL2Health";
    const char* const SetGpsSatelliteL2Health::Documentation = "Please note the command GpsSatelliteL2Health is deprecated since 21.3. You may use GpsL2HealthForSV.\n\nSet GPS L2 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(SetGpsSatelliteL2Health);


    SetGpsSatelliteL2Health::SetGpsSatelliteL2Health()
      : CommandBase(CmdName)
    {}

    SetGpsSatelliteL2Health::SetGpsSatelliteL2Health(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetGpsSatelliteL2HealthPtr SetGpsSatelliteL2Health::create(int prn, bool health)
    {
      return SetGpsSatelliteL2HealthPtr(new SetGpsSatelliteL2Health(prn, health));
    }

    SetGpsSatelliteL2HealthPtr SetGpsSatelliteL2Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatelliteL2Health>(ptr);
    }

    bool SetGpsSatelliteL2Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsSatelliteL2Health::documentation() const { return Documentation; }


    int SetGpsSatelliteL2Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSatelliteL2Health::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatelliteL2Health::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsSatelliteL2Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsSatelliteL2Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteL2Health
///
#include "gen/GetGpsSatelliteL2Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteL2Health::CmdName = "GetGpsSatelliteL2Health";
    const char* const GetGpsSatelliteL2Health::Documentation = "Please note the command GpsSatelliteL2Health is deprecated since 21.3. You may use GpsL2HealthForSV.\n\nGet GPS L2 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(GetGpsSatelliteL2Health);


    GetGpsSatelliteL2Health::GetGpsSatelliteL2Health()
      : CommandBase(CmdName)
    {}

    GetGpsSatelliteL2Health::GetGpsSatelliteL2Health(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSatelliteL2HealthPtr GetGpsSatelliteL2Health::create(int prn)
    {
      return GetGpsSatelliteL2HealthPtr(new GetGpsSatelliteL2Health(prn));
    }

    GetGpsSatelliteL2HealthPtr GetGpsSatelliteL2Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteL2Health>(ptr);
    }

    bool GetGpsSatelliteL2Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSatelliteL2Health::documentation() const { return Documentation; }


    int GetGpsSatelliteL2Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSatelliteL2Health::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteL2Health::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteL2HealthResult
///
#include "gen/GetGpsSatelliteL2HealthResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteL2HealthResult::CmdName = "GetGpsSatelliteL2HealthResult";
    const char* const GetGpsSatelliteL2HealthResult::Documentation = "Result of GetGpsSatelliteL2Health";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSatelliteL2HealthResult);


    GetGpsSatelliteL2HealthResult::GetGpsSatelliteL2HealthResult()
      : CommandResult(CmdName)
    {}

    GetGpsSatelliteL2HealthResult::GetGpsSatelliteL2HealthResult(CommandBasePtr relatedCommand, int prn, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetGpsSatelliteL2HealthResultPtr GetGpsSatelliteL2HealthResult::create(CommandBasePtr relatedCommand, int prn, bool health)
    {
      return GetGpsSatelliteL2HealthResultPtr(new GetGpsSatelliteL2HealthResult(relatedCommand, prn, health));
    }

    GetGpsSatelliteL2HealthResultPtr GetGpsSatelliteL2HealthResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteL2HealthResult>(ptr);
    }

    bool GetGpsSatelliteL2HealthResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsSatelliteL2HealthResult::documentation() const { return Documentation; }


    int GetGpsSatelliteL2HealthResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteL2HealthResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsSatelliteL2HealthResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsSatelliteL2HealthResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatelliteL5Health
///
#include "gen/SetGpsSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatelliteL5Health::CmdName = "SetGpsSatelliteL5Health";
    const char* const SetGpsSatelliteL5Health::Documentation = "Please note the command GpsSatelliteL5Health is deprecated since 21.3. You may use GpsL5HealthForSV.\n\nSet GPS L5 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(SetGpsSatelliteL5Health);


    SetGpsSatelliteL5Health::SetGpsSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    SetGpsSatelliteL5Health::SetGpsSatelliteL5Health(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetGpsSatelliteL5HealthPtr SetGpsSatelliteL5Health::create(int prn, bool health)
    {
      return SetGpsSatelliteL5HealthPtr(new SetGpsSatelliteL5Health(prn, health));
    }

    SetGpsSatelliteL5HealthPtr SetGpsSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatelliteL5Health>(ptr);
    }

    bool SetGpsSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsSatelliteL5Health::documentation() const { return Documentation; }


    int SetGpsSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSatelliteL5Health::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatelliteL5Health::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsSatelliteL5Health::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsSatelliteL5Health::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteL5Health
///
#include "gen/GetGpsSatelliteL5Health.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteL5Health::CmdName = "GetGpsSatelliteL5Health";
    const char* const GetGpsSatelliteL5Health::Documentation = "Please note the command GpsSatelliteL5Health is deprecated since 21.3. You may use GpsL5HealthForSV.\n\nGet GPS L5 health (used with CNAV and CNAV2)";

    REGISTER_COMMAND_FACTORY(GetGpsSatelliteL5Health);


    GetGpsSatelliteL5Health::GetGpsSatelliteL5Health()
      : CommandBase(CmdName)
    {}

    GetGpsSatelliteL5Health::GetGpsSatelliteL5Health(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSatelliteL5HealthPtr GetGpsSatelliteL5Health::create(int prn)
    {
      return GetGpsSatelliteL5HealthPtr(new GetGpsSatelliteL5Health(prn));
    }

    GetGpsSatelliteL5HealthPtr GetGpsSatelliteL5Health::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteL5Health>(ptr);
    }

    bool GetGpsSatelliteL5Health::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSatelliteL5Health::documentation() const { return Documentation; }


    int GetGpsSatelliteL5Health::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSatelliteL5Health::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteL5Health::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteL5HealthResult
///
#include "gen/GetGpsSatelliteL5HealthResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteL5HealthResult::CmdName = "GetGpsSatelliteL5HealthResult";
    const char* const GetGpsSatelliteL5HealthResult::Documentation = "Result of GetGpsSatelliteL5Health";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSatelliteL5HealthResult);


    GetGpsSatelliteL5HealthResult::GetGpsSatelliteL5HealthResult()
      : CommandResult(CmdName)
    {}

    GetGpsSatelliteL5HealthResult::GetGpsSatelliteL5HealthResult(CommandBasePtr relatedCommand, int prn, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetGpsSatelliteL5HealthResultPtr GetGpsSatelliteL5HealthResult::create(CommandBasePtr relatedCommand, int prn, bool health)
    {
      return GetGpsSatelliteL5HealthResultPtr(new GetGpsSatelliteL5HealthResult(relatedCommand, prn, health));
    }

    GetGpsSatelliteL5HealthResultPtr GetGpsSatelliteL5HealthResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteL5HealthResult>(ptr);
    }

    bool GetGpsSatelliteL5HealthResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsSatelliteL5HealthResult::documentation() const { return Documentation; }


    int GetGpsSatelliteL5HealthResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteL5HealthResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsSatelliteL5HealthResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsSatelliteL5HealthResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatelliteL1cHealth
///
#include "gen/SetGpsSatelliteL1cHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatelliteL1cHealth::CmdName = "SetGpsSatelliteL1cHealth";
    const char* const SetGpsSatelliteL1cHealth::Documentation = "Please note the command GpsSatelliteL1cHealth is deprecated since 21.3. You may use GpsL1cHealthForSV.\n\nSet GPS L1C health (used in CNAV2 only)";

    REGISTER_COMMAND_FACTORY(SetGpsSatelliteL1cHealth);


    SetGpsSatelliteL1cHealth::SetGpsSatelliteL1cHealth()
      : CommandBase(CmdName)
    {}

    SetGpsSatelliteL1cHealth::SetGpsSatelliteL1cHealth(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetGpsSatelliteL1cHealthPtr SetGpsSatelliteL1cHealth::create(int prn, bool health)
    {
      return SetGpsSatelliteL1cHealthPtr(new SetGpsSatelliteL1cHealth(prn, health));
    }

    SetGpsSatelliteL1cHealthPtr SetGpsSatelliteL1cHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatelliteL1cHealth>(ptr);
    }

    bool SetGpsSatelliteL1cHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetGpsSatelliteL1cHealth::documentation() const { return Documentation; }


    int SetGpsSatelliteL1cHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSatelliteL1cHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatelliteL1cHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsSatelliteL1cHealth::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetGpsSatelliteL1cHealth::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteL1cHealth
///
#include "gen/GetGpsSatelliteL1cHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteL1cHealth::CmdName = "GetGpsSatelliteL1cHealth";
    const char* const GetGpsSatelliteL1cHealth::Documentation = "Please note the command GpsSatelliteL1cHealth is deprecated since 21.3. You may use GpsL1cHealthForSV.\n\nGet GPS L1C health (used in CNAV2 only)";

    REGISTER_COMMAND_FACTORY(GetGpsSatelliteL1cHealth);


    GetGpsSatelliteL1cHealth::GetGpsSatelliteL1cHealth()
      : CommandBase(CmdName)
    {}

    GetGpsSatelliteL1cHealth::GetGpsSatelliteL1cHealth(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSatelliteL1cHealthPtr GetGpsSatelliteL1cHealth::create(int prn)
    {
      return GetGpsSatelliteL1cHealthPtr(new GetGpsSatelliteL1cHealth(prn));
    }

    GetGpsSatelliteL1cHealthPtr GetGpsSatelliteL1cHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteL1cHealth>(ptr);
    }

    bool GetGpsSatelliteL1cHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSatelliteL1cHealth::documentation() const { return Documentation; }


    int GetGpsSatelliteL1cHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSatelliteL1cHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteL1cHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteL1cHealthResult
///
#include "gen/GetGpsSatelliteL1cHealthResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteL1cHealthResult::CmdName = "GetGpsSatelliteL1cHealthResult";
    const char* const GetGpsSatelliteL1cHealthResult::Documentation = "Result of GetGpsSatelliteL1cHealth";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSatelliteL1cHealthResult);


    GetGpsSatelliteL1cHealthResult::GetGpsSatelliteL1cHealthResult()
      : CommandResult(CmdName)
    {}

    GetGpsSatelliteL1cHealthResult::GetGpsSatelliteL1cHealthResult(CommandBasePtr relatedCommand, int prn, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetGpsSatelliteL1cHealthResultPtr GetGpsSatelliteL1cHealthResult::create(CommandBasePtr relatedCommand, int prn, bool health)
    {
      return GetGpsSatelliteL1cHealthResultPtr(new GetGpsSatelliteL1cHealthResult(relatedCommand, prn, health));
    }

    GetGpsSatelliteL1cHealthResultPtr GetGpsSatelliteL1cHealthResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteL1cHealthResult>(ptr);
    }

    bool GetGpsSatelliteL1cHealthResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetGpsSatelliteL1cHealthResult::documentation() const { return Documentation; }


    int GetGpsSatelliteL1cHealthResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteL1cHealthResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsSatelliteL1cHealthResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetGpsSatelliteL1cHealthResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatelliteAntiSpoofingFlag
///
#include "gen/SetGpsSatelliteAntiSpoofingFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatelliteAntiSpoofingFlag::CmdName = "SetGpsSatelliteAntiSpoofingFlag";
    const char* const SetGpsSatelliteAntiSpoofingFlag::Documentation = "Please note the command GpsSatelliteAntiSpoofingFlag is deprecated since 21.3. You may use GpsAntiSpoofingFlagForSV.\n\nSet GPS Anti-Spoofing Flag";

    REGISTER_COMMAND_FACTORY(SetGpsSatelliteAntiSpoofingFlag);


    SetGpsSatelliteAntiSpoofingFlag::SetGpsSatelliteAntiSpoofingFlag()
      : CommandBase(CmdName)
    {}

    SetGpsSatelliteAntiSpoofingFlag::SetGpsSatelliteAntiSpoofingFlag(int prn, const Sdx::GpsASFlag& antiSpoofing)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setAntiSpoofing(antiSpoofing);
    }


    SetGpsSatelliteAntiSpoofingFlagPtr SetGpsSatelliteAntiSpoofingFlag::create(int prn, const Sdx::GpsASFlag& antiSpoofing)
    {
      return SetGpsSatelliteAntiSpoofingFlagPtr(new SetGpsSatelliteAntiSpoofingFlag(prn, antiSpoofing));
    }

    SetGpsSatelliteAntiSpoofingFlagPtr SetGpsSatelliteAntiSpoofingFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatelliteAntiSpoofingFlag>(ptr);
    }

    bool SetGpsSatelliteAntiSpoofingFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::GpsASFlag>::is_valid(m_values["AntiSpoofing"])
        ;

    }

    std::string SetGpsSatelliteAntiSpoofingFlag::documentation() const { return Documentation; }


    int SetGpsSatelliteAntiSpoofingFlag::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSatelliteAntiSpoofingFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatelliteAntiSpoofingFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GpsASFlag SetGpsSatelliteAntiSpoofingFlag::antiSpoofing() const
    {
      return parse_json<Sdx::GpsASFlag>::parse(m_values["AntiSpoofing"]);
    }

    void SetGpsSatelliteAntiSpoofingFlag::setAntiSpoofing(const Sdx::GpsASFlag& antiSpoofing)
    {
      m_values.AddMember("AntiSpoofing", parse_json<Sdx::GpsASFlag>::format(antiSpoofing, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteAntiSpoofingFlag
///
#include "gen/GetGpsSatelliteAntiSpoofingFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteAntiSpoofingFlag::CmdName = "GetGpsSatelliteAntiSpoofingFlag";
    const char* const GetGpsSatelliteAntiSpoofingFlag::Documentation = "Please note the command GpsSatelliteAntiSpoofingFlag is deprecated since 21.3. You may use GpsAntiSpoofingFlagForSV.\n\nGet GPS Anti-Spoofing Flag";

    REGISTER_COMMAND_FACTORY(GetGpsSatelliteAntiSpoofingFlag);


    GetGpsSatelliteAntiSpoofingFlag::GetGpsSatelliteAntiSpoofingFlag()
      : CommandBase(CmdName)
    {}

    GetGpsSatelliteAntiSpoofingFlag::GetGpsSatelliteAntiSpoofingFlag(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSatelliteAntiSpoofingFlagPtr GetGpsSatelliteAntiSpoofingFlag::create(int prn)
    {
      return GetGpsSatelliteAntiSpoofingFlagPtr(new GetGpsSatelliteAntiSpoofingFlag(prn));
    }

    GetGpsSatelliteAntiSpoofingFlagPtr GetGpsSatelliteAntiSpoofingFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteAntiSpoofingFlag>(ptr);
    }

    bool GetGpsSatelliteAntiSpoofingFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSatelliteAntiSpoofingFlag::documentation() const { return Documentation; }


    int GetGpsSatelliteAntiSpoofingFlag::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSatelliteAntiSpoofingFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteAntiSpoofingFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteAntiSpoofingFlagResult
///
#include "gen/GetGpsSatelliteAntiSpoofingFlagResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteAntiSpoofingFlagResult::CmdName = "GetGpsSatelliteAntiSpoofingFlagResult";
    const char* const GetGpsSatelliteAntiSpoofingFlagResult::Documentation = "Result of GetGpsSatelliteAntiSpoofingFlag";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSatelliteAntiSpoofingFlagResult);


    GetGpsSatelliteAntiSpoofingFlagResult::GetGpsSatelliteAntiSpoofingFlagResult()
      : CommandResult(CmdName)
    {}

    GetGpsSatelliteAntiSpoofingFlagResult::GetGpsSatelliteAntiSpoofingFlagResult(CommandBasePtr relatedCommand, int prn, const Sdx::GpsASFlag& antiSpoofing)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setAntiSpoofing(antiSpoofing);
    }


    GetGpsSatelliteAntiSpoofingFlagResultPtr GetGpsSatelliteAntiSpoofingFlagResult::create(CommandBasePtr relatedCommand, int prn, const Sdx::GpsASFlag& antiSpoofing)
    {
      return GetGpsSatelliteAntiSpoofingFlagResultPtr(new GetGpsSatelliteAntiSpoofingFlagResult(relatedCommand, prn, antiSpoofing));
    }

    GetGpsSatelliteAntiSpoofingFlagResultPtr GetGpsSatelliteAntiSpoofingFlagResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteAntiSpoofingFlagResult>(ptr);
    }

    bool GetGpsSatelliteAntiSpoofingFlagResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::GpsASFlag>::is_valid(m_values["AntiSpoofing"])
        ;

    }

    std::string GetGpsSatelliteAntiSpoofingFlagResult::documentation() const { return Documentation; }


    int GetGpsSatelliteAntiSpoofingFlagResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteAntiSpoofingFlagResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::GpsASFlag GetGpsSatelliteAntiSpoofingFlagResult::antiSpoofing() const
    {
      return parse_json<Sdx::GpsASFlag>::parse(m_values["AntiSpoofing"]);
    }

    void GetGpsSatelliteAntiSpoofingFlagResult::setAntiSpoofing(const Sdx::GpsASFlag& antiSpoofing)
    {
      m_values.AddMember("AntiSpoofing", parse_json<Sdx::GpsASFlag>::format(antiSpoofing, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatelliteNavAlertFlag
///
#include "gen/SetGpsSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatelliteNavAlertFlag::CmdName = "SetGpsSatelliteNavAlertFlag";
    const char* const SetGpsSatelliteNavAlertFlag::Documentation = "Please note the command GpsSatelliteNavAlertFlag is deprecated since 21.3. You may use GpsNavAlertFlagForSV.\n\nSet GPS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetGpsSatelliteNavAlertFlag);


    SetGpsSatelliteNavAlertFlag::SetGpsSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    SetGpsSatelliteNavAlertFlag::SetGpsSatelliteNavAlertFlag(int prn, bool alert)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setAlert(alert);
    }


    SetGpsSatelliteNavAlertFlagPtr SetGpsSatelliteNavAlertFlag::create(int prn, bool alert)
    {
      return SetGpsSatelliteNavAlertFlagPtr(new SetGpsSatelliteNavAlertFlag(prn, alert));
    }

    SetGpsSatelliteNavAlertFlagPtr SetGpsSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatelliteNavAlertFlag>(ptr);
    }

    bool SetGpsSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string SetGpsSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int SetGpsSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSatelliteNavAlertFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatelliteNavAlertFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsSatelliteNavAlertFlag::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetGpsSatelliteNavAlertFlag::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteNavAlertFlag
///
#include "gen/GetGpsSatelliteNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteNavAlertFlag::CmdName = "GetGpsSatelliteNavAlertFlag";
    const char* const GetGpsSatelliteNavAlertFlag::Documentation = "Please note the command GpsSatelliteNavAlertFlag is deprecated since 21.3. You may use GpsNavAlertFlagForSV.\n\nGet GPS NAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetGpsSatelliteNavAlertFlag);


    GetGpsSatelliteNavAlertFlag::GetGpsSatelliteNavAlertFlag()
      : CommandBase(CmdName)
    {}

    GetGpsSatelliteNavAlertFlag::GetGpsSatelliteNavAlertFlag(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSatelliteNavAlertFlagPtr GetGpsSatelliteNavAlertFlag::create(int prn)
    {
      return GetGpsSatelliteNavAlertFlagPtr(new GetGpsSatelliteNavAlertFlag(prn));
    }

    GetGpsSatelliteNavAlertFlagPtr GetGpsSatelliteNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteNavAlertFlag>(ptr);
    }

    bool GetGpsSatelliteNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSatelliteNavAlertFlag::documentation() const { return Documentation; }


    int GetGpsSatelliteNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSatelliteNavAlertFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteNavAlertFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteNavAlertFlagResult
///
#include "gen/GetGpsSatelliteNavAlertFlagResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteNavAlertFlagResult::CmdName = "GetGpsSatelliteNavAlertFlagResult";
    const char* const GetGpsSatelliteNavAlertFlagResult::Documentation = "Result of GetGpsSatelliteNavAlertFlag";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSatelliteNavAlertFlagResult);


    GetGpsSatelliteNavAlertFlagResult::GetGpsSatelliteNavAlertFlagResult()
      : CommandResult(CmdName)
    {}

    GetGpsSatelliteNavAlertFlagResult::GetGpsSatelliteNavAlertFlagResult(CommandBasePtr relatedCommand, int prn, bool alert)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setAlert(alert);
    }


    GetGpsSatelliteNavAlertFlagResultPtr GetGpsSatelliteNavAlertFlagResult::create(CommandBasePtr relatedCommand, int prn, bool alert)
    {
      return GetGpsSatelliteNavAlertFlagResultPtr(new GetGpsSatelliteNavAlertFlagResult(relatedCommand, prn, alert));
    }

    GetGpsSatelliteNavAlertFlagResultPtr GetGpsSatelliteNavAlertFlagResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteNavAlertFlagResult>(ptr);
    }

    bool GetGpsSatelliteNavAlertFlagResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string GetGpsSatelliteNavAlertFlagResult::documentation() const { return Documentation; }


    int GetGpsSatelliteNavAlertFlagResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteNavAlertFlagResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsSatelliteNavAlertFlagResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetGpsSatelliteNavAlertFlagResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsSatelliteCNavAlertFlag
///
#include "gen/SetGpsSatelliteCNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsSatelliteCNavAlertFlag::CmdName = "SetGpsSatelliteCNavAlertFlag";
    const char* const SetGpsSatelliteCNavAlertFlag::Documentation = "Please note the command GpsSatelliteCNavAlertFlag is deprecated since 21.3. You may use GpsCNavAlertFlagToSV.\n\nSet GPS CNAV Alert Flag";

    REGISTER_COMMAND_FACTORY(SetGpsSatelliteCNavAlertFlag);


    SetGpsSatelliteCNavAlertFlag::SetGpsSatelliteCNavAlertFlag()
      : CommandBase(CmdName)
    {}

    SetGpsSatelliteCNavAlertFlag::SetGpsSatelliteCNavAlertFlag(int prn, bool alert)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setAlert(alert);
    }


    SetGpsSatelliteCNavAlertFlagPtr SetGpsSatelliteCNavAlertFlag::create(int prn, bool alert)
    {
      return SetGpsSatelliteCNavAlertFlagPtr(new SetGpsSatelliteCNavAlertFlag(prn, alert));
    }

    SetGpsSatelliteCNavAlertFlagPtr SetGpsSatelliteCNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsSatelliteCNavAlertFlag>(ptr);
    }

    bool SetGpsSatelliteCNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string SetGpsSatelliteCNavAlertFlag::documentation() const { return Documentation; }


    int SetGpsSatelliteCNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetGpsSatelliteCNavAlertFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsSatelliteCNavAlertFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetGpsSatelliteCNavAlertFlag::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void SetGpsSatelliteCNavAlertFlag::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteCNavAlertFlag
///
#include "gen/GetGpsSatelliteCNavAlertFlag.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteCNavAlertFlag::CmdName = "GetGpsSatelliteCNavAlertFlag";
    const char* const GetGpsSatelliteCNavAlertFlag::Documentation = "Please note the command GpsSatelliteCNavAlertFlag is deprecated since 21.3. You may use GpsCNavAlertFlagToSV.\n\nGet GPS CNAV Alert Flag";

    REGISTER_COMMAND_FACTORY(GetGpsSatelliteCNavAlertFlag);


    GetGpsSatelliteCNavAlertFlag::GetGpsSatelliteCNavAlertFlag()
      : CommandBase(CmdName)
    {}

    GetGpsSatelliteCNavAlertFlag::GetGpsSatelliteCNavAlertFlag(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsSatelliteCNavAlertFlagPtr GetGpsSatelliteCNavAlertFlag::create(int prn)
    {
      return GetGpsSatelliteCNavAlertFlagPtr(new GetGpsSatelliteCNavAlertFlag(prn));
    }

    GetGpsSatelliteCNavAlertFlagPtr GetGpsSatelliteCNavAlertFlag::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteCNavAlertFlag>(ptr);
    }

    bool GetGpsSatelliteCNavAlertFlag::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsSatelliteCNavAlertFlag::documentation() const { return Documentation; }


    int GetGpsSatelliteCNavAlertFlag::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsSatelliteCNavAlertFlag::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteCNavAlertFlag::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsSatelliteCNavAlertFlagResult
///
#include "gen/GetGpsSatelliteCNavAlertFlagResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsSatelliteCNavAlertFlagResult::CmdName = "GetGpsSatelliteCNavAlertFlagResult";
    const char* const GetGpsSatelliteCNavAlertFlagResult::Documentation = "Result of GetGpsSatelliteCNavAlertFlag";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsSatelliteCNavAlertFlagResult);


    GetGpsSatelliteCNavAlertFlagResult::GetGpsSatelliteCNavAlertFlagResult()
      : CommandResult(CmdName)
    {}

    GetGpsSatelliteCNavAlertFlagResult::GetGpsSatelliteCNavAlertFlagResult(CommandBasePtr relatedCommand, int prn, bool alert)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setAlert(alert);
    }


    GetGpsSatelliteCNavAlertFlagResultPtr GetGpsSatelliteCNavAlertFlagResult::create(CommandBasePtr relatedCommand, int prn, bool alert)
    {
      return GetGpsSatelliteCNavAlertFlagResultPtr(new GetGpsSatelliteCNavAlertFlagResult(relatedCommand, prn, alert));
    }

    GetGpsSatelliteCNavAlertFlagResultPtr GetGpsSatelliteCNavAlertFlagResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsSatelliteCNavAlertFlagResult>(ptr);
    }

    bool GetGpsSatelliteCNavAlertFlagResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Alert"])
        ;

    }

    std::string GetGpsSatelliteCNavAlertFlagResult::documentation() const { return Documentation; }


    int GetGpsSatelliteCNavAlertFlagResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsSatelliteCNavAlertFlagResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsSatelliteCNavAlertFlagResult::alert() const
    {
      return parse_json<bool>::parse(m_values["Alert"]);
    }

    void GetGpsSatelliteCNavAlertFlagResult::setAlert(bool alert)
    {
      m_values.AddMember("Alert", parse_json<bool>::format(alert, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLOS
///
#include "gen/EnableLOS.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLOS::CmdName = "EnableLOS";
    const char* const EnableLOS::Documentation = "Please note the command EnableLOS is deprecated since 21.3. You may use EnableLosForSV.\n\nSet Direct Line Of Sight signal from satellite enabled or disabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(EnableLOS);


    EnableLOS::EnableLOS()
      : CommandBase(CmdName)
    {}

    EnableLOS::EnableLOS(int prn, const std::string& system, bool enabled)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSystem(system);
      setEnabled(enabled);
    }


    EnableLOSPtr EnableLOS::create(int prn, const std::string& system, bool enabled)
    {
      return EnableLOSPtr(new EnableLOS(prn, system, enabled));
    }

    EnableLOSPtr EnableLOS::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLOS>(ptr);
    }

    bool EnableLOS::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLOS::documentation() const { return Documentation; }


    int EnableLOS::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int EnableLOS::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void EnableLOS::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnableLOS::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableLOS::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnableLOS::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnableLOS::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLOSEnabled
///
#include "gen/IsLOSEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLOSEnabled::CmdName = "IsLOSEnabled";
    const char* const IsLOSEnabled::Documentation = "Please note the command EnableLOS is deprecated since 21.3. You may use EnableLosForSV.\n\nGet Direct Line Of Sight signal from satellite enabled or disabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(IsLOSEnabled);


    IsLOSEnabled::IsLOSEnabled()
      : CommandBase(CmdName)
    {}

    IsLOSEnabled::IsLOSEnabled(int prn, const std::string& system)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSystem(system);
    }


    IsLOSEnabledPtr IsLOSEnabled::create(int prn, const std::string& system)
    {
      return IsLOSEnabledPtr(new IsLOSEnabled(prn, system));
    }

    IsLOSEnabledPtr IsLOSEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLOSEnabled>(ptr);
    }

    bool IsLOSEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsLOSEnabled::documentation() const { return Documentation; }


    int IsLOSEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int IsLOSEnabled::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsLOSEnabled::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsLOSEnabled::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLOSEnabled::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLOSEnabledResult
///
#include "gen/IsLOSEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLOSEnabledResult::CmdName = "IsLOSEnabledResult";
    const char* const IsLOSEnabledResult::Documentation = "Result of IsLOSEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsLOSEnabledResult);


    IsLOSEnabledResult::IsLOSEnabledResult()
      : CommandResult(CmdName)
    {}

    IsLOSEnabledResult::IsLOSEnabledResult(CommandBasePtr relatedCommand, int prn, const std::string& system, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setSystem(system);
      setEnabled(enabled);
    }


    IsLOSEnabledResultPtr IsLOSEnabledResult::create(CommandBasePtr relatedCommand, int prn, const std::string& system, bool enabled)
    {
      return IsLOSEnabledResultPtr(new IsLOSEnabledResult(relatedCommand, prn, system, enabled));
    }

    IsLOSEnabledResultPtr IsLOSEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLOSEnabledResult>(ptr);
    }

    bool IsLOSEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLOSEnabledResult::documentation() const { return Documentation; }


    int IsLOSEnabledResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsLOSEnabledResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsLOSEnabledResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLOSEnabledResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsLOSEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsLOSEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnableLOSForEachPrn
///
#include "gen/EnableLOSForEachPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnableLOSForEachPrn::CmdName = "EnableLOSForEachPrn";
    const char* const EnableLOSForEachPrn::Documentation = "Please note the command EnableLOSForEachPrn is deprecated since 21.3. You may use EnableLosForEachSV.\n\nSet Direct Line Of Sight signal from satellite disabled or enabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(EnableLOSForEachPrn);


    EnableLOSForEachPrn::EnableLOSForEachPrn()
      : CommandBase(CmdName)
    {}

    EnableLOSForEachPrn::EnableLOSForEachPrn(const std::string& system, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    EnableLOSForEachPrnPtr EnableLOSForEachPrn::create(const std::string& system, const std::vector<bool>& enabled)
    {
      return EnableLOSForEachPrnPtr(new EnableLOSForEachPrn(system, enabled));
    }

    EnableLOSForEachPrnPtr EnableLOSForEachPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnableLOSForEachPrn>(ptr);
    }

    bool EnableLOSForEachPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnableLOSForEachPrn::documentation() const { return Documentation; }


    int EnableLOSForEachPrn::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnableLOSForEachPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void EnableLOSForEachPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnableLOSForEachPrn::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnableLOSForEachPrn::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLOSEnabledForEachPrn
///
#include "gen/IsLOSEnabledForEachPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLOSEnabledForEachPrn::CmdName = "IsLOSEnabledForEachPrn";
    const char* const IsLOSEnabledForEachPrn::Documentation = "Please note the command EnableLOSForEachPrn is deprecated since 21.3. You may use EnableLosForEachSV.\n\nGet Direct Line Of Sight signal from satellite disabled or enabled. Generally used when only multipaths signal is visible.";

    REGISTER_COMMAND_FACTORY(IsLOSEnabledForEachPrn);


    IsLOSEnabledForEachPrn::IsLOSEnabledForEachPrn()
      : CommandBase(CmdName)
    {}

    IsLOSEnabledForEachPrn::IsLOSEnabledForEachPrn(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    IsLOSEnabledForEachPrnPtr IsLOSEnabledForEachPrn::create(const std::string& system)
    {
      return IsLOSEnabledForEachPrnPtr(new IsLOSEnabledForEachPrn(system));
    }

    IsLOSEnabledForEachPrnPtr IsLOSEnabledForEachPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLOSEnabledForEachPrn>(ptr);
    }

    bool IsLOSEnabledForEachPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string IsLOSEnabledForEachPrn::documentation() const { return Documentation; }


    int IsLOSEnabledForEachPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsLOSEnabledForEachPrn::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLOSEnabledForEachPrn::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsLOSEnabledForEachPrnResult
///
#include "gen/IsLOSEnabledForEachPrnResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsLOSEnabledForEachPrnResult::CmdName = "IsLOSEnabledForEachPrnResult";
    const char* const IsLOSEnabledForEachPrnResult::Documentation = "Result of IsLOSEnabledForEachPrn";

    REGISTER_COMMAND_RESULT_FACTORY(IsLOSEnabledForEachPrnResult);


    IsLOSEnabledForEachPrnResult::IsLOSEnabledForEachPrnResult()
      : CommandResult(CmdName)
    {}

    IsLOSEnabledForEachPrnResult::IsLOSEnabledForEachPrnResult(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setEnabled(enabled);
    }


    IsLOSEnabledForEachPrnResultPtr IsLOSEnabledForEachPrnResult::create(CommandBasePtr relatedCommand, const std::string& system, const std::vector<bool>& enabled)
    {
      return IsLOSEnabledForEachPrnResultPtr(new IsLOSEnabledForEachPrnResult(relatedCommand, system, enabled));
    }

    IsLOSEnabledForEachPrnResultPtr IsLOSEnabledForEachPrnResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsLOSEnabledForEachPrnResult>(ptr);
    }

    bool IsLOSEnabledForEachPrnResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsLOSEnabledForEachPrnResult::documentation() const { return Documentation; }


    std::string IsLOSEnabledForEachPrnResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsLOSEnabledForEachPrnResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> IsLOSEnabledForEachPrnResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void IsLOSEnabledForEachPrnResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouSatelliteHealthInfo
///
#include "gen/SetBeiDouSatelliteHealthInfo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouSatelliteHealthInfo::CmdName = "SetBeiDouSatelliteHealthInfo";
    const char* const SetBeiDouSatelliteHealthInfo::Documentation = "Please note the command BeiDouSatelliteHealthInfo is deprecated since 21.3. You may use BeiDouHealthInfoForSV.\n\nSet BeiDou satellite health info";

    REGISTER_COMMAND_FACTORY(SetBeiDouSatelliteHealthInfo);


    SetBeiDouSatelliteHealthInfo::SetBeiDouSatelliteHealthInfo()
      : CommandBase(CmdName)
    {}

    SetBeiDouSatelliteHealthInfo::SetBeiDouSatelliteHealthInfo(int prn, int health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetBeiDouSatelliteHealthInfoPtr SetBeiDouSatelliteHealthInfo::create(int prn, int health)
    {
      return SetBeiDouSatelliteHealthInfoPtr(new SetBeiDouSatelliteHealthInfo(prn, health));
    }

    SetBeiDouSatelliteHealthInfoPtr SetBeiDouSatelliteHealthInfo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouSatelliteHealthInfo>(ptr);
    }

    bool SetBeiDouSatelliteHealthInfo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetBeiDouSatelliteHealthInfo::documentation() const { return Documentation; }


    int SetBeiDouSatelliteHealthInfo::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouSatelliteHealthInfo::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouSatelliteHealthInfo::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouSatelliteHealthInfo::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetBeiDouSatelliteHealthInfo::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouSatelliteHealthInfo
///
#include "gen/GetBeiDouSatelliteHealthInfo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouSatelliteHealthInfo::CmdName = "GetBeiDouSatelliteHealthInfo";
    const char* const GetBeiDouSatelliteHealthInfo::Documentation = "Please note the command BeiDouSatelliteHealthInfo is deprecated since 21.3. You may use BeiDouHealthInfoForSV.\n\nGet BeiDou satellite health info";

    REGISTER_COMMAND_FACTORY(GetBeiDouSatelliteHealthInfo);


    GetBeiDouSatelliteHealthInfo::GetBeiDouSatelliteHealthInfo()
      : CommandBase(CmdName)
    {}

    GetBeiDouSatelliteHealthInfo::GetBeiDouSatelliteHealthInfo(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouSatelliteHealthInfoPtr GetBeiDouSatelliteHealthInfo::create(int prn)
    {
      return GetBeiDouSatelliteHealthInfoPtr(new GetBeiDouSatelliteHealthInfo(prn));
    }

    GetBeiDouSatelliteHealthInfoPtr GetBeiDouSatelliteHealthInfo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouSatelliteHealthInfo>(ptr);
    }

    bool GetBeiDouSatelliteHealthInfo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouSatelliteHealthInfo::documentation() const { return Documentation; }


    int GetBeiDouSatelliteHealthInfo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouSatelliteHealthInfo::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouSatelliteHealthInfo::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouSatelliteHealthInfoResult
///
#include "gen/GetBeiDouSatelliteHealthInfoResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouSatelliteHealthInfoResult::CmdName = "GetBeiDouSatelliteHealthInfoResult";
    const char* const GetBeiDouSatelliteHealthInfoResult::Documentation = "Result of GetBeiDouSatelliteHealthInfo";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouSatelliteHealthInfoResult);


    GetBeiDouSatelliteHealthInfoResult::GetBeiDouSatelliteHealthInfoResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouSatelliteHealthInfoResult::GetBeiDouSatelliteHealthInfoResult(CommandBasePtr relatedCommand, int prn, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetBeiDouSatelliteHealthInfoResultPtr GetBeiDouSatelliteHealthInfoResult::create(CommandBasePtr relatedCommand, int prn, int health)
    {
      return GetBeiDouSatelliteHealthInfoResultPtr(new GetBeiDouSatelliteHealthInfoResult(relatedCommand, prn, health));
    }

    GetBeiDouSatelliteHealthInfoResultPtr GetBeiDouSatelliteHealthInfoResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouSatelliteHealthInfoResult>(ptr);
    }

    bool GetBeiDouSatelliteHealthInfoResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetBeiDouSatelliteHealthInfoResult::documentation() const { return Documentation; }


    int GetBeiDouSatelliteHealthInfoResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouSatelliteHealthInfoResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouSatelliteHealthInfoResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetBeiDouSatelliteHealthInfoResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouSatelliteAutonomousHealth
///
#include "gen/SetBeiDouSatelliteAutonomousHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouSatelliteAutonomousHealth::CmdName = "SetBeiDouSatelliteAutonomousHealth";
    const char* const SetBeiDouSatelliteAutonomousHealth::Documentation = "Please note the command BeiDouSatelliteAutonomousHealth is deprecated since 21.3. You may use BeiDouAutonomousHealthForSV.\n\nSet BeiDou satellite autonomous health";

    REGISTER_COMMAND_FACTORY(SetBeiDouSatelliteAutonomousHealth);


    SetBeiDouSatelliteAutonomousHealth::SetBeiDouSatelliteAutonomousHealth()
      : CommandBase(CmdName)
    {}

    SetBeiDouSatelliteAutonomousHealth::SetBeiDouSatelliteAutonomousHealth(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetBeiDouSatelliteAutonomousHealthPtr SetBeiDouSatelliteAutonomousHealth::create(int prn, bool health)
    {
      return SetBeiDouSatelliteAutonomousHealthPtr(new SetBeiDouSatelliteAutonomousHealth(prn, health));
    }

    SetBeiDouSatelliteAutonomousHealthPtr SetBeiDouSatelliteAutonomousHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouSatelliteAutonomousHealth>(ptr);
    }

    bool SetBeiDouSatelliteAutonomousHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetBeiDouSatelliteAutonomousHealth::documentation() const { return Documentation; }


    int SetBeiDouSatelliteAutonomousHealth::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouSatelliteAutonomousHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouSatelliteAutonomousHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetBeiDouSatelliteAutonomousHealth::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetBeiDouSatelliteAutonomousHealth::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouSatelliteAutonomousHealth
///
#include "gen/GetBeiDouSatelliteAutonomousHealth.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouSatelliteAutonomousHealth::CmdName = "GetBeiDouSatelliteAutonomousHealth";
    const char* const GetBeiDouSatelliteAutonomousHealth::Documentation = "Please note the command BeiDouSatelliteAutonomousHealth is deprecated since 21.3. You may use BeiDouAutonomousHealthForSV.\n\nGet BeiDou satellite autonomous health";

    REGISTER_COMMAND_FACTORY(GetBeiDouSatelliteAutonomousHealth);


    GetBeiDouSatelliteAutonomousHealth::GetBeiDouSatelliteAutonomousHealth()
      : CommandBase(CmdName)
    {}

    GetBeiDouSatelliteAutonomousHealth::GetBeiDouSatelliteAutonomousHealth(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouSatelliteAutonomousHealthPtr GetBeiDouSatelliteAutonomousHealth::create(int prn)
    {
      return GetBeiDouSatelliteAutonomousHealthPtr(new GetBeiDouSatelliteAutonomousHealth(prn));
    }

    GetBeiDouSatelliteAutonomousHealthPtr GetBeiDouSatelliteAutonomousHealth::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouSatelliteAutonomousHealth>(ptr);
    }

    bool GetBeiDouSatelliteAutonomousHealth::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouSatelliteAutonomousHealth::documentation() const { return Documentation; }


    int GetBeiDouSatelliteAutonomousHealth::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouSatelliteAutonomousHealth::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouSatelliteAutonomousHealth::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouSatelliteAutonomousHealthResult
///
#include "gen/GetBeiDouSatelliteAutonomousHealthResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouSatelliteAutonomousHealthResult::CmdName = "GetBeiDouSatelliteAutonomousHealthResult";
    const char* const GetBeiDouSatelliteAutonomousHealthResult::Documentation = "Result of GetBeiDouSatelliteAutonomousHealth";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouSatelliteAutonomousHealthResult);


    GetBeiDouSatelliteAutonomousHealthResult::GetBeiDouSatelliteAutonomousHealthResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouSatelliteAutonomousHealthResult::GetBeiDouSatelliteAutonomousHealthResult(CommandBasePtr relatedCommand, int prn, bool health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetBeiDouSatelliteAutonomousHealthResultPtr GetBeiDouSatelliteAutonomousHealthResult::create(CommandBasePtr relatedCommand, int prn, bool health)
    {
      return GetBeiDouSatelliteAutonomousHealthResultPtr(new GetBeiDouSatelliteAutonomousHealthResult(relatedCommand, prn, health));
    }

    GetBeiDouSatelliteAutonomousHealthResultPtr GetBeiDouSatelliteAutonomousHealthResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouSatelliteAutonomousHealthResult>(ptr);
    }

    bool GetBeiDouSatelliteAutonomousHealthResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string GetBeiDouSatelliteAutonomousHealthResult::documentation() const { return Documentation; }


    int GetBeiDouSatelliteAutonomousHealthResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouSatelliteAutonomousHealthResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouSatelliteAutonomousHealthResult::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void GetBeiDouSatelliteAutonomousHealthResult::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouCNavSatelliteHealthInfo
///
#include "gen/SetBeiDouCNavSatelliteHealthInfo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouCNavSatelliteHealthInfo::CmdName = "SetBeiDouCNavSatelliteHealthInfo";
    const char* const SetBeiDouCNavSatelliteHealthInfo::Documentation = "Please note the command BeiDouCNavSatelliteHealthInfo is deprecated since 21.3. You may use BeiDouCNavHealthInfoForSV.\n\nSet BeiDou CNav satellite health info";

    REGISTER_COMMAND_FACTORY(SetBeiDouCNavSatelliteHealthInfo);


    SetBeiDouCNavSatelliteHealthInfo::SetBeiDouCNavSatelliteHealthInfo()
      : CommandBase(CmdName)
    {}

    SetBeiDouCNavSatelliteHealthInfo::SetBeiDouCNavSatelliteHealthInfo(int prn, int health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetBeiDouCNavSatelliteHealthInfoPtr SetBeiDouCNavSatelliteHealthInfo::create(int prn, int health)
    {
      return SetBeiDouCNavSatelliteHealthInfoPtr(new SetBeiDouCNavSatelliteHealthInfo(prn, health));
    }

    SetBeiDouCNavSatelliteHealthInfoPtr SetBeiDouCNavSatelliteHealthInfo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouCNavSatelliteHealthInfo>(ptr);
    }

    bool SetBeiDouCNavSatelliteHealthInfo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetBeiDouCNavSatelliteHealthInfo::documentation() const { return Documentation; }


    int SetBeiDouCNavSatelliteHealthInfo::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouCNavSatelliteHealthInfo::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouCNavSatelliteHealthInfo::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouCNavSatelliteHealthInfo::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetBeiDouCNavSatelliteHealthInfo::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNavSatelliteHealthInfo
///
#include "gen/GetBeiDouCNavSatelliteHealthInfo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNavSatelliteHealthInfo::CmdName = "GetBeiDouCNavSatelliteHealthInfo";
    const char* const GetBeiDouCNavSatelliteHealthInfo::Documentation = "Please note the command BeiDouCNavSatelliteHealthInfo is deprecated since 21.3. You may use BeiDouCNavHealthInfoForSV.\n\nGet BeiDou CNav satellite health info";

    REGISTER_COMMAND_FACTORY(GetBeiDouCNavSatelliteHealthInfo);


    GetBeiDouCNavSatelliteHealthInfo::GetBeiDouCNavSatelliteHealthInfo()
      : CommandBase(CmdName)
    {}

    GetBeiDouCNavSatelliteHealthInfo::GetBeiDouCNavSatelliteHealthInfo(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouCNavSatelliteHealthInfoPtr GetBeiDouCNavSatelliteHealthInfo::create(int prn)
    {
      return GetBeiDouCNavSatelliteHealthInfoPtr(new GetBeiDouCNavSatelliteHealthInfo(prn));
    }

    GetBeiDouCNavSatelliteHealthInfoPtr GetBeiDouCNavSatelliteHealthInfo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNavSatelliteHealthInfo>(ptr);
    }

    bool GetBeiDouCNavSatelliteHealthInfo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouCNavSatelliteHealthInfo::documentation() const { return Documentation; }


    int GetBeiDouCNavSatelliteHealthInfo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouCNavSatelliteHealthInfo::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouCNavSatelliteHealthInfo::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNavSatelliteHealthInfoResult
///
#include "gen/GetBeiDouCNavSatelliteHealthInfoResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNavSatelliteHealthInfoResult::CmdName = "GetBeiDouCNavSatelliteHealthInfoResult";
    const char* const GetBeiDouCNavSatelliteHealthInfoResult::Documentation = "Result of GetBeiDouCNavSatelliteHealthInfo";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouCNavSatelliteHealthInfoResult);


    GetBeiDouCNavSatelliteHealthInfoResult::GetBeiDouCNavSatelliteHealthInfoResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouCNavSatelliteHealthInfoResult::GetBeiDouCNavSatelliteHealthInfoResult(CommandBasePtr relatedCommand, int prn, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetBeiDouCNavSatelliteHealthInfoResultPtr GetBeiDouCNavSatelliteHealthInfoResult::create(CommandBasePtr relatedCommand, int prn, int health)
    {
      return GetBeiDouCNavSatelliteHealthInfoResultPtr(new GetBeiDouCNavSatelliteHealthInfoResult(relatedCommand, prn, health));
    }

    GetBeiDouCNavSatelliteHealthInfoResultPtr GetBeiDouCNavSatelliteHealthInfoResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNavSatelliteHealthInfoResult>(ptr);
    }

    bool GetBeiDouCNavSatelliteHealthInfoResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetBeiDouCNavSatelliteHealthInfoResult::documentation() const { return Documentation; }


    int GetBeiDouCNavSatelliteHealthInfoResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouCNavSatelliteHealthInfoResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouCNavSatelliteHealthInfoResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetBeiDouCNavSatelliteHealthInfoResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouSatelliteHealthStatus
///
#include "gen/SetBeiDouSatelliteHealthStatus.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouSatelliteHealthStatus::CmdName = "SetBeiDouSatelliteHealthStatus";
    const char* const SetBeiDouSatelliteHealthStatus::Documentation = "Please note the command BeiDouSatelliteHealthStatus is deprecated since 21.3. You may use BeiDouHealthStatusForSV.\n\nSet BeiDou satellite health status";

    REGISTER_COMMAND_FACTORY(SetBeiDouSatelliteHealthStatus);


    SetBeiDouSatelliteHealthStatus::SetBeiDouSatelliteHealthStatus()
      : CommandBase(CmdName)
    {}

    SetBeiDouSatelliteHealthStatus::SetBeiDouSatelliteHealthStatus(int prn, int health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetBeiDouSatelliteHealthStatusPtr SetBeiDouSatelliteHealthStatus::create(int prn, int health)
    {
      return SetBeiDouSatelliteHealthStatusPtr(new SetBeiDouSatelliteHealthStatus(prn, health));
    }

    SetBeiDouSatelliteHealthStatusPtr SetBeiDouSatelliteHealthStatus::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouSatelliteHealthStatus>(ptr);
    }

    bool SetBeiDouSatelliteHealthStatus::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetBeiDouSatelliteHealthStatus::documentation() const { return Documentation; }


    int SetBeiDouSatelliteHealthStatus::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetBeiDouSatelliteHealthStatus::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouSatelliteHealthStatus::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouSatelliteHealthStatus::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetBeiDouSatelliteHealthStatus::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouSatelliteHealthStatus
///
#include "gen/GetBeiDouSatelliteHealthStatus.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouSatelliteHealthStatus::CmdName = "GetBeiDouSatelliteHealthStatus";
    const char* const GetBeiDouSatelliteHealthStatus::Documentation = "Please note the command BeiDouSatelliteHealthStatus is deprecated since 21.3. You may use BeiDouHealthStatusForSV.\n\nGet BeiDou satellite health status";

    REGISTER_COMMAND_FACTORY(GetBeiDouSatelliteHealthStatus);


    GetBeiDouSatelliteHealthStatus::GetBeiDouSatelliteHealthStatus()
      : CommandBase(CmdName)
    {}

    GetBeiDouSatelliteHealthStatus::GetBeiDouSatelliteHealthStatus(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouSatelliteHealthStatusPtr GetBeiDouSatelliteHealthStatus::create(int prn)
    {
      return GetBeiDouSatelliteHealthStatusPtr(new GetBeiDouSatelliteHealthStatus(prn));
    }

    GetBeiDouSatelliteHealthStatusPtr GetBeiDouSatelliteHealthStatus::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouSatelliteHealthStatus>(ptr);
    }

    bool GetBeiDouSatelliteHealthStatus::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouSatelliteHealthStatus::documentation() const { return Documentation; }


    int GetBeiDouSatelliteHealthStatus::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouSatelliteHealthStatus::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouSatelliteHealthStatus::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouSatelliteHealthStatusResult
///
#include "gen/GetBeiDouSatelliteHealthStatusResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouSatelliteHealthStatusResult::CmdName = "GetBeiDouSatelliteHealthStatusResult";
    const char* const GetBeiDouSatelliteHealthStatusResult::Documentation = "Result of GetBeiDouSatelliteHealthStatus";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouSatelliteHealthStatusResult);


    GetBeiDouSatelliteHealthStatusResult::GetBeiDouSatelliteHealthStatusResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouSatelliteHealthStatusResult::GetBeiDouSatelliteHealthStatusResult(CommandBasePtr relatedCommand, int prn, int health)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setHealth(health);
    }


    GetBeiDouSatelliteHealthStatusResultPtr GetBeiDouSatelliteHealthStatusResult::create(CommandBasePtr relatedCommand, int prn, int health)
    {
      return GetBeiDouSatelliteHealthStatusResultPtr(new GetBeiDouSatelliteHealthStatusResult(relatedCommand, prn, health));
    }

    GetBeiDouSatelliteHealthStatusResultPtr GetBeiDouSatelliteHealthStatusResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouSatelliteHealthStatusResult>(ptr);
    }

    bool GetBeiDouSatelliteHealthStatusResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string GetBeiDouSatelliteHealthStatusResult::documentation() const { return Documentation; }


    int GetBeiDouSatelliteHealthStatusResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouSatelliteHealthStatusResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouSatelliteHealthStatusResult::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void GetBeiDouSatelliteHealthStatusResult::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsUraIndex
///
#include "gen/SetGpsUraIndex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsUraIndex::CmdName = "SetGpsUraIndex";
    const char* const SetGpsUraIndex::Documentation = "Please note the command SetGpsUraIndex is deprecated since 21.3. You may use SetGpsUraIndexForSV.\n\nSet the ura index of a GPS satellite";

    REGISTER_COMMAND_FACTORY(SetGpsUraIndex);


    SetGpsUraIndex::SetGpsUraIndex()
      : CommandBase(CmdName)
    {}

    SetGpsUraIndex::SetGpsUraIndex(int prn, int urai)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setUrai(urai);
    }


    SetGpsUraIndexPtr SetGpsUraIndex::create(int prn, int urai)
    {
      return SetGpsUraIndexPtr(new SetGpsUraIndex(prn, urai));
    }

    SetGpsUraIndexPtr SetGpsUraIndex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsUraIndex>(ptr);
    }

    bool SetGpsUraIndex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Urai"])
        ;

    }

    std::string SetGpsUraIndex::documentation() const { return Documentation; }


    int SetGpsUraIndex::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGpsUraIndex::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGpsUraIndex::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsUraIndex::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetGpsUraIndex::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetBeiDouUraIndex
///
#include "gen/SetBeiDouUraIndex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetBeiDouUraIndex::CmdName = "SetBeiDouUraIndex";
    const char* const SetBeiDouUraIndex::Documentation = "Please note the command SetBeiDouUraIndex is deprecated since 21.3. You may use SetBeiDouUraIndexForSV.\n\nSet the ura index of a BeiDou satellite";

    REGISTER_COMMAND_FACTORY(SetBeiDouUraIndex);


    SetBeiDouUraIndex::SetBeiDouUraIndex()
      : CommandBase(CmdName)
    {}

    SetBeiDouUraIndex::SetBeiDouUraIndex(int prn, int urai)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setUrai(urai);
    }


    SetBeiDouUraIndexPtr SetBeiDouUraIndex::create(int prn, int urai)
    {
      return SetBeiDouUraIndexPtr(new SetBeiDouUraIndex(prn, urai));
    }

    SetBeiDouUraIndexPtr SetBeiDouUraIndex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetBeiDouUraIndex>(ptr);
    }

    bool SetBeiDouUraIndex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Urai"])
        ;

    }

    std::string SetBeiDouUraIndex::documentation() const { return Documentation; }


    int SetBeiDouUraIndex::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetBeiDouUraIndex::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetBeiDouUraIndex::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetBeiDouUraIndex::urai() const
    {
      return parse_json<int>::parse(m_values["Urai"]);
    }

    void SetBeiDouUraIndex::setUrai(int urai)
    {
      m_values.AddMember("Urai", parse_json<int>::format(urai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToGpsCNavMessage
///
#include "gen/SetModificationToGpsCNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToGpsCNavMessage::CmdName = "SetModificationToGpsCNavMessage";
    const char* const SetModificationToGpsCNavMessage::Documentation = "Please note the command ModificationToGpsCNavMessage is deprecated since 21.3. You may use MessageModificationToGpsCNav.\n\nSet (or Modify) event to change CNAV message bits. If you send this command without setting the Id\nparameter, or if you set the Id with a value never used before, a new Modification event will be\ncreated. If you reuse the same event Id, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbits mods.\n\nBitsMods can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bits mods using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetModificationToGpsCNavMessage);


    SetModificationToGpsCNavMessage::SetModificationToGpsCNavMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToGpsCNavMessage::SetModificationToGpsCNavMessage(int prn, int startTime, int stopTime, int msgTypeId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMsgTypeId(msgTypeId);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    SetModificationToGpsCNavMessagePtr SetModificationToGpsCNavMessage::create(int prn, int startTime, int stopTime, int msgTypeId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return SetModificationToGpsCNavMessagePtr(new SetModificationToGpsCNavMessage(prn, startTime, stopTime, msgTypeId, condition, updateCRC, bitsMods, id));
    }

    SetModificationToGpsCNavMessagePtr SetModificationToGpsCNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToGpsCNavMessage>(ptr);
    }

    bool SetModificationToGpsCNavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MsgTypeId"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToGpsCNavMessage::documentation() const { return Documentation; }


    int SetModificationToGpsCNavMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToGpsCNavMessage::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToGpsCNavMessage::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsCNavMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToGpsCNavMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsCNavMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToGpsCNavMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsCNavMessage::msgTypeId() const
    {
      return parse_json<int>::parse(m_values["MsgTypeId"]);
    }

    void SetModificationToGpsCNavMessage::setMsgTypeId(int msgTypeId)
    {
      m_values.AddMember("MsgTypeId", parse_json<int>::format(msgTypeId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsCNavMessage::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetModificationToGpsCNavMessage::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToGpsCNavMessage::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetModificationToGpsCNavMessage::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsCNavMessage::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void SetModificationToGpsCNavMessage::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsCNavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToGpsCNavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNavMessage
///
#include "gen/GetGpsCNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNavMessage::CmdName = "GetGpsCNavMessage";
    const char* const GetGpsCNavMessage::Documentation = "Please note the command ModificationToGpsCNavMessage is deprecated since 21.3. You may use MessageModificationToGpsCNav.\n\nGet infos about the CNAV Message with this id";

    REGISTER_COMMAND_FACTORY(GetGpsCNavMessage);


    GetGpsCNavMessage::GetGpsCNavMessage()
      : CommandBase(CmdName)
    {}

    GetGpsCNavMessage::GetGpsCNavMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetGpsCNavMessagePtr GetGpsCNavMessage::create(const std::string& id)
    {
      return GetGpsCNavMessagePtr(new GetGpsCNavMessage(id));
    }

    GetGpsCNavMessagePtr GetGpsCNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNavMessage>(ptr);
    }

    bool GetGpsCNavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpsCNavMessage::documentation() const { return Documentation; }


    int GetGpsCNavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsCNavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpsCNavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNavMessageResult
///
#include "gen/GetGpsCNavMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNavMessageResult::CmdName = "GetGpsCNavMessageResult";
    const char* const GetGpsCNavMessageResult::Documentation = "Result of GetGpsCNavMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsCNavMessageResult);


    GetGpsCNavMessageResult::GetGpsCNavMessageResult()
      : CommandResult(CmdName)
    {}

    GetGpsCNavMessageResult::GetGpsCNavMessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int msgTypeId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMsgTypeId(msgTypeId);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    GetGpsCNavMessageResultPtr GetGpsCNavMessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int msgTypeId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return GetGpsCNavMessageResultPtr(new GetGpsCNavMessageResult(relatedCommand, prn, startTime, stopTime, msgTypeId, condition, updateCRC, bitsMods, id));
    }

    GetGpsCNavMessageResultPtr GetGpsCNavMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNavMessageResult>(ptr);
    }

    bool GetGpsCNavMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MsgTypeId"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpsCNavMessageResult::documentation() const { return Documentation; }


    int GetGpsCNavMessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsCNavMessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsCNavMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetGpsCNavMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsCNavMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetGpsCNavMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsCNavMessageResult::msgTypeId() const
    {
      return parse_json<int>::parse(m_values["MsgTypeId"]);
    }

    void GetGpsCNavMessageResult::setMsgTypeId(int msgTypeId)
    {
      m_values.AddMember("MsgTypeId", parse_json<int>::format(msgTypeId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsCNavMessageResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetGpsCNavMessageResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsCNavMessageResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetGpsCNavMessageResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsCNavMessageResult::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void GetGpsCNavMessageResult::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsCNavMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpsCNavMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToGpsCNavMessage
///
#include "gen/RemoveModificationToGpsCNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToGpsCNavMessage::CmdName = "RemoveModificationToGpsCNavMessage";
    const char* const RemoveModificationToGpsCNavMessage::Documentation = "Please note the command RemoveModificationToGpsCNavMessage is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves a modification.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToGpsCNavMessage);


    RemoveModificationToGpsCNavMessage::RemoveModificationToGpsCNavMessage()
      : CommandBase(CmdName)
    {}

    RemoveModificationToGpsCNavMessage::RemoveModificationToGpsCNavMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToGpsCNavMessagePtr RemoveModificationToGpsCNavMessage::create(const std::string& id)
    {
      return RemoveModificationToGpsCNavMessagePtr(new RemoveModificationToGpsCNavMessage(id));
    }

    RemoveModificationToGpsCNavMessagePtr RemoveModificationToGpsCNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToGpsCNavMessage>(ptr);
    }

    bool RemoveModificationToGpsCNavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToGpsCNavMessage::documentation() const { return Documentation; }


    int RemoveModificationToGpsCNavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToGpsCNavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToGpsCNavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToGpsCNavMessage
///
#include "gen/ClearAllModificationsToGpsCNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToGpsCNavMessage::CmdName = "ClearAllModificationsToGpsCNavMessage";
    const char* const ClearAllModificationsToGpsCNavMessage::Documentation = "Please note the command ClearAllModificationsToGpsCNavMessage is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change GPS navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToGpsCNavMessage);


    ClearAllModificationsToGpsCNavMessage::ClearAllModificationsToGpsCNavMessage()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToGpsCNavMessagePtr ClearAllModificationsToGpsCNavMessage::create()
    {
      return ClearAllModificationsToGpsCNavMessagePtr(new ClearAllModificationsToGpsCNavMessage());
    }

    ClearAllModificationsToGpsCNavMessagePtr ClearAllModificationsToGpsCNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToGpsCNavMessage>(ptr);
    }

    bool ClearAllModificationsToGpsCNavMessage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToGpsCNavMessage::documentation() const { return Documentation; }


    int ClearAllModificationsToGpsCNavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsCNavMessages
///
#include "gen/GetGpsCNavMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNavMessages::CmdName = "GetGpsCNavMessages";
    const char* const GetGpsCNavMessages::Documentation = "Please note the command GetGpsCNavMessages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the GPS CNav Message for this PRN";

    REGISTER_COMMAND_FACTORY(GetGpsCNavMessages);


    GetGpsCNavMessages::GetGpsCNavMessages()
      : CommandBase(CmdName)
    {}

    GetGpsCNavMessages::GetGpsCNavMessages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsCNavMessagesPtr GetGpsCNavMessages::create(int prn)
    {
      return GetGpsCNavMessagesPtr(new GetGpsCNavMessages(prn));
    }

    GetGpsCNavMessagesPtr GetGpsCNavMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNavMessages>(ptr);
    }

    bool GetGpsCNavMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsCNavMessages::documentation() const { return Documentation; }


    int GetGpsCNavMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsCNavMessages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsCNavMessages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNavMessagesResult
///
#include "gen/GetGpsCNavMessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNavMessagesResult::CmdName = "GetGpsCNavMessagesResult";
    const char* const GetGpsCNavMessagesResult::Documentation = "Result of GetGpsCNavMessages";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsCNavMessagesResult);


    GetGpsCNavMessagesResult::GetGpsCNavMessagesResult()
      : CommandResult(CmdName)
    {}

    GetGpsCNavMessagesResult::GetGpsCNavMessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetGpsCNavMessagesResultPtr GetGpsCNavMessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetGpsCNavMessagesResultPtr(new GetGpsCNavMessagesResult(relatedCommand, ids));
    }

    GetGpsCNavMessagesResultPtr GetGpsCNavMessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNavMessagesResult>(ptr);
    }

    bool GetGpsCNavMessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetGpsCNavMessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetGpsCNavMessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetGpsCNavMessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToGpsMNavMessage
///
#include "gen/SetModificationToGpsMNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToGpsMNavMessage::CmdName = "SetModificationToGpsMNavMessage";
    const char* const SetModificationToGpsMNavMessage::Documentation = "Please note the command SetModificationToGpsMNavMessage is deprecated since 21.3. You may use SetMessageModificationToGpsMNav.\n\nSet (or Modify) event to change MNAV message bits. If you send this command without setting the Id\nparameter, or if you set the Id with a value never used before, a new Modification event will be\ncreated. If you reuse the same event Id, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbits mods.\n\nBitsMods can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bits mods using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetModificationToGpsMNavMessage);


    SetModificationToGpsMNavMessage::SetModificationToGpsMNavMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToGpsMNavMessage::SetModificationToGpsMNavMessage(int prn, int startTime, int stopTime, int msgTypeId, int occurrence, const std::string& condition, const std::string& bitsMods, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMsgTypeId(msgTypeId);
      setOccurrence(occurrence);
      setCondition(condition);
      setBitsMods(bitsMods);
      setId(id);
    }


    SetModificationToGpsMNavMessagePtr SetModificationToGpsMNavMessage::create(int prn, int startTime, int stopTime, int msgTypeId, int occurrence, const std::string& condition, const std::string& bitsMods, const std::string& id)
    {
      return SetModificationToGpsMNavMessagePtr(new SetModificationToGpsMNavMessage(prn, startTime, stopTime, msgTypeId, occurrence, condition, bitsMods, id));
    }

    SetModificationToGpsMNavMessagePtr SetModificationToGpsMNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToGpsMNavMessage>(ptr);
    }

    bool SetModificationToGpsMNavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MsgTypeId"])
          && parse_json<int>::is_valid(m_values["Occurrence"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToGpsMNavMessage::documentation() const { return Documentation; }


    int SetModificationToGpsMNavMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToGpsMNavMessage::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToGpsMNavMessage::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsMNavMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToGpsMNavMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsMNavMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToGpsMNavMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsMNavMessage::msgTypeId() const
    {
      return parse_json<int>::parse(m_values["MsgTypeId"]);
    }

    void SetModificationToGpsMNavMessage::setMsgTypeId(int msgTypeId)
    {
      m_values.AddMember("MsgTypeId", parse_json<int>::format(msgTypeId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsMNavMessage::occurrence() const
    {
      return parse_json<int>::parse(m_values["Occurrence"]);
    }

    void SetModificationToGpsMNavMessage::setOccurrence(int occurrence)
    {
      m_values.AddMember("Occurrence", parse_json<int>::format(occurrence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsMNavMessage::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetModificationToGpsMNavMessage::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsMNavMessage::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void SetModificationToGpsMNavMessage::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsMNavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToGpsMNavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsMNavMessage
///
#include "gen/GetGpsMNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsMNavMessage::CmdName = "GetGpsMNavMessage";
    const char* const GetGpsMNavMessage::Documentation = "Please note the command GetGpsMNavMessage is deprecated since 21.3. You may use GetMessageModificationToGpsMNav.\n\nGet infos about the MNAV Message with this id";

    REGISTER_COMMAND_FACTORY(GetGpsMNavMessage);


    GetGpsMNavMessage::GetGpsMNavMessage()
      : CommandBase(CmdName)
    {}

    GetGpsMNavMessage::GetGpsMNavMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetGpsMNavMessagePtr GetGpsMNavMessage::create(const std::string& id)
    {
      return GetGpsMNavMessagePtr(new GetGpsMNavMessage(id));
    }

    GetGpsMNavMessagePtr GetGpsMNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsMNavMessage>(ptr);
    }

    bool GetGpsMNavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpsMNavMessage::documentation() const { return Documentation; }


    int GetGpsMNavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsMNavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpsMNavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsMNavMessageResult
///
#include "gen/GetGpsMNavMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsMNavMessageResult::CmdName = "GetGpsMNavMessageResult";
    const char* const GetGpsMNavMessageResult::Documentation = "Result of GetGpsMNavMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsMNavMessageResult);


    GetGpsMNavMessageResult::GetGpsMNavMessageResult()
      : CommandResult(CmdName)
    {}

    GetGpsMNavMessageResult::GetGpsMNavMessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int msgTypeId, int occurrence, const std::string& condition, const std::string& bitsMods, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMsgTypeId(msgTypeId);
      setOccurrence(occurrence);
      setCondition(condition);
      setBitsMods(bitsMods);
      setId(id);
    }


    GetGpsMNavMessageResultPtr GetGpsMNavMessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int msgTypeId, int occurrence, const std::string& condition, const std::string& bitsMods, const std::string& id)
    {
      return GetGpsMNavMessageResultPtr(new GetGpsMNavMessageResult(relatedCommand, prn, startTime, stopTime, msgTypeId, occurrence, condition, bitsMods, id));
    }

    GetGpsMNavMessageResultPtr GetGpsMNavMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsMNavMessageResult>(ptr);
    }

    bool GetGpsMNavMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MsgTypeId"])
          && parse_json<int>::is_valid(m_values["Occurrence"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpsMNavMessageResult::documentation() const { return Documentation; }


    int GetGpsMNavMessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsMNavMessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsMNavMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetGpsMNavMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsMNavMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetGpsMNavMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsMNavMessageResult::msgTypeId() const
    {
      return parse_json<int>::parse(m_values["MsgTypeId"]);
    }

    void GetGpsMNavMessageResult::setMsgTypeId(int msgTypeId)
    {
      m_values.AddMember("MsgTypeId", parse_json<int>::format(msgTypeId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsMNavMessageResult::occurrence() const
    {
      return parse_json<int>::parse(m_values["Occurrence"]);
    }

    void GetGpsMNavMessageResult::setOccurrence(int occurrence)
    {
      m_values.AddMember("Occurrence", parse_json<int>::format(occurrence, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsMNavMessageResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetGpsMNavMessageResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsMNavMessageResult::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void GetGpsMNavMessageResult::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsMNavMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpsMNavMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToGpsMNavMessage
///
#include "gen/RemoveModificationToGpsMNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToGpsMNavMessage::CmdName = "RemoveModificationToGpsMNavMessage";
    const char* const RemoveModificationToGpsMNavMessage::Documentation = "Please note the command RemoveModificationToGpsMNavMessage is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves a modification.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToGpsMNavMessage);


    RemoveModificationToGpsMNavMessage::RemoveModificationToGpsMNavMessage()
      : CommandBase(CmdName)
    {}

    RemoveModificationToGpsMNavMessage::RemoveModificationToGpsMNavMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToGpsMNavMessagePtr RemoveModificationToGpsMNavMessage::create(const std::string& id)
    {
      return RemoveModificationToGpsMNavMessagePtr(new RemoveModificationToGpsMNavMessage(id));
    }

    RemoveModificationToGpsMNavMessagePtr RemoveModificationToGpsMNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToGpsMNavMessage>(ptr);
    }

    bool RemoveModificationToGpsMNavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToGpsMNavMessage::documentation() const { return Documentation; }


    int RemoveModificationToGpsMNavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToGpsMNavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToGpsMNavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToGpsMNavMessage
///
#include "gen/ClearAllModificationsToGpsMNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToGpsMNavMessage::CmdName = "ClearAllModificationsToGpsMNavMessage";
    const char* const ClearAllModificationsToGpsMNavMessage::Documentation = "Please note the command ClearAllModificationsToGpsMNavMessage is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change GPS navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToGpsMNavMessage);


    ClearAllModificationsToGpsMNavMessage::ClearAllModificationsToGpsMNavMessage()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToGpsMNavMessagePtr ClearAllModificationsToGpsMNavMessage::create()
    {
      return ClearAllModificationsToGpsMNavMessagePtr(new ClearAllModificationsToGpsMNavMessage());
    }

    ClearAllModificationsToGpsMNavMessagePtr ClearAllModificationsToGpsMNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToGpsMNavMessage>(ptr);
    }

    bool ClearAllModificationsToGpsMNavMessage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToGpsMNavMessage::documentation() const { return Documentation; }


    int ClearAllModificationsToGpsMNavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsMNavMessages
///
#include "gen/GetGpsMNavMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsMNavMessages::CmdName = "GetGpsMNavMessages";
    const char* const GetGpsMNavMessages::Documentation = "Please note the command GetGpsMNavMessages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the GPS MNav Message for this PRN";

    REGISTER_COMMAND_FACTORY(GetGpsMNavMessages);


    GetGpsMNavMessages::GetGpsMNavMessages()
      : CommandBase(CmdName)
    {}

    GetGpsMNavMessages::GetGpsMNavMessages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsMNavMessagesPtr GetGpsMNavMessages::create(int prn)
    {
      return GetGpsMNavMessagesPtr(new GetGpsMNavMessages(prn));
    }

    GetGpsMNavMessagesPtr GetGpsMNavMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsMNavMessages>(ptr);
    }

    bool GetGpsMNavMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsMNavMessages::documentation() const { return Documentation; }


    int GetGpsMNavMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsMNavMessages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsMNavMessages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsMNavMessagesResult
///
#include "gen/GetGpsMNavMessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsMNavMessagesResult::CmdName = "GetGpsMNavMessagesResult";
    const char* const GetGpsMNavMessagesResult::Documentation = "Result of GetGpsMNavMessages";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsMNavMessagesResult);


    GetGpsMNavMessagesResult::GetGpsMNavMessagesResult()
      : CommandResult(CmdName)
    {}

    GetGpsMNavMessagesResult::GetGpsMNavMessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetGpsMNavMessagesResultPtr GetGpsMNavMessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetGpsMNavMessagesResultPtr(new GetGpsMNavMessagesResult(relatedCommand, ids));
    }

    GetGpsMNavMessagesResultPtr GetGpsMNavMessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsMNavMessagesResult>(ptr);
    }

    bool GetGpsMNavMessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetGpsMNavMessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetGpsMNavMessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetGpsMNavMessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToGpsCNav2Message
///
#include "gen/SetModificationToGpsCNav2Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToGpsCNav2Message::CmdName = "SetModificationToGpsCNav2Message";
    const char* const SetModificationToGpsCNav2Message::Documentation = "Please note the command ModificationToGpsCNav2Message is deprecated since 21.3. You may use MessageModificationToGpsCNav2.\n\nSet (or Modify) event to change CNAV2 message bits. If you send this command without setting the Id\nparameter, or if you set the Id with a value never used before, a new Modification event will be\ncreated. If you reuse the same event Id, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbits mods.\n\nBitsMods can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bits mods using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetModificationToGpsCNav2Message);


    SetModificationToGpsCNav2Message::SetModificationToGpsCNav2Message()
      : CommandBase(CmdName)
    {}

    SetModificationToGpsCNav2Message::SetModificationToGpsCNav2Message(int prn, int startTime, int stopTime, int pageId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPageId(pageId);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    SetModificationToGpsCNav2MessagePtr SetModificationToGpsCNav2Message::create(int prn, int startTime, int stopTime, int pageId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return SetModificationToGpsCNav2MessagePtr(new SetModificationToGpsCNav2Message(prn, startTime, stopTime, pageId, condition, updateCRC, bitsMods, id));
    }

    SetModificationToGpsCNav2MessagePtr SetModificationToGpsCNav2Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToGpsCNav2Message>(ptr);
    }

    bool SetModificationToGpsCNav2Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["PageId"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToGpsCNav2Message::documentation() const { return Documentation; }


    int SetModificationToGpsCNav2Message::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToGpsCNav2Message::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToGpsCNav2Message::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsCNav2Message::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToGpsCNav2Message::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsCNav2Message::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToGpsCNav2Message::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsCNav2Message::pageId() const
    {
      return parse_json<int>::parse(m_values["PageId"]);
    }

    void SetModificationToGpsCNav2Message::setPageId(int pageId)
    {
      m_values.AddMember("PageId", parse_json<int>::format(pageId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsCNav2Message::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetModificationToGpsCNav2Message::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToGpsCNav2Message::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetModificationToGpsCNav2Message::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsCNav2Message::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void SetModificationToGpsCNav2Message::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsCNav2Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToGpsCNav2Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNav2Message
///
#include "gen/GetGpsCNav2Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNav2Message::CmdName = "GetGpsCNav2Message";
    const char* const GetGpsCNav2Message::Documentation = "Please note the command ModificationToGpsCNav2Message is deprecated since 21.3. You may use MessageModificationToGpsCNav2.\n\nGet infos about the CNAV2 Message with this id";

    REGISTER_COMMAND_FACTORY(GetGpsCNav2Message);


    GetGpsCNav2Message::GetGpsCNav2Message()
      : CommandBase(CmdName)
    {}

    GetGpsCNav2Message::GetGpsCNav2Message(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetGpsCNav2MessagePtr GetGpsCNav2Message::create(const std::string& id)
    {
      return GetGpsCNav2MessagePtr(new GetGpsCNav2Message(id));
    }

    GetGpsCNav2MessagePtr GetGpsCNav2Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNav2Message>(ptr);
    }

    bool GetGpsCNav2Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpsCNav2Message::documentation() const { return Documentation; }


    int GetGpsCNav2Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsCNav2Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpsCNav2Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNav2MessageResult
///
#include "gen/GetGpsCNav2MessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNav2MessageResult::CmdName = "GetGpsCNav2MessageResult";
    const char* const GetGpsCNav2MessageResult::Documentation = "Result of GetGpsCNav2Message";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsCNav2MessageResult);


    GetGpsCNav2MessageResult::GetGpsCNav2MessageResult()
      : CommandResult(CmdName)
    {}

    GetGpsCNav2MessageResult::GetGpsCNav2MessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int pageId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPageId(pageId);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    GetGpsCNav2MessageResultPtr GetGpsCNav2MessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int pageId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return GetGpsCNav2MessageResultPtr(new GetGpsCNav2MessageResult(relatedCommand, prn, startTime, stopTime, pageId, condition, updateCRC, bitsMods, id));
    }

    GetGpsCNav2MessageResultPtr GetGpsCNav2MessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNav2MessageResult>(ptr);
    }

    bool GetGpsCNav2MessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["PageId"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpsCNav2MessageResult::documentation() const { return Documentation; }


    int GetGpsCNav2MessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsCNav2MessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsCNav2MessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetGpsCNav2MessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsCNav2MessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetGpsCNav2MessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsCNav2MessageResult::pageId() const
    {
      return parse_json<int>::parse(m_values["PageId"]);
    }

    void GetGpsCNav2MessageResult::setPageId(int pageId)
    {
      m_values.AddMember("PageId", parse_json<int>::format(pageId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsCNav2MessageResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetGpsCNav2MessageResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsCNav2MessageResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetGpsCNav2MessageResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsCNav2MessageResult::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void GetGpsCNav2MessageResult::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsCNav2MessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpsCNav2MessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToGpsCNav2Message
///
#include "gen/RemoveModificationToGpsCNav2Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToGpsCNav2Message::CmdName = "RemoveModificationToGpsCNav2Message";
    const char* const RemoveModificationToGpsCNav2Message::Documentation = "Please note the command RemoveModificationToGpsCNav2Message is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves a modification.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToGpsCNav2Message);


    RemoveModificationToGpsCNav2Message::RemoveModificationToGpsCNav2Message()
      : CommandBase(CmdName)
    {}

    RemoveModificationToGpsCNav2Message::RemoveModificationToGpsCNav2Message(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToGpsCNav2MessagePtr RemoveModificationToGpsCNav2Message::create(const std::string& id)
    {
      return RemoveModificationToGpsCNav2MessagePtr(new RemoveModificationToGpsCNav2Message(id));
    }

    RemoveModificationToGpsCNav2MessagePtr RemoveModificationToGpsCNav2Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToGpsCNav2Message>(ptr);
    }

    bool RemoveModificationToGpsCNav2Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToGpsCNav2Message::documentation() const { return Documentation; }


    int RemoveModificationToGpsCNav2Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToGpsCNav2Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToGpsCNav2Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToGpsCNav2Message
///
#include "gen/ClearAllModificationsToGpsCNav2Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToGpsCNav2Message::CmdName = "ClearAllModificationsToGpsCNav2Message";
    const char* const ClearAllModificationsToGpsCNav2Message::Documentation = "Please note the command ClearAllModificationsToGpsCNav2Message is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change GPS navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToGpsCNav2Message);


    ClearAllModificationsToGpsCNav2Message::ClearAllModificationsToGpsCNav2Message()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToGpsCNav2MessagePtr ClearAllModificationsToGpsCNav2Message::create()
    {
      return ClearAllModificationsToGpsCNav2MessagePtr(new ClearAllModificationsToGpsCNav2Message());
    }

    ClearAllModificationsToGpsCNav2MessagePtr ClearAllModificationsToGpsCNav2Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToGpsCNav2Message>(ptr);
    }

    bool ClearAllModificationsToGpsCNav2Message::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToGpsCNav2Message::documentation() const { return Documentation; }


    int ClearAllModificationsToGpsCNav2Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsCNav2Messages
///
#include "gen/GetGpsCNav2Messages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNav2Messages::CmdName = "GetGpsCNav2Messages";
    const char* const GetGpsCNav2Messages::Documentation = "Please note the command GetGpsCNav2Messages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the GPS CNav2 Message for this PRN";

    REGISTER_COMMAND_FACTORY(GetGpsCNav2Messages);


    GetGpsCNav2Messages::GetGpsCNav2Messages()
      : CommandBase(CmdName)
    {}

    GetGpsCNav2Messages::GetGpsCNav2Messages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsCNav2MessagesPtr GetGpsCNav2Messages::create(int prn)
    {
      return GetGpsCNav2MessagesPtr(new GetGpsCNav2Messages(prn));
    }

    GetGpsCNav2MessagesPtr GetGpsCNav2Messages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNav2Messages>(ptr);
    }

    bool GetGpsCNav2Messages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsCNav2Messages::documentation() const { return Documentation; }


    int GetGpsCNav2Messages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsCNav2Messages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsCNav2Messages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCNav2MessagesResult
///
#include "gen/GetGpsCNav2MessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCNav2MessagesResult::CmdName = "GetGpsCNav2MessagesResult";
    const char* const GetGpsCNav2MessagesResult::Documentation = "Result of GetGpsCNav2Messages";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsCNav2MessagesResult);


    GetGpsCNav2MessagesResult::GetGpsCNav2MessagesResult()
      : CommandResult(CmdName)
    {}

    GetGpsCNav2MessagesResult::GetGpsCNav2MessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetGpsCNav2MessagesResultPtr GetGpsCNav2MessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetGpsCNav2MessagesResultPtr(new GetGpsCNav2MessagesResult(relatedCommand, ids));
    }

    GetGpsCNav2MessagesResultPtr GetGpsCNav2MessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCNav2MessagesResult>(ptr);
    }

    bool GetGpsCNav2MessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetGpsCNav2MessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetGpsCNav2MessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetGpsCNav2MessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToGpsNavigationMessage
///
#include "gen/SetModificationToGpsNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToGpsNavigationMessage::CmdName = "SetModificationToGpsNavigationMessage";
    const char* const SetModificationToGpsNavigationMessage::Documentation = "Please note the command ModificationToGpsNavigationMessage is deprecated since 21.3. You may use MessageModificationToGpsLNav.\n\nSet (or Modify) event to change navigation message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to bits 25..30 will have no effect.\n\nThe Id parameter is automatically updated with a unique id by the simulator for future reference.\nIf the Id is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the id is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetModificationToGpsNavigationMessage);


    SetModificationToGpsNavigationMessage::SetModificationToGpsNavigationMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToGpsNavigationMessage::SetModificationToGpsNavigationMessage(int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setModification(modification);
      setId(id);
    }


    SetModificationToGpsNavigationMessagePtr SetModificationToGpsNavigationMessage::create(int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
    {
      return SetModificationToGpsNavigationMessagePtr(new SetModificationToGpsNavigationMessage(prn, startTime, stopTime, subFrame, page, word, updateParity, modification, id));
    }

    SetModificationToGpsNavigationMessagePtr SetModificationToGpsNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToGpsNavigationMessage>(ptr);
    }

    bool SetModificationToGpsNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToGpsNavigationMessage::documentation() const { return Documentation; }


    int SetModificationToGpsNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToGpsNavigationMessage::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToGpsNavigationMessage::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsNavigationMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToGpsNavigationMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsNavigationMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToGpsNavigationMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsNavigationMessage::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void SetModificationToGpsNavigationMessage::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsNavigationMessage::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetModificationToGpsNavigationMessage::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGpsNavigationMessage::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetModificationToGpsNavigationMessage::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToGpsNavigationMessage::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetModificationToGpsNavigationMessage::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsNavigationMessage::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void SetModificationToGpsNavigationMessage::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGpsNavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToGpsNavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsNavigationMessage
///
#include "gen/GetGpsNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsNavigationMessage::CmdName = "GetGpsNavigationMessage";
    const char* const GetGpsNavigationMessage::Documentation = "Please note the command ModificationToGpsNavigationMessage is deprecated since 21.3. You may use MessageModificationToGpsLNav.\n\nGet infos about this modification gps navigation message event.";

    REGISTER_COMMAND_FACTORY(GetGpsNavigationMessage);


    GetGpsNavigationMessage::GetGpsNavigationMessage()
      : CommandBase(CmdName)
    {}

    GetGpsNavigationMessage::GetGpsNavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetGpsNavigationMessagePtr GetGpsNavigationMessage::create(const std::string& id)
    {
      return GetGpsNavigationMessagePtr(new GetGpsNavigationMessage(id));
    }

    GetGpsNavigationMessagePtr GetGpsNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsNavigationMessage>(ptr);
    }

    bool GetGpsNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpsNavigationMessage::documentation() const { return Documentation; }


    int GetGpsNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGpsNavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpsNavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsNavigationMessageResult
///
#include "gen/GetGpsNavigationMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsNavigationMessageResult::CmdName = "GetGpsNavigationMessageResult";
    const char* const GetGpsNavigationMessageResult::Documentation = "Result of GetGpsNavigationMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsNavigationMessageResult);


    GetGpsNavigationMessageResult::GetGpsNavigationMessageResult()
      : CommandResult(CmdName)
    {}

    GetGpsNavigationMessageResult::GetGpsNavigationMessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setModification(modification);
      setId(id);
    }


    GetGpsNavigationMessageResultPtr GetGpsNavigationMessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
    {
      return GetGpsNavigationMessageResultPtr(new GetGpsNavigationMessageResult(relatedCommand, prn, startTime, stopTime, subFrame, page, word, updateParity, modification, id));
    }

    GetGpsNavigationMessageResultPtr GetGpsNavigationMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsNavigationMessageResult>(ptr);
    }

    bool GetGpsNavigationMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGpsNavigationMessageResult::documentation() const { return Documentation; }


    int GetGpsNavigationMessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsNavigationMessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsNavigationMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetGpsNavigationMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsNavigationMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetGpsNavigationMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsNavigationMessageResult::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void GetGpsNavigationMessageResult::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsNavigationMessageResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetGpsNavigationMessageResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsNavigationMessageResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetGpsNavigationMessageResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGpsNavigationMessageResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetGpsNavigationMessageResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsNavigationMessageResult::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void GetGpsNavigationMessageResult::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGpsNavigationMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGpsNavigationMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToGpsNavigationMessage
///
#include "gen/RemoveModificationToGpsNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToGpsNavigationMessage::CmdName = "RemoveModificationToGpsNavigationMessage";
    const char* const RemoveModificationToGpsNavigationMessage::Documentation = "Please note the command RemoveModificationToGpsNavigationMessage is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves an event added with SetModificationToGpsNavigationMessage. When adding an event, the simulator\nsets the Id parameter. Use that Id here to remove the associated event.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToGpsNavigationMessage);


    RemoveModificationToGpsNavigationMessage::RemoveModificationToGpsNavigationMessage()
      : CommandBase(CmdName)
    {}

    RemoveModificationToGpsNavigationMessage::RemoveModificationToGpsNavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToGpsNavigationMessagePtr RemoveModificationToGpsNavigationMessage::create(const std::string& id)
    {
      return RemoveModificationToGpsNavigationMessagePtr(new RemoveModificationToGpsNavigationMessage(id));
    }

    RemoveModificationToGpsNavigationMessagePtr RemoveModificationToGpsNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToGpsNavigationMessage>(ptr);
    }

    bool RemoveModificationToGpsNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToGpsNavigationMessage::documentation() const { return Documentation; }


    int RemoveModificationToGpsNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToGpsNavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToGpsNavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToGpsNavigationMessage
///
#include "gen/ClearAllModificationsToGpsNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToGpsNavigationMessage::CmdName = "ClearAllModificationsToGpsNavigationMessage";
    const char* const ClearAllModificationsToGpsNavigationMessage::Documentation = "Please note the command ClearAllModificationsToGpsNavigationMessage is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change GPS navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToGpsNavigationMessage);


    ClearAllModificationsToGpsNavigationMessage::ClearAllModificationsToGpsNavigationMessage()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToGpsNavigationMessagePtr ClearAllModificationsToGpsNavigationMessage::create()
    {
      return ClearAllModificationsToGpsNavigationMessagePtr(new ClearAllModificationsToGpsNavigationMessage());
    }

    ClearAllModificationsToGpsNavigationMessagePtr ClearAllModificationsToGpsNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToGpsNavigationMessage>(ptr);
    }

    bool ClearAllModificationsToGpsNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToGpsNavigationMessage::documentation() const { return Documentation; }


    int ClearAllModificationsToGpsNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGpsNavigationMessages
///
#include "gen/GetGpsNavigationMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsNavigationMessages::CmdName = "GetGpsNavigationMessages";
    const char* const GetGpsNavigationMessages::Documentation = "Please note the command GetGpsNavigationMessages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the GPS Navigation Message for this PRN";

    REGISTER_COMMAND_FACTORY(GetGpsNavigationMessages);


    GetGpsNavigationMessages::GetGpsNavigationMessages()
      : CommandBase(CmdName)
    {}

    GetGpsNavigationMessages::GetGpsNavigationMessages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGpsNavigationMessagesPtr GetGpsNavigationMessages::create(int prn)
    {
      return GetGpsNavigationMessagesPtr(new GetGpsNavigationMessages(prn));
    }

    GetGpsNavigationMessagesPtr GetGpsNavigationMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsNavigationMessages>(ptr);
    }

    bool GetGpsNavigationMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGpsNavigationMessages::documentation() const { return Documentation; }


    int GetGpsNavigationMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsNavigationMessages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGpsNavigationMessages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsNavigationMessagesResult
///
#include "gen/GetGpsNavigationMessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsNavigationMessagesResult::CmdName = "GetGpsNavigationMessagesResult";
    const char* const GetGpsNavigationMessagesResult::Documentation = "Result of GetGpsNavigationMessages";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsNavigationMessagesResult);


    GetGpsNavigationMessagesResult::GetGpsNavigationMessagesResult()
      : CommandResult(CmdName)
    {}

    GetGpsNavigationMessagesResult::GetGpsNavigationMessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetGpsNavigationMessagesResultPtr GetGpsNavigationMessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetGpsNavigationMessagesResultPtr(new GetGpsNavigationMessagesResult(relatedCommand, ids));
    }

    GetGpsNavigationMessagesResultPtr GetGpsNavigationMessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsNavigationMessagesResult>(ptr);
    }

    bool GetGpsNavigationMessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetGpsNavigationMessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetGpsNavigationMessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetGpsNavigationMessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToGalileoFNavMessage
///
#include "gen/SetModificationToGalileoFNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToGalileoFNavMessage::CmdName = "SetModificationToGalileoFNavMessage";
    const char* const SetModificationToGalileoFNavMessage::Documentation = "Please note the command ModificationToGalileoFNavMessage is deprecated since 21.3. You may use MessageModificationToGalileoFNav.\n\nSet (or Modify) event to change FNAV message bits. If you send this command without setting the Id\nparameter, or if you set the Id with a value never used before, a new Modification event will be\ncreated. If you reuse the same event Id, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nBitsMods can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bits mods using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetModificationToGalileoFNavMessage);


    SetModificationToGalileoFNavMessage::SetModificationToGalileoFNavMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToGalileoFNavMessage::SetModificationToGalileoFNavMessage(int prn, int startTime, int stopTime, int subFrame, int page, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    SetModificationToGalileoFNavMessagePtr SetModificationToGalileoFNavMessage::create(int prn, int startTime, int stopTime, int subFrame, int page, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return SetModificationToGalileoFNavMessagePtr(new SetModificationToGalileoFNavMessage(prn, startTime, stopTime, subFrame, page, updateCRC, bitsMods, id));
    }

    SetModificationToGalileoFNavMessagePtr SetModificationToGalileoFNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToGalileoFNavMessage>(ptr);
    }

    bool SetModificationToGalileoFNavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToGalileoFNavMessage::documentation() const { return Documentation; }


    int SetModificationToGalileoFNavMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToGalileoFNavMessage::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToGalileoFNavMessage::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGalileoFNavMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToGalileoFNavMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGalileoFNavMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToGalileoFNavMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGalileoFNavMessage::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void SetModificationToGalileoFNavMessage::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGalileoFNavMessage::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetModificationToGalileoFNavMessage::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToGalileoFNavMessage::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetModificationToGalileoFNavMessage::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGalileoFNavMessage::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void SetModificationToGalileoFNavMessage::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGalileoFNavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToGalileoFNavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoFNavMessage
///
#include "gen/GetGalileoFNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoFNavMessage::CmdName = "GetGalileoFNavMessage";
    const char* const GetGalileoFNavMessage::Documentation = "Please note the command ModificationToGalileoFNavMessage is deprecated since 21.3. You may use MessageModificationToGalileoFNav.\n\nGet infos about the FNAV Message with this id";

    REGISTER_COMMAND_FACTORY(GetGalileoFNavMessage);


    GetGalileoFNavMessage::GetGalileoFNavMessage()
      : CommandBase(CmdName)
    {}

    GetGalileoFNavMessage::GetGalileoFNavMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetGalileoFNavMessagePtr GetGalileoFNavMessage::create(const std::string& id)
    {
      return GetGalileoFNavMessagePtr(new GetGalileoFNavMessage(id));
    }

    GetGalileoFNavMessagePtr GetGalileoFNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoFNavMessage>(ptr);
    }

    bool GetGalileoFNavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGalileoFNavMessage::documentation() const { return Documentation; }


    int GetGalileoFNavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGalileoFNavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGalileoFNavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoFNavMessageResult
///
#include "gen/GetGalileoFNavMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoFNavMessageResult::CmdName = "GetGalileoFNavMessageResult";
    const char* const GetGalileoFNavMessageResult::Documentation = "Result of GetGalileoFNavMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoFNavMessageResult);


    GetGalileoFNavMessageResult::GetGalileoFNavMessageResult()
      : CommandResult(CmdName)
    {}

    GetGalileoFNavMessageResult::GetGalileoFNavMessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    GetGalileoFNavMessageResultPtr GetGalileoFNavMessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return GetGalileoFNavMessageResultPtr(new GetGalileoFNavMessageResult(relatedCommand, prn, startTime, stopTime, subFrame, page, updateCRC, bitsMods, id));
    }

    GetGalileoFNavMessageResultPtr GetGalileoFNavMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoFNavMessageResult>(ptr);
    }

    bool GetGalileoFNavMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGalileoFNavMessageResult::documentation() const { return Documentation; }


    int GetGalileoFNavMessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoFNavMessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoFNavMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetGalileoFNavMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoFNavMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetGalileoFNavMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoFNavMessageResult::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void GetGalileoFNavMessageResult::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoFNavMessageResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetGalileoFNavMessageResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGalileoFNavMessageResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetGalileoFNavMessageResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoFNavMessageResult::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void GetGalileoFNavMessageResult::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoFNavMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGalileoFNavMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToGalileoFNavMessage
///
#include "gen/RemoveModificationToGalileoFNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToGalileoFNavMessage::CmdName = "RemoveModificationToGalileoFNavMessage";
    const char* const RemoveModificationToGalileoFNavMessage::Documentation = "Please note the command RemoveModificationToGalileoFNavMessage is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves a modification.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToGalileoFNavMessage);


    RemoveModificationToGalileoFNavMessage::RemoveModificationToGalileoFNavMessage()
      : CommandBase(CmdName)
    {}

    RemoveModificationToGalileoFNavMessage::RemoveModificationToGalileoFNavMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToGalileoFNavMessagePtr RemoveModificationToGalileoFNavMessage::create(const std::string& id)
    {
      return RemoveModificationToGalileoFNavMessagePtr(new RemoveModificationToGalileoFNavMessage(id));
    }

    RemoveModificationToGalileoFNavMessagePtr RemoveModificationToGalileoFNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToGalileoFNavMessage>(ptr);
    }

    bool RemoveModificationToGalileoFNavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToGalileoFNavMessage::documentation() const { return Documentation; }


    int RemoveModificationToGalileoFNavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToGalileoFNavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToGalileoFNavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToGalileoFNavMessage
///
#include "gen/ClearAllModificationsToGalileoFNavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToGalileoFNavMessage::CmdName = "ClearAllModificationsToGalileoFNavMessage";
    const char* const ClearAllModificationsToGalileoFNavMessage::Documentation = "Please note the command ClearAllModificationsToGalileoFNavMessage is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change GALILEO navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToGalileoFNavMessage);


    ClearAllModificationsToGalileoFNavMessage::ClearAllModificationsToGalileoFNavMessage()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToGalileoFNavMessagePtr ClearAllModificationsToGalileoFNavMessage::create()
    {
      return ClearAllModificationsToGalileoFNavMessagePtr(new ClearAllModificationsToGalileoFNavMessage());
    }

    ClearAllModificationsToGalileoFNavMessagePtr ClearAllModificationsToGalileoFNavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToGalileoFNavMessage>(ptr);
    }

    bool ClearAllModificationsToGalileoFNavMessage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToGalileoFNavMessage::documentation() const { return Documentation; }


    int ClearAllModificationsToGalileoFNavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGalileoFNavMessages
///
#include "gen/GetGalileoFNavMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoFNavMessages::CmdName = "GetGalileoFNavMessages";
    const char* const GetGalileoFNavMessages::Documentation = "Please note the command GetGalileoFNavMessages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the GALILEO FNAV Message for this PRN";

    REGISTER_COMMAND_FACTORY(GetGalileoFNavMessages);


    GetGalileoFNavMessages::GetGalileoFNavMessages()
      : CommandBase(CmdName)
    {}

    GetGalileoFNavMessages::GetGalileoFNavMessages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGalileoFNavMessagesPtr GetGalileoFNavMessages::create(int prn)
    {
      return GetGalileoFNavMessagesPtr(new GetGalileoFNavMessages(prn));
    }

    GetGalileoFNavMessagesPtr GetGalileoFNavMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoFNavMessages>(ptr);
    }

    bool GetGalileoFNavMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGalileoFNavMessages::documentation() const { return Documentation; }


    int GetGalileoFNavMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoFNavMessages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoFNavMessages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoFNavMessagesResult
///
#include "gen/GetGalileoFNavMessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoFNavMessagesResult::CmdName = "GetGalileoFNavMessagesResult";
    const char* const GetGalileoFNavMessagesResult::Documentation = "Result of GetGalileoFNavMessages";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoFNavMessagesResult);


    GetGalileoFNavMessagesResult::GetGalileoFNavMessagesResult()
      : CommandResult(CmdName)
    {}

    GetGalileoFNavMessagesResult::GetGalileoFNavMessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetGalileoFNavMessagesResultPtr GetGalileoFNavMessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetGalileoFNavMessagesResultPtr(new GetGalileoFNavMessagesResult(relatedCommand, ids));
    }

    GetGalileoFNavMessagesResultPtr GetGalileoFNavMessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoFNavMessagesResult>(ptr);
    }

    bool GetGalileoFNavMessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetGalileoFNavMessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetGalileoFNavMessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetGalileoFNavMessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToGalileoINavMessage
///
#include "gen/SetModificationToGalileoINavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToGalileoINavMessage::CmdName = "SetModificationToGalileoINavMessage";
    const char* const SetModificationToGalileoINavMessage::Documentation = "Please note the command ModificationToGalileoINavMessage is deprecated since 21.3. You may use MessageModificationToGalileoINav.\n\nSet (or Modify) event to change INAV message bits. If you send this command without setting the Id\nparameter, or if you set the Id with a value never used before, a new Modification event will be\ncreated. If you reuse the same event Id, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nBitsMods can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bits mods using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetModificationToGalileoINavMessage);


    SetModificationToGalileoINavMessage::SetModificationToGalileoINavMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToGalileoINavMessage::SetModificationToGalileoINavMessage(int prn, int startTime, int stopTime, int subFrame, int page, bool updateCRC, const std::string& bitsMods, bool e1, bool e5b, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setE1(e1);
      setE5b(e5b);
      setId(id);
    }


    SetModificationToGalileoINavMessagePtr SetModificationToGalileoINavMessage::create(int prn, int startTime, int stopTime, int subFrame, int page, bool updateCRC, const std::string& bitsMods, bool e1, bool e5b, const std::string& id)
    {
      return SetModificationToGalileoINavMessagePtr(new SetModificationToGalileoINavMessage(prn, startTime, stopTime, subFrame, page, updateCRC, bitsMods, e1, e5b, id));
    }

    SetModificationToGalileoINavMessagePtr SetModificationToGalileoINavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToGalileoINavMessage>(ptr);
    }

    bool SetModificationToGalileoINavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<bool>::is_valid(m_values["E1"])
          && parse_json<bool>::is_valid(m_values["E5b"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToGalileoINavMessage::documentation() const { return Documentation; }


    int SetModificationToGalileoINavMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToGalileoINavMessage::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToGalileoINavMessage::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGalileoINavMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToGalileoINavMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGalileoINavMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToGalileoINavMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGalileoINavMessage::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void SetModificationToGalileoINavMessage::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGalileoINavMessage::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetModificationToGalileoINavMessage::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToGalileoINavMessage::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetModificationToGalileoINavMessage::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGalileoINavMessage::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void SetModificationToGalileoINavMessage::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToGalileoINavMessage::e1() const
    {
      return parse_json<bool>::parse(m_values["E1"]);
    }

    void SetModificationToGalileoINavMessage::setE1(bool e1)
    {
      m_values.AddMember("E1", parse_json<bool>::format(e1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToGalileoINavMessage::e5b() const
    {
      return parse_json<bool>::parse(m_values["E5b"]);
    }

    void SetModificationToGalileoINavMessage::setE5b(bool e5b)
    {
      m_values.AddMember("E5b", parse_json<bool>::format(e5b, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGalileoINavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToGalileoINavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoINavMessage
///
#include "gen/GetGalileoINavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoINavMessage::CmdName = "GetGalileoINavMessage";
    const char* const GetGalileoINavMessage::Documentation = "Please note the command ModificationToGalileoINavMessage is deprecated since 21.3. You may use MessageModificationToGalileoINav.\n\nGet infos about the INAV Message with this id";

    REGISTER_COMMAND_FACTORY(GetGalileoINavMessage);


    GetGalileoINavMessage::GetGalileoINavMessage()
      : CommandBase(CmdName)
    {}

    GetGalileoINavMessage::GetGalileoINavMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetGalileoINavMessagePtr GetGalileoINavMessage::create(const std::string& id)
    {
      return GetGalileoINavMessagePtr(new GetGalileoINavMessage(id));
    }

    GetGalileoINavMessagePtr GetGalileoINavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoINavMessage>(ptr);
    }

    bool GetGalileoINavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGalileoINavMessage::documentation() const { return Documentation; }


    int GetGalileoINavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGalileoINavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGalileoINavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoINavMessageResult
///
#include "gen/GetGalileoINavMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoINavMessageResult::CmdName = "GetGalileoINavMessageResult";
    const char* const GetGalileoINavMessageResult::Documentation = "Result of GetGalileoINavMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoINavMessageResult);


    GetGalileoINavMessageResult::GetGalileoINavMessageResult()
      : CommandResult(CmdName)
    {}

    GetGalileoINavMessageResult::GetGalileoINavMessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, bool updateCRC, const std::string& bitsMods, bool e1, bool e5b, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setE1(e1);
      setE5b(e5b);
      setId(id);
    }


    GetGalileoINavMessageResultPtr GetGalileoINavMessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, bool updateCRC, const std::string& bitsMods, bool e1, bool e5b, const std::string& id)
    {
      return GetGalileoINavMessageResultPtr(new GetGalileoINavMessageResult(relatedCommand, prn, startTime, stopTime, subFrame, page, updateCRC, bitsMods, e1, e5b, id));
    }

    GetGalileoINavMessageResultPtr GetGalileoINavMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoINavMessageResult>(ptr);
    }

    bool GetGalileoINavMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<bool>::is_valid(m_values["E1"])
          && parse_json<bool>::is_valid(m_values["E5b"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGalileoINavMessageResult::documentation() const { return Documentation; }


    int GetGalileoINavMessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoINavMessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoINavMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetGalileoINavMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoINavMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetGalileoINavMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoINavMessageResult::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void GetGalileoINavMessageResult::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGalileoINavMessageResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetGalileoINavMessageResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGalileoINavMessageResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetGalileoINavMessageResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoINavMessageResult::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void GetGalileoINavMessageResult::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGalileoINavMessageResult::e1() const
    {
      return parse_json<bool>::parse(m_values["E1"]);
    }

    void GetGalileoINavMessageResult::setE1(bool e1)
    {
      m_values.AddMember("E1", parse_json<bool>::format(e1, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGalileoINavMessageResult::e5b() const
    {
      return parse_json<bool>::parse(m_values["E5b"]);
    }

    void GetGalileoINavMessageResult::setE5b(bool e5b)
    {
      m_values.AddMember("E5b", parse_json<bool>::format(e5b, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGalileoINavMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGalileoINavMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToGalileoINavMessage
///
#include "gen/RemoveModificationToGalileoINavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToGalileoINavMessage::CmdName = "RemoveModificationToGalileoINavMessage";
    const char* const RemoveModificationToGalileoINavMessage::Documentation = "Please note the command RemoveModificationToGalileoINavMessage is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves a modification.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToGalileoINavMessage);


    RemoveModificationToGalileoINavMessage::RemoveModificationToGalileoINavMessage()
      : CommandBase(CmdName)
    {}

    RemoveModificationToGalileoINavMessage::RemoveModificationToGalileoINavMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToGalileoINavMessagePtr RemoveModificationToGalileoINavMessage::create(const std::string& id)
    {
      return RemoveModificationToGalileoINavMessagePtr(new RemoveModificationToGalileoINavMessage(id));
    }

    RemoveModificationToGalileoINavMessagePtr RemoveModificationToGalileoINavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToGalileoINavMessage>(ptr);
    }

    bool RemoveModificationToGalileoINavMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToGalileoINavMessage::documentation() const { return Documentation; }


    int RemoveModificationToGalileoINavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToGalileoINavMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToGalileoINavMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToGalileoINavMessage
///
#include "gen/ClearAllModificationsToGalileoINavMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToGalileoINavMessage::CmdName = "ClearAllModificationsToGalileoINavMessage";
    const char* const ClearAllModificationsToGalileoINavMessage::Documentation = "Please note the command ClearAllModificationsToGalileoINavMessage is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change GALILEO navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToGalileoINavMessage);


    ClearAllModificationsToGalileoINavMessage::ClearAllModificationsToGalileoINavMessage()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToGalileoINavMessagePtr ClearAllModificationsToGalileoINavMessage::create()
    {
      return ClearAllModificationsToGalileoINavMessagePtr(new ClearAllModificationsToGalileoINavMessage());
    }

    ClearAllModificationsToGalileoINavMessagePtr ClearAllModificationsToGalileoINavMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToGalileoINavMessage>(ptr);
    }

    bool ClearAllModificationsToGalileoINavMessage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToGalileoINavMessage::documentation() const { return Documentation; }


    int ClearAllModificationsToGalileoINavMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGalileoINavMessages
///
#include "gen/GetGalileoINavMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoINavMessages::CmdName = "GetGalileoINavMessages";
    const char* const GetGalileoINavMessages::Documentation = "Please note the command GetGalileoINavMessages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the GALILEO INAV Message for this PRN";

    REGISTER_COMMAND_FACTORY(GetGalileoINavMessages);


    GetGalileoINavMessages::GetGalileoINavMessages()
      : CommandBase(CmdName)
    {}

    GetGalileoINavMessages::GetGalileoINavMessages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGalileoINavMessagesPtr GetGalileoINavMessages::create(int prn)
    {
      return GetGalileoINavMessagesPtr(new GetGalileoINavMessages(prn));
    }

    GetGalileoINavMessagesPtr GetGalileoINavMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoINavMessages>(ptr);
    }

    bool GetGalileoINavMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGalileoINavMessages::documentation() const { return Documentation; }


    int GetGalileoINavMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGalileoINavMessages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGalileoINavMessages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGalileoINavMessagesResult
///
#include "gen/GetGalileoINavMessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGalileoINavMessagesResult::CmdName = "GetGalileoINavMessagesResult";
    const char* const GetGalileoINavMessagesResult::Documentation = "Result of GetGalileoINavMessages";

    REGISTER_COMMAND_RESULT_FACTORY(GetGalileoINavMessagesResult);


    GetGalileoINavMessagesResult::GetGalileoINavMessagesResult()
      : CommandResult(CmdName)
    {}

    GetGalileoINavMessagesResult::GetGalileoINavMessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetGalileoINavMessagesResultPtr GetGalileoINavMessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetGalileoINavMessagesResultPtr(new GetGalileoINavMessagesResult(relatedCommand, ids));
    }

    GetGalileoINavMessagesResultPtr GetGalileoINavMessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGalileoINavMessagesResult>(ptr);
    }

    bool GetGalileoINavMessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetGalileoINavMessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetGalileoINavMessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetGalileoINavMessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToGlonassNavigationMessage
///
#include "gen/SetModificationToGlonassNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToGlonassNavigationMessage::CmdName = "SetModificationToGlonassNavigationMessage";
    const char* const SetModificationToGlonassNavigationMessage::Documentation = "Please note the command ModificationToGlonassNavigationMessage is deprecated since 21.3. You may use MessageModificationToGlonassNav.\n\nSet (or Modify) event to change navigation message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessage strings. The Modification parameter is a string where the first character applies to bit\n85 of frame string and last character applies to Hamming Code bit 1.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   ' ' white space are ignored (use them to separate the string into bytes to help reading)\n   '-' or any other byte value will have no effect\n\nExample:\n\n\"-0--- 1------- -------- -------- -------- -------- -------- -------- -------- -------- ---1--X-\"\n  |  |                                           |  |\n  |  +- Force bit 80 to '1'               Force Hamming code bit 5 to '1' -+  |\n  |                                               |\n  +------ Force bit 84 to 0                   Negate Hamming code bit 2 ----+\n\nNote: if UpdateHammingCode is true, any modification to bits 1..8 will have no effect.\n\nThe Id parameter is automatically updated with a unique id by the simulator for future reference.\nIf the Id is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the id is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetModificationToGlonassNavigationMessage);


    SetModificationToGlonassNavigationMessage::SetModificationToGlonassNavigationMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToGlonassNavigationMessage::SetModificationToGlonassNavigationMessage(int prn, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& modification, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setFrame(frame);
      setStringNumber(stringNumber);
      setUpdateHammingCode(updateHammingCode);
      setModification(modification);
      setId(id);
    }


    SetModificationToGlonassNavigationMessagePtr SetModificationToGlonassNavigationMessage::create(int prn, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& modification, const std::string& id)
    {
      return SetModificationToGlonassNavigationMessagePtr(new SetModificationToGlonassNavigationMessage(prn, startTime, stopTime, frame, stringNumber, updateHammingCode, modification, id));
    }

    SetModificationToGlonassNavigationMessagePtr SetModificationToGlonassNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToGlonassNavigationMessage>(ptr);
    }

    bool SetModificationToGlonassNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Frame"])
          && parse_json<int>::is_valid(m_values["StringNumber"])
          && parse_json<bool>::is_valid(m_values["UpdateHammingCode"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToGlonassNavigationMessage::documentation() const { return Documentation; }


    int SetModificationToGlonassNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToGlonassNavigationMessage::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToGlonassNavigationMessage::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGlonassNavigationMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToGlonassNavigationMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGlonassNavigationMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToGlonassNavigationMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGlonassNavigationMessage::frame() const
    {
      return parse_json<int>::parse(m_values["Frame"]);
    }

    void SetModificationToGlonassNavigationMessage::setFrame(int frame)
    {
      m_values.AddMember("Frame", parse_json<int>::format(frame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToGlonassNavigationMessage::stringNumber() const
    {
      return parse_json<int>::parse(m_values["StringNumber"]);
    }

    void SetModificationToGlonassNavigationMessage::setStringNumber(int stringNumber)
    {
      m_values.AddMember("StringNumber", parse_json<int>::format(stringNumber, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToGlonassNavigationMessage::updateHammingCode() const
    {
      return parse_json<bool>::parse(m_values["UpdateHammingCode"]);
    }

    void SetModificationToGlonassNavigationMessage::setUpdateHammingCode(bool updateHammingCode)
    {
      m_values.AddMember("UpdateHammingCode", parse_json<bool>::format(updateHammingCode, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGlonassNavigationMessage::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void SetModificationToGlonassNavigationMessage::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToGlonassNavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToGlonassNavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassNavigationMessage
///
#include "gen/GetGlonassNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassNavigationMessage::CmdName = "GetGlonassNavigationMessage";
    const char* const GetGlonassNavigationMessage::Documentation = "Please note the command ModificationToGlonassNavigationMessage is deprecated since 21.3. You may use MessageModificationToGlonassNav.\n\nGet infos about this modification Glonass navigation message event";

    REGISTER_COMMAND_FACTORY(GetGlonassNavigationMessage);


    GetGlonassNavigationMessage::GetGlonassNavigationMessage()
      : CommandBase(CmdName)
    {}

    GetGlonassNavigationMessage::GetGlonassNavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetGlonassNavigationMessagePtr GetGlonassNavigationMessage::create(const std::string& id)
    {
      return GetGlonassNavigationMessagePtr(new GetGlonassNavigationMessage(id));
    }

    GetGlonassNavigationMessagePtr GetGlonassNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassNavigationMessage>(ptr);
    }

    bool GetGlonassNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGlonassNavigationMessage::documentation() const { return Documentation; }


    int GetGlonassNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetGlonassNavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGlonassNavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassNavigationMessageResult
///
#include "gen/GetGlonassNavigationMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassNavigationMessageResult::CmdName = "GetGlonassNavigationMessageResult";
    const char* const GetGlonassNavigationMessageResult::Documentation = "Result of GetGlonassNavigationMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassNavigationMessageResult);


    GetGlonassNavigationMessageResult::GetGlonassNavigationMessageResult()
      : CommandResult(CmdName)
    {}

    GetGlonassNavigationMessageResult::GetGlonassNavigationMessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& modification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setFrame(frame);
      setStringNumber(stringNumber);
      setUpdateHammingCode(updateHammingCode);
      setModification(modification);
      setId(id);
    }


    GetGlonassNavigationMessageResultPtr GetGlonassNavigationMessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int frame, int stringNumber, bool updateHammingCode, const std::string& modification, const std::string& id)
    {
      return GetGlonassNavigationMessageResultPtr(new GetGlonassNavigationMessageResult(relatedCommand, prn, startTime, stopTime, frame, stringNumber, updateHammingCode, modification, id));
    }

    GetGlonassNavigationMessageResultPtr GetGlonassNavigationMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassNavigationMessageResult>(ptr);
    }

    bool GetGlonassNavigationMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Frame"])
          && parse_json<int>::is_valid(m_values["StringNumber"])
          && parse_json<bool>::is_valid(m_values["UpdateHammingCode"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetGlonassNavigationMessageResult::documentation() const { return Documentation; }


    int GetGlonassNavigationMessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGlonassNavigationMessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGlonassNavigationMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetGlonassNavigationMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGlonassNavigationMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetGlonassNavigationMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGlonassNavigationMessageResult::frame() const
    {
      return parse_json<int>::parse(m_values["Frame"]);
    }

    void GetGlonassNavigationMessageResult::setFrame(int frame)
    {
      m_values.AddMember("Frame", parse_json<int>::format(frame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGlonassNavigationMessageResult::stringNumber() const
    {
      return parse_json<int>::parse(m_values["StringNumber"]);
    }

    void GetGlonassNavigationMessageResult::setStringNumber(int stringNumber)
    {
      m_values.AddMember("StringNumber", parse_json<int>::format(stringNumber, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetGlonassNavigationMessageResult::updateHammingCode() const
    {
      return parse_json<bool>::parse(m_values["UpdateHammingCode"]);
    }

    void GetGlonassNavigationMessageResult::setUpdateHammingCode(bool updateHammingCode)
    {
      m_values.AddMember("UpdateHammingCode", parse_json<bool>::format(updateHammingCode, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGlonassNavigationMessageResult::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void GetGlonassNavigationMessageResult::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetGlonassNavigationMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetGlonassNavigationMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToGlonassNavigationMessage
///
#include "gen/RemoveModificationToGlonassNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToGlonassNavigationMessage::CmdName = "RemoveModificationToGlonassNavigationMessage";
    const char* const RemoveModificationToGlonassNavigationMessage::Documentation = "Please note the command RemoveModificationToGlonassNavigationMessage is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves an event added with SetModificationToGlonassNavigationMessage. When adding an event, the simulator\nsets the Id parameter. Use that Id here to remove the associated event.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToGlonassNavigationMessage);


    RemoveModificationToGlonassNavigationMessage::RemoveModificationToGlonassNavigationMessage()
      : CommandBase(CmdName)
    {}

    RemoveModificationToGlonassNavigationMessage::RemoveModificationToGlonassNavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToGlonassNavigationMessagePtr RemoveModificationToGlonassNavigationMessage::create(const std::string& id)
    {
      return RemoveModificationToGlonassNavigationMessagePtr(new RemoveModificationToGlonassNavigationMessage(id));
    }

    RemoveModificationToGlonassNavigationMessagePtr RemoveModificationToGlonassNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToGlonassNavigationMessage>(ptr);
    }

    bool RemoveModificationToGlonassNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToGlonassNavigationMessage::documentation() const { return Documentation; }


    int RemoveModificationToGlonassNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToGlonassNavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToGlonassNavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToGlonassNavigationMessage
///
#include "gen/ClearAllModificationsToGlonassNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToGlonassNavigationMessage::CmdName = "ClearAllModificationsToGlonassNavigationMessage";
    const char* const ClearAllModificationsToGlonassNavigationMessage::Documentation = "Please note the command ClearAllModificationsToGlonassNavigationMessage is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change GLONASS navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToGlonassNavigationMessage);


    ClearAllModificationsToGlonassNavigationMessage::ClearAllModificationsToGlonassNavigationMessage()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToGlonassNavigationMessagePtr ClearAllModificationsToGlonassNavigationMessage::create()
    {
      return ClearAllModificationsToGlonassNavigationMessagePtr(new ClearAllModificationsToGlonassNavigationMessage());
    }

    ClearAllModificationsToGlonassNavigationMessagePtr ClearAllModificationsToGlonassNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToGlonassNavigationMessage>(ptr);
    }

    bool ClearAllModificationsToGlonassNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToGlonassNavigationMessage::documentation() const { return Documentation; }


    int ClearAllModificationsToGlonassNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetGlonassNavigationMessages
///
#include "gen/GetGlonassNavigationMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassNavigationMessages::CmdName = "GetGlonassNavigationMessages";
    const char* const GetGlonassNavigationMessages::Documentation = "Please note the command GetGlonassNavigationMessages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the Glonass Navigation Message for this PRN";

    REGISTER_COMMAND_FACTORY(GetGlonassNavigationMessages);


    GetGlonassNavigationMessages::GetGlonassNavigationMessages()
      : CommandBase(CmdName)
    {}

    GetGlonassNavigationMessages::GetGlonassNavigationMessages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetGlonassNavigationMessagesPtr GetGlonassNavigationMessages::create(int prn)
    {
      return GetGlonassNavigationMessagesPtr(new GetGlonassNavigationMessages(prn));
    }

    GetGlonassNavigationMessagesPtr GetGlonassNavigationMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassNavigationMessages>(ptr);
    }

    bool GetGlonassNavigationMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetGlonassNavigationMessages::documentation() const { return Documentation; }


    int GetGlonassNavigationMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGlonassNavigationMessages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetGlonassNavigationMessages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGlonassNavigationMessagesResult
///
#include "gen/GetGlonassNavigationMessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGlonassNavigationMessagesResult::CmdName = "GetGlonassNavigationMessagesResult";
    const char* const GetGlonassNavigationMessagesResult::Documentation = "Result of GetGlonassNavigationMessages";

    REGISTER_COMMAND_RESULT_FACTORY(GetGlonassNavigationMessagesResult);


    GetGlonassNavigationMessagesResult::GetGlonassNavigationMessagesResult()
      : CommandResult(CmdName)
    {}

    GetGlonassNavigationMessagesResult::GetGlonassNavigationMessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetGlonassNavigationMessagesResultPtr GetGlonassNavigationMessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetGlonassNavigationMessagesResultPtr(new GetGlonassNavigationMessagesResult(relatedCommand, ids));
    }

    GetGlonassNavigationMessagesResultPtr GetGlonassNavigationMessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGlonassNavigationMessagesResult>(ptr);
    }

    bool GetGlonassNavigationMessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetGlonassNavigationMessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetGlonassNavigationMessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetGlonassNavigationMessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToBeiDouD1NavigationMessage
///
#include "gen/SetModificationToBeiDouD1NavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToBeiDouD1NavigationMessage::CmdName = "SetModificationToBeiDouD1NavigationMessage";
    const char* const SetModificationToBeiDouD1NavigationMessage::Documentation = "Please note the command ModificationToBeiDouD1NavigationMessage is deprecated since 21.3. You may use MessageModificationToBeiDouD1Nav.\n\nSet (or Modify) event to change navigation message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to parity bits will have no effect.\n\nThe Id parameter is automatically updated with a unique id by the simulator for future reference.\nIf the Id is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the id is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetModificationToBeiDouD1NavigationMessage);


    SetModificationToBeiDouD1NavigationMessage::SetModificationToBeiDouD1NavigationMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToBeiDouD1NavigationMessage::SetModificationToBeiDouD1NavigationMessage(int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setModification(modification);
      setId(id);
    }


    SetModificationToBeiDouD1NavigationMessagePtr SetModificationToBeiDouD1NavigationMessage::create(int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
    {
      return SetModificationToBeiDouD1NavigationMessagePtr(new SetModificationToBeiDouD1NavigationMessage(prn, startTime, stopTime, subFrame, page, word, updateParity, modification, id));
    }

    SetModificationToBeiDouD1NavigationMessagePtr SetModificationToBeiDouD1NavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToBeiDouD1NavigationMessage>(ptr);
    }

    bool SetModificationToBeiDouD1NavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToBeiDouD1NavigationMessage::documentation() const { return Documentation; }


    int SetModificationToBeiDouD1NavigationMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToBeiDouD1NavigationMessage::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToBeiDouD1NavigationMessage::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD1NavigationMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToBeiDouD1NavigationMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD1NavigationMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToBeiDouD1NavigationMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD1NavigationMessage::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void SetModificationToBeiDouD1NavigationMessage::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD1NavigationMessage::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetModificationToBeiDouD1NavigationMessage::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD1NavigationMessage::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetModificationToBeiDouD1NavigationMessage::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToBeiDouD1NavigationMessage::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetModificationToBeiDouD1NavigationMessage::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouD1NavigationMessage::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void SetModificationToBeiDouD1NavigationMessage::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouD1NavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToBeiDouD1NavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouD1NavigationMessage
///
#include "gen/GetBeiDouD1NavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouD1NavigationMessage::CmdName = "GetBeiDouD1NavigationMessage";
    const char* const GetBeiDouD1NavigationMessage::Documentation = "Please note the command ModificationToBeiDouD1NavigationMessage is deprecated since 21.3. You may use MessageModificationToBeiDouD1Nav.\n\nGet infos about this modification BeiDou D1 navigation message event";

    REGISTER_COMMAND_FACTORY(GetBeiDouD1NavigationMessage);


    GetBeiDouD1NavigationMessage::GetBeiDouD1NavigationMessage()
      : CommandBase(CmdName)
    {}

    GetBeiDouD1NavigationMessage::GetBeiDouD1NavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetBeiDouD1NavigationMessagePtr GetBeiDouD1NavigationMessage::create(const std::string& id)
    {
      return GetBeiDouD1NavigationMessagePtr(new GetBeiDouD1NavigationMessage(id));
    }

    GetBeiDouD1NavigationMessagePtr GetBeiDouD1NavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouD1NavigationMessage>(ptr);
    }

    bool GetBeiDouD1NavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetBeiDouD1NavigationMessage::documentation() const { return Documentation; }


    int GetBeiDouD1NavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouD1NavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetBeiDouD1NavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouD1NavigationMessageResult
///
#include "gen/GetBeiDouD1NavigationMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouD1NavigationMessageResult::CmdName = "GetBeiDouD1NavigationMessageResult";
    const char* const GetBeiDouD1NavigationMessageResult::Documentation = "Result of GetBeiDouD1NavigationMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouD1NavigationMessageResult);


    GetBeiDouD1NavigationMessageResult::GetBeiDouD1NavigationMessageResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouD1NavigationMessageResult::GetBeiDouD1NavigationMessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setModification(modification);
      setId(id);
    }


    GetBeiDouD1NavigationMessageResultPtr GetBeiDouD1NavigationMessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
    {
      return GetBeiDouD1NavigationMessageResultPtr(new GetBeiDouD1NavigationMessageResult(relatedCommand, prn, startTime, stopTime, subFrame, page, word, updateParity, modification, id));
    }

    GetBeiDouD1NavigationMessageResultPtr GetBeiDouD1NavigationMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouD1NavigationMessageResult>(ptr);
    }

    bool GetBeiDouD1NavigationMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetBeiDouD1NavigationMessageResult::documentation() const { return Documentation; }


    int GetBeiDouD1NavigationMessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouD1NavigationMessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD1NavigationMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetBeiDouD1NavigationMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD1NavigationMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetBeiDouD1NavigationMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD1NavigationMessageResult::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void GetBeiDouD1NavigationMessageResult::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD1NavigationMessageResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetBeiDouD1NavigationMessageResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD1NavigationMessageResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetBeiDouD1NavigationMessageResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouD1NavigationMessageResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetBeiDouD1NavigationMessageResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouD1NavigationMessageResult::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void GetBeiDouD1NavigationMessageResult::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouD1NavigationMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetBeiDouD1NavigationMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToBeiDouD1NavigationMessage
///
#include "gen/RemoveModificationToBeiDouD1NavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToBeiDouD1NavigationMessage::CmdName = "RemoveModificationToBeiDouD1NavigationMessage";
    const char* const RemoveModificationToBeiDouD1NavigationMessage::Documentation = "Please note the command RemoveModificationToBeiDouD1NavigationMessage is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves an event added with SetModificationToBeiDouNavigationMessage. When adding an event, the simulator\nsets the Id parameter. Use that Id here to remove the associated event.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToBeiDouD1NavigationMessage);


    RemoveModificationToBeiDouD1NavigationMessage::RemoveModificationToBeiDouD1NavigationMessage()
      : CommandBase(CmdName)
    {}

    RemoveModificationToBeiDouD1NavigationMessage::RemoveModificationToBeiDouD1NavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToBeiDouD1NavigationMessagePtr RemoveModificationToBeiDouD1NavigationMessage::create(const std::string& id)
    {
      return RemoveModificationToBeiDouD1NavigationMessagePtr(new RemoveModificationToBeiDouD1NavigationMessage(id));
    }

    RemoveModificationToBeiDouD1NavigationMessagePtr RemoveModificationToBeiDouD1NavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToBeiDouD1NavigationMessage>(ptr);
    }

    bool RemoveModificationToBeiDouD1NavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToBeiDouD1NavigationMessage::documentation() const { return Documentation; }


    int RemoveModificationToBeiDouD1NavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToBeiDouD1NavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToBeiDouD1NavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToBeiDouD1NavigationMessage
///
#include "gen/ClearAllModificationsToBeiDouD1NavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToBeiDouD1NavigationMessage::CmdName = "ClearAllModificationsToBeiDouD1NavigationMessage";
    const char* const ClearAllModificationsToBeiDouD1NavigationMessage::Documentation = "Please note the command ClearAllModificationsToBeiDouD1NavigationMessage is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change BeiDou navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToBeiDouD1NavigationMessage);


    ClearAllModificationsToBeiDouD1NavigationMessage::ClearAllModificationsToBeiDouD1NavigationMessage()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToBeiDouD1NavigationMessagePtr ClearAllModificationsToBeiDouD1NavigationMessage::create()
    {
      return ClearAllModificationsToBeiDouD1NavigationMessagePtr(new ClearAllModificationsToBeiDouD1NavigationMessage());
    }

    ClearAllModificationsToBeiDouD1NavigationMessagePtr ClearAllModificationsToBeiDouD1NavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToBeiDouD1NavigationMessage>(ptr);
    }

    bool ClearAllModificationsToBeiDouD1NavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToBeiDouD1NavigationMessage::documentation() const { return Documentation; }


    int ClearAllModificationsToBeiDouD1NavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetBeiDouD1NavigationMessages
///
#include "gen/GetBeiDouD1NavigationMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouD1NavigationMessages::CmdName = "GetBeiDouD1NavigationMessages";
    const char* const GetBeiDouD1NavigationMessages::Documentation = "Please note the command GetBeiDouD1NavigationMessages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the BeiDou D1 Navigation Messages for this PRN";

    REGISTER_COMMAND_FACTORY(GetBeiDouD1NavigationMessages);


    GetBeiDouD1NavigationMessages::GetBeiDouD1NavigationMessages()
      : CommandBase(CmdName)
    {}

    GetBeiDouD1NavigationMessages::GetBeiDouD1NavigationMessages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouD1NavigationMessagesPtr GetBeiDouD1NavigationMessages::create(int prn)
    {
      return GetBeiDouD1NavigationMessagesPtr(new GetBeiDouD1NavigationMessages(prn));
    }

    GetBeiDouD1NavigationMessagesPtr GetBeiDouD1NavigationMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouD1NavigationMessages>(ptr);
    }

    bool GetBeiDouD1NavigationMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouD1NavigationMessages::documentation() const { return Documentation; }


    int GetBeiDouD1NavigationMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouD1NavigationMessages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouD1NavigationMessages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouD1NavigationMessagesResult
///
#include "gen/GetBeiDouD1NavigationMessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouD1NavigationMessagesResult::CmdName = "GetBeiDouD1NavigationMessagesResult";
    const char* const GetBeiDouD1NavigationMessagesResult::Documentation = "Result of GetBeiDouD1NavigationMessages";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouD1NavigationMessagesResult);


    GetBeiDouD1NavigationMessagesResult::GetBeiDouD1NavigationMessagesResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouD1NavigationMessagesResult::GetBeiDouD1NavigationMessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetBeiDouD1NavigationMessagesResultPtr GetBeiDouD1NavigationMessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetBeiDouD1NavigationMessagesResultPtr(new GetBeiDouD1NavigationMessagesResult(relatedCommand, ids));
    }

    GetBeiDouD1NavigationMessagesResultPtr GetBeiDouD1NavigationMessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouD1NavigationMessagesResult>(ptr);
    }

    bool GetBeiDouD1NavigationMessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetBeiDouD1NavigationMessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetBeiDouD1NavigationMessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetBeiDouD1NavigationMessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToBeiDouD2NavigationMessage
///
#include "gen/SetModificationToBeiDouD2NavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToBeiDouD2NavigationMessage::CmdName = "SetModificationToBeiDouD2NavigationMessage";
    const char* const SetModificationToBeiDouD2NavigationMessage::Documentation = "Please note the command ModificationToBeiDouD2NavigationMessage is deprecated since 21.3. You may use MessageModificationToBeiDouD2Nav.\n\nSet (or Modify) event to change navigation message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to parity bits will have no effect.\n\nThe Id parameter is automatically updated with a unique id by the simulator for future reference.\nIf the Id is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the id is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetModificationToBeiDouD2NavigationMessage);


    SetModificationToBeiDouD2NavigationMessage::SetModificationToBeiDouD2NavigationMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToBeiDouD2NavigationMessage::SetModificationToBeiDouD2NavigationMessage(int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setModification(modification);
      setId(id);
    }


    SetModificationToBeiDouD2NavigationMessagePtr SetModificationToBeiDouD2NavigationMessage::create(int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
    {
      return SetModificationToBeiDouD2NavigationMessagePtr(new SetModificationToBeiDouD2NavigationMessage(prn, startTime, stopTime, subFrame, page, word, updateParity, modification, id));
    }

    SetModificationToBeiDouD2NavigationMessagePtr SetModificationToBeiDouD2NavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToBeiDouD2NavigationMessage>(ptr);
    }

    bool SetModificationToBeiDouD2NavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToBeiDouD2NavigationMessage::documentation() const { return Documentation; }


    int SetModificationToBeiDouD2NavigationMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToBeiDouD2NavigationMessage::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToBeiDouD2NavigationMessage::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD2NavigationMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToBeiDouD2NavigationMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD2NavigationMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToBeiDouD2NavigationMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD2NavigationMessage::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void SetModificationToBeiDouD2NavigationMessage::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD2NavigationMessage::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void SetModificationToBeiDouD2NavigationMessage::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouD2NavigationMessage::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetModificationToBeiDouD2NavigationMessage::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToBeiDouD2NavigationMessage::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetModificationToBeiDouD2NavigationMessage::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouD2NavigationMessage::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void SetModificationToBeiDouD2NavigationMessage::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouD2NavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToBeiDouD2NavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouD2NavigationMessage
///
#include "gen/GetBeiDouD2NavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouD2NavigationMessage::CmdName = "GetBeiDouD2NavigationMessage";
    const char* const GetBeiDouD2NavigationMessage::Documentation = "Please note the command ModificationToBeiDouD2NavigationMessage is deprecated since 21.3. You may use MessageModificationToBeiDouD2Nav.\n\nGet infos about this modification BeiDou D2 navigation message event";

    REGISTER_COMMAND_FACTORY(GetBeiDouD2NavigationMessage);


    GetBeiDouD2NavigationMessage::GetBeiDouD2NavigationMessage()
      : CommandBase(CmdName)
    {}

    GetBeiDouD2NavigationMessage::GetBeiDouD2NavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetBeiDouD2NavigationMessagePtr GetBeiDouD2NavigationMessage::create(const std::string& id)
    {
      return GetBeiDouD2NavigationMessagePtr(new GetBeiDouD2NavigationMessage(id));
    }

    GetBeiDouD2NavigationMessagePtr GetBeiDouD2NavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouD2NavigationMessage>(ptr);
    }

    bool GetBeiDouD2NavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetBeiDouD2NavigationMessage::documentation() const { return Documentation; }


    int GetBeiDouD2NavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouD2NavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetBeiDouD2NavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouD2NavigationMessageResult
///
#include "gen/GetBeiDouD2NavigationMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouD2NavigationMessageResult::CmdName = "GetBeiDouD2NavigationMessageResult";
    const char* const GetBeiDouD2NavigationMessageResult::Documentation = "Result of GetBeiDouD2NavigationMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouD2NavigationMessageResult);


    GetBeiDouD2NavigationMessageResult::GetBeiDouD2NavigationMessageResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouD2NavigationMessageResult::GetBeiDouD2NavigationMessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setPage(page);
      setWord(word);
      setUpdateParity(updateParity);
      setModification(modification);
      setId(id);
    }


    GetBeiDouD2NavigationMessageResultPtr GetBeiDouD2NavigationMessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int subFrame, int page, int word, bool updateParity, const std::string& modification, const std::string& id)
    {
      return GetBeiDouD2NavigationMessageResultPtr(new GetBeiDouD2NavigationMessageResult(relatedCommand, prn, startTime, stopTime, subFrame, page, word, updateParity, modification, id));
    }

    GetBeiDouD2NavigationMessageResultPtr GetBeiDouD2NavigationMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouD2NavigationMessageResult>(ptr);
    }

    bool GetBeiDouD2NavigationMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["Page"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetBeiDouD2NavigationMessageResult::documentation() const { return Documentation; }


    int GetBeiDouD2NavigationMessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouD2NavigationMessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD2NavigationMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetBeiDouD2NavigationMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD2NavigationMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetBeiDouD2NavigationMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD2NavigationMessageResult::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void GetBeiDouD2NavigationMessageResult::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD2NavigationMessageResult::page() const
    {
      return parse_json<int>::parse(m_values["Page"]);
    }

    void GetBeiDouD2NavigationMessageResult::setPage(int page)
    {
      m_values.AddMember("Page", parse_json<int>::format(page, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouD2NavigationMessageResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetBeiDouD2NavigationMessageResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouD2NavigationMessageResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetBeiDouD2NavigationMessageResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouD2NavigationMessageResult::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void GetBeiDouD2NavigationMessageResult::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouD2NavigationMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetBeiDouD2NavigationMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToBeiDouD2NavigationMessage
///
#include "gen/RemoveModificationToBeiDouD2NavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToBeiDouD2NavigationMessage::CmdName = "RemoveModificationToBeiDouD2NavigationMessage";
    const char* const RemoveModificationToBeiDouD2NavigationMessage::Documentation = "Please note the command RemoveModificationToBeiDouD2NavigationMessage is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves an event added with SetModificationToBeiDouNavigationMessage. When adding an event, the simulator\nsets the Id parameter. Use that Id here to remove the associated event.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToBeiDouD2NavigationMessage);


    RemoveModificationToBeiDouD2NavigationMessage::RemoveModificationToBeiDouD2NavigationMessage()
      : CommandBase(CmdName)
    {}

    RemoveModificationToBeiDouD2NavigationMessage::RemoveModificationToBeiDouD2NavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToBeiDouD2NavigationMessagePtr RemoveModificationToBeiDouD2NavigationMessage::create(const std::string& id)
    {
      return RemoveModificationToBeiDouD2NavigationMessagePtr(new RemoveModificationToBeiDouD2NavigationMessage(id));
    }

    RemoveModificationToBeiDouD2NavigationMessagePtr RemoveModificationToBeiDouD2NavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToBeiDouD2NavigationMessage>(ptr);
    }

    bool RemoveModificationToBeiDouD2NavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToBeiDouD2NavigationMessage::documentation() const { return Documentation; }


    int RemoveModificationToBeiDouD2NavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToBeiDouD2NavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToBeiDouD2NavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToBeiDouD2NavigationMessage
///
#include "gen/ClearAllModificationsToBeiDouD2NavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToBeiDouD2NavigationMessage::CmdName = "ClearAllModificationsToBeiDouD2NavigationMessage";
    const char* const ClearAllModificationsToBeiDouD2NavigationMessage::Documentation = "Please note the command ClearAllModificationsToBeiDouD2NavigationMessage is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change BeiDou navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToBeiDouD2NavigationMessage);


    ClearAllModificationsToBeiDouD2NavigationMessage::ClearAllModificationsToBeiDouD2NavigationMessage()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToBeiDouD2NavigationMessagePtr ClearAllModificationsToBeiDouD2NavigationMessage::create()
    {
      return ClearAllModificationsToBeiDouD2NavigationMessagePtr(new ClearAllModificationsToBeiDouD2NavigationMessage());
    }

    ClearAllModificationsToBeiDouD2NavigationMessagePtr ClearAllModificationsToBeiDouD2NavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToBeiDouD2NavigationMessage>(ptr);
    }

    bool ClearAllModificationsToBeiDouD2NavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToBeiDouD2NavigationMessage::documentation() const { return Documentation; }


    int ClearAllModificationsToBeiDouD2NavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetBeiDouD2NavigationMessages
///
#include "gen/GetBeiDouD2NavigationMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouD2NavigationMessages::CmdName = "GetBeiDouD2NavigationMessages";
    const char* const GetBeiDouD2NavigationMessages::Documentation = "Please note the command GetBeiDouD2NavigationMessages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the BeiDou D2 Navigation Messages for this PRN";

    REGISTER_COMMAND_FACTORY(GetBeiDouD2NavigationMessages);


    GetBeiDouD2NavigationMessages::GetBeiDouD2NavigationMessages()
      : CommandBase(CmdName)
    {}

    GetBeiDouD2NavigationMessages::GetBeiDouD2NavigationMessages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouD2NavigationMessagesPtr GetBeiDouD2NavigationMessages::create(int prn)
    {
      return GetBeiDouD2NavigationMessagesPtr(new GetBeiDouD2NavigationMessages(prn));
    }

    GetBeiDouD2NavigationMessagesPtr GetBeiDouD2NavigationMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouD2NavigationMessages>(ptr);
    }

    bool GetBeiDouD2NavigationMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouD2NavigationMessages::documentation() const { return Documentation; }


    int GetBeiDouD2NavigationMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouD2NavigationMessages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouD2NavigationMessages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouD2NavigationMessagesResult
///
#include "gen/GetBeiDouD2NavigationMessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouD2NavigationMessagesResult::CmdName = "GetBeiDouD2NavigationMessagesResult";
    const char* const GetBeiDouD2NavigationMessagesResult::Documentation = "Result of GetBeiDouD2NavigationMessages";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouD2NavigationMessagesResult);


    GetBeiDouD2NavigationMessagesResult::GetBeiDouD2NavigationMessagesResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouD2NavigationMessagesResult::GetBeiDouD2NavigationMessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetBeiDouD2NavigationMessagesResultPtr GetBeiDouD2NavigationMessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetBeiDouD2NavigationMessagesResultPtr(new GetBeiDouD2NavigationMessagesResult(relatedCommand, ids));
    }

    GetBeiDouD2NavigationMessagesResultPtr GetBeiDouD2NavigationMessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouD2NavigationMessagesResult>(ptr);
    }

    bool GetBeiDouD2NavigationMessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetBeiDouD2NavigationMessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetBeiDouD2NavigationMessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetBeiDouD2NavigationMessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToBeiDouCNav1Message
///
#include "gen/SetModificationToBeiDouCNav1Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToBeiDouCNav1Message::CmdName = "SetModificationToBeiDouCNav1Message";
    const char* const SetModificationToBeiDouCNav1Message::Documentation = "Please note the command ModificationToBeiDouCNav1Message is deprecated since 21.3. You may use MessageModificationToBeiDouCNav1.\n\nSet (or Modify) event to change CNAV1 message bits. If you send this command without setting the Id\nparameter, or if you set the Id with a value never used before, a new Modification event will be\ncreated. If you reuse the same event Id, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbits mods.\n\nBitsMods can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bits mods using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetModificationToBeiDouCNav1Message);


    SetModificationToBeiDouCNav1Message::SetModificationToBeiDouCNav1Message()
      : CommandBase(CmdName)
    {}

    SetModificationToBeiDouCNav1Message::SetModificationToBeiDouCNav1Message(int prn, int startTime, int stopTime, int pageId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPageId(pageId);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    SetModificationToBeiDouCNav1MessagePtr SetModificationToBeiDouCNav1Message::create(int prn, int startTime, int stopTime, int pageId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return SetModificationToBeiDouCNav1MessagePtr(new SetModificationToBeiDouCNav1Message(prn, startTime, stopTime, pageId, condition, updateCRC, bitsMods, id));
    }

    SetModificationToBeiDouCNav1MessagePtr SetModificationToBeiDouCNav1Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToBeiDouCNav1Message>(ptr);
    }

    bool SetModificationToBeiDouCNav1Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["PageId"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToBeiDouCNav1Message::documentation() const { return Documentation; }


    int SetModificationToBeiDouCNav1Message::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToBeiDouCNav1Message::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToBeiDouCNav1Message::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouCNav1Message::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToBeiDouCNav1Message::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouCNav1Message::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToBeiDouCNav1Message::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouCNav1Message::pageId() const
    {
      return parse_json<int>::parse(m_values["PageId"]);
    }

    void SetModificationToBeiDouCNav1Message::setPageId(int pageId)
    {
      m_values.AddMember("PageId", parse_json<int>::format(pageId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouCNav1Message::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetModificationToBeiDouCNav1Message::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToBeiDouCNav1Message::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetModificationToBeiDouCNav1Message::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouCNav1Message::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void SetModificationToBeiDouCNav1Message::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouCNav1Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToBeiDouCNav1Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNav1Message
///
#include "gen/GetBeiDouCNav1Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNav1Message::CmdName = "GetBeiDouCNav1Message";
    const char* const GetBeiDouCNav1Message::Documentation = "Please note the command ModificationToBeiDouCNav1Message is deprecated since 21.3. You may use MessageModificationToBeiDouCNav1.\n\nGet infos about the CNAV1 Message with this id";

    REGISTER_COMMAND_FACTORY(GetBeiDouCNav1Message);


    GetBeiDouCNav1Message::GetBeiDouCNav1Message()
      : CommandBase(CmdName)
    {}

    GetBeiDouCNav1Message::GetBeiDouCNav1Message(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetBeiDouCNav1MessagePtr GetBeiDouCNav1Message::create(const std::string& id)
    {
      return GetBeiDouCNav1MessagePtr(new GetBeiDouCNav1Message(id));
    }

    GetBeiDouCNav1MessagePtr GetBeiDouCNav1Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNav1Message>(ptr);
    }

    bool GetBeiDouCNav1Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetBeiDouCNav1Message::documentation() const { return Documentation; }


    int GetBeiDouCNav1Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouCNav1Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetBeiDouCNav1Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNav1MessageResult
///
#include "gen/GetBeiDouCNav1MessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNav1MessageResult::CmdName = "GetBeiDouCNav1MessageResult";
    const char* const GetBeiDouCNav1MessageResult::Documentation = "Result of GetBeiDouCNav1Message";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouCNav1MessageResult);


    GetBeiDouCNav1MessageResult::GetBeiDouCNav1MessageResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouCNav1MessageResult::GetBeiDouCNav1MessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int pageId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setPageId(pageId);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    GetBeiDouCNav1MessageResultPtr GetBeiDouCNav1MessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int pageId, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return GetBeiDouCNav1MessageResultPtr(new GetBeiDouCNav1MessageResult(relatedCommand, prn, startTime, stopTime, pageId, condition, updateCRC, bitsMods, id));
    }

    GetBeiDouCNav1MessageResultPtr GetBeiDouCNav1MessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNav1MessageResult>(ptr);
    }

    bool GetBeiDouCNav1MessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["PageId"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetBeiDouCNav1MessageResult::documentation() const { return Documentation; }


    int GetBeiDouCNav1MessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouCNav1MessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouCNav1MessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetBeiDouCNav1MessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouCNav1MessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetBeiDouCNav1MessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouCNav1MessageResult::pageId() const
    {
      return parse_json<int>::parse(m_values["PageId"]);
    }

    void GetBeiDouCNav1MessageResult::setPageId(int pageId)
    {
      m_values.AddMember("PageId", parse_json<int>::format(pageId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouCNav1MessageResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetBeiDouCNav1MessageResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouCNav1MessageResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetBeiDouCNav1MessageResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouCNav1MessageResult::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void GetBeiDouCNav1MessageResult::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouCNav1MessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetBeiDouCNav1MessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToBeiDouCNav1Message
///
#include "gen/RemoveModificationToBeiDouCNav1Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToBeiDouCNav1Message::CmdName = "RemoveModificationToBeiDouCNav1Message";
    const char* const RemoveModificationToBeiDouCNav1Message::Documentation = "Please note the command RemoveModificationToBeiDouCNav1Message is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves a modification.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToBeiDouCNav1Message);


    RemoveModificationToBeiDouCNav1Message::RemoveModificationToBeiDouCNav1Message()
      : CommandBase(CmdName)
    {}

    RemoveModificationToBeiDouCNav1Message::RemoveModificationToBeiDouCNav1Message(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToBeiDouCNav1MessagePtr RemoveModificationToBeiDouCNav1Message::create(const std::string& id)
    {
      return RemoveModificationToBeiDouCNav1MessagePtr(new RemoveModificationToBeiDouCNav1Message(id));
    }

    RemoveModificationToBeiDouCNav1MessagePtr RemoveModificationToBeiDouCNav1Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToBeiDouCNav1Message>(ptr);
    }

    bool RemoveModificationToBeiDouCNav1Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToBeiDouCNav1Message::documentation() const { return Documentation; }


    int RemoveModificationToBeiDouCNav1Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToBeiDouCNav1Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToBeiDouCNav1Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToBeiDouCNav1Message
///
#include "gen/ClearAllModificationsToBeiDouCNav1Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToBeiDouCNav1Message::CmdName = "ClearAllModificationsToBeiDouCNav1Message";
    const char* const ClearAllModificationsToBeiDouCNav1Message::Documentation = "Please note the command ClearAllModificationsToBeiDouCNav1Message is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change BeiDou navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToBeiDouCNav1Message);


    ClearAllModificationsToBeiDouCNav1Message::ClearAllModificationsToBeiDouCNav1Message()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToBeiDouCNav1MessagePtr ClearAllModificationsToBeiDouCNav1Message::create()
    {
      return ClearAllModificationsToBeiDouCNav1MessagePtr(new ClearAllModificationsToBeiDouCNav1Message());
    }

    ClearAllModificationsToBeiDouCNav1MessagePtr ClearAllModificationsToBeiDouCNav1Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToBeiDouCNav1Message>(ptr);
    }

    bool ClearAllModificationsToBeiDouCNav1Message::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToBeiDouCNav1Message::documentation() const { return Documentation; }


    int ClearAllModificationsToBeiDouCNav1Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetBeiDouCNav1Messages
///
#include "gen/GetBeiDouCNav1Messages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNav1Messages::CmdName = "GetBeiDouCNav1Messages";
    const char* const GetBeiDouCNav1Messages::Documentation = "Please note the command GetBeiDouCNav1Messages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the BeiDou CNav1 Message for this PRN";

    REGISTER_COMMAND_FACTORY(GetBeiDouCNav1Messages);


    GetBeiDouCNav1Messages::GetBeiDouCNav1Messages()
      : CommandBase(CmdName)
    {}

    GetBeiDouCNav1Messages::GetBeiDouCNav1Messages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouCNav1MessagesPtr GetBeiDouCNav1Messages::create(int prn)
    {
      return GetBeiDouCNav1MessagesPtr(new GetBeiDouCNav1Messages(prn));
    }

    GetBeiDouCNav1MessagesPtr GetBeiDouCNav1Messages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNav1Messages>(ptr);
    }

    bool GetBeiDouCNav1Messages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouCNav1Messages::documentation() const { return Documentation; }


    int GetBeiDouCNav1Messages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouCNav1Messages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouCNav1Messages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNav1MessagesResult
///
#include "gen/GetBeiDouCNav1MessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNav1MessagesResult::CmdName = "GetBeiDouCNav1MessagesResult";
    const char* const GetBeiDouCNav1MessagesResult::Documentation = "Result of GetBeiDouCNav1Messages";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouCNav1MessagesResult);


    GetBeiDouCNav1MessagesResult::GetBeiDouCNav1MessagesResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouCNav1MessagesResult::GetBeiDouCNav1MessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetBeiDouCNav1MessagesResultPtr GetBeiDouCNav1MessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetBeiDouCNav1MessagesResultPtr(new GetBeiDouCNav1MessagesResult(relatedCommand, ids));
    }

    GetBeiDouCNav1MessagesResultPtr GetBeiDouCNav1MessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNav1MessagesResult>(ptr);
    }

    bool GetBeiDouCNav1MessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetBeiDouCNav1MessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetBeiDouCNav1MessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetBeiDouCNav1MessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToBeiDouCNav2Message
///
#include "gen/SetModificationToBeiDouCNav2Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToBeiDouCNav2Message::CmdName = "SetModificationToBeiDouCNav2Message";
    const char* const SetModificationToBeiDouCNav2Message::Documentation = "Please note the command ModificationToBeiDouCNav2Message is deprecated since 21.3. You may use MessageModificationToBeiDouCNav2.\n\nSet (or Modify) event to change CNAV2 message bits. If you send this command without setting the Id\nparameter, or if you set the Id with a value never used before, a new Modification event will be\ncreated. If you reuse the same event Id, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbits mods.\n\nBitsMods can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bits mods using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetModificationToBeiDouCNav2Message);


    SetModificationToBeiDouCNav2Message::SetModificationToBeiDouCNav2Message()
      : CommandBase(CmdName)
    {}

    SetModificationToBeiDouCNav2Message::SetModificationToBeiDouCNav2Message(int prn, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    SetModificationToBeiDouCNav2MessagePtr SetModificationToBeiDouCNav2Message::create(int prn, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return SetModificationToBeiDouCNav2MessagePtr(new SetModificationToBeiDouCNav2Message(prn, startTime, stopTime, messageType, condition, updateCRC, bitsMods, id));
    }

    SetModificationToBeiDouCNav2MessagePtr SetModificationToBeiDouCNav2Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToBeiDouCNav2Message>(ptr);
    }

    bool SetModificationToBeiDouCNav2Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToBeiDouCNav2Message::documentation() const { return Documentation; }


    int SetModificationToBeiDouCNav2Message::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToBeiDouCNav2Message::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetModificationToBeiDouCNav2Message::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouCNav2Message::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToBeiDouCNav2Message::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouCNav2Message::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToBeiDouCNav2Message::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToBeiDouCNav2Message::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetModificationToBeiDouCNav2Message::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouCNav2Message::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetModificationToBeiDouCNav2Message::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToBeiDouCNav2Message::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetModificationToBeiDouCNav2Message::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouCNav2Message::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void SetModificationToBeiDouCNav2Message::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToBeiDouCNav2Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToBeiDouCNav2Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNav2Message
///
#include "gen/GetBeiDouCNav2Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNav2Message::CmdName = "GetBeiDouCNav2Message";
    const char* const GetBeiDouCNav2Message::Documentation = "Please note the command ModificationToBeiDouCNav2Message is deprecated since 21.3. You may use MessageModificationToBeiDouCNav2.\n\nGet infos about the modifications of CNAV2 Message with this id";

    REGISTER_COMMAND_FACTORY(GetBeiDouCNav2Message);


    GetBeiDouCNav2Message::GetBeiDouCNav2Message()
      : CommandBase(CmdName)
    {}

    GetBeiDouCNav2Message::GetBeiDouCNav2Message(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetBeiDouCNav2MessagePtr GetBeiDouCNav2Message::create(const std::string& id)
    {
      return GetBeiDouCNav2MessagePtr(new GetBeiDouCNav2Message(id));
    }

    GetBeiDouCNav2MessagePtr GetBeiDouCNav2Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNav2Message>(ptr);
    }

    bool GetBeiDouCNav2Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetBeiDouCNav2Message::documentation() const { return Documentation; }


    int GetBeiDouCNav2Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetBeiDouCNav2Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetBeiDouCNav2Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNav2MessageResult
///
#include "gen/GetBeiDouCNav2MessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNav2MessageResult::CmdName = "GetBeiDouCNav2MessageResult";
    const char* const GetBeiDouCNav2MessageResult::Documentation = "Result of GetBeiDouCNav2Message";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouCNav2MessageResult);


    GetBeiDouCNav2MessageResult::GetBeiDouCNav2MessageResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouCNav2MessageResult::GetBeiDouCNav2MessageResult(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    GetBeiDouCNav2MessageResultPtr GetBeiDouCNav2MessageResult::create(CommandBasePtr relatedCommand, int prn, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return GetBeiDouCNav2MessageResultPtr(new GetBeiDouCNav2MessageResult(relatedCommand, prn, startTime, stopTime, messageType, condition, updateCRC, bitsMods, id));
    }

    GetBeiDouCNav2MessageResultPtr GetBeiDouCNav2MessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNav2MessageResult>(ptr);
    }

    bool GetBeiDouCNav2MessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetBeiDouCNav2MessageResult::documentation() const { return Documentation; }


    int GetBeiDouCNav2MessageResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouCNav2MessageResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouCNav2MessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetBeiDouCNav2MessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouCNav2MessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetBeiDouCNav2MessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetBeiDouCNav2MessageResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetBeiDouCNav2MessageResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouCNav2MessageResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetBeiDouCNav2MessageResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetBeiDouCNav2MessageResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetBeiDouCNav2MessageResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouCNav2MessageResult::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void GetBeiDouCNav2MessageResult::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetBeiDouCNav2MessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetBeiDouCNav2MessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToBeiDouCNav2Message
///
#include "gen/RemoveModificationToBeiDouCNav2Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToBeiDouCNav2Message::CmdName = "RemoveModificationToBeiDouCNav2Message";
    const char* const RemoveModificationToBeiDouCNav2Message::Documentation = "Please note the command RemoveModificationToBeiDouCNav2Message is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves a BeiDou CNAV2 modification.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToBeiDouCNav2Message);


    RemoveModificationToBeiDouCNav2Message::RemoveModificationToBeiDouCNav2Message()
      : CommandBase(CmdName)
    {}

    RemoveModificationToBeiDouCNav2Message::RemoveModificationToBeiDouCNav2Message(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToBeiDouCNav2MessagePtr RemoveModificationToBeiDouCNav2Message::create(const std::string& id)
    {
      return RemoveModificationToBeiDouCNav2MessagePtr(new RemoveModificationToBeiDouCNav2Message(id));
    }

    RemoveModificationToBeiDouCNav2MessagePtr RemoveModificationToBeiDouCNav2Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToBeiDouCNav2Message>(ptr);
    }

    bool RemoveModificationToBeiDouCNav2Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToBeiDouCNav2Message::documentation() const { return Documentation; }


    int RemoveModificationToBeiDouCNav2Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToBeiDouCNav2Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToBeiDouCNav2Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToBeiDouCNav2Message
///
#include "gen/ClearAllModificationsToBeiDouCNav2Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToBeiDouCNav2Message::CmdName = "ClearAllModificationsToBeiDouCNav2Message";
    const char* const ClearAllModificationsToBeiDouCNav2Message::Documentation = "Please note the command ClearAllModificationsToBeiDouCNav2Message is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change BeiDou CNAV2 navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToBeiDouCNav2Message);


    ClearAllModificationsToBeiDouCNav2Message::ClearAllModificationsToBeiDouCNav2Message()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToBeiDouCNav2MessagePtr ClearAllModificationsToBeiDouCNav2Message::create()
    {
      return ClearAllModificationsToBeiDouCNav2MessagePtr(new ClearAllModificationsToBeiDouCNav2Message());
    }

    ClearAllModificationsToBeiDouCNav2MessagePtr ClearAllModificationsToBeiDouCNav2Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToBeiDouCNav2Message>(ptr);
    }

    bool ClearAllModificationsToBeiDouCNav2Message::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToBeiDouCNav2Message::documentation() const { return Documentation; }


    int ClearAllModificationsToBeiDouCNav2Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetBeiDouCNav2Messages
///
#include "gen/GetBeiDouCNav2Messages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNav2Messages::CmdName = "GetBeiDouCNav2Messages";
    const char* const GetBeiDouCNav2Messages::Documentation = "Please note the command GetBeiDouCNav2Messages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the BeiDou CNAV2 Message for this PRN";

    REGISTER_COMMAND_FACTORY(GetBeiDouCNav2Messages);


    GetBeiDouCNav2Messages::GetBeiDouCNav2Messages()
      : CommandBase(CmdName)
    {}

    GetBeiDouCNav2Messages::GetBeiDouCNav2Messages(int prn)
      : CommandBase(CmdName)
    {

      setPrn(prn);
    }


    GetBeiDouCNav2MessagesPtr GetBeiDouCNav2Messages::create(int prn)
    {
      return GetBeiDouCNav2MessagesPtr(new GetBeiDouCNav2Messages(prn));
    }

    GetBeiDouCNav2MessagesPtr GetBeiDouCNav2Messages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNav2Messages>(ptr);
    }

    bool GetBeiDouCNav2Messages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetBeiDouCNav2Messages::documentation() const { return Documentation; }


    int GetBeiDouCNav2Messages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetBeiDouCNav2Messages::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetBeiDouCNav2Messages::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetBeiDouCNav2MessagesResult
///
#include "gen/GetBeiDouCNav2MessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetBeiDouCNav2MessagesResult::CmdName = "GetBeiDouCNav2MessagesResult";
    const char* const GetBeiDouCNav2MessagesResult::Documentation = "Result of GetBeiDouCNav2Messages";

    REGISTER_COMMAND_RESULT_FACTORY(GetBeiDouCNav2MessagesResult);


    GetBeiDouCNav2MessagesResult::GetBeiDouCNav2MessagesResult()
      : CommandResult(CmdName)
    {}

    GetBeiDouCNav2MessagesResult::GetBeiDouCNav2MessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetBeiDouCNav2MessagesResultPtr GetBeiDouCNav2MessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetBeiDouCNav2MessagesResultPtr(new GetBeiDouCNav2MessagesResult(relatedCommand, ids));
    }

    GetBeiDouCNav2MessagesResultPtr GetBeiDouCNav2MessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetBeiDouCNav2MessagesResult>(ptr);
    }

    bool GetBeiDouCNav2MessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetBeiDouCNav2MessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetBeiDouCNav2MessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetBeiDouCNav2MessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToQzssLNAVNavigationMessage
///
#include "gen/SetModificationToQzssLNAVNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToQzssLNAVNavigationMessage::CmdName = "SetModificationToQzssLNAVNavigationMessage";
    const char* const SetModificationToQzssLNAVNavigationMessage::Documentation = "Please note the command ModificationToQzssLNAVNavigationMessage is deprecated since 21.3. You may use MessageModificationToQzssLNav.\n\nSet (or Modify) event to change navigation message bits.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nsubframes. The Modification parameter is a string where the first character applies to the first\nbit of subframe word and last character applies to last bit of subframe word.\n   '0' will force bit to zero\n   '1' will for bit to one\n   'X' will negate bit value\n   any other byte value will have no effect\n\nExample: \"-00------------------1-X------\" will force bits 1 and 2 to zero and bit 22 to one\n                      and negate bit 24\n\nNote: if UpdateParity is true, any modification to bits 25..30 will have no effect.\n\nThe Id parameter is automatically updated with a unique id by the simulator for future reference.\nIf the ID is set with a value other than an empty string, the simulator will try to find a match\nwith previously added events. If there is a match, the event is updated with this message\ninstead of adding a new event. If there is no match, the event is added and the ID is not\nchanged.";

    REGISTER_COMMAND_FACTORY(SetModificationToQzssLNAVNavigationMessage);


    SetModificationToQzssLNAVNavigationMessage::SetModificationToQzssLNAVNavigationMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToQzssLNAVNavigationMessage::SetModificationToQzssLNAVNavigationMessage(int svId, int startTime, int stopTime, int subFrame, int transmittedSvId, int word, bool updateParity, const std::string& modification, const std::string& id)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setTransmittedSvId(transmittedSvId);
      setWord(word);
      setUpdateParity(updateParity);
      setModification(modification);
      setId(id);
    }


    SetModificationToQzssLNAVNavigationMessagePtr SetModificationToQzssLNAVNavigationMessage::create(int svId, int startTime, int stopTime, int subFrame, int transmittedSvId, int word, bool updateParity, const std::string& modification, const std::string& id)
    {
      return SetModificationToQzssLNAVNavigationMessagePtr(new SetModificationToQzssLNAVNavigationMessage(svId, startTime, stopTime, subFrame, transmittedSvId, word, updateParity, modification, id));
    }

    SetModificationToQzssLNAVNavigationMessagePtr SetModificationToQzssLNAVNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToQzssLNAVNavigationMessage>(ptr);
    }

    bool SetModificationToQzssLNAVNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["TransmittedSvId"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToQzssLNAVNavigationMessage::documentation() const { return Documentation; }


    int SetModificationToQzssLNAVNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToQzssLNAVNavigationMessage::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetModificationToQzssLNAVNavigationMessage::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToQzssLNAVNavigationMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToQzssLNAVNavigationMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToQzssLNAVNavigationMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToQzssLNAVNavigationMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToQzssLNAVNavigationMessage::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void SetModificationToQzssLNAVNavigationMessage::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToQzssLNAVNavigationMessage::transmittedSvId() const
    {
      return parse_json<int>::parse(m_values["TransmittedSvId"]);
    }

    void SetModificationToQzssLNAVNavigationMessage::setTransmittedSvId(int transmittedSvId)
    {
      m_values.AddMember("TransmittedSvId", parse_json<int>::format(transmittedSvId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToQzssLNAVNavigationMessage::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void SetModificationToQzssLNAVNavigationMessage::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToQzssLNAVNavigationMessage::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void SetModificationToQzssLNAVNavigationMessage::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToQzssLNAVNavigationMessage::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void SetModificationToQzssLNAVNavigationMessage::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToQzssLNAVNavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToQzssLNAVNavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssLNAVNavigationMessage
///
#include "gen/GetQzssLNAVNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssLNAVNavigationMessage::CmdName = "GetQzssLNAVNavigationMessage";
    const char* const GetQzssLNAVNavigationMessage::Documentation = "Please note the command ModificationToQzssLNAVNavigationMessage is deprecated since 21.3. You may use MessageModificationToQzssLNav.\n\nGet infos about this modification QZSS navigation message event.";

    REGISTER_COMMAND_FACTORY(GetQzssLNAVNavigationMessage);


    GetQzssLNAVNavigationMessage::GetQzssLNAVNavigationMessage()
      : CommandBase(CmdName)
    {}

    GetQzssLNAVNavigationMessage::GetQzssLNAVNavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetQzssLNAVNavigationMessagePtr GetQzssLNAVNavigationMessage::create(const std::string& id)
    {
      return GetQzssLNAVNavigationMessagePtr(new GetQzssLNAVNavigationMessage(id));
    }

    GetQzssLNAVNavigationMessagePtr GetQzssLNAVNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssLNAVNavigationMessage>(ptr);
    }

    bool GetQzssLNAVNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetQzssLNAVNavigationMessage::documentation() const { return Documentation; }


    int GetQzssLNAVNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssLNAVNavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetQzssLNAVNavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssLNAVNavigationMessageResult
///
#include "gen/GetQzssLNAVNavigationMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssLNAVNavigationMessageResult::CmdName = "GetQzssLNAVNavigationMessageResult";
    const char* const GetQzssLNAVNavigationMessageResult::Documentation = "Result of GetQzssLNAVNavigationMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssLNAVNavigationMessageResult);


    GetQzssLNAVNavigationMessageResult::GetQzssLNAVNavigationMessageResult()
      : CommandResult(CmdName)
    {}

    GetQzssLNAVNavigationMessageResult::GetQzssLNAVNavigationMessageResult(CommandBasePtr relatedCommand, int svId, int startTime, int stopTime, int subFrame, int transmittedSvId, int word, bool updateParity, const std::string& modification, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubFrame(subFrame);
      setTransmittedSvId(transmittedSvId);
      setWord(word);
      setUpdateParity(updateParity);
      setModification(modification);
      setId(id);
    }


    GetQzssLNAVNavigationMessageResultPtr GetQzssLNAVNavigationMessageResult::create(CommandBasePtr relatedCommand, int svId, int startTime, int stopTime, int subFrame, int transmittedSvId, int word, bool updateParity, const std::string& modification, const std::string& id)
    {
      return GetQzssLNAVNavigationMessageResultPtr(new GetQzssLNAVNavigationMessageResult(relatedCommand, svId, startTime, stopTime, subFrame, transmittedSvId, word, updateParity, modification, id));
    }

    GetQzssLNAVNavigationMessageResultPtr GetQzssLNAVNavigationMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssLNAVNavigationMessageResult>(ptr);
    }

    bool GetQzssLNAVNavigationMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["SubFrame"])
          && parse_json<int>::is_valid(m_values["TransmittedSvId"])
          && parse_json<int>::is_valid(m_values["Word"])
          && parse_json<bool>::is_valid(m_values["UpdateParity"])
          && parse_json<std::string>::is_valid(m_values["Modification"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetQzssLNAVNavigationMessageResult::documentation() const { return Documentation; }


    int GetQzssLNAVNavigationMessageResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssLNAVNavigationMessageResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssLNAVNavigationMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetQzssLNAVNavigationMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssLNAVNavigationMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetQzssLNAVNavigationMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssLNAVNavigationMessageResult::subFrame() const
    {
      return parse_json<int>::parse(m_values["SubFrame"]);
    }

    void GetQzssLNAVNavigationMessageResult::setSubFrame(int subFrame)
    {
      m_values.AddMember("SubFrame", parse_json<int>::format(subFrame, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssLNAVNavigationMessageResult::transmittedSvId() const
    {
      return parse_json<int>::parse(m_values["TransmittedSvId"]);
    }

    void GetQzssLNAVNavigationMessageResult::setTransmittedSvId(int transmittedSvId)
    {
      m_values.AddMember("TransmittedSvId", parse_json<int>::format(transmittedSvId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssLNAVNavigationMessageResult::word() const
    {
      return parse_json<int>::parse(m_values["Word"]);
    }

    void GetQzssLNAVNavigationMessageResult::setWord(int word)
    {
      m_values.AddMember("Word", parse_json<int>::format(word, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssLNAVNavigationMessageResult::updateParity() const
    {
      return parse_json<bool>::parse(m_values["UpdateParity"]);
    }

    void GetQzssLNAVNavigationMessageResult::setUpdateParity(bool updateParity)
    {
      m_values.AddMember("UpdateParity", parse_json<bool>::format(updateParity, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssLNAVNavigationMessageResult::modification() const
    {
      return parse_json<std::string>::parse(m_values["Modification"]);
    }

    void GetQzssLNAVNavigationMessageResult::setModification(const std::string& modification)
    {
      m_values.AddMember("Modification", parse_json<std::string>::format(modification, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssLNAVNavigationMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetQzssLNAVNavigationMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of RemoveModificationToQzssLNAVNavigationMessage
///
#include "gen/RemoveModificationToQzssLNAVNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const RemoveModificationToQzssLNAVNavigationMessage::CmdName = "RemoveModificationToQzssLNAVNavigationMessage";
    const char* const RemoveModificationToQzssLNAVNavigationMessage::Documentation = "Please note the command RemoveModificationToQzssLNAVNavigationMessage is deprecated since 21.3. You may use RemoveMessageModificationForNavMsgFamily.\n\nRemoves an event added with SetModificationToQzssLNAVNavigationMessage. When adding an event, the simulator\nsets the Id parameter. Use that Id here to remove the associated event.";

    REGISTER_COMMAND_FACTORY(RemoveModificationToQzssLNAVNavigationMessage);


    RemoveModificationToQzssLNAVNavigationMessage::RemoveModificationToQzssLNAVNavigationMessage()
      : CommandBase(CmdName)
    {}

    RemoveModificationToQzssLNAVNavigationMessage::RemoveModificationToQzssLNAVNavigationMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    RemoveModificationToQzssLNAVNavigationMessagePtr RemoveModificationToQzssLNAVNavigationMessage::create(const std::string& id)
    {
      return RemoveModificationToQzssLNAVNavigationMessagePtr(new RemoveModificationToQzssLNAVNavigationMessage(id));
    }

    RemoveModificationToQzssLNAVNavigationMessagePtr RemoveModificationToQzssLNAVNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<RemoveModificationToQzssLNAVNavigationMessage>(ptr);
    }

    bool RemoveModificationToQzssLNAVNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string RemoveModificationToQzssLNAVNavigationMessage::documentation() const { return Documentation; }


    int RemoveModificationToQzssLNAVNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string RemoveModificationToQzssLNAVNavigationMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void RemoveModificationToQzssLNAVNavigationMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of ClearAllModificationsToQzssLNAVNavigationMessage
///
#include "gen/ClearAllModificationsToQzssLNAVNavigationMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const ClearAllModificationsToQzssLNAVNavigationMessage::CmdName = "ClearAllModificationsToQzssLNAVNavigationMessage";
    const char* const ClearAllModificationsToQzssLNAVNavigationMessage::Documentation = "Please note the command ClearAllModificationsToQzssLNAVNavigationMessage is deprecated since 21.3. You may use ClearAllMessageModificationsForNavMsgFamily.\n\nClear all events to change QZSS navigation message bits";

    REGISTER_COMMAND_FACTORY(ClearAllModificationsToQzssLNAVNavigationMessage);


    ClearAllModificationsToQzssLNAVNavigationMessage::ClearAllModificationsToQzssLNAVNavigationMessage()
      : CommandBase(CmdName)
    {

    }


    ClearAllModificationsToQzssLNAVNavigationMessagePtr ClearAllModificationsToQzssLNAVNavigationMessage::create()
    {
      return ClearAllModificationsToQzssLNAVNavigationMessagePtr(new ClearAllModificationsToQzssLNAVNavigationMessage());
    }

    ClearAllModificationsToQzssLNAVNavigationMessagePtr ClearAllModificationsToQzssLNAVNavigationMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<ClearAllModificationsToQzssLNAVNavigationMessage>(ptr);
    }

    bool ClearAllModificationsToQzssLNAVNavigationMessage::isValid() const
    {
      
        return m_values.IsObject()
        ;

    }

    std::string ClearAllModificationsToQzssLNAVNavigationMessage::documentation() const { return Documentation; }


    int ClearAllModificationsToQzssLNAVNavigationMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }

  }
}


///
/// Definition of GetQzssLNAVNavigationMessages
///
#include "gen/GetQzssLNAVNavigationMessages.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssLNAVNavigationMessages::CmdName = "GetQzssLNAVNavigationMessages";
    const char* const GetQzssLNAVNavigationMessages::Documentation = "Please note the command GetQzssLNAVNavigationMessages is deprecated since 21.3. You may use GetAllMessageModificationIdsForNavMsgFamily.\n\nGet all events' IDs whose will modify the QZSS Navigation Message for this SV ID";

    REGISTER_COMMAND_FACTORY(GetQzssLNAVNavigationMessages);


    GetQzssLNAVNavigationMessages::GetQzssLNAVNavigationMessages()
      : CommandBase(CmdName)
    {}

    GetQzssLNAVNavigationMessages::GetQzssLNAVNavigationMessages(int svId)
      : CommandBase(CmdName)
    {

      setSvId(svId);
    }


    GetQzssLNAVNavigationMessagesPtr GetQzssLNAVNavigationMessages::create(int svId)
    {
      return GetQzssLNAVNavigationMessagesPtr(new GetQzssLNAVNavigationMessages(svId));
    }

    GetQzssLNAVNavigationMessagesPtr GetQzssLNAVNavigationMessages::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssLNAVNavigationMessages>(ptr);
    }

    bool GetQzssLNAVNavigationMessages::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetQzssLNAVNavigationMessages::documentation() const { return Documentation; }


    int GetQzssLNAVNavigationMessages::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetQzssLNAVNavigationMessages::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssLNAVNavigationMessages::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssLNAVNavigationMessagesResult
///
#include "gen/GetQzssLNAVNavigationMessagesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssLNAVNavigationMessagesResult::CmdName = "GetQzssLNAVNavigationMessagesResult";
    const char* const GetQzssLNAVNavigationMessagesResult::Documentation = "Result of GetQzssLNAVNavigationMessages";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssLNAVNavigationMessagesResult);


    GetQzssLNAVNavigationMessagesResult::GetQzssLNAVNavigationMessagesResult()
      : CommandResult(CmdName)
    {}

    GetQzssLNAVNavigationMessagesResult::GetQzssLNAVNavigationMessagesResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetQzssLNAVNavigationMessagesResultPtr GetQzssLNAVNavigationMessagesResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetQzssLNAVNavigationMessagesResultPtr(new GetQzssLNAVNavigationMessagesResult(relatedCommand, ids));
    }

    GetQzssLNAVNavigationMessagesResultPtr GetQzssLNAVNavigationMessagesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssLNAVNavigationMessagesResult>(ptr);
    }

    bool GetQzssLNAVNavigationMessagesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetQzssLNAVNavigationMessagesResult::documentation() const { return Documentation; }


    std::vector<std::string> GetQzssLNAVNavigationMessagesResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetQzssLNAVNavigationMessagesResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToQzssL1SMessage
///
#include "gen/SetModificationToQzssL1SMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToQzssL1SMessage::CmdName = "SetModificationToQzssL1SMessage";
    const char* const SetModificationToQzssL1SMessage::Documentation = "Please note the command ModificationToQzssL1SMessage is deprecated since 21.3. You may use MessageModificationToQzssSlas.\n\nSet (or Modify) event to change L1S message bits. If you send this command without setting the Id\nparameter, or if you set the Id with a value never used before, a new Modification event will be\ncreated. If you reuse the same event Id, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbits mods.\n\nBitsMods can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bits mods using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetModificationToQzssL1SMessage);


    SetModificationToQzssL1SMessage::SetModificationToQzssL1SMessage()
      : CommandBase(CmdName)
    {}

    SetModificationToQzssL1SMessage::SetModificationToQzssL1SMessage(int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    SetModificationToQzssL1SMessagePtr SetModificationToQzssL1SMessage::create(int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return SetModificationToQzssL1SMessagePtr(new SetModificationToQzssL1SMessage(svId, startTime, stopTime, messageType, condition, updateCRC, bitsMods, id));
    }

    SetModificationToQzssL1SMessagePtr SetModificationToQzssL1SMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToQzssL1SMessage>(ptr);
    }

    bool SetModificationToQzssL1SMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToQzssL1SMessage::documentation() const { return Documentation; }


    int SetModificationToQzssL1SMessage::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToQzssL1SMessage::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetModificationToQzssL1SMessage::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToQzssL1SMessage::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToQzssL1SMessage::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToQzssL1SMessage::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToQzssL1SMessage::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToQzssL1SMessage::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetModificationToQzssL1SMessage::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToQzssL1SMessage::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetModificationToQzssL1SMessage::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToQzssL1SMessage::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetModificationToQzssL1SMessage::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToQzssL1SMessage::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void SetModificationToQzssL1SMessage::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToQzssL1SMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToQzssL1SMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1SMessage
///
#include "gen/GetQzssL1SMessage.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SMessage::CmdName = "GetQzssL1SMessage";
    const char* const GetQzssL1SMessage::Documentation = "Please note the command ModificationToQzssL1SMessage is deprecated since 21.3. You may use MessageModificationToQzssSlas.\n\nGet infos about the L1S Message with this id";

    REGISTER_COMMAND_FACTORY(GetQzssL1SMessage);


    GetQzssL1SMessage::GetQzssL1SMessage()
      : CommandBase(CmdName)
    {}

    GetQzssL1SMessage::GetQzssL1SMessage(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetQzssL1SMessagePtr GetQzssL1SMessage::create(const std::string& id)
    {
      return GetQzssL1SMessagePtr(new GetQzssL1SMessage(id));
    }

    GetQzssL1SMessagePtr GetQzssL1SMessage::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SMessage>(ptr);
    }

    bool GetQzssL1SMessage::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetQzssL1SMessage::documentation() const { return Documentation; }


    int GetQzssL1SMessage::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetQzssL1SMessage::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetQzssL1SMessage::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetQzssL1SMessageResult
///
#include "gen/GetQzssL1SMessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetQzssL1SMessageResult::CmdName = "GetQzssL1SMessageResult";
    const char* const GetQzssL1SMessageResult::Documentation = "Result of GetQzssL1SMessage";

    REGISTER_COMMAND_RESULT_FACTORY(GetQzssL1SMessageResult);


    GetQzssL1SMessageResult::GetQzssL1SMessageResult()
      : CommandResult(CmdName)
    {}

    GetQzssL1SMessageResult::GetQzssL1SMessageResult(CommandBasePtr relatedCommand, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    GetQzssL1SMessageResultPtr GetQzssL1SMessageResult::create(CommandBasePtr relatedCommand, int svId, int startTime, int stopTime, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return GetQzssL1SMessageResultPtr(new GetQzssL1SMessageResult(relatedCommand, svId, startTime, stopTime, messageType, condition, updateCRC, bitsMods, id));
    }

    GetQzssL1SMessageResultPtr GetQzssL1SMessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetQzssL1SMessageResult>(ptr);
    }

    bool GetQzssL1SMessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetQzssL1SMessageResult::documentation() const { return Documentation; }


    int GetQzssL1SMessageResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetQzssL1SMessageResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssL1SMessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetQzssL1SMessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssL1SMessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetQzssL1SMessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetQzssL1SMessageResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetQzssL1SMessageResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssL1SMessageResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetQzssL1SMessageResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetQzssL1SMessageResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetQzssL1SMessageResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssL1SMessageResult::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void GetQzssL1SMessageResult::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetQzssL1SMessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetQzssL1SMessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetModificationToNavICL5Message
///
#include "gen/SetModificationToNavICL5Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetModificationToNavICL5Message::CmdName = "SetModificationToNavICL5Message";
    const char* const SetModificationToNavICL5Message::Documentation = "Please note the command ModificationToNavICL5Message is deprecated since 21.3. You may use MessageModificationToNavICNav.\n\nSet (or Modify) event to change NavIC L5 message bits. If you send this command without setting the Id\nparameter, or if you set the Id with a value never used before, a new Modification event will be\ncreated. If you reuse the same event Id, it will modify the existing event.\n\nNote that start and stop time are automatically extended to beginning and ending of overlapped\nmessages.\n\nThe Condition parameter is optional and allows you to add content matching condition before applying\nbits mods.\n\nBitsMods can be an empty string. The Modification will have no effect until you modify it with at\nleast one bits mod.\n\nA bits mod is represented with a string using the following format: \"I:Bits\" where I is a bit\nindex (1 refers to the first transmitted bit) and Bits is a modification mask where each\ncharacter describes a modification to a single bit. The allowed characters are:\n   0 : force bit to 0\n   1 : force bit to 1\n   - : leave bit unchanged\n   X : revert bit (0 becomes 1 and 1 becomes 0)\n\nFor example: \"24:X---10XX\" will: revert bits 24, 30 and 31\n                 set bit 28 to 1\n                 set bit 29 to 0\nThe other bits are not affected.\n\nYou can add multiple bits mods using commas. For example: \"24:X---10XX,127:100X,231:01\"";

    REGISTER_COMMAND_FACTORY(SetModificationToNavICL5Message);


    SetModificationToNavICL5Message::SetModificationToNavICL5Message()
      : CommandBase(CmdName)
    {}

    SetModificationToNavICL5Message::SetModificationToNavICL5Message(int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandBase(CmdName)
    {

      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    SetModificationToNavICL5MessagePtr SetModificationToNavICL5Message::create(int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return SetModificationToNavICL5MessagePtr(new SetModificationToNavICL5Message(svId, startTime, stopTime, subframe, messageType, condition, updateCRC, bitsMods, id));
    }

    SetModificationToNavICL5MessagePtr SetModificationToNavICL5Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetModificationToNavICL5Message>(ptr);
    }

    bool SetModificationToNavICL5Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetModificationToNavICL5Message::documentation() const { return Documentation; }


    int SetModificationToNavICL5Message::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetModificationToNavICL5Message::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void SetModificationToNavICL5Message::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToNavICL5Message::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetModificationToNavICL5Message::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToNavICL5Message::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetModificationToNavICL5Message::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToNavICL5Message::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void SetModificationToNavICL5Message::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetModificationToNavICL5Message::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void SetModificationToNavICL5Message::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToNavICL5Message::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void SetModificationToNavICL5Message::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetModificationToNavICL5Message::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void SetModificationToNavICL5Message::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToNavICL5Message::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void SetModificationToNavICL5Message::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetModificationToNavICL5Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetModificationToNavICL5Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICL5Message
///
#include "gen/GetNavICL5Message.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICL5Message::CmdName = "GetNavICL5Message";
    const char* const GetNavICL5Message::Documentation = "Please note the command ModificationToNavICL5Message is deprecated since 21.3. You may use MessageModificationToNavICNav.\n\nGet infos about the NAV Message with this id";

    REGISTER_COMMAND_FACTORY(GetNavICL5Message);


    GetNavICL5Message::GetNavICL5Message()
      : CommandBase(CmdName)
    {}

    GetNavICL5Message::GetNavICL5Message(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetNavICL5MessagePtr GetNavICL5Message::create(const std::string& id)
    {
      return GetNavICL5MessagePtr(new GetNavICL5Message(id));
    }

    GetNavICL5MessagePtr GetNavICL5Message::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICL5Message>(ptr);
    }

    bool GetNavICL5Message::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetNavICL5Message::documentation() const { return Documentation; }


    int GetNavICL5Message::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetNavICL5Message::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetNavICL5Message::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetNavICL5MessageResult
///
#include "gen/GetNavICL5MessageResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetNavICL5MessageResult::CmdName = "GetNavICL5MessageResult";
    const char* const GetNavICL5MessageResult::Documentation = "Result of GetNavICL5Message";

    REGISTER_COMMAND_RESULT_FACTORY(GetNavICL5MessageResult);


    GetNavICL5MessageResult::GetNavICL5MessageResult()
      : CommandResult(CmdName)
    {}

    GetNavICL5MessageResult::GetNavICL5MessageResult(CommandBasePtr relatedCommand, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSvId(svId);
      setStartTime(startTime);
      setStopTime(stopTime);
      setSubframe(subframe);
      setMessageType(messageType);
      setCondition(condition);
      setUpdateCRC(updateCRC);
      setBitsMods(bitsMods);
      setId(id);
    }


    GetNavICL5MessageResultPtr GetNavICL5MessageResult::create(CommandBasePtr relatedCommand, int svId, int startTime, int stopTime, int subframe, int messageType, const std::string& condition, bool updateCRC, const std::string& bitsMods, const std::string& id)
    {
      return GetNavICL5MessageResultPtr(new GetNavICL5MessageResult(relatedCommand, svId, startTime, stopTime, subframe, messageType, condition, updateCRC, bitsMods, id));
    }

    GetNavICL5MessageResultPtr GetNavICL5MessageResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetNavICL5MessageResult>(ptr);
    }

    bool GetNavICL5MessageResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SvId"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<int>::is_valid(m_values["Subframe"])
          && parse_json<int>::is_valid(m_values["MessageType"])
          && parse_json<std::string>::is_valid(m_values["Condition"])
          && parse_json<bool>::is_valid(m_values["UpdateCRC"])
          && parse_json<std::string>::is_valid(m_values["BitsMods"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetNavICL5MessageResult::documentation() const { return Documentation; }


    int GetNavICL5MessageResult::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetNavICL5MessageResult::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetNavICL5MessageResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetNavICL5MessageResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetNavICL5MessageResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetNavICL5MessageResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetNavICL5MessageResult::subframe() const
    {
      return parse_json<int>::parse(m_values["Subframe"]);
    }

    void GetNavICL5MessageResult::setSubframe(int subframe)
    {
      m_values.AddMember("Subframe", parse_json<int>::format(subframe, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetNavICL5MessageResult::messageType() const
    {
      return parse_json<int>::parse(m_values["MessageType"]);
    }

    void GetNavICL5MessageResult::setMessageType(int messageType)
    {
      m_values.AddMember("MessageType", parse_json<int>::format(messageType, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetNavICL5MessageResult::condition() const
    {
      return parse_json<std::string>::parse(m_values["Condition"]);
    }

    void GetNavICL5MessageResult::setCondition(const std::string& condition)
    {
      m_values.AddMember("Condition", parse_json<std::string>::format(condition, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetNavICL5MessageResult::updateCRC() const
    {
      return parse_json<bool>::parse(m_values["UpdateCRC"]);
    }

    void GetNavICL5MessageResult::setUpdateCRC(bool updateCRC)
    {
      m_values.AddMember("UpdateCRC", parse_json<bool>::format(updateCRC, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetNavICL5MessageResult::bitsMods() const
    {
      return parse_json<std::string>::parse(m_values["BitsMods"]);
    }

    void GetNavICL5MessageResult::setBitsMods(const std::string& bitsMods)
    {
      m_values.AddMember("BitsMods", parse_json<std::string>::format(bitsMods, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetNavICL5MessageResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetNavICL5MessageResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModifications
///
#include "gen/GetMessageModifications.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModifications::CmdName = "GetMessageModifications";
    const char* const GetMessageModifications::Documentation = "Please note the command GetMessageModifications is deprecated since 21.3. You may use GetAllMessageModificationIdsForSignal.\n\nGet all event's IDs whose will modify the signal's message for this SV ID";

    REGISTER_COMMAND_FACTORY(GetMessageModifications);


    GetMessageModifications::GetMessageModifications()
      : CommandBase(CmdName)
    {}

    GetMessageModifications::GetMessageModifications(const std::string& signal, int svId)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setSvId(svId);
    }


    GetMessageModificationsPtr GetMessageModifications::create(const std::string& signal, int svId)
    {
      return GetMessageModificationsPtr(new GetMessageModifications(signal, svId));
    }

    GetMessageModificationsPtr GetMessageModifications::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModifications>(ptr);
    }

    bool GetMessageModifications::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<int>::is_valid(m_values["SvId"])
        ;

    }

    std::string GetMessageModifications::documentation() const { return Documentation; }


    int GetMessageModifications::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetMessageModifications::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetMessageModifications::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetMessageModifications::svId() const
    {
      return parse_json<int>::parse(m_values["SvId"]);
    }

    void GetMessageModifications::setSvId(int svId)
    {
      m_values.AddMember("SvId", parse_json<int>::format(svId, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetMessageModificationsResult
///
#include "gen/GetMessageModificationsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetMessageModificationsResult::CmdName = "GetMessageModificationsResult";
    const char* const GetMessageModificationsResult::Documentation = "Result of GetMessageModifications";

    REGISTER_COMMAND_RESULT_FACTORY(GetMessageModificationsResult);


    GetMessageModificationsResult::GetMessageModificationsResult()
      : CommandResult(CmdName)
    {}

    GetMessageModificationsResult::GetMessageModificationsResult(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setIds(ids);
    }


    GetMessageModificationsResultPtr GetMessageModificationsResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& ids)
    {
      return GetMessageModificationsResultPtr(new GetMessageModificationsResult(relatedCommand, ids));
    }

    GetMessageModificationsResultPtr GetMessageModificationsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetMessageModificationsResult>(ptr);
    }

    bool GetMessageModificationsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetMessageModificationsResult::documentation() const { return Documentation; }


    std::vector<std::string> GetMessageModificationsResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetMessageModificationsResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasHealthRanging
///
#include "gen/SetSbasHealthRanging.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasHealthRanging::CmdName = "SetSbasHealthRanging";
    const char* const SetSbasHealthRanging::Documentation = "Apply ranging flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasHealthRanging);


    SetSbasHealthRanging::SetSbasHealthRanging()
      : CommandBase(CmdName)
    {}

    SetSbasHealthRanging::SetSbasHealthRanging(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetSbasHealthRangingPtr SetSbasHealthRanging::create(int prn, bool health)
    {
      return SetSbasHealthRangingPtr(new SetSbasHealthRanging(prn, health));
    }

    SetSbasHealthRangingPtr SetSbasHealthRanging::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasHealthRanging>(ptr);
    }

    bool SetSbasHealthRanging::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasHealthRanging::documentation() const { return Documentation; }


    int SetSbasHealthRanging::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasHealthRanging::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSbasHealthRanging::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasHealthRanging::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasHealthRanging::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasHealthCorrections
///
#include "gen/SetSbasHealthCorrections.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasHealthCorrections::CmdName = "SetSbasHealthCorrections";
    const char* const SetSbasHealthCorrections::Documentation = "Apply correction flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasHealthCorrections);


    SetSbasHealthCorrections::SetSbasHealthCorrections()
      : CommandBase(CmdName)
    {}

    SetSbasHealthCorrections::SetSbasHealthCorrections(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetSbasHealthCorrectionsPtr SetSbasHealthCorrections::create(int prn, bool health)
    {
      return SetSbasHealthCorrectionsPtr(new SetSbasHealthCorrections(prn, health));
    }

    SetSbasHealthCorrectionsPtr SetSbasHealthCorrections::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasHealthCorrections>(ptr);
    }

    bool SetSbasHealthCorrections::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasHealthCorrections::documentation() const { return Documentation; }


    int SetSbasHealthCorrections::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasHealthCorrections::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSbasHealthCorrections::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasHealthCorrections::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasHealthCorrections::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasHealthIntegrity
///
#include "gen/SetSbasHealthIntegrity.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasHealthIntegrity::CmdName = "SetSbasHealthIntegrity";
    const char* const SetSbasHealthIntegrity::Documentation = "Apply integrity flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasHealthIntegrity);


    SetSbasHealthIntegrity::SetSbasHealthIntegrity()
      : CommandBase(CmdName)
    {}

    SetSbasHealthIntegrity::SetSbasHealthIntegrity(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetSbasHealthIntegrityPtr SetSbasHealthIntegrity::create(int prn, bool health)
    {
      return SetSbasHealthIntegrityPtr(new SetSbasHealthIntegrity(prn, health));
    }

    SetSbasHealthIntegrityPtr SetSbasHealthIntegrity::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasHealthIntegrity>(ptr);
    }

    bool SetSbasHealthIntegrity::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasHealthIntegrity::documentation() const { return Documentation; }


    int SetSbasHealthIntegrity::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasHealthIntegrity::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSbasHealthIntegrity::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasHealthIntegrity::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasHealthIntegrity::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasHealthReserved
///
#include "gen/SetSbasHealthReserved.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasHealthReserved::CmdName = "SetSbasHealthReserved";
    const char* const SetSbasHealthReserved::Documentation = "Apply reserved flag for a SBAS satellite";

    REGISTER_COMMAND_FACTORY(SetSbasHealthReserved);


    SetSbasHealthReserved::SetSbasHealthReserved()
      : CommandBase(CmdName)
    {}

    SetSbasHealthReserved::SetSbasHealthReserved(int prn, bool health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetSbasHealthReservedPtr SetSbasHealthReserved::create(int prn, bool health)
    {
      return SetSbasHealthReservedPtr(new SetSbasHealthReserved(prn, health));
    }

    SetSbasHealthReservedPtr SetSbasHealthReserved::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasHealthReserved>(ptr);
    }

    bool SetSbasHealthReserved::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasHealthReserved::documentation() const { return Documentation; }


    int SetSbasHealthReserved::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int SetSbasHealthReserved::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSbasHealthReserved::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSbasHealthReserved::health() const
    {
      return parse_json<bool>::parse(m_values["Health"]);
    }

    void SetSbasHealthReserved::setHealth(bool health)
    {
      m_values.AddMember("Health", parse_json<bool>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSbasHealthService
///
#include "gen/SetSbasHealthService.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSbasHealthService::CmdName = "SetSbasHealthService";
    const char* const SetSbasHealthService::Documentation = "Apply service provider for a satellite";

    REGISTER_COMMAND_FACTORY(SetSbasHealthService);


    SetSbasHealthService::SetSbasHealthService()
      : CommandBase(CmdName)
    {}

    SetSbasHealthService::SetSbasHealthService(int prn, int health)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setHealth(health);
    }


    SetSbasHealthServicePtr SetSbasHealthService::create(int prn, int health)
    {
      return SetSbasHealthServicePtr(new SetSbasHealthService(prn, health));
    }

    SetSbasHealthServicePtr SetSbasHealthService::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSbasHealthService>(ptr);
    }

    bool SetSbasHealthService::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Health"])
        ;

    }

    std::string SetSbasHealthService::documentation() const { return Documentation; }


    int SetSbasHealthService::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetSbasHealthService::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSbasHealthService::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSbasHealthService::health() const
    {
      return parse_json<int>::parse(m_values["Health"]);
    }

    void SetSbasHealthService::setHealth(int health)
    {
      m_values.AddMember("Health", parse_json<int>::format(health, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSisaE1E5aIndex
///
#include "gen/SetGalileoSisaE1E5aIndex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSisaE1E5aIndex::CmdName = "SetGalileoSisaE1E5aIndex";
    const char* const SetGalileoSisaE1E5aIndex::Documentation = "Please note the command SetGalileoSisaE1E5aIndex is deprecated since 21.3. You may use SetGalileoSisaE1E5aIndexForSV.\n\nSet the SISA(E1,E5a) index of a Galileo satellite";

    REGISTER_COMMAND_FACTORY(SetGalileoSisaE1E5aIndex);


    SetGalileoSisaE1E5aIndex::SetGalileoSisaE1E5aIndex()
      : CommandBase(CmdName)
    {}

    SetGalileoSisaE1E5aIndex::SetGalileoSisaE1E5aIndex(int prn, int sisai)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSisai(sisai);
    }


    SetGalileoSisaE1E5aIndexPtr SetGalileoSisaE1E5aIndex::create(int prn, int sisai)
    {
      return SetGalileoSisaE1E5aIndexPtr(new SetGalileoSisaE1E5aIndex(prn, sisai));
    }

    SetGalileoSisaE1E5aIndexPtr SetGalileoSisaE1E5aIndex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSisaE1E5aIndex>(ptr);
    }

    bool SetGalileoSisaE1E5aIndex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Sisai"])
        ;

    }

    std::string SetGalileoSisaE1E5aIndex::documentation() const { return Documentation; }


    int SetGalileoSisaE1E5aIndex::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGalileoSisaE1E5aIndex::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoSisaE1E5aIndex::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoSisaE1E5aIndex::sisai() const
    {
      return parse_json<int>::parse(m_values["Sisai"]);
    }

    void SetGalileoSisaE1E5aIndex::setSisai(int sisai)
    {
      m_values.AddMember("Sisai", parse_json<int>::format(sisai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGalileoSisaE1E5bIndex
///
#include "gen/SetGalileoSisaE1E5bIndex.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGalileoSisaE1E5bIndex::CmdName = "SetGalileoSisaE1E5bIndex";
    const char* const SetGalileoSisaE1E5bIndex::Documentation = "Please note the command SetGalileoSisaE1E5bIndex is deprecated since 21.3. You may use SetGalileoSisaE1E5bIndexForSV.\n\nSet the SISA(E1,E5b) index of a Galileo satellite";

    REGISTER_COMMAND_FACTORY(SetGalileoSisaE1E5bIndex);


    SetGalileoSisaE1E5bIndex::SetGalileoSisaE1E5bIndex()
      : CommandBase(CmdName)
    {}

    SetGalileoSisaE1E5bIndex::SetGalileoSisaE1E5bIndex(int prn, int sisai)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSisai(sisai);
    }


    SetGalileoSisaE1E5bIndexPtr SetGalileoSisaE1E5bIndex::create(int prn, int sisai)
    {
      return SetGalileoSisaE1E5bIndexPtr(new SetGalileoSisaE1E5bIndex(prn, sisai));
    }

    SetGalileoSisaE1E5bIndexPtr SetGalileoSisaE1E5bIndex::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGalileoSisaE1E5bIndex>(ptr);
    }

    bool SetGalileoSisaE1E5bIndex::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Sisai"])
        ;

    }

    std::string SetGalileoSisaE1E5bIndex::documentation() const { return Documentation; }


    int SetGalileoSisaE1E5bIndex::executePermission() const
    {
      return EXECUTE_IF_IDLE | EXECUTE_IF_SIMULATING;
    }


    int SetGalileoSisaE1E5bIndex::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetGalileoSisaE1E5bIndex::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGalileoSisaE1E5bIndex::sisai() const
    {
      return parse_json<int>::parse(m_values["Sisai"]);
    }

    void SetGalileoSisaE1E5bIndex::setSisai(int sisai)
    {
      m_values.AddMember("Sisai", parse_json<int>::format(sisai, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSatellitePower
///
#include "gen/SetSatellitePower.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSatellitePower::CmdName = "SetSatellitePower";
    const char* const SetSatellitePower::Documentation = "Please note the command SetSatellitePower is deprecated since 21.3. You may use SetPowerForSV.\n\nSet power offset for specified satellite PRN. Use PRN 0 to set power for all satellites.";

    REGISTER_COMMAND_FACTORY(SetSatellitePower);


    SetSatellitePower::SetSatellitePower()
      : CommandBase(CmdName)
    {}

    SetSatellitePower::SetSatellitePower(const std::string& system, int prn, double powerOffset, bool otherSatsFollow)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setPowerOffset(powerOffset);
      setOtherSatsFollow(otherSatsFollow);
    }


    SetSatellitePowerPtr SetSatellitePower::create(const std::string& system, int prn, double powerOffset, bool otherSatsFollow)
    {
      return SetSatellitePowerPtr(new SetSatellitePower(system, prn, powerOffset, otherSatsFollow));
    }

    SetSatellitePowerPtr SetSatellitePower::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSatellitePower>(ptr);
    }

    bool SetSatellitePower::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<double>::is_valid(m_values["PowerOffset"])
          && parse_json<bool>::is_valid(m_values["OtherSatsFollow"])
        ;

    }

    std::string SetSatellitePower::documentation() const { return Documentation; }


    int SetSatellitePower::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string SetSatellitePower::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSatellitePower::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatellitePower::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSatellitePower::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSatellitePower::powerOffset() const
    {
      return parse_json<double>::parse(m_values["PowerOffset"]);
    }

    void SetSatellitePower::setPowerOffset(double powerOffset)
    {
      m_values.AddMember("PowerOffset", parse_json<double>::format(powerOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSatellitePower::otherSatsFollow() const
    {
      return parse_json<bool>::parse(m_values["OtherSatsFollow"]);
    }

    void SetSatellitePower::setOtherSatsFollow(bool otherSatsFollow)
    {
      m_values.AddMember("OtherSatsFollow", parse_json<bool>::format(otherSatsFollow, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatellitePower
///
#include "gen/GetSatellitePower.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatellitePower::CmdName = "GetSatellitePower";
    const char* const GetSatellitePower::Documentation = "Please note the command GetSatellitePower is deprecated since 21.3. You may use GetPowerForSV.\n\nGet power offset for specified satellite PRN.";

    REGISTER_COMMAND_FACTORY(GetSatellitePower);


    GetSatellitePower::GetSatellitePower()
      : CommandBase(CmdName)
    {}

    GetSatellitePower::GetSatellitePower(const std::string& system, int prn)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
    }


    GetSatellitePowerPtr GetSatellitePower::create(const std::string& system, int prn)
    {
      return GetSatellitePowerPtr(new GetSatellitePower(system, prn));
    }

    GetSatellitePowerPtr GetSatellitePower::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatellitePower>(ptr);
    }

    bool GetSatellitePower::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetSatellitePower::documentation() const { return Documentation; }


    int GetSatellitePower::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string GetSatellitePower::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSatellitePower::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePower::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSatellitePower::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatellitePowerResult
///
#include "gen/GetSatellitePowerResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatellitePowerResult::CmdName = "GetSatellitePowerResult";
    const char* const GetSatellitePowerResult::Documentation = "Result of GetSatellitePower.";

    REGISTER_COMMAND_RESULT_FACTORY(GetSatellitePowerResult);


    GetSatellitePowerResult::GetSatellitePowerResult()
      : CommandResult(CmdName)
    {}

    GetSatellitePowerResult::GetSatellitePowerResult(CommandBasePtr relatedCommand, double nominalPower, double signalStrengthModel, double antenna, double signalLevelOffset, double manualGain, double total)
      : CommandResult(CmdName, relatedCommand)
    {

      setNominalPower(nominalPower);
      setSignalStrengthModel(signalStrengthModel);
      setAntenna(antenna);
      setSignalLevelOffset(signalLevelOffset);
      setManualGain(manualGain);
      setTotal(total);
    }


    GetSatellitePowerResultPtr GetSatellitePowerResult::create(CommandBasePtr relatedCommand, double nominalPower, double signalStrengthModel, double antenna, double signalLevelOffset, double manualGain, double total)
    {
      return GetSatellitePowerResultPtr(new GetSatellitePowerResult(relatedCommand, nominalPower, signalStrengthModel, antenna, signalLevelOffset, manualGain, total));
    }

    GetSatellitePowerResultPtr GetSatellitePowerResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatellitePowerResult>(ptr);
    }

    bool GetSatellitePowerResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<double>::is_valid(m_values["NominalPower"])
          && parse_json<double>::is_valid(m_values["SignalStrengthModel"])
          && parse_json<double>::is_valid(m_values["Antenna"])
          && parse_json<double>::is_valid(m_values["SignalLevelOffset"])
          && parse_json<double>::is_valid(m_values["ManualGain"])
          && parse_json<double>::is_valid(m_values["Total"])
        ;

    }

    std::string GetSatellitePowerResult::documentation() const { return Documentation; }


    double GetSatellitePowerResult::nominalPower() const
    {
      return parse_json<double>::parse(m_values["NominalPower"]);
    }

    void GetSatellitePowerResult::setNominalPower(double nominalPower)
    {
      m_values.AddMember("NominalPower", parse_json<double>::format(nominalPower, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePowerResult::signalStrengthModel() const
    {
      return parse_json<double>::parse(m_values["SignalStrengthModel"]);
    }

    void GetSatellitePowerResult::setSignalStrengthModel(double signalStrengthModel)
    {
      m_values.AddMember("SignalStrengthModel", parse_json<double>::format(signalStrengthModel, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePowerResult::antenna() const
    {
      return parse_json<double>::parse(m_values["Antenna"]);
    }

    void GetSatellitePowerResult::setAntenna(double antenna)
    {
      m_values.AddMember("Antenna", parse_json<double>::format(antenna, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePowerResult::signalLevelOffset() const
    {
      return parse_json<double>::parse(m_values["SignalLevelOffset"]);
    }

    void GetSatellitePowerResult::setSignalLevelOffset(double signalLevelOffset)
    {
      m_values.AddMember("SignalLevelOffset", parse_json<double>::format(signalLevelOffset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePowerResult::manualGain() const
    {
      return parse_json<double>::parse(m_values["ManualGain"]);
    }

    void GetSatellitePowerResult::setManualGain(double manualGain)
    {
      m_values.AddMember("ManualGain", parse_json<double>::format(manualGain, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePowerResult::total() const
    {
      return parse_json<double>::parse(m_values["Total"]);
    }

    void GetSatellitePowerResult::setTotal(double total)
    {
      m_values.AddMember("Total", parse_json<double>::format(total, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVisibleSatellites
///
#include "gen/GetVisibleSatellites.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVisibleSatellites::CmdName = "GetVisibleSatellites";
    const char* const GetVisibleSatellites::Documentation = "Please note the command GetVisibleSatellites is deprecated since 21.3. You may use GetVisibleSV.\n\nGet a list of visible satellites within a system, returns a GetVisibleSatellitesResult";

    REGISTER_COMMAND_FACTORY(GetVisibleSatellites);


    GetVisibleSatellites::GetVisibleSatellites()
      : CommandBase(CmdName)
    {}

    GetVisibleSatellites::GetVisibleSatellites(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetVisibleSatellitesPtr GetVisibleSatellites::create(const std::string& system)
    {
      return GetVisibleSatellitesPtr(new GetVisibleSatellites(system));
    }

    GetVisibleSatellitesPtr GetVisibleSatellites::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVisibleSatellites>(ptr);
    }

    bool GetVisibleSatellites::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetVisibleSatellites::documentation() const { return Documentation; }


    int GetVisibleSatellites::executePermission() const
    {
      return EXECUTE_IF_SIMULATING;
    }


    std::string GetVisibleSatellites::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetVisibleSatellites::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetVisibleSatellitesResult
///
#include "gen/GetVisibleSatellitesResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetVisibleSatellitesResult::CmdName = "GetVisibleSatellitesResult";
    const char* const GetVisibleSatellitesResult::Documentation = "Result of GetVisibleSatellites";

    REGISTER_COMMAND_RESULT_FACTORY(GetVisibleSatellitesResult);


    GetVisibleSatellitesResult::GetVisibleSatellitesResult()
      : CommandResult(CmdName)
    {}

    GetVisibleSatellitesResult::GetVisibleSatellitesResult(CommandBasePtr relatedCommand, const std::vector<int>& prns)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrns(prns);
    }


    GetVisibleSatellitesResultPtr GetVisibleSatellitesResult::create(CommandBasePtr relatedCommand, const std::vector<int>& prns)
    {
      return GetVisibleSatellitesResultPtr(new GetVisibleSatellitesResult(relatedCommand, prns));
    }

    GetVisibleSatellitesResultPtr GetVisibleSatellitesResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetVisibleSatellitesResult>(ptr);
    }

    bool GetVisibleSatellitesResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<int>>::is_valid(m_values["Prns"])
        ;

    }

    std::string GetVisibleSatellitesResult::documentation() const { return Documentation; }


    std::vector<int> GetVisibleSatellitesResult::prns() const
    {
      return parse_json<std::vector<int>>::parse(m_values["Prns"]);
    }

    void GetVisibleSatellitesResult::setPrns(const std::vector<int>& prns)
    {
      m_values.AddMember("Prns", parse_json<std::vector<int>>::format(prns, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSatGeo
///
#include "gen/SetSatGeo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSatGeo::CmdName = "SetSatGeo";
    const char* const SetSatGeo::Documentation = "Please note the command SatGeo is deprecated since 21.3. You may use ForceSVGeo.\n\nSet whether a satellite is geostationary";

    REGISTER_COMMAND_FACTORY(SetSatGeo);


    SetSatGeo::SetSatGeo()
      : CommandBase(CmdName)
    {}

    SetSatGeo::SetSatGeo(const std::string& system, int prn, bool isGeo, double longitude)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setIsGeo(isGeo);
      setLongitude(longitude);
    }


    SetSatGeoPtr SetSatGeo::create(const std::string& system, int prn, bool isGeo, double longitude)
    {
      return SetSatGeoPtr(new SetSatGeo(system, prn, isGeo, longitude));
    }

    SetSatGeoPtr SetSatGeo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSatGeo>(ptr);
    }

    bool SetSatGeo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["IsGeo"])
          && parse_json<double>::is_valid(m_values["Longitude"])
        ;

    }

    std::string SetSatGeo::documentation() const { return Documentation; }


    int SetSatGeo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSatGeo::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSatGeo::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatGeo::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSatGeo::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSatGeo::isGeo() const
    {
      return parse_json<bool>::parse(m_values["IsGeo"]);
    }

    void SetSatGeo::setIsGeo(bool isGeo)
    {
      m_values.AddMember("IsGeo", parse_json<bool>::format(isGeo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSatGeo::longitude() const
    {
      return parse_json<double>::parse(m_values["Longitude"]);
    }

    void SetSatGeo::setLongitude(double longitude)
    {
      m_values.AddMember("Longitude", parse_json<double>::format(longitude, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSatGeo
///
#include "gen/IsSatGeo.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSatGeo::CmdName = "IsSatGeo";
    const char* const IsSatGeo::Documentation = "Please note the command SatGeo is deprecated since 21.3. You may use ForceSVGeo.\n\nGet whether a satellite is geostationary";

    REGISTER_COMMAND_FACTORY(IsSatGeo);


    IsSatGeo::IsSatGeo()
      : CommandBase(CmdName)
    {}

    IsSatGeo::IsSatGeo(const std::string& system, int prn)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
    }


    IsSatGeoPtr IsSatGeo::create(const std::string& system, int prn)
    {
      return IsSatGeoPtr(new IsSatGeo(system, prn));
    }

    IsSatGeoPtr IsSatGeo::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSatGeo>(ptr);
    }

    bool IsSatGeo::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string IsSatGeo::documentation() const { return Documentation; }


    int IsSatGeo::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string IsSatGeo::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSatGeo::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSatGeo::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsSatGeo::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsSatGeoResult
///
#include "gen/IsSatGeoResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsSatGeoResult::CmdName = "IsSatGeoResult";
    const char* const IsSatGeoResult::Documentation = "Result of IsSatGeo";

    REGISTER_COMMAND_RESULT_FACTORY(IsSatGeoResult);


    IsSatGeoResult::IsSatGeoResult()
      : CommandResult(CmdName)
    {}

    IsSatGeoResult::IsSatGeoResult(CommandBasePtr relatedCommand, const std::string& system, int prn, bool isGeo, double longitude)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setIsGeo(isGeo);
      setLongitude(longitude);
    }


    IsSatGeoResultPtr IsSatGeoResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, bool isGeo, double longitude)
    {
      return IsSatGeoResultPtr(new IsSatGeoResult(relatedCommand, system, prn, isGeo, longitude));
    }

    IsSatGeoResultPtr IsSatGeoResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsSatGeoResult>(ptr);
    }

    bool IsSatGeoResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["IsGeo"])
          && parse_json<double>::is_valid(m_values["Longitude"])
        ;

    }

    std::string IsSatGeoResult::documentation() const { return Documentation; }


    std::string IsSatGeoResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void IsSatGeoResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int IsSatGeoResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsSatGeoResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsSatGeoResult::isGeo() const
    {
      return parse_json<bool>::parse(m_values["IsGeo"]);
    }

    void IsSatGeoResult::setIsGeo(bool isGeo)
    {
      m_values.AddMember("IsGeo", parse_json<bool>::format(isGeo, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double IsSatGeoResult::longitude() const
    {
      return parse_json<double>::parse(m_values["Longitude"]);
    }

    void IsSatGeoResult::setLongitude(double longitude)
    {
      m_values.AddMember("Longitude", parse_json<double>::format(longitude, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnablePY
///
#include "gen/EnablePY.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnablePY::CmdName = "EnablePY";
    const char* const EnablePY::Documentation = "Please note the command EnablePY is deprecated since 21.3. You may use EnablePYCodeForSV.\n\nEnable (or disable) P(Y)-Code for specified satellite PRN. Use PRN 0 to enabled/disable all satellites.\nAllowed signal keys: \"L1P\", \"L2P\"";

    REGISTER_COMMAND_FACTORY(EnablePY);


    EnablePY::EnablePY()
      : CommandBase(CmdName)
    {}

    EnablePY::EnablePY(int prn, const std::string& signal, bool enabled)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSignal(signal);
      setEnabled(enabled);
    }


    EnablePYPtr EnablePY::create(int prn, const std::string& signal, bool enabled)
    {
      return EnablePYPtr(new EnablePY(prn, signal, enabled));
    }

    EnablePYPtr EnablePY::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnablePY>(ptr);
    }

    bool EnablePY::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnablePY::documentation() const { return Documentation; }


    int EnablePY::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    int EnablePY::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void EnablePY::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string EnablePY::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnablePY::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool EnablePY::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void EnablePY::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYEnabled
///
#include "gen/IsPYEnabled.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYEnabled::CmdName = "IsPYEnabled";
    const char* const IsPYEnabled::Documentation = "Please note the command EnablePY is deprecated since 21.3. You may use EnablePYCodeForSV.\n\nTells if P(Y)-Code is enabled for the specified satellite PRN. See EnablePY description for allowed signals.";

    REGISTER_COMMAND_FACTORY(IsPYEnabled);


    IsPYEnabled::IsPYEnabled()
      : CommandBase(CmdName)
    {}

    IsPYEnabled::IsPYEnabled(int prn, const std::string& signal)
      : CommandBase(CmdName)
    {

      setPrn(prn);
      setSignal(signal);
    }


    IsPYEnabledPtr IsPYEnabled::create(int prn, const std::string& signal)
    {
      return IsPYEnabledPtr(new IsPYEnabled(prn, signal));
    }

    IsPYEnabledPtr IsPYEnabled::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYEnabled>(ptr);
    }

    bool IsPYEnabled::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string IsPYEnabled::documentation() const { return Documentation; }


    int IsPYEnabled::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int IsPYEnabled::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsPYEnabled::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsPYEnabled::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYEnabled::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of IsPYEnabledResult
///
#include "gen/IsPYEnabledResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const IsPYEnabledResult::CmdName = "IsPYEnabledResult";
    const char* const IsPYEnabledResult::Documentation = "Result of IsPYEnabled";

    REGISTER_COMMAND_RESULT_FACTORY(IsPYEnabledResult);


    IsPYEnabledResult::IsPYEnabledResult()
      : CommandResult(CmdName)
    {}

    IsPYEnabledResult::IsPYEnabledResult(CommandBasePtr relatedCommand, int prn, const std::string& signal, bool enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setPrn(prn);
      setSignal(signal);
      setEnabled(enabled);
    }


    IsPYEnabledResultPtr IsPYEnabledResult::create(CommandBasePtr relatedCommand, int prn, const std::string& signal, bool enabled)
    {
      return IsPYEnabledResultPtr(new IsPYEnabledResult(relatedCommand, prn, signal, enabled));
    }

    IsPYEnabledResultPtr IsPYEnabledResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<IsPYEnabledResult>(ptr);
    }

    bool IsPYEnabledResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
        ;

    }

    std::string IsPYEnabledResult::documentation() const { return Documentation; }


    int IsPYEnabledResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void IsPYEnabledResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string IsPYEnabledResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void IsPYEnabledResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool IsPYEnabledResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void IsPYEnabledResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of EnablePYForEachPrn
///
#include "gen/EnablePYForEachPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const EnablePYForEachPrn::CmdName = "EnablePYForEachPrn";
    const char* const EnablePYForEachPrn::Documentation = "Please note the command EnablePYForEachPrn is deprecated since 21.3. You may use EnablePYCodeForEachSV.\n\nEnable (or disable) P(Y)-Code for each satellite individually.\nAllowed signal keys: \"L1P\", \"L2P\"";

    REGISTER_COMMAND_FACTORY(EnablePYForEachPrn);


    EnablePYForEachPrn::EnablePYForEachPrn()
      : CommandBase(CmdName)
    {}

    EnablePYForEachPrn::EnablePYForEachPrn(const std::string& signal, const std::vector<bool>& enabled)
      : CommandBase(CmdName)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    EnablePYForEachPrnPtr EnablePYForEachPrn::create(const std::string& signal, const std::vector<bool>& enabled)
    {
      return EnablePYForEachPrnPtr(new EnablePYForEachPrn(signal, enabled));
    }

    EnablePYForEachPrnPtr EnablePYForEachPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<EnablePYForEachPrn>(ptr);
    }

    bool EnablePYForEachPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string EnablePYForEachPrn::documentation() const { return Documentation; }


    int EnablePYForEachPrn::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string EnablePYForEachPrn::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void EnablePYForEachPrn::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> EnablePYForEachPrn::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void EnablePYForEachPrn::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPYEnabledForEachPrn
///
#include "gen/GetPYEnabledForEachPrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPYEnabledForEachPrn::CmdName = "GetPYEnabledForEachPrn";
    const char* const GetPYEnabledForEachPrn::Documentation = "Please note the command EnablePYForEachPrn is deprecated since 21.3. You may use EnablePYCodeForEachSV.\n\nTells if the P(Y)-Code is enabled or disabled for each satellite. See EnablePYForEachPrn description for allowed signals.";

    REGISTER_COMMAND_FACTORY(GetPYEnabledForEachPrn);


    GetPYEnabledForEachPrn::GetPYEnabledForEachPrn()
      : CommandBase(CmdName)
    {}

    GetPYEnabledForEachPrn::GetPYEnabledForEachPrn(const std::string& signal)
      : CommandBase(CmdName)
    {

      setSignal(signal);
    }


    GetPYEnabledForEachPrnPtr GetPYEnabledForEachPrn::create(const std::string& signal)
    {
      return GetPYEnabledForEachPrnPtr(new GetPYEnabledForEachPrn(signal));
    }

    GetPYEnabledForEachPrnPtr GetPYEnabledForEachPrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPYEnabledForEachPrn>(ptr);
    }

    bool GetPYEnabledForEachPrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
        ;

    }

    std::string GetPYEnabledForEachPrn::documentation() const { return Documentation; }


    int GetPYEnabledForEachPrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPYEnabledForEachPrn::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPYEnabledForEachPrn::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPYEnabledForEachPrnResult
///
#include "gen/GetPYEnabledForEachPrnResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPYEnabledForEachPrnResult::CmdName = "GetPYEnabledForEachPrnResult";
    const char* const GetPYEnabledForEachPrnResult::Documentation = "Result of GetPYEnabledForEachPrn";

    REGISTER_COMMAND_RESULT_FACTORY(GetPYEnabledForEachPrnResult);


    GetPYEnabledForEachPrnResult::GetPYEnabledForEachPrnResult()
      : CommandResult(CmdName)
    {}

    GetPYEnabledForEachPrnResult::GetPYEnabledForEachPrnResult(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
      : CommandResult(CmdName, relatedCommand)
    {

      setSignal(signal);
      setEnabled(enabled);
    }


    GetPYEnabledForEachPrnResultPtr GetPYEnabledForEachPrnResult::create(CommandBasePtr relatedCommand, const std::string& signal, const std::vector<bool>& enabled)
    {
      return GetPYEnabledForEachPrnResultPtr(new GetPYEnabledForEachPrnResult(relatedCommand, signal, enabled));
    }

    GetPYEnabledForEachPrnResultPtr GetPYEnabledForEachPrnResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPYEnabledForEachPrnResult>(ptr);
    }

    bool GetPYEnabledForEachPrnResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Signal"])
          && parse_json<std::vector<bool>>::is_valid(m_values["Enabled"])
        ;

    }

    std::string GetPYEnabledForEachPrnResult::documentation() const { return Documentation; }


    std::string GetPYEnabledForEachPrnResult::signal() const
    {
      return parse_json<std::string>::parse(m_values["Signal"]);
    }

    void GetPYEnabledForEachPrnResult::setSignal(const std::string& signal)
    {
      m_values.AddMember("Signal", parse_json<std::string>::format(signal, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<bool> GetPYEnabledForEachPrnResult::enabled() const
    {
      return parse_json<std::vector<bool>>::parse(m_values["Enabled"]);
    }

    void GetPYEnabledForEachPrnResult::setEnabled(const std::vector<bool>& enabled)
    {
      m_values.AddMember("Enabled", parse_json<std::vector<bool>>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSatellitePseudorangeNoiseOffset
///
#include "gen/SetSatellitePseudorangeNoiseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSatellitePseudorangeNoiseOffset::CmdName = "SetSatellitePseudorangeNoiseOffset";
    const char* const SetSatellitePseudorangeNoiseOffset::Documentation = "Please note the command SatellitePseudorangeNoiseOffset is deprecated since 21.3. You may use PseudorangeNoiseOffsetForSV.\n\nSet the satellite pseudorange noise constant offset.";

    REGISTER_COMMAND_FACTORY(SetSatellitePseudorangeNoiseOffset);


    SetSatellitePseudorangeNoiseOffset::SetSatellitePseudorangeNoiseOffset()
      : CommandBase(CmdName)
    {}

    SetSatellitePseudorangeNoiseOffset::SetSatellitePseudorangeNoiseOffset(const std::string& system, int prn, bool enabled, double offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setEnabled(enabled);
      setOffset(offset);
    }


    SetSatellitePseudorangeNoiseOffsetPtr SetSatellitePseudorangeNoiseOffset::create(const std::string& system, int prn, bool enabled, double offset)
    {
      return SetSatellitePseudorangeNoiseOffsetPtr(new SetSatellitePseudorangeNoiseOffset(system, prn, enabled, offset));
    }

    SetSatellitePseudorangeNoiseOffsetPtr SetSatellitePseudorangeNoiseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSatellitePseudorangeNoiseOffset>(ptr);
    }

    bool SetSatellitePseudorangeNoiseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetSatellitePseudorangeNoiseOffset::documentation() const { return Documentation; }


    int SetSatellitePseudorangeNoiseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSatellitePseudorangeNoiseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSatellitePseudorangeNoiseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatellitePseudorangeNoiseOffset::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSatellitePseudorangeNoiseOffset::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSatellitePseudorangeNoiseOffset::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetSatellitePseudorangeNoiseOffset::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSatellitePseudorangeNoiseOffset::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetSatellitePseudorangeNoiseOffset::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatellitePseudorangeNoiseOffset
///
#include "gen/GetSatellitePseudorangeNoiseOffset.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatellitePseudorangeNoiseOffset::CmdName = "GetSatellitePseudorangeNoiseOffset";
    const char* const GetSatellitePseudorangeNoiseOffset::Documentation = "Please note the command SatellitePseudorangeNoiseOffset is deprecated since 21.3. You may use PseudorangeNoiseOffsetForSV.\n\nGet the satellite pseudorange noise constant offset.";

    REGISTER_COMMAND_FACTORY(GetSatellitePseudorangeNoiseOffset);


    GetSatellitePseudorangeNoiseOffset::GetSatellitePseudorangeNoiseOffset()
      : CommandBase(CmdName)
    {}

    GetSatellitePseudorangeNoiseOffset::GetSatellitePseudorangeNoiseOffset(const std::string& system, int prn)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
    }


    GetSatellitePseudorangeNoiseOffsetPtr GetSatellitePseudorangeNoiseOffset::create(const std::string& system, int prn)
    {
      return GetSatellitePseudorangeNoiseOffsetPtr(new GetSatellitePseudorangeNoiseOffset(system, prn));
    }

    GetSatellitePseudorangeNoiseOffsetPtr GetSatellitePseudorangeNoiseOffset::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatellitePseudorangeNoiseOffset>(ptr);
    }

    bool GetSatellitePseudorangeNoiseOffset::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetSatellitePseudorangeNoiseOffset::documentation() const { return Documentation; }


    int GetSatellitePseudorangeNoiseOffset::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSatellitePseudorangeNoiseOffset::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSatellitePseudorangeNoiseOffset::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseOffset::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSatellitePseudorangeNoiseOffset::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatellitePseudorangeNoiseOffsetResult
///
#include "gen/GetSatellitePseudorangeNoiseOffsetResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatellitePseudorangeNoiseOffsetResult::CmdName = "GetSatellitePseudorangeNoiseOffsetResult";
    const char* const GetSatellitePseudorangeNoiseOffsetResult::Documentation = "Result of GetSatellitePseudorangeNoiseOffset";

    REGISTER_COMMAND_RESULT_FACTORY(GetSatellitePseudorangeNoiseOffsetResult);


    GetSatellitePseudorangeNoiseOffsetResult::GetSatellitePseudorangeNoiseOffsetResult()
      : CommandResult(CmdName)
    {}

    GetSatellitePseudorangeNoiseOffsetResult::GetSatellitePseudorangeNoiseOffsetResult(CommandBasePtr relatedCommand, const std::string& system, int prn, bool enabled, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setEnabled(enabled);
      setOffset(offset);
    }


    GetSatellitePseudorangeNoiseOffsetResultPtr GetSatellitePseudorangeNoiseOffsetResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, bool enabled, double offset)
    {
      return GetSatellitePseudorangeNoiseOffsetResultPtr(new GetSatellitePseudorangeNoiseOffsetResult(relatedCommand, system, prn, enabled, offset));
    }

    GetSatellitePseudorangeNoiseOffsetResultPtr GetSatellitePseudorangeNoiseOffsetResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatellitePseudorangeNoiseOffsetResult>(ptr);
    }

    bool GetSatellitePseudorangeNoiseOffsetResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetSatellitePseudorangeNoiseOffsetResult::documentation() const { return Documentation; }


    std::string GetSatellitePseudorangeNoiseOffsetResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSatellitePseudorangeNoiseOffsetResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseOffsetResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSatellitePseudorangeNoiseOffsetResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetSatellitePseudorangeNoiseOffsetResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetSatellitePseudorangeNoiseOffsetResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePseudorangeNoiseOffsetResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetSatellitePseudorangeNoiseOffsetResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSatellitePseudorangeNoiseSineWave
///
#include "gen/SetSatellitePseudorangeNoiseSineWave.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSatellitePseudorangeNoiseSineWave::CmdName = "SetSatellitePseudorangeNoiseSineWave";
    const char* const SetSatellitePseudorangeNoiseSineWave::Documentation = "Please note the command SatellitePseudorangeNoiseSineWave is deprecated since 21.3. You may use PseudorangeNoiseSineWaveForSV.\n\nSet the satellite pseudorange noise sine wave attributes.";

    REGISTER_COMMAND_FACTORY(SetSatellitePseudorangeNoiseSineWave);


    SetSatellitePseudorangeNoiseSineWave::SetSatellitePseudorangeNoiseSineWave()
      : CommandBase(CmdName)
    {}

    SetSatellitePseudorangeNoiseSineWave::SetSatellitePseudorangeNoiseSineWave(const std::string& system, int prn, int sineWave, bool enabled, double amplitude, int period, double offset)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    SetSatellitePseudorangeNoiseSineWavePtr SetSatellitePseudorangeNoiseSineWave::create(const std::string& system, int prn, int sineWave, bool enabled, double amplitude, int period, double offset)
    {
      return SetSatellitePseudorangeNoiseSineWavePtr(new SetSatellitePseudorangeNoiseSineWave(system, prn, sineWave, enabled, amplitude, period, offset));
    }

    SetSatellitePseudorangeNoiseSineWavePtr SetSatellitePseudorangeNoiseSineWave::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSatellitePseudorangeNoiseSineWave>(ptr);
    }

    bool SetSatellitePseudorangeNoiseSineWave::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Amplitude"])
          && parse_json<int>::is_valid(m_values["Period"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string SetSatellitePseudorangeNoiseSineWave::documentation() const { return Documentation; }


    int SetSatellitePseudorangeNoiseSineWave::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSatellitePseudorangeNoiseSineWave::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSatellitePseudorangeNoiseSineWave::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatellitePseudorangeNoiseSineWave::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSatellitePseudorangeNoiseSineWave::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatellitePseudorangeNoiseSineWave::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void SetSatellitePseudorangeNoiseSineWave::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSatellitePseudorangeNoiseSineWave::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetSatellitePseudorangeNoiseSineWave::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSatellitePseudorangeNoiseSineWave::amplitude() const
    {
      return parse_json<double>::parse(m_values["Amplitude"]);
    }

    void SetSatellitePseudorangeNoiseSineWave::setAmplitude(double amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<double>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatellitePseudorangeNoiseSineWave::period() const
    {
      return parse_json<int>::parse(m_values["Period"]);
    }

    void SetSatellitePseudorangeNoiseSineWave::setPeriod(int period)
    {
      m_values.AddMember("Period", parse_json<int>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSatellitePseudorangeNoiseSineWave::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetSatellitePseudorangeNoiseSineWave::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatellitePseudorangeNoiseSineWave
///
#include "gen/GetSatellitePseudorangeNoiseSineWave.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatellitePseudorangeNoiseSineWave::CmdName = "GetSatellitePseudorangeNoiseSineWave";
    const char* const GetSatellitePseudorangeNoiseSineWave::Documentation = "Please note the command SatellitePseudorangeNoiseSineWave is deprecated since 21.3. You may use PseudorangeNoiseSineWaveForSV.\n\nGet the satellite pseudorange noise sine wave attributes.";

    REGISTER_COMMAND_FACTORY(GetSatellitePseudorangeNoiseSineWave);


    GetSatellitePseudorangeNoiseSineWave::GetSatellitePseudorangeNoiseSineWave()
      : CommandBase(CmdName)
    {}

    GetSatellitePseudorangeNoiseSineWave::GetSatellitePseudorangeNoiseSineWave(const std::string& system, int prn, int sineWave)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setSineWave(sineWave);
    }


    GetSatellitePseudorangeNoiseSineWavePtr GetSatellitePseudorangeNoiseSineWave::create(const std::string& system, int prn, int sineWave)
    {
      return GetSatellitePseudorangeNoiseSineWavePtr(new GetSatellitePseudorangeNoiseSineWave(system, prn, sineWave));
    }

    GetSatellitePseudorangeNoiseSineWavePtr GetSatellitePseudorangeNoiseSineWave::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatellitePseudorangeNoiseSineWave>(ptr);
    }

    bool GetSatellitePseudorangeNoiseSineWave::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["SineWave"])
        ;

    }

    std::string GetSatellitePseudorangeNoiseSineWave::documentation() const { return Documentation; }


    int GetSatellitePseudorangeNoiseSineWave::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSatellitePseudorangeNoiseSineWave::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSatellitePseudorangeNoiseSineWave::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseSineWave::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSatellitePseudorangeNoiseSineWave::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseSineWave::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetSatellitePseudorangeNoiseSineWave::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatellitePseudorangeNoiseSineWaveResult
///
#include "gen/GetSatellitePseudorangeNoiseSineWaveResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatellitePseudorangeNoiseSineWaveResult::CmdName = "GetSatellitePseudorangeNoiseSineWaveResult";
    const char* const GetSatellitePseudorangeNoiseSineWaveResult::Documentation = "Result of GetSatellitePseudorangeNoiseSineWave";

    REGISTER_COMMAND_RESULT_FACTORY(GetSatellitePseudorangeNoiseSineWaveResult);


    GetSatellitePseudorangeNoiseSineWaveResult::GetSatellitePseudorangeNoiseSineWaveResult()
      : CommandResult(CmdName)
    {}

    GetSatellitePseudorangeNoiseSineWaveResult::GetSatellitePseudorangeNoiseSineWaveResult(CommandBasePtr relatedCommand, const std::string& system, int prn, int sineWave, bool enabled, double amplitude, int period, double offset)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setSineWave(sineWave);
      setEnabled(enabled);
      setAmplitude(amplitude);
      setPeriod(period);
      setOffset(offset);
    }


    GetSatellitePseudorangeNoiseSineWaveResultPtr GetSatellitePseudorangeNoiseSineWaveResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, int sineWave, bool enabled, double amplitude, int period, double offset)
    {
      return GetSatellitePseudorangeNoiseSineWaveResultPtr(new GetSatellitePseudorangeNoiseSineWaveResult(relatedCommand, system, prn, sineWave, enabled, amplitude, period, offset));
    }

    GetSatellitePseudorangeNoiseSineWaveResultPtr GetSatellitePseudorangeNoiseSineWaveResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatellitePseudorangeNoiseSineWaveResult>(ptr);
    }

    bool GetSatellitePseudorangeNoiseSineWaveResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["SineWave"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Amplitude"])
          && parse_json<int>::is_valid(m_values["Period"])
          && parse_json<double>::is_valid(m_values["Offset"])
        ;

    }

    std::string GetSatellitePseudorangeNoiseSineWaveResult::documentation() const { return Documentation; }


    std::string GetSatellitePseudorangeNoiseSineWaveResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSatellitePseudorangeNoiseSineWaveResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseSineWaveResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSatellitePseudorangeNoiseSineWaveResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseSineWaveResult::sineWave() const
    {
      return parse_json<int>::parse(m_values["SineWave"]);
    }

    void GetSatellitePseudorangeNoiseSineWaveResult::setSineWave(int sineWave)
    {
      m_values.AddMember("SineWave", parse_json<int>::format(sineWave, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetSatellitePseudorangeNoiseSineWaveResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetSatellitePseudorangeNoiseSineWaveResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePseudorangeNoiseSineWaveResult::amplitude() const
    {
      return parse_json<double>::parse(m_values["Amplitude"]);
    }

    void GetSatellitePseudorangeNoiseSineWaveResult::setAmplitude(double amplitude)
    {
      m_values.AddMember("Amplitude", parse_json<double>::format(amplitude, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseSineWaveResult::period() const
    {
      return parse_json<int>::parse(m_values["Period"]);
    }

    void GetSatellitePseudorangeNoiseSineWaveResult::setPeriod(int period)
    {
      m_values.AddMember("Period", parse_json<int>::format(period, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePseudorangeNoiseSineWaveResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetSatellitePseudorangeNoiseSineWaveResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSatellitePseudorangeNoiseGaussMarkov
///
#include "gen/SetSatellitePseudorangeNoiseGaussMarkov.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSatellitePseudorangeNoiseGaussMarkov::CmdName = "SetSatellitePseudorangeNoiseGaussMarkov";
    const char* const SetSatellitePseudorangeNoiseGaussMarkov::Documentation = "Please note the command SatellitePseudorangeNoiseGaussMarkov is deprecated since 21.3. You may use PseudorangeNoiseGaussMarkovForSV.\n\nSet the satellite pseudorange noise Gauss-Markov process attributes.";

    REGISTER_COMMAND_FACTORY(SetSatellitePseudorangeNoiseGaussMarkov);


    SetSatellitePseudorangeNoiseGaussMarkov::SetSatellitePseudorangeNoiseGaussMarkov()
      : CommandBase(CmdName)
    {}

    SetSatellitePseudorangeNoiseGaussMarkov::SetSatellitePseudorangeNoiseGaussMarkov(const std::string& system, int prn, int process, bool enabled, double sigma, double time, int seed)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    SetSatellitePseudorangeNoiseGaussMarkovPtr SetSatellitePseudorangeNoiseGaussMarkov::create(const std::string& system, int prn, int process, bool enabled, double sigma, double time, int seed)
    {
      return SetSatellitePseudorangeNoiseGaussMarkovPtr(new SetSatellitePseudorangeNoiseGaussMarkov(system, prn, process, enabled, sigma, time, seed));
    }

    SetSatellitePseudorangeNoiseGaussMarkovPtr SetSatellitePseudorangeNoiseGaussMarkov::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSatellitePseudorangeNoiseGaussMarkov>(ptr);
    }

    bool SetSatellitePseudorangeNoiseGaussMarkov::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Sigma"])
          && parse_json<double>::is_valid(m_values["Time"])
          && parse_json<int>::is_valid(m_values["Seed"])
        ;

    }

    std::string SetSatellitePseudorangeNoiseGaussMarkov::documentation() const { return Documentation; }


    int SetSatellitePseudorangeNoiseGaussMarkov::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSatellitePseudorangeNoiseGaussMarkov::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSatellitePseudorangeNoiseGaussMarkov::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatellitePseudorangeNoiseGaussMarkov::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSatellitePseudorangeNoiseGaussMarkov::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatellitePseudorangeNoiseGaussMarkov::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void SetSatellitePseudorangeNoiseGaussMarkov::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool SetSatellitePseudorangeNoiseGaussMarkov::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void SetSatellitePseudorangeNoiseGaussMarkov::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSatellitePseudorangeNoiseGaussMarkov::sigma() const
    {
      return parse_json<double>::parse(m_values["Sigma"]);
    }

    void SetSatellitePseudorangeNoiseGaussMarkov::setSigma(double sigma)
    {
      m_values.AddMember("Sigma", parse_json<double>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSatellitePseudorangeNoiseGaussMarkov::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void SetSatellitePseudorangeNoiseGaussMarkov::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatellitePseudorangeNoiseGaussMarkov::seed() const
    {
      return parse_json<int>::parse(m_values["Seed"]);
    }

    void SetSatellitePseudorangeNoiseGaussMarkov::setSeed(int seed)
    {
      m_values.AddMember("Seed", parse_json<int>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatellitePseudorangeNoiseGaussMarkov
///
#include "gen/GetSatellitePseudorangeNoiseGaussMarkov.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatellitePseudorangeNoiseGaussMarkov::CmdName = "GetSatellitePseudorangeNoiseGaussMarkov";
    const char* const GetSatellitePseudorangeNoiseGaussMarkov::Documentation = "Please note the command SatellitePseudorangeNoiseGaussMarkov is deprecated since 21.3. You may use PseudorangeNoiseGaussMarkovForSV.\n\nGet the satellite pseudorange noise Gauss-Markov process attributes.";

    REGISTER_COMMAND_FACTORY(GetSatellitePseudorangeNoiseGaussMarkov);


    GetSatellitePseudorangeNoiseGaussMarkov::GetSatellitePseudorangeNoiseGaussMarkov()
      : CommandBase(CmdName)
    {}

    GetSatellitePseudorangeNoiseGaussMarkov::GetSatellitePseudorangeNoiseGaussMarkov(const std::string& system, int prn, int process)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setProcess(process);
    }


    GetSatellitePseudorangeNoiseGaussMarkovPtr GetSatellitePseudorangeNoiseGaussMarkov::create(const std::string& system, int prn, int process)
    {
      return GetSatellitePseudorangeNoiseGaussMarkovPtr(new GetSatellitePseudorangeNoiseGaussMarkov(system, prn, process));
    }

    GetSatellitePseudorangeNoiseGaussMarkovPtr GetSatellitePseudorangeNoiseGaussMarkov::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatellitePseudorangeNoiseGaussMarkov>(ptr);
    }

    bool GetSatellitePseudorangeNoiseGaussMarkov::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Process"])
        ;

    }

    std::string GetSatellitePseudorangeNoiseGaussMarkov::documentation() const { return Documentation; }


    int GetSatellitePseudorangeNoiseGaussMarkov::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSatellitePseudorangeNoiseGaussMarkov::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkov::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseGaussMarkov::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkov::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseGaussMarkov::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkov::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatellitePseudorangeNoiseGaussMarkovResult
///
#include "gen/GetSatellitePseudorangeNoiseGaussMarkovResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatellitePseudorangeNoiseGaussMarkovResult::CmdName = "GetSatellitePseudorangeNoiseGaussMarkovResult";
    const char* const GetSatellitePseudorangeNoiseGaussMarkovResult::Documentation = "Result of GetSatellitePseudorangeNoiseGaussMarkov";

    REGISTER_COMMAND_RESULT_FACTORY(GetSatellitePseudorangeNoiseGaussMarkovResult);


    GetSatellitePseudorangeNoiseGaussMarkovResult::GetSatellitePseudorangeNoiseGaussMarkovResult()
      : CommandResult(CmdName)
    {}

    GetSatellitePseudorangeNoiseGaussMarkovResult::GetSatellitePseudorangeNoiseGaussMarkovResult(CommandBasePtr relatedCommand, const std::string& system, int prn, int process, bool enabled, double sigma, double time, int seed)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setProcess(process);
      setEnabled(enabled);
      setSigma(sigma);
      setTime(time);
      setSeed(seed);
    }


    GetSatellitePseudorangeNoiseGaussMarkovResultPtr GetSatellitePseudorangeNoiseGaussMarkovResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, int process, bool enabled, double sigma, double time, int seed)
    {
      return GetSatellitePseudorangeNoiseGaussMarkovResultPtr(new GetSatellitePseudorangeNoiseGaussMarkovResult(relatedCommand, system, prn, process, enabled, sigma, time, seed));
    }

    GetSatellitePseudorangeNoiseGaussMarkovResultPtr GetSatellitePseudorangeNoiseGaussMarkovResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatellitePseudorangeNoiseGaussMarkovResult>(ptr);
    }

    bool GetSatellitePseudorangeNoiseGaussMarkovResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<int>::is_valid(m_values["Process"])
          && parse_json<bool>::is_valid(m_values["Enabled"])
          && parse_json<double>::is_valid(m_values["Sigma"])
          && parse_json<double>::is_valid(m_values["Time"])
          && parse_json<int>::is_valid(m_values["Seed"])
        ;

    }

    std::string GetSatellitePseudorangeNoiseGaussMarkovResult::documentation() const { return Documentation; }


    std::string GetSatellitePseudorangeNoiseGaussMarkovResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkovResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseGaussMarkovResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkovResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseGaussMarkovResult::process() const
    {
      return parse_json<int>::parse(m_values["Process"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkovResult::setProcess(int process)
    {
      m_values.AddMember("Process", parse_json<int>::format(process, m_values.GetAllocator()), m_values.GetAllocator());
    }



    bool GetSatellitePseudorangeNoiseGaussMarkovResult::enabled() const
    {
      return parse_json<bool>::parse(m_values["Enabled"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkovResult::setEnabled(bool enabled)
    {
      m_values.AddMember("Enabled", parse_json<bool>::format(enabled, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePseudorangeNoiseGaussMarkovResult::sigma() const
    {
      return parse_json<double>::parse(m_values["Sigma"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkovResult::setSigma(double sigma)
    {
      m_values.AddMember("Sigma", parse_json<double>::format(sigma, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatellitePseudorangeNoiseGaussMarkovResult::time() const
    {
      return parse_json<double>::parse(m_values["Time"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkovResult::setTime(double time)
    {
      m_values.AddMember("Time", parse_json<double>::format(time, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatellitePseudorangeNoiseGaussMarkovResult::seed() const
    {
      return parse_json<int>::parse(m_values["Seed"]);
    }

    void GetSatellitePseudorangeNoiseGaussMarkovResult::setSeed(int seed)
    {
      m_values.AddMember("Seed", parse_json<int>::format(seed, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSatelliteEphemerisError
///
#include "gen/SetSatelliteEphemerisError.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSatelliteEphemerisError::CmdName = "SetSatelliteEphemerisError";
    const char* const SetSatelliteEphemerisError::Documentation = "Please note the command SatelliteEphemerisError is deprecated since 21.3. You may use EphemerisErrorForSV.\n\nSet the satellite ephemeris error.";

    REGISTER_COMMAND_FACTORY(SetSatelliteEphemerisError);


    SetSatelliteEphemerisError::SetSatelliteEphemerisError()
      : CommandBase(CmdName)
    {}

    SetSatelliteEphemerisError::SetSatelliteEphemerisError(const std::string& system, int prn, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setOrbit(orbit);
      setDeltaAf0(deltaAf0);
      setDeltaAf1(deltaAf1);
    }


    SetSatelliteEphemerisErrorPtr SetSatelliteEphemerisError::create(const std::string& system, int prn, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
    {
      return SetSatelliteEphemerisErrorPtr(new SetSatelliteEphemerisError(system, prn, orbit, deltaAf0, deltaAf1));
    }

    SetSatelliteEphemerisErrorPtr SetSatelliteEphemerisError::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSatelliteEphemerisError>(ptr);
    }

    bool SetSatelliteEphemerisError::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::RIC>::is_valid(m_values["Orbit"])
          && parse_json<double>::is_valid(m_values["DeltaAf0"])
          && parse_json<double>::is_valid(m_values["DeltaAf1"])
        ;

    }

    std::string SetSatelliteEphemerisError::documentation() const { return Documentation; }


    int SetSatelliteEphemerisError::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string SetSatelliteEphemerisError::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSatelliteEphemerisError::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetSatelliteEphemerisError::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetSatelliteEphemerisError::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::RIC SetSatelliteEphemerisError::orbit() const
    {
      return parse_json<Sdx::RIC>::parse(m_values["Orbit"]);
    }

    void SetSatelliteEphemerisError::setOrbit(const Sdx::RIC& orbit)
    {
      m_values.AddMember("Orbit", parse_json<Sdx::RIC>::format(orbit, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSatelliteEphemerisError::deltaAf0() const
    {
      return parse_json<double>::parse(m_values["DeltaAf0"]);
    }

    void SetSatelliteEphemerisError::setDeltaAf0(double deltaAf0)
    {
      m_values.AddMember("DeltaAf0", parse_json<double>::format(deltaAf0, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetSatelliteEphemerisError::deltaAf1() const
    {
      return parse_json<double>::parse(m_values["DeltaAf1"]);
    }

    void SetSatelliteEphemerisError::setDeltaAf1(double deltaAf1)
    {
      m_values.AddMember("DeltaAf1", parse_json<double>::format(deltaAf1, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatelliteEphemerisError
///
#include "gen/GetSatelliteEphemerisError.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatelliteEphemerisError::CmdName = "GetSatelliteEphemerisError";
    const char* const GetSatelliteEphemerisError::Documentation = "Please note the command SatelliteEphemerisError is deprecated since 21.3. You may use EphemerisErrorForSV.\n\nGet the satellite ephemeris error.";

    REGISTER_COMMAND_FACTORY(GetSatelliteEphemerisError);


    GetSatelliteEphemerisError::GetSatelliteEphemerisError()
      : CommandBase(CmdName)
    {}

    GetSatelliteEphemerisError::GetSatelliteEphemerisError(const std::string& system, int prn)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
    }


    GetSatelliteEphemerisErrorPtr GetSatelliteEphemerisError::create(const std::string& system, int prn)
    {
      return GetSatelliteEphemerisErrorPtr(new GetSatelliteEphemerisError(system, prn));
    }

    GetSatelliteEphemerisErrorPtr GetSatelliteEphemerisError::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatelliteEphemerisError>(ptr);
    }

    bool GetSatelliteEphemerisError::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetSatelliteEphemerisError::documentation() const { return Documentation; }


    int GetSatelliteEphemerisError::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSatelliteEphemerisError::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSatelliteEphemerisError::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatelliteEphemerisError::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSatelliteEphemerisError::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSatelliteEphemerisErrorResult
///
#include "gen/GetSatelliteEphemerisErrorResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSatelliteEphemerisErrorResult::CmdName = "GetSatelliteEphemerisErrorResult";
    const char* const GetSatelliteEphemerisErrorResult::Documentation = "Result of GetSatelliteEphemerisError";

    REGISTER_COMMAND_RESULT_FACTORY(GetSatelliteEphemerisErrorResult);


    GetSatelliteEphemerisErrorResult::GetSatelliteEphemerisErrorResult()
      : CommandResult(CmdName)
    {}

    GetSatelliteEphemerisErrorResult::GetSatelliteEphemerisErrorResult(CommandBasePtr relatedCommand, const std::string& system, int prn, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setOrbit(orbit);
      setDeltaAf0(deltaAf0);
      setDeltaAf1(deltaAf1);
    }


    GetSatelliteEphemerisErrorResultPtr GetSatelliteEphemerisErrorResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, const Sdx::RIC& orbit, double deltaAf0, double deltaAf1)
    {
      return GetSatelliteEphemerisErrorResultPtr(new GetSatelliteEphemerisErrorResult(relatedCommand, system, prn, orbit, deltaAf0, deltaAf1));
    }

    GetSatelliteEphemerisErrorResultPtr GetSatelliteEphemerisErrorResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSatelliteEphemerisErrorResult>(ptr);
    }

    bool GetSatelliteEphemerisErrorResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<Sdx::RIC>::is_valid(m_values["Orbit"])
          && parse_json<double>::is_valid(m_values["DeltaAf0"])
          && parse_json<double>::is_valid(m_values["DeltaAf1"])
        ;

    }

    std::string GetSatelliteEphemerisErrorResult::documentation() const { return Documentation; }


    std::string GetSatelliteEphemerisErrorResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSatelliteEphemerisErrorResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetSatelliteEphemerisErrorResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetSatelliteEphemerisErrorResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    Sdx::RIC GetSatelliteEphemerisErrorResult::orbit() const
    {
      return parse_json<Sdx::RIC>::parse(m_values["Orbit"]);
    }

    void GetSatelliteEphemerisErrorResult::setOrbit(const Sdx::RIC& orbit)
    {
      m_values.AddMember("Orbit", parse_json<Sdx::RIC>::format(orbit, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatelliteEphemerisErrorResult::deltaAf0() const
    {
      return parse_json<double>::parse(m_values["DeltaAf0"]);
    }

    void GetSatelliteEphemerisErrorResult::setDeltaAf0(double deltaAf0)
    {
      m_values.AddMember("DeltaAf0", parse_json<double>::format(deltaAf0, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetSatelliteEphemerisErrorResult::deltaAf1() const
    {
      return parse_json<double>::parse(m_values["DeltaAf1"]);
    }

    void GetSatelliteEphemerisErrorResult::setDeltaAf1(double deltaAf1)
    {
      m_values.AddMember("DeltaAf1", parse_json<double>::format(deltaAf1, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetGpsCodePrn
///
#include "gen/SetGpsCodePrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetGpsCodePrn::CmdName = "SetGpsCodePrn";
    const char* const SetGpsCodePrn::Documentation = "Please note the command GpsCodePrn is deprecated since 21.3. You may use PrnOfSVID.\n\nSet the transmitted PRN code for the specified satellite";

    REGISTER_COMMAND_FACTORY(SetGpsCodePrn);


    SetGpsCodePrn::SetGpsCodePrn()
      : CommandBase(CmdName)
    {}

    SetGpsCodePrn::SetGpsCodePrn(int satPrn, int transmittedPrn)
      : CommandBase(CmdName)
    {

      setSatPrn(satPrn);
      setTransmittedPrn(transmittedPrn);
    }


    SetGpsCodePrnPtr SetGpsCodePrn::create(int satPrn, int transmittedPrn)
    {
      return SetGpsCodePrnPtr(new SetGpsCodePrn(satPrn, transmittedPrn));
    }

    SetGpsCodePrnPtr SetGpsCodePrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetGpsCodePrn>(ptr);
    }

    bool SetGpsCodePrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SatPrn"])
          && parse_json<int>::is_valid(m_values["TransmittedPrn"])
        ;

    }

    std::string SetGpsCodePrn::documentation() const { return Documentation; }


    int SetGpsCodePrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int SetGpsCodePrn::satPrn() const
    {
      return parse_json<int>::parse(m_values["SatPrn"]);
    }

    void SetGpsCodePrn::setSatPrn(int satPrn)
    {
      m_values.AddMember("SatPrn", parse_json<int>::format(satPrn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetGpsCodePrn::transmittedPrn() const
    {
      return parse_json<int>::parse(m_values["TransmittedPrn"]);
    }

    void SetGpsCodePrn::setTransmittedPrn(int transmittedPrn)
    {
      m_values.AddMember("TransmittedPrn", parse_json<int>::format(transmittedPrn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCodePrn
///
#include "gen/GetGpsCodePrn.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCodePrn::CmdName = "GetGpsCodePrn";
    const char* const GetGpsCodePrn::Documentation = "Please note the command GpsCodePrn is deprecated since 21.3. You may use PrnOfSVID.\n\nGet the transmitted PRN code for the specified satellite";

    REGISTER_COMMAND_FACTORY(GetGpsCodePrn);


    GetGpsCodePrn::GetGpsCodePrn()
      : CommandBase(CmdName)
    {}

    GetGpsCodePrn::GetGpsCodePrn(int satPrn)
      : CommandBase(CmdName)
    {

      setSatPrn(satPrn);
    }


    GetGpsCodePrnPtr GetGpsCodePrn::create(int satPrn)
    {
      return GetGpsCodePrnPtr(new GetGpsCodePrn(satPrn));
    }

    GetGpsCodePrnPtr GetGpsCodePrn::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCodePrn>(ptr);
    }

    bool GetGpsCodePrn::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SatPrn"])
        ;

    }

    std::string GetGpsCodePrn::documentation() const { return Documentation; }


    int GetGpsCodePrn::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    int GetGpsCodePrn::satPrn() const
    {
      return parse_json<int>::parse(m_values["SatPrn"]);
    }

    void GetGpsCodePrn::setSatPrn(int satPrn)
    {
      m_values.AddMember("SatPrn", parse_json<int>::format(satPrn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetGpsCodePrnResult
///
#include "gen/GetGpsCodePrnResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetGpsCodePrnResult::CmdName = "GetGpsCodePrnResult";
    const char* const GetGpsCodePrnResult::Documentation = "Result of GetGpsCodePrn";

    REGISTER_COMMAND_RESULT_FACTORY(GetGpsCodePrnResult);


    GetGpsCodePrnResult::GetGpsCodePrnResult()
      : CommandResult(CmdName)
    {}

    GetGpsCodePrnResult::GetGpsCodePrnResult(CommandBasePtr relatedCommand, int satPrn, int transmittedPrn)
      : CommandResult(CmdName, relatedCommand)
    {

      setSatPrn(satPrn);
      setTransmittedPrn(transmittedPrn);
    }


    GetGpsCodePrnResultPtr GetGpsCodePrnResult::create(CommandBasePtr relatedCommand, int satPrn, int transmittedPrn)
    {
      return GetGpsCodePrnResultPtr(new GetGpsCodePrnResult(relatedCommand, satPrn, transmittedPrn));
    }

    GetGpsCodePrnResultPtr GetGpsCodePrnResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetGpsCodePrnResult>(ptr);
    }

    bool GetGpsCodePrnResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<int>::is_valid(m_values["SatPrn"])
          && parse_json<int>::is_valid(m_values["TransmittedPrn"])
        ;

    }

    std::string GetGpsCodePrnResult::documentation() const { return Documentation; }


    int GetGpsCodePrnResult::satPrn() const
    {
      return parse_json<int>::parse(m_values["SatPrn"]);
    }

    void GetGpsCodePrnResult::setSatPrn(int satPrn)
    {
      m_values.AddMember("SatPrn", parse_json<int>::format(satPrn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetGpsCodePrnResult::transmittedPrn() const
    {
      return parse_json<int>::parse(m_values["TransmittedPrn"]);
    }

    void GetGpsCodePrnResult::setTransmittedPrn(int transmittedPrn)
    {
      m_values.AddMember("TransmittedPrn", parse_json<int>::format(transmittedPrn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetPseudorangeRamp
///
#include "gen/SetPseudorangeRamp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetPseudorangeRamp::CmdName = "SetPseudorangeRamp";
    const char* const SetPseudorangeRamp::Documentation = "Please note the command PseudorangeRamp is deprecated since 21.3. You may use PseudorangeRampForSV.\n\nSet PSR ramp event. This function lets user change the pseudorange of any satellite.\nIf PRN is set to 0, the change is applied to all satellites.\n\n         Hold Start Time\n         |     Hold Stop Time\n         |     |\n         ...........\n       ..       ...\n       ..        ...\n  .......           .........> Time\n      |           |\n      Start Time      Stop Time\n";

    REGISTER_COMMAND_FACTORY(SetPseudorangeRamp);


    SetPseudorangeRamp::SetPseudorangeRamp()
      : CommandBase(CmdName)
    {}

    SetPseudorangeRamp::SetPseudorangeRamp(const std::string& system, int prn, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
      setOffset(offset);
      setStartTime(startTime);
      setHoldStartTime(holdStartTime);
      setHoldStopTime(holdStopTime);
      setStopTime(stopTime);
      setId(id);
    }


    SetPseudorangeRampPtr SetPseudorangeRamp::create(const std::string& system, int prn, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
    {
      return SetPseudorangeRampPtr(new SetPseudorangeRamp(system, prn, offset, startTime, holdStartTime, holdStopTime, stopTime, id));
    }

    SetPseudorangeRampPtr SetPseudorangeRamp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetPseudorangeRamp>(ptr);
    }

    bool SetPseudorangeRamp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["HoldStartTime"])
          && parse_json<int>::is_valid(m_values["HoldStopTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string SetPseudorangeRamp::documentation() const { return Documentation; }


    int SetPseudorangeRamp::executePermission() const
    {
      return EXECUTE_IF_SIMULATING | EXECUTE_IF_IDLE;
    }


    std::string SetPseudorangeRamp::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetPseudorangeRamp::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRamp::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void SetPseudorangeRamp::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double SetPseudorangeRamp::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void SetPseudorangeRamp::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRamp::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void SetPseudorangeRamp::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRamp::holdStartTime() const
    {
      return parse_json<int>::parse(m_values["HoldStartTime"]);
    }

    void SetPseudorangeRamp::setHoldStartTime(int holdStartTime)
    {
      m_values.AddMember("HoldStartTime", parse_json<int>::format(holdStartTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRamp::holdStopTime() const
    {
      return parse_json<int>::parse(m_values["HoldStopTime"]);
    }

    void SetPseudorangeRamp::setHoldStopTime(int holdStopTime)
    {
      m_values.AddMember("HoldStopTime", parse_json<int>::format(holdStopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int SetPseudorangeRamp::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void SetPseudorangeRamp::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetPseudorangeRamp::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void SetPseudorangeRamp::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeRamp
///
#include "gen/GetPseudorangeRamp.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeRamp::CmdName = "GetPseudorangeRamp";
    const char* const GetPseudorangeRamp::Documentation = "Please note the command PseudorangeRamp is deprecated since 21.3. You may use PseudorangeRampForSV.\n\nGet PSR ramp event. This function lets user change the pseudorange of any satellite.\nIf PRN is set to 0, the change is applied to all satellites.\n\n         Hold Start Time\n         |     Hold Stop Time\n         |     |\n         ...........\n       ..       ...\n       ..        ...\n  .......           .........> Time\n      |           |\n      Start Time      Stop Time\n";

    REGISTER_COMMAND_FACTORY(GetPseudorangeRamp);


    GetPseudorangeRamp::GetPseudorangeRamp()
      : CommandBase(CmdName)
    {}

    GetPseudorangeRamp::GetPseudorangeRamp(const std::string& id)
      : CommandBase(CmdName)
    {

      setId(id);
    }


    GetPseudorangeRampPtr GetPseudorangeRamp::create(const std::string& id)
    {
      return GetPseudorangeRampPtr(new GetPseudorangeRamp(id));
    }

    GetPseudorangeRampPtr GetPseudorangeRamp::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeRamp>(ptr);
    }

    bool GetPseudorangeRamp::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetPseudorangeRamp::documentation() const { return Documentation; }


    int GetPseudorangeRamp::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeRamp::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetPseudorangeRamp::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeRampResult
///
#include "gen/GetPseudorangeRampResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeRampResult::CmdName = "GetPseudorangeRampResult";
    const char* const GetPseudorangeRampResult::Documentation = "Result of GetPseudorangeRamp";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeRampResult);


    GetPseudorangeRampResult::GetPseudorangeRampResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeRampResult::GetPseudorangeRampResult(CommandBasePtr relatedCommand, const std::string& system, int prn, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setOffset(offset);
      setStartTime(startTime);
      setHoldStartTime(holdStartTime);
      setHoldStopTime(holdStopTime);
      setStopTime(stopTime);
      setId(id);
    }


    GetPseudorangeRampResultPtr GetPseudorangeRampResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, double offset, int startTime, int holdStartTime, int holdStopTime, int stopTime, const std::string& id)
    {
      return GetPseudorangeRampResultPtr(new GetPseudorangeRampResult(relatedCommand, system, prn, offset, startTime, holdStartTime, holdStopTime, stopTime, id));
    }

    GetPseudorangeRampResultPtr GetPseudorangeRampResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeRampResult>(ptr);
    }

    bool GetPseudorangeRampResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<double>::is_valid(m_values["Offset"])
          && parse_json<int>::is_valid(m_values["StartTime"])
          && parse_json<int>::is_valid(m_values["HoldStartTime"])
          && parse_json<int>::is_valid(m_values["HoldStopTime"])
          && parse_json<int>::is_valid(m_values["StopTime"])
          && parse_json<std::string>::is_valid(m_values["Id"])
        ;

    }

    std::string GetPseudorangeRampResult::documentation() const { return Documentation; }


    std::string GetPseudorangeRampResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeRampResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetPseudorangeRampResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    double GetPseudorangeRampResult::offset() const
    {
      return parse_json<double>::parse(m_values["Offset"]);
    }

    void GetPseudorangeRampResult::setOffset(double offset)
    {
      m_values.AddMember("Offset", parse_json<double>::format(offset, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampResult::startTime() const
    {
      return parse_json<int>::parse(m_values["StartTime"]);
    }

    void GetPseudorangeRampResult::setStartTime(int startTime)
    {
      m_values.AddMember("StartTime", parse_json<int>::format(startTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampResult::holdStartTime() const
    {
      return parse_json<int>::parse(m_values["HoldStartTime"]);
    }

    void GetPseudorangeRampResult::setHoldStartTime(int holdStartTime)
    {
      m_values.AddMember("HoldStartTime", parse_json<int>::format(holdStartTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampResult::holdStopTime() const
    {
      return parse_json<int>::parse(m_values["HoldStopTime"]);
    }

    void GetPseudorangeRampResult::setHoldStopTime(int holdStopTime)
    {
      m_values.AddMember("HoldStopTime", parse_json<int>::format(holdStopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampResult::stopTime() const
    {
      return parse_json<int>::parse(m_values["StopTime"]);
    }

    void GetPseudorangeRampResult::setStopTime(int stopTime)
    {
      m_values.AddMember("StopTime", parse_json<int>::format(stopTime, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetPseudorangeRampResult::id() const
    {
      return parse_json<std::string>::parse(m_values["Id"]);
    }

    void GetPseudorangeRampResult::setId(const std::string& id)
    {
      m_values.AddMember("Id", parse_json<std::string>::format(id, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeRamps
///
#include "gen/GetPseudorangeRamps.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeRamps::CmdName = "GetPseudorangeRamps";
    const char* const GetPseudorangeRamps::Documentation = "Please note the command GetPseudorangeRamps is deprecated since 21.3. You may use GetAllPseudorangeRampForSV.\n\nGet a list of all the pseudorange ramps IDs for one satellite of a system";

    REGISTER_COMMAND_FACTORY(GetPseudorangeRamps);


    GetPseudorangeRamps::GetPseudorangeRamps()
      : CommandBase(CmdName)
    {}

    GetPseudorangeRamps::GetPseudorangeRamps(const std::string& system, int prn)
      : CommandBase(CmdName)
    {

      setSystem(system);
      setPrn(prn);
    }


    GetPseudorangeRampsPtr GetPseudorangeRamps::create(const std::string& system, int prn)
    {
      return GetPseudorangeRampsPtr(new GetPseudorangeRamps(system, prn));
    }

    GetPseudorangeRampsPtr GetPseudorangeRamps::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeRamps>(ptr);
    }

    bool GetPseudorangeRamps::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
        ;

    }

    std::string GetPseudorangeRamps::documentation() const { return Documentation; }


    int GetPseudorangeRamps::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetPseudorangeRamps::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeRamps::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRamps::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetPseudorangeRamps::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetPseudorangeRampsResult
///
#include "gen/GetPseudorangeRampsResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetPseudorangeRampsResult::CmdName = "GetPseudorangeRampsResult";
    const char* const GetPseudorangeRampsResult::Documentation = "result of GetPseudorangeRamps";

    REGISTER_COMMAND_RESULT_FACTORY(GetPseudorangeRampsResult);


    GetPseudorangeRampsResult::GetPseudorangeRampsResult()
      : CommandResult(CmdName)
    {}

    GetPseudorangeRampsResult::GetPseudorangeRampsResult(CommandBasePtr relatedCommand, const std::string& system, int prn, const std::vector<std::string>& ids)
      : CommandResult(CmdName, relatedCommand)
    {

      setSystem(system);
      setPrn(prn);
      setIds(ids);
    }


    GetPseudorangeRampsResultPtr GetPseudorangeRampsResult::create(CommandBasePtr relatedCommand, const std::string& system, int prn, const std::vector<std::string>& ids)
    {
      return GetPseudorangeRampsResultPtr(new GetPseudorangeRampsResult(relatedCommand, system, prn, ids));
    }

    GetPseudorangeRampsResultPtr GetPseudorangeRampsResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetPseudorangeRampsResult>(ptr);
    }

    bool GetPseudorangeRampsResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
          && parse_json<int>::is_valid(m_values["Prn"])
          && parse_json<std::vector<std::string>>::is_valid(m_values["Ids"])
        ;

    }

    std::string GetPseudorangeRampsResult::documentation() const { return Documentation; }


    std::string GetPseudorangeRampsResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetPseudorangeRampsResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }



    int GetPseudorangeRampsResult::prn() const
    {
      return parse_json<int>::parse(m_values["Prn"]);
    }

    void GetPseudorangeRampsResult::setPrn(int prn)
    {
      m_values.AddMember("Prn", parse_json<int>::format(prn, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::vector<std::string> GetPseudorangeRampsResult::ids() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["Ids"]);
    }

    void GetPseudorangeRampsResult::setIds(const std::vector<std::string>& ids)
    {
      m_values.AddMember("Ids", parse_json<std::vector<std::string>>::format(ids, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of SetSVAntennaModelForAllSat
///
#include "gen/SetSVAntennaModelForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const SetSVAntennaModelForAllSat::CmdName = "SetSVAntennaModelForAllSat";
    const char* const SetSVAntennaModelForAllSat::Documentation = "Please note the command SVAntennaModelForAllSat is deprecated since 21.3. You may use SVAntennaModelForEachSV.\n\nSet the antenna model for all satellites.";

    REGISTER_COMMAND_FACTORY(SetSVAntennaModelForAllSat);


    SetSVAntennaModelForAllSat::SetSVAntennaModelForAllSat()
      : CommandBase(CmdName)
    {}

    SetSVAntennaModelForAllSat::SetSVAntennaModelForAllSat(const std::vector<std::string>& antennaModelNames, const std::string& system)
      : CommandBase(CmdName)
    {

      setAntennaModelNames(antennaModelNames);
      setSystem(system);
    }


    SetSVAntennaModelForAllSatPtr SetSVAntennaModelForAllSat::create(const std::vector<std::string>& antennaModelNames, const std::string& system)
    {
      return SetSVAntennaModelForAllSatPtr(new SetSVAntennaModelForAllSat(antennaModelNames, system));
    }

    SetSVAntennaModelForAllSatPtr SetSVAntennaModelForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<SetSVAntennaModelForAllSat>(ptr);
    }

    bool SetSVAntennaModelForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaModelNames"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string SetSVAntennaModelForAllSat::documentation() const { return Documentation; }


    int SetSVAntennaModelForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::vector<std::string> SetSVAntennaModelForAllSat::antennaModelNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaModelNames"]);
    }

    void SetSVAntennaModelForAllSat::setAntennaModelNames(const std::vector<std::string>& antennaModelNames)
    {
      m_values.AddMember("AntennaModelNames", parse_json<std::vector<std::string>>::format(antennaModelNames, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string SetSVAntennaModelForAllSat::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void SetSVAntennaModelForAllSat::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForAllSat
///
#include "gen/GetSVAntennaModelForAllSat.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForAllSat::CmdName = "GetSVAntennaModelForAllSat";
    const char* const GetSVAntennaModelForAllSat::Documentation = "Please note the command SVAntennaModelForAllSat is deprecated since 21.3. You may use SVAntennaModelForEachSV.\n\nGet the antenna model for all satellites.";

    REGISTER_COMMAND_FACTORY(GetSVAntennaModelForAllSat);


    GetSVAntennaModelForAllSat::GetSVAntennaModelForAllSat()
      : CommandBase(CmdName)
    {}

    GetSVAntennaModelForAllSat::GetSVAntennaModelForAllSat(const std::string& system)
      : CommandBase(CmdName)
    {

      setSystem(system);
    }


    GetSVAntennaModelForAllSatPtr GetSVAntennaModelForAllSat::create(const std::string& system)
    {
      return GetSVAntennaModelForAllSatPtr(new GetSVAntennaModelForAllSat(system));
    }

    GetSVAntennaModelForAllSatPtr GetSVAntennaModelForAllSat::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForAllSat>(ptr);
    }

    bool GetSVAntennaModelForAllSat::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetSVAntennaModelForAllSat::documentation() const { return Documentation; }


    int GetSVAntennaModelForAllSat::executePermission() const
    {
      return EXECUTE_IF_IDLE;
    }


    std::string GetSVAntennaModelForAllSat::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForAllSat::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}


///
/// Definition of GetSVAntennaModelForAllSatResult
///
#include "gen/GetSVAntennaModelForAllSatResult.h"

namespace Sdx
{
  namespace Cmd
  {
    const char* const GetSVAntennaModelForAllSatResult::CmdName = "GetSVAntennaModelForAllSatResult";
    const char* const GetSVAntennaModelForAllSatResult::Documentation = "Result of GetSVAntennaModelForAllSat";

    REGISTER_COMMAND_RESULT_FACTORY(GetSVAntennaModelForAllSatResult);


    GetSVAntennaModelForAllSatResult::GetSVAntennaModelForAllSatResult()
      : CommandResult(CmdName)
    {}

    GetSVAntennaModelForAllSatResult::GetSVAntennaModelForAllSatResult(CommandBasePtr relatedCommand, const std::vector<std::string>& antennaModelNames, const std::string& system)
      : CommandResult(CmdName, relatedCommand)
    {

      setAntennaModelNames(antennaModelNames);
      setSystem(system);
    }


    GetSVAntennaModelForAllSatResultPtr GetSVAntennaModelForAllSatResult::create(CommandBasePtr relatedCommand, const std::vector<std::string>& antennaModelNames, const std::string& system)
    {
      return GetSVAntennaModelForAllSatResultPtr(new GetSVAntennaModelForAllSatResult(relatedCommand, antennaModelNames, system));
    }

    GetSVAntennaModelForAllSatResultPtr GetSVAntennaModelForAllSatResult::dynamicCast(CommandBasePtr ptr)
    {
      return std::dynamic_pointer_cast<GetSVAntennaModelForAllSatResult>(ptr);
    }

    bool GetSVAntennaModelForAllSatResult::isValid() const
    {
      
        return m_values.IsObject()
          && parse_json<std::vector<std::string>>::is_valid(m_values["AntennaModelNames"])
          && parse_json<std::string>::is_valid(m_values["System"])
        ;

    }

    std::string GetSVAntennaModelForAllSatResult::documentation() const { return Documentation; }


    std::vector<std::string> GetSVAntennaModelForAllSatResult::antennaModelNames() const
    {
      return parse_json<std::vector<std::string>>::parse(m_values["AntennaModelNames"]);
    }

    void GetSVAntennaModelForAllSatResult::setAntennaModelNames(const std::vector<std::string>& antennaModelNames)
    {
      m_values.AddMember("AntennaModelNames", parse_json<std::vector<std::string>>::format(antennaModelNames, m_values.GetAllocator()), m_values.GetAllocator());
    }



    std::string GetSVAntennaModelForAllSatResult::system() const
    {
      return parse_json<std::string>::parse(m_values["System"]);
    }

    void GetSVAntennaModelForAllSatResult::setSystem(const std::string& system)
    {
      m_values.AddMember("System", parse_json<std::string>::format(system, m_values.GetAllocator()), m_values.GetAllocator());
    }


  }
}

